{"title":"UE4 功能整理","uid":"8d0c33a1aee99d366309310c2d2adece","slug":"7_UE4功能整理_09","date":"2022-10-06T07:28:25.960Z","updated":"2022-08-02T09:38:12.820Z","comments":true,"path":"api/articles/7_UE4功能整理_09.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN/Post_Img_mini/postImg_31.jpg","content":"<h1 id=\"UE4-功能整理\"><a href=\"#UE4-功能整理\" class=\"headerlink\" title=\"UE4 功能整理\"></a>UE4 功能整理</h1><h3 id=\"1-SpawnActor\"><a href=\"#1-SpawnActor\" class=\"headerlink\" title=\"1. SpawnActor\"></a>1. SpawnActor</h3><p>情景：</p>\n<ul>\n<li>我有一个<code>Cpp类</code></li>\n<li>这个<code>Cpp类</code>要生成一个其他<code>Cpp</code>或<code>蓝图</code>类</li>\n<li>可以使用<code>TSubclassOf&lt;&gt;</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;AActor&gt; SpawnActorTest;</code></pre>\n</li>\n<li><p>实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void AActor_SpawnTest::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tFActorSpawnParameters SpawnParameters;\n\tSpawnParameters.Name &#x3D; FName(&quot;SpawnActorTest&quot;);\n\tSpawnParameters.Owner &#x3D; this;\n\tSpawnParameters.Instigator &#x3D; nullptr;\n    \n\tGetWorld()-&gt;SpawnActor&lt;AActor&gt;(SpawnActorTest, GetActorTransform(), SpawnParameters);\n&#125;</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><p>定义中的<code>SpawnActorTest</code>是私有变量，若要保持私有，其蓝图可以<code>Get</code>, <code>Set</code>和参数列表中显示继承中：</p>\n<ul>\n<li><code>UPOPERTY()</code>中加入<code>BlueprintReadWrite</code>，<code>meta=(AllowPrivateAccess=true)</code></li>\n</ul>\n</li>\n<li><p><code>FActorSpawnParameters</code>是可以自定义生成参数，默认可以不写</p>\n</li>\n<li><p><code>GetActorTransform()</code>可以是<code>GetActorLocation</code>和<code>GetActorRotation</code></p>\n</li>\n</ul>\n<h3 id=\"2-LineTrace\"><a href=\"#2-LineTrace\" class=\"headerlink\" title=\"2. LineTrace\"></a>2. LineTrace</h3><ul>\n<li>Trace模式<ul>\n<li>TraceSingle 单个结果</li>\n<li>TraceMulti 多个结果</li>\n</ul>\n</li>\n<li>Trace 的检测依据<ul>\n<li>ByChanne</li>\n<li>ByObjectType</li>\n<li>ByProfile</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-1-UWorld\"><a href=\"#2-1-UWorld\" class=\"headerlink\" title=\"2.1 UWorld\"></a>2.1 UWorld</h4><p><strong><code>LineTraceSingleByChannel</code></strong></p>\n<p>情景：</p>\n<ul>\n<li>场景中的某个<code>Actor</code>需要发射检测射线</li>\n<li>可以直接在<code>Actor</code>上写，也可以通过组件<code>SceneComponent</code>，<code>ActorComponent</code></li>\n<li>示例采用<code>SceneComponent</code></li>\n</ul>\n<p>Syntax：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool LineTraceSingleByChannel(\n\tstruct FHitResult&amp; OutHit,\n\tconst FVector&amp; Start,\n\tconst FVector&amp; End,\n\tECollisionChannel TraceChannel,\n\tconst FCollisionQueryParams&amp; Params &#x3D; FCollisionQueryParams::DefaultQueryParam,\n\tconst FCollisionResponseParams&amp; ResponseParam &#x3D; FCollisionResponseParams::DefaultResponseParam\n) const;</code></pre>\n\n\n\n<p>示例：</p>\n<ul>\n<li><p>定义</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Trace&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceDistance;</code></pre>\n</li>\n<li><p>实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const FVector Start &#x3D; GetOwner()-&gt;GetActorLocation();\nconst FVector End &#x3D; Start + (GetForwardVector() * TraceDistance);\n\nFHitResult HitResult;\nconst bool IsHit &#x3D; GetWorld()-&gt;LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility);\n\nDrawDebugLine(GetWorld(), Start, End, FColor::Red, false, 0.5f);\n\nif (!IsHit)&#123;return;&#125;\nGEngine-&gt;AddOnScreenDebugMessage(-1, 1.f, FColor::Green,\n\t\tFString::Printf(TEXT(&quot;Trace Hit: %s&quot;), *HitResult.GetActor()-&gt;GetName()));</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><code>HitResult</code>会包含射线检测到的<code>Actor</code>的信息</li>\n</ul>\n<h4 id=\"2-2-Kismet\"><a href=\"#2-2-Kismet\" class=\"headerlink\" title=\"2.2 Kismet\"></a>2.2 Kismet</h4><h5 id=\"2-2-1-LineTraceSingle\"><a href=\"#2-2-1-LineTraceSingle\" class=\"headerlink\" title=\"2.2.1 LineTraceSingle\"></a>2.2.1 LineTraceSingle</h5><p>情景：</p>\n<ul>\n<li>根据 <code>Channel</code> 检测单个物体</li>\n</ul>\n<p>Syntax：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">static bool LineTraceSingle(\n\tconst UObject* WorldContextObject,\n\tconst FVector Start,\n\tconst FVector End, \n\tETraceTypeQuery TraceChannel, \n\tbool bTraceComplex, \n\tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore, \n\tEDrawDebugTrace::Type DrawDebugType,\n\tFHitResult&amp; OutHit, \n\tbool bIgnoreSelf, \n\tFLinearColor TraceColor &#x3D; FLinearColor::Red, \n\tFLinearColor TraceHitColor &#x3D; FLinearColor::Green, \n\tfloat DrawTime &#x3D; 5.0f\n);</code></pre>\n\n\n\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Trace&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceDistance;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const FVector Start &#x3D; GetOwner()-&gt;GetActorLocation();\nconst FVector End &#x3D; Start + (GetForwardVector() * TraceDistance);\n\nFHitResult HitResult;\nconst TArray&lt;AActor*&gt; ActorsToIgnore;\nconst bool IsHit &#x3D; UKismetSystemLibrary::LineTraceSingle(\n\t\tthis, Start, End, TraceTypeQuery1,\n\t\tfalse, ActorsToIgnore, EDrawDebugTrace::ForDuration, HitResult, true,\n\t\tFLinearColor::Red, FLinearColor::Green, 1.f);\n\nif (!IsHit)&#123;return;&#125;\nGEngine-&gt;AddOnScreenDebugMessage(-1, 1.f, FColor::Green,\n\t\tFString::Printf(TEXT(&quot;Trace Hit: %s&quot;), *HitResult.GetActor()-&gt;GetName()));</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><code>ETraceTypeQuery</code> 说明<ul>\n<li>默认 <code>TraceTypeQuery1</code> —— <code>Visibility</code></li>\n<li>默认 <code>TraceTypeQuery2</code> —— <code>Camera</code></li>\n<li>可在 <code>ProjectSettings</code>-&gt;<code>Engine</code>-&gt;<code>Collision</code>-&gt;<code>Trace Channels</code> 添加自定义</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-2-2-LineTraceSingleForObjects\"><a href=\"#2-2-2-LineTraceSingleForObjects\" class=\"headerlink\" title=\"2.2.2 LineTraceSingleForObjects\"></a>2.2.2 LineTraceSingleForObjects</h5><p>情景：</p>\n<ul>\n<li>根据 <code>Object Type</code> 检测单个物体</li>\n</ul>\n<p>Syntax</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">static bool LineTraceSingleForObjects(\n\tconst UObject* WorldContextObject,\n\tconst FVector Start,\n\tconst FVector End,\n\tconst TArray&lt;TEnumAsByte&lt;EObjectTypeQuery&gt; &gt; &amp; ObjectTypes,\n\tbool bTraceComplex,\n\tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore,\n\tEDrawDebugTrace::Type DrawDebugType,\n\tFHitResult&amp; OutHit,\n\tbool bIgnoreSelf,\n\tFLinearColor TraceColor &#x3D; FLinearColor::Red,\n\tFLinearColor TraceHitColor &#x3D; FLinearColor::Green,\n\tfloat DrawTime &#x3D; 5.0f \n);</code></pre>\n\n\n\n<p>示例：</p>\n<ul>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 设置要检测的 Object Type\nTArray&lt;TEnumAsByte&lt;EObjectTypeQuery&gt; &gt; ObjectTypes;\nObjectTypes.Add(EObjectTypeQuery::ObjectTypeQuery1);\n\n&#x2F;&#x2F;开始检测\nbool bIsHit &#x3D; UKismetSystemLibrary::LineTraceSingleForObjects(GetWorld(), BeginLoc, EndLoc, ObjectTypes, false, IgnoreActors, EDrawDebugTrace::ForDuration, HitResult, true);\nif (bIsHit)\n&#123;\n\tUKismetSystemLibrary::PrintString(GetWorld(), HitResult.GetActor()-&gt;GetName());\n&#125;</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><code>EObjectTypeQuery</code> 对应 <code>ObjectType</code><ul>\n<li>默认 <code>ObjectTypeQuery1</code> —— <code>WorldStatic</code></li>\n<li>默认 <code>ObjectTypeQuery2</code> —— <code>WorldDynamic</code></li>\n<li>默认 <code>ObjectTypeQuery3</code> —— <code>Oawn</code></li>\n<li>默认 <code>ObjectTypeQuery4</code> —— <code>PhysicasBody</code></li>\n<li>默认 <code>ObjectTypeQuery5</code> —— <code>Vehicle</code></li>\n<li>默认 <code>ObjectTypeQuery6</code> —— <code>Destructible</code></li>\n<li>可以再 <code>ProjectSettings</code>-&gt;<code>Engine</code>-&gt;<code>Collision</code>-&gt;<code>Object Channels</code> 添加自定义</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-2-3-LineTraceSingleByProfile\"><a href=\"#2-2-3-LineTraceSingleByProfile\" class=\"headerlink\" title=\"2.2.3 LineTraceSingleByProfile\"></a>2.2.3 LineTraceSingleByProfile</h5><p>情景：</p>\n<ul>\n<li>根据 <code>Collision Preset</code> 检测单个物体</li>\n</ul>\n<p>Syntax</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">static bool LineTraceSingleByProfile(\n\tconst UObject* WorldContextObject,\n\tconst FVector Start, \n\tconst FVector End, \n\tFName ProfileName,\n\tbool bTraceComplex,\n\tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore,\n\tEDrawDebugTrace::Type DrawDebugType,\n\tFHitResult&amp; OutHit,\n\tbool bIgnoreSelf,\n\tFLinearColor TraceColor &#x3D; FLinearColor::Red,\n\tFLinearColor TraceHitColor &#x3D; FLinearColor::Green,\n\tfloat DrawTime &#x3D; 5.0f\n);</code></pre>\n\n\n\n<p>示例：</p>\n<ul>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool bIsHit &#x3D; UKismetSystemLibrary::LineTraceSingleByProfile(\n    GetWorld(), BeginLoc, EndLoc,TEXT(&quot;BlockAll&quot;), \n    false, IgnoreActors, EDrawDebugTrace::ForDuration, \n    HitResult, true);\n\nif (bIsHit)\n&#123;\n\tUKismetSystemLibrary::PrintString(GetWorld(), HitResult.GetActor()-&gt;GetName());\n&#125;</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><code>ProfileName</code> 对应 <code>Collision Preset</code> 的名称</li>\n</ul>\n<h3 id=\"3-SweepTrace\"><a href=\"#3-SweepTrace\" class=\"headerlink\" title=\"3. SweepTrace\"></a>3. SweepTrace</h3><p>情景：</p>\n<ul>\n<li><p>使用<code>UWorld</code>生成</p>\n</li>\n<li><p>生成一个范围检测周边的<code>Actor</code></p>\n</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(EditDefaultsOnly, Category&#x3D;&quot;Trace&quot;, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceRadius;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">TArray&lt;FHitResult&gt; HitResults;\nconst FVector Start, End &#x3D; GetOwner()-&gt;GetActorLocation();\nconst FCollisionShape CollisionShape &#x3D; FCollisionShape::MakeSphere(TraceRadius);\n\nconst bool IsHit &#x3D; GetWorld()-&gt;SweepMultiByChannel(\n\t\t\tHitResults, Start, End, FQuat::Identity,\n\t\t\tECC_Visibility, CollisionShape);\n\nDrawDebugSphere(GetWorld(), Start, TraceRadius, 50, FColor::Green, true);\n\nif (!IsHit)&#123;return;&#125;\nfor (const auto &amp;result : HitResults)\n&#123;\n\tGEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green,\n\t\tFString::Printf(TEXT(&quot;Hit: %s&quot;), *result.GetActor()-&gt;GetName()));\n&#125;</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><code>FQuat</code>四元数<ul>\n<li><code>Indentity</code>：无旋转</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-SphereTrace\"><a href=\"#4-SphereTrace\" class=\"headerlink\" title=\"4. SphereTrace\"></a>4. SphereTrace</h3><p>情景：</p>\n<ul>\n<li>使用<code>Kismet</code>生成</li>\n<li>生成一个范围检测周边的<code>Actor</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(EditDefaultsOnly, Category&#x3D;&quot;Trace&quot;, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceRadius;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const FVector Start, End &#x3D; GetOwner()-&gt;GetActorLocation();\nTArray&lt;AActor*&gt; ActorsToIgnore;\nActorsToIgnore.Add(GetOwner());\nTArray&lt;FHitResult&gt; HitResults;\n\t\nconst bool IsHit &#x3D; UKismetSystemLibrary::SphereTraceMulti(\n\t\tthis,\n\t\tStart,\n\t\tEnd,\n\t\tTraceRadius,\n\t\tTraceTypeQuery1, \n\t\tfalse,\n\t\tActorsToIgnore,\n\t\tEDrawDebugTrace::ForDuration,\n\t\tHitResults,\n\t\ttrue,\n\t\tFLinearColor::Green,\n\t\tFLinearColor::Red,\n\t\t60.f);\n\t\nif (!IsHit)&#123;return;&#125;\nfor (const auto &amp;result : HitResults)\n&#123;\n\tGEngine-&gt;AddOnScreenDebugMessage(\n        -1, 60.f, FColor::Green,\n\t\tFString::Printf(TEXT(&quot;Hit: %s&quot;), \n        *result.GetActor()-&gt;GetName()));\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"5-Character\"><a href=\"#5-Character\" class=\"headerlink\" title=\"5. Character\"></a>5. Character</h3><p>情景：</p>\n<ul>\n<li>第三人称</li>\n<li>自由视角</li>\n<li>角色朝向鼠标输入和控制器指向</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>准备：</p>\n<ol>\n<li>编辑 &gt;&gt; 项目设置 &gt;&gt; 引擎 &gt;&gt; 输入</li>\n<li>添加操作映射<ul>\n<li>Jump &#x3D;&#x3D; 空格键</li>\n</ul>\n</li>\n<li>添加轴映射<ul>\n<li>MoveForward<ul>\n<li>W &#x3D;&#x3D; 1.0</li>\n<li>S &#x3D;&#x3D; -1.0</li>\n</ul>\n</li>\n<li>MoveRight<ul>\n<li>D &#x3D;&#x3D; 1.0</li>\n<li>A &#x3D;&#x3D; -1.0</li>\n</ul>\n</li>\n<li>PitchCamera<ul>\n<li>鼠标Y &#x3D;&#x3D; -1.0</li>\n</ul>\n</li>\n<li>YawCamera<ul>\n<li>鼠标X &#x3D;&#x3D; 1.0</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class USpringArmComponent;\nclass UCameraComponent;\n\nprivate:\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Player&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUSpringArmComponent *PlayerSpringArmComponent;\n\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Player&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUCameraComponent *PlayerCameraComponent;\n\t\npublic:\n\tUFUNCTION()\n\tvoid MoveForward(float Value);\n\n\tUFUNCTION()\n\tvoid MoveRight(float Value);</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">ACharacterBase::ACharacterBase()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; true;\n\n\tGetCapsuleComponent()-&gt;InitCapsuleSize(36.f, 92.f);\n\t\n\tPlayerSpringArmComponent &#x3D; CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT(&quot;SpringArm&quot;));\n\tPlayerSpringArmComponent-&gt;SetupAttachment(RootComponent);\n    PlayerSpringArmComponent-&gt;bUsePawnControlRotation &#x3D; true;\n    &#x2F;&#x2F; 以下是详细配置\n\tPlayerSpringArmComponent-&gt;SetRelativeLocation(FVector(0.f, 0.f, 90.f));\n\tPlayerSpringArmComponent-&gt;TargetArmLength &#x3D; 300.f;\n\tPlayerSpringArmComponent-&gt;bEnableCameraLag &#x3D; true;\n\tPlayerSpringArmComponent-&gt;bEnableCameraRotationLag &#x3D; true;\n\tPlayerSpringArmComponent-&gt;CameraLagSpeed &#x3D; 10.f;\n\tPlayerSpringArmComponent-&gt;CameraRotationLagSpeed &#x3D; 10.f;\n\tPlayerSpringArmComponent-&gt;CameraLagMaxDistance &#x3D; 100.f;\n\n\tPlayerCameraComponent &#x3D; CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;Camera&quot;));\n\tPlayerCameraComponent-&gt;SetupAttachment(PlayerSpringArmComponent, USpringArmComponent::SocketName);\n\tPlayerCameraComponent-&gt;bUsePawnControlRotation &#x3D; false;\n\n\tGetCharacterMovement()-&gt;bOrientRotationToMovement &#x3D; true;\n    &#x2F;&#x2F; 以下是详细配置\n\tGetCharacterMovement()-&gt;RotationRate &#x3D; FRotator(0.f, 90.f, 0.f);\n\tGetCharacterMovement()-&gt;GravityScale &#x3D; 1.5f;\n\tGetCharacterMovement()-&gt;MaxAcceleration &#x3D; 980.f;\n\tGetCharacterMovement()-&gt;JumpZVelocity &#x3D; 600.f;\n\tGetCharacterMovement()-&gt;AirControl &#x3D; 0.2f;\n\n\tbUseControllerRotationPitch &#x3D; false;\n\tbUseControllerRotationRoll &#x3D; false;\n\tbUseControllerRotationYaw &#x3D; false;\n&#125;\n\nvoid ACharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n&#123;\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t&#x2F;&#x2F; Bind Axis &#x3D;&gt; MoveForward, MoveRight\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveForward&quot;), this, &amp;ACharacterBase::MoveForward);\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveRight&quot;), this, &amp;ACharacterBase::MoveRight);\n    &#x2F;&#x2F; Pawn, Character 已经写好了内部的鼠标输入\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;PitchCamera&quot;), this, &amp;ACharacter::AddControllerPitchInput);\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;YawCamera&quot;), this, &amp;ACharacter::AddControllerYawInput);\n\n\t&#x2F;&#x2F; Bind Action &#x3D;&gt; Jump\n\tPlayerInputComponent-&gt;BindAction(TEXT(&quot;Jump&quot;), IE_Pressed, this, &amp;ACharacter::Jump);\n\tPlayerInputComponent-&gt;BindAction(TEXT(&quot;Jump&quot;), IE_Released, this, &amp;ACharacter::StopJumping);\n&#125;\n\nvoid ACharacterBase::MoveForward(float Value)\n&#123;\n    &#x2F;&#x2F; 这种方法有问题：人物应用摄像机旋转，摄像机应用控制器旋转时，鼠标完全朝上或朝下，将无法正常行走\n\t&#x2F;&#x2F;const FVector Direction &#x3D; FRotationMatrix(GetController()-&gt;GetControlRotation()).GetScaledAxis(EAxis::X);\n    \n    &#x2F;&#x2F; 这个方法简单，通用\n    const FVector Direction &#x3D; GetActorForwardVector();\n\tAddMovementInput(Direction, Value);\n    \n    ###### 官方写法 ######\n\tif ((Controller !&#x3D; nullptr) &amp;&amp; (Value !&#x3D; 0.0f))\n\t&#123;\n\t\t&#x2F;&#x2F; find out which way is forward\n\t\tconst FRotator Rotation &#x3D; Controller-&gt;GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t&#x2F;&#x2F; get forward vector\n\t\tconst FVector Direction &#x3D; FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\t\tAddMovementInput(Direction, Value);\n\t&#125;\n&#125;\n\nvoid ACharacterBase::MoveRight(float Value)\n&#123;\n\t&#x2F;&#x2F; const FVector Direction &#x3D; FRotationMatrix(GetController()-&gt;GetControlRotation()).GetScaledAxis(EAxis::Y);\n    \n    const FVector Direction &#x3D; GetActorRightVector();\n\tAddMovementInput(Direction, Value);\n    \n    ###### 官方写法 ######\n    if ( (Controller !&#x3D; nullptr) &amp;&amp; (Value !&#x3D; 0.0f) )\n\t&#123;\n\t\t&#x2F;&#x2F; find out which way is right\n\t\tconst FRotator Rotation &#x3D; Controller-&gt;GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\t\n\t\t&#x2F;&#x2F; get right vector \n\t\tconst FVector Direction &#x3D; FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\t\t&#x2F;&#x2F; add movement in that direction\n\t\tAddMovementInput(Direction, Value);\n\t&#125;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"6-Pawn\"><a href=\"#6-Pawn\" class=\"headerlink\" title=\"6. Pawn\"></a>6. Pawn</h3><p>情景：</p>\n<ul>\n<li>使用<code>Pawn</code>去写非人型</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category&#x3D;&quot;Pawn&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFVector MovementDirection;\n\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Pawn&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat MovementSpeed;\n\t\npublic:\n\tUFUNCTION()\n\tvoid MoveForward(float Value);\n\n\tUFUNCTION()\n\tvoid MoveRight(float Value);</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void APawnBase::Tick(float DeltaTime)\n&#123;\n\tSuper::Tick(DeltaTime);\n\n\tif (!MovementDirection.IsZero())\n\t&#123;\n\t\tconst FVector NewLocation &#x3D; GetActorLocation() + (MovementDirection * DeltaTime * MovementSpeed);\n\t\tSetActorLocation(NewLocation);\n\t&#125;\n&#125;\n\nvoid APawnBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n&#123;\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t&#x2F;&#x2F; Bind Axis &#x3D;&gt; MoveForward, MoveRight\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveForward&quot;), this, &amp;APawnBase::MoveForward);\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveRight&quot;), this, &amp;APawnBase::MoveRight);\n&#125;\n\nvoid APawnBase::MoveForward(float Value)\n&#123;\n\tMovementDirection.X &#x3D; FMath::Clamp(Value, -1.f, 1.f);\n&#125;\n\nvoid APawnBase::MoveRight(float Value)\n&#123;\n\tMovementDirection.Y &#x3D; FMath::Clamp(Value, -1.f, 1.f);\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"7-Impulse-Force\"><a href=\"#7-Impulse-Force\" class=\"headerlink\" title=\"7. Impulse Force\"></a>7. Impulse Force</h3><p>情景：</p>\n<ul>\n<li>反射一条射线，朝向<code>可移动</code>，开启<code>模拟物理</code>的<code>Actor</code></li>\n<li>使得<code>Actor</code>往射线方向添加<code>脉冲力</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceDistance;\n\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat ImpulseForce;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">FHitResult HitResult;\nconst FVector Start &#x3D; GetComponentLocation();\nconst FVector End &#x3D; Start + (GetComponentRotation().Vector() * TraceDistance);\n\nconst bool IsHit &#x3D; GetWorld()-&gt;LineTraceSingleByChannel(\n\tHitResult,\n\tStart,\n\tEnd,\n\tECC_Visibility);\n\nif (!IsHit)&#123;return;&#125;\nDrawDebugLine(GetWorld(), Start, End, FColor::Green, false, 0.1f);\nUStaticMeshComponent *StaticMeshComponent &#x3D; Cast&lt;UStaticMeshComponent&gt;(HitResult.GetActor()-&gt;GetRootComponent());\n\nif (!StaticMeshComponent || !HitResult.GetActor()-&gt;IsRootComponentMovable())&#123;return;&#125;\nStaticMeshComponent-&gt;AddImpulse(GetForwardVector() * ImpulseForce * StaticMeshComponent-&gt;GetMass());</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><code>HitResult.GetActor()-&gt;GetRootComponent()</code>是针对根组件是<code>UStaticMeshComponent</code></li>\n<li>最好改为<code>HitResult.GetActor()-&gt;GetStaticMeshComponent()</code></li>\n<li>目的确保任意<code>可移动</code>，<code>模拟物理</code>的<code>Actor</code>都能收到影响</li>\n<li><code>GetStaticMeshComponent()</code>可在任意<code>Actor</code>内实现此函数，返回<code>UStaticMeshComponent*</code></li>\n</ul>\n<h3 id=\"8-Add-Force\"><a href=\"#8-Add-Force\" class=\"headerlink\" title=\"8. Add Force\"></a>8. Add Force</h3><p>情景：</p>\n<ul>\n<li>不发射射线</li>\n<li>给可以模拟物理的<code>Actor</code>添加力</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class UStaticMeshComponent;\n\nprivate:\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent *StaticMeshComponent;\n\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat Force;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void UAddForce_SComp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tStaticMeshComponent &#x3D; Cast&lt;UStaticMeshComponent&gt;(GetOwner()-&gt;GetRootComponent());\n&#125;\n\nvoid UAddForce_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n&#123;\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tconst FVector UpForce &#x3D; GetUpVector();\n\tStaticMeshComponent-&gt;AddForce(UpForce * Force * StaticMeshComponent-&gt;GetMass());\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"9-Radia-Impulse-Force\"><a href=\"#9-Radia-Impulse-Force\" class=\"headerlink\" title=\"9. Radia Impulse Force\"></a>9. Radia Impulse Force</h3><p>情景：</p>\n<ul>\n<li>实现<code>爆炸力</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat ImpulseRadius;\n\t\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat ImpulseForceStrength;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void URadiaImpulse_SComp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tTArray&lt;FHitResult&gt; HitResults;\n\tconst FVector Start, End &#x3D; GetComponentLocation();\n\n\tconst bool IsHit &#x3D; GetWorld()-&gt;SweepMultiByChannel(\n\t\tHitResults,\n\t\tStart,\n\t\tEnd,\n\t\tFQuat::Identity,\n\t\tECC_WorldStatic,\n\t\tFCollisionShape::MakeSphere(ImpulseRadius));\n\n\tDrawDebugSphere(\n\t\tGetWorld(),\n\t\tStart,\n\t\tImpulseRadius,\n\t\t50,\n\t\tFColor::Green,\n\t\ttrue);\n\t\n\tif (!IsHit)&#123;return;&#125;\n\tfor (const auto &amp;result : HitResults)\n\t&#123;\n\t\tUStaticMeshComponent *MeshComponent &#x3D; Cast&lt;UStaticMeshComponent&gt;(result.GetActor()-&gt;GetRootComponent());\n\t\tif (!MeshComponent)&#123;continue;&#125;\n\t\tMeshComponent-&gt;AddRadialImpulse(\n\t\t\tStart,\n\t\t\tImpulseRadius,\n\t\t\tImpulseForceStrength,\n\t\t\tRIF_Linear,\n\t\t\ttrue);\n\t&#125;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"10-TimerHandle\"><a href=\"#10-TimerHandle\" class=\"headerlink\" title=\"10. TimerHandle\"></a>10. TimerHandle</h3><p>情景：</p>\n<ul>\n<li>需要使用定时器</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tint32 CallTracker;\n\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFTimerHandle TimerHandle;\n\t\npublic:\n\tUFUNCTION()\n\tvoid TimerFunction();</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void ATimerHandle_Actor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(\n\t\tTimerHandle,\n\t\tthis,\n\t\t&amp;ATimerHandle_Actor::TimerFunction,\n\t\t1.f,\n\t\ttrue,\n\t\t1.f);\n&#125;\n\nvoid ATimerHandle_Actor::TimerFunction()\n&#123;\n\tCallTracker &#x3D;&#x3D; 0 ?\n\t\tPrintScreen(&quot;Timer End&quot;), GetWorldTimerManager().ClearTimer(TimerHandle) :\n\t\tPrintScreen(FString::Printf(TEXT(&quot;Timer: %d&quot;), CallTracker));\n\n\t--CallTracker;\n&#125;</code></pre>\n\n\n</li>\n<li><p>注意：</p>\n<ul>\n<li>但类作为父类时，要使子类也可使用<code>TimerHandle</code>，需要用<code>protected</code>修饰</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"11-Disable-Actor\"><a href=\"#11-Disable-Actor\" class=\"headerlink\" title=\"11. Disable Actor\"></a>11. Disable Actor</h3><p>情景：</p>\n<ul>\n<li>编辑场景中的<code>Actor</code></li>\n<li>不希望直接从场景中删除</li>\n<li>可以在生成的实例编辑中关闭</li>\n<li>不消耗性能</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool isOverrideTick &#x3D; false;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool isAutoDisable &#x3D; false;\n\npublic:\n\tUFUNCTION()\n\tvoid SetActive(bool isActive);</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">ADisableActor::ADisableActor()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; true;\n\n&#125;\n\nvoid ADisableActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tisOverrideTick &#x3D; !PrimaryActorTick.bCanEverTick;\n\tif (isAutoDisable)&#123;SetActive(false);&#125;\n&#125;\n\nvoid ADisableActor::Tick(float DeltaSeconds)\n&#123;\n\tSuper::Tick(DeltaSeconds);\n\n\tPrintScreen(&quot;Tick&quot;);\n&#125;\n\nvoid ADisableActor::SetActive(bool isActive)\n&#123;\n\tif (isOverrideTick)\n\t&#123;\n\t\tSetActorTickEnabled(false);\n\t&#125;\n\telse\n\t&#123;\n\t\tSetActorTickEnabled(isActive);\n\t&#125;\n\n\tSetActorHiddenInGame(!isActive);\n\tSetActorEnableCollision(isActive);\n&#125;</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li>在场景中，只需要实例中的<code>isAutoDisable</code>进行勾选</li>\n<li>重新运行，<code>Actor</code>将会被禁用，不会作用于场景中</li>\n</ul>\n<h3 id=\"12-Hit-Event\"><a href=\"#12-Hit-Event\" class=\"headerlink\" title=\"12. Hit Event\"></a>12. Hit Event</h3><p>情景：</p>\n<ul>\n<li>通过一个<code>Actor</code>和场景中的其他<code>Actor</code>碰撞</li>\n<li>产生碰撞事件</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)\n\nclass UBoxComponent;\n\nprivate:\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUBoxComponent *HitBox;\n\npublic:\n\tUFUNCTION()\n\tvoid OnHitComp(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n\t\tFVector NormalImpulse, const FHitResult&amp; Hit);</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">AHitEventActor::AHitEventActor()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n\tHitBox &#x3D; CreateDefaultSubobject&lt;UBoxComponent&gt;(TEXT(&quot;Hit Box&quot;));\n&#125;\n\nvoid AHitEventActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tHitBox-&gt;OnComponentHit.AddDynamic(this, &amp;AHitEventActor::OnHitComp);\n&#125;\n\nvoid AHitEventActor::OnHitComp(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n\tFVector NormalImpulse, const FHitResult&amp; Hit)\n&#123;\n\tPrintScreen(FString::Printf(TEXT(&quot;Hit: %s&quot;), *OtherActor-&gt;GetName()));\n&#125;</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><code>HitBox</code>需要些设置，碰撞事件才能生效</li>\n<li>配置：<ul>\n<li>方便查看：<ul>\n<li>设置<code>形状</code></li>\n<li>设置<code>渲染</code></li>\n</ul>\n</li>\n<li>产生事件：设置<code>碰撞</code><ul>\n<li>打开<code>模拟生成命中事件</code></li>\n<li>设置<code>碰撞预设</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"13-Set-Material\"><a href=\"#13-Set-Material\" class=\"headerlink\" title=\"13. Set Material\"></a>13. Set Material</h3><p>情景：</p>\n<ul>\n<li>材质的创建</li>\n<li>材质的使用</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class UStaticMeshComponent;\nclass UMaterialInterface;\nclass UMaterial;\nclass UMaterialInstance;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent *Mesh;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInterface *MaterialOne;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInterface *MaterialTwo;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterial *Material;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInstance *MaterialInstance;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool IsChooseOne &#x3D; true;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">ASetMaterial::ASetMaterial()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n\tMesh &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;Mesh_Comp&quot;));\n\tRootComponent &#x3D; Mesh;\n\n\tMaterialOne &#x3D; CreateDefaultSubobject&lt;UMaterialInterface&gt;(TEXT(&quot;Material_One&quot;));\n\tMaterialTwo &#x3D; CreateDefaultSubobject&lt;UMaterialInterface&gt;(TEXT(&quot;Material_Two&quot;));\n&#125;\n\nvoid ASetMaterial::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tMesh-&gt;SetMaterial(0, IsChooseOne ? MaterialOne : MaterialTwo);\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"14-Dynamic-Material\"><a href=\"#14-Dynamic-Material\" class=\"headerlink\" title=\"14. Dynamic Material\"></a>14. Dynamic Material</h3><p>情景：</p>\n<ul>\n<li>有一个基本的材质</li>\n<li>通过创建材质实例</li>\n<li>对其中的<code>ScaleParam</code>，<code>VectorParam</code>进行动态修改</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class UStaticMeshComponent;\nclass UMaterialInterface;\nclass UMaterialInstanceDynamic;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent *Mesh;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInterface *MaterialInterface;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInstanceDynamic *DynamicInstance;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">ADynamicMaterial::ADynamicMaterial()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n\tMesh &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));\n\tRootComponent &#x3D; Mesh;\n&#125;\n\nvoid ADynamicMaterial::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tMaterialInterface &#x3D; Mesh-&gt;GetMaterial(0);\n\tDynamicInstance &#x3D; UMaterialInstanceDynamic::Create(MaterialInterface, this);\n\t\n\tMesh-&gt;SetMaterial(0, DynamicInstance);\n\n\tDynamicInstance-&gt;SetScalarParameterValue(TEXT(&quot;EmissiveStrength&quot;), 50.f);\n\tDynamicInstance-&gt;SetVectorParameterValue(TEXT(&quot;Color&quot;), FLinearColor::Yellow);\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"15-Interp-Target\"><a href=\"#15-Interp-Target\" class=\"headerlink\" title=\"15. Interp Target\"></a>15. Interp Target</h3><p>情景：</p>\n<ul>\n<li>指定<code>Actor</code>插值移动到<code>Target</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">private:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tAActor *Origin &#x3D; nullptr;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tAActor *Target;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat InterpSpeed &#x3D; 3.f;\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat WaitTime &#x3D; 1.f;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void UInterpTarget_SComp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\t\n\tOrigin &#x3D; GetOwner();\n&#125;\n\nvoid UInterpTarget_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n&#123;\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (WaitTime &gt; 0)\n\t&#123;\n\t\tWaitTime -&#x3D; DeltaTime;\n\t\treturn;\n\t&#125;\n\n\tif (!Target || !Origin)&#123;return;&#125;\n\t\n\tOrigin-&gt;SetActorLocation(\n\t\tFMath::VInterpTo(\n\t\t\tOrigin-&gt;GetActorLocation(),\n\t\t\tTarget-&gt;GetActorLocation(),\n\t\t\tDeltaTime,\n\t\t\tInterpSpeed));\n&#125;</code></pre></li>\n</ul>\n<p>说明：</p>\n<ul>\n<li><code>Origin = GetOwner();</code>写在构造函数里无效</li>\n</ul>\n<h3 id=\"16-Lerp\"><a href=\"#16-Lerp\" class=\"headerlink\" title=\"16. Lerp\"></a>16. Lerp</h3><p>情景：</p>\n<ul>\n<li>需要使用<code>Lerp</code></li>\n<li>修改<code>Actor</code>的<code>位置</code>和<code>材质</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class UMaterialInterface;\nclass UMaterialInstanceDynamic;\nclass UStaticMeshComponent;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInterface *MaterialInter;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInstanceDynamic *InstanceDynamic;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tAActor *OriginActor &#x3D; nullptr;\n\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent *Mesh;\n\t\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFVector StartLocation;\n\n\tUPROPERTY(EditAnywhere, meta&#x3D;(MakeEditWidget&#x3D;true))\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TimeElapsed &#x3D; 0;\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat LerpDuration &#x3D; 3.f;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat WaitTime &#x3D; 1.f;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;Lerp_SComp.h&quot;\n\nULerp_SComp::ULerp_SComp()\n&#123;\n\tPrimaryComponentTick.bCanEverTick &#x3D; true;\n\n\tMesh &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));\n&#125;\n\nvoid ULerp_SComp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tOriginActor &#x3D; GetOwner();\n\tStartLocation &#x3D; GetComponentLocation();\n\tMaterialInter &#x3D; Mesh-&gt;GetMaterial(0);\n\tInstanceDynamic &#x3D; UMaterialInstanceDynamic::Create(MaterialInter, this);\n\tMesh-&gt;SetMaterial(0, InstanceDynamic);\n\tInstanceDynamic-&gt;SetVectorParameterValue(TEXT(&quot;Color&quot;), FLinearColor::Blue);\n&#125;\n\nvoid ULerp_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n&#123;\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!OriginActor)&#123;return;&#125;\n\n\tif (WaitTime &gt; 0)&#123;WaitTime -&#x3D; DeltaTime; return;&#125;\n\n\tif (TimeElapsed &lt; LerpDuration)\n\t&#123;\n\t\tOriginActor-&gt;SetActorLocation(\n\t\t\tFMath::Lerp(\n\t\t\t\tStartLocation,\n\t\t\t\tTargetLocation,\n\t\t\t\tTimeElapsed &#x2F; LerpDuration));\n\n\t\tInstanceDynamic-&gt;SetVectorParameterValue(\n\t\t\tTEXT(&quot;Color&quot;),\n\t\t\tFMath::Lerp(\n\t\t\t\tFLinearColor::Blue,\n\t\t\t\tFLinearColor::Red,\n\t\t\t\tTimeElapsed &#x2F; LerpDuration));\n\n\t\tTimeElapsed +&#x3D; DeltaTime;\n\t&#125;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"18-黑洞\"><a href=\"#18-黑洞\" class=\"headerlink\" title=\"18. 黑洞\"></a>18. 黑洞</h3><p>情景：</p>\n<ul>\n<li>一个球，可以在一定范围内吸引<code>开启模拟物理的Actor</code></li>\n<li>吸到黑洞的<code>Actor</code>会被销毁</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li>简单的材质</li>\n<li>黑洞要黑，不能反光</li>\n<li>创建材质<code>Mat_BlackHole</code></li>\n<li>创建节点<code>VectorParameter</code>，设置<code>RGBA(0, 0, 0, 1)</code>，连接<code>基础颜色</code></li>\n<li>创建常量节点，设置为<code>0</code>， 连接其余的选项</li>\n</ul>\n<p>定义：</p>\n<p><code>BlackHole_Actor.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;Actor.h&quot;\n#include &quot;BlackHole_Actor.generated.h&quot;\n\nclass UStaticMeshComponent;\nclass USphereComponent;\nstruct FTimerHandle;\n\nUCLASS()\nclass FPSGAME_API ABlackHole_Actor : public AActor\n&#123;\n\tGENERATED_BODY()\n\t\npublic:\n\tABlackHole_Actor();\n\tvirtual void BeginPlay() override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;BlackHole&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat BlackHoleActionRate;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;BlackHole&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat BlackHoleStrength;\n\t\npublic:\n\tFTimerHandle BlackHoleActionHandle;\n\t\n\t&#x2F;&#x2F; Component\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;A_Hole&quot;)\n\tUStaticMeshComponent *BlackHoleStaticMeshComp;\n\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;A_Hole&quot;)\n\tUSphereComponent *InnerSphereComp;\n\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;A_Hole&quot;)\n\tUSphereComponent *OuterSphereComp;\n\npublic:\n\tUFUNCTION()\n\tvoid OverlapInnerSphere(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\t\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult &amp;SweepResult);\n\n\tUFUNCTION()\n\tvoid OnBlackHoleAction();\n&#125;;</code></pre>\n\n\n\n<p>实现</p>\n<p><code>BlackHole_Actor.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;BlackHole_Actor.h&quot;\n#include &quot;Components&#x2F;SphereComponent.h&quot;\n\nABlackHole_Actor::ABlackHole_Actor()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n\tBlackHoleActionRate &#x3D; 0.05f;\n\tBlackHoleStrength &#x3D; 10000.f;\n\n\tBlackHoleStaticMeshComp &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;BlackStaticMesh&quot;));\n\tBlackHoleStaticMeshComp-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\tBlackHoleStaticMeshComp-&gt;CastShadow &#x3D; false;\n\tRootComponent &#x3D; BlackHoleStaticMeshComp;\n\n\tInnerSphereComp &#x3D; CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;InnerSphereComp&quot;));\n\tInnerSphereComp-&gt;SetSphereRadius(100.f);\n\tInnerSphereComp-&gt;SetupAttachment(BlackHoleStaticMeshComp);\n\t\n\tOuterSphereComp &#x3D; CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;OuterSphereComp&quot;));\n\tOuterSphereComp-&gt;SetSphereRadius(3000.f);\n\tOuterSphereComp-&gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tOuterSphereComp-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\n\tOuterSphereComp-&gt;SetupAttachment(BlackHoleStaticMeshComp);\n&#125;\n\nvoid ABlackHole_Actor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tcheck(InnerSphereComp);\n\tcheck(OuterSphereComp);\n\t\n\tif (InnerSphereComp)\n\t&#123;\n\t\tInnerSphereComp-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;ABlackHole_Actor::OverlapInnerSphere);\n\t&#125;\n\n\tif (GetWorld())\n\t&#123;\n\t\tGetWorldTimerManager().SetTimer(\n\t\t\tBlackHoleActionHandle,\n\t\t\tthis,\n\t\t\t&amp;ABlackHole_Actor::OnBlackHoleAction,\n\t\t\tBlackHoleActionRate,\n\t\t\ttrue\n\t\t\t);\n\t&#125;\n&#125;\n\nvoid ABlackHole_Actor::OverlapInnerSphere(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&amp; SweepResult)\n&#123;\n\tif (!OtherActor)&#123;return;&#125;\n\tOtherActor-&gt;Destroy();\n&#125;\n\nvoid ABlackHole_Actor::OnBlackHoleAction()\n&#123;\n\tTArray&lt;UPrimitiveComponent*&gt; OverlappingComp;\n\n\tif (!OuterSphereComp)&#123;return;&#125;\n\tOuterSphereComp-&gt;GetOverlappingComponents(OverlappingComp);\n\n\tfor (int i &#x3D; 0; i &lt; OverlappingComp.Num(); ++i)\n\t&#123;\n\t\tif (OverlappingComp[i] &amp;&amp; OverlappingComp[i]-&gt;IsSimulatingPhysics())\n\t\t&#123;\n\t\t\tconst float SphereRadius &#x3D; OuterSphereComp-&gt;GetScaledSphereRadius();\n\t\t\tOverlappingComp[i]-&gt;AddRadialForce(\n\t\t\t\tGetActorLocation(),\n\t\t\t\tSphereRadius,\n\t\t\t\t-BlackHoleStrength,\n\t\t\t\tRIF_Constant,\n\t\t\t\ttrue);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n\n\n\n\n\n\n<h3 id=\"19-玩家死亡后进入观察\"><a href=\"#19-玩家死亡后进入观察\" class=\"headerlink\" title=\"19. 玩家死亡后进入观察\"></a>19. 玩家死亡后进入观察</h3><p>情景：</p>\n<ul>\n<li>但玩家死亡后</li>\n<li>播放死亡动画</li>\n<li>禁用玩家输入</li>\n<li>控制器切换控制到<code>Spectator</code></li>\n<li>玩家不与其他玩家产生碰撞</li>\n<li>玩家外的胶囊体组件无碰撞</li>\n<li>死亡动画播放带有布娃娃效果</li>\n<li>一定时间后销毁</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>前提：</p>\n<ul>\n<li>将死亡动画创建为<code>蒙太奇动画</code></li>\n<li>设置蒙太奇的<code>启用自动混出</code>为<code>false</code></li>\n</ul>\n</li>\n<li><p>代码：</p>\n<ul>\n<li><p>定义</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class UAnimMontage;\n\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Montage&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nUAnimMontage *AnimMontage_Death;\n\nUFUNCTION()\nvoid OnDead();</code></pre>\n\n\n</li>\n<li><p>实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void ASTUCharacterBase::OnDead()\n&#123;\n\tif (!AnimMontage_Death)&#123;return;&#125;\n\tPlayAnimMontage(AnimMontage_Death);\n\tGetCharacterMovement()-&gt;DisableMovement();\n\n\tif (GetController())\n\t&#123;\n\t\tGetController()-&gt;ChangeState(NAME_Spectating);\n\t&#125;\n\tGetCapsuleComponent()-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);\n\tSetLifeSpan(5.0f);\n\n\tGetMesh()-&gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tGetMesh()-&gt;SetSimulatePhysics(true);\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"20-高处坠落伤害\"><a href=\"#20-高处坠落伤害\" class=\"headerlink\" title=\"20. 高处坠落伤害\"></a>20. 高处坠落伤害</h3><p>情景：</p>\n<ul>\n<li>高处下落的速度达到指定值</li>\n<li>玩家受到相应的伤害</li>\n<li>使用<code>ACharacter</code>自带的功能实现<ul>\n<li><code>virtual void Landed(const FHitResult&amp; Hit);</code></li>\n<li><code>FLandedSignature LandedDelegate;</code></li>\n</ul>\n</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>介绍：</p>\n<p><code>ACharacter.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\t&#x2F;**\n\t * Called upon landing when falling, to perform actions based on the Hit result. Triggers the OnLanded event.\n\t * Note that movement mode is still &quot;Falling&quot; during this event. Current Velocity value is the velocity at the time of landing.\n\t * Consider OnMovementModeChanged() as well, as that can be used once the movement mode changes to the new mode (most likely Walking).\n\t *\n\t * @param Hit Result describing the landing that resulted in a valid landing spot.\n\t * @see OnMovementModeChanged()\n\t *&#x2F;\n\tvirtual void Landed(const FHitResult&amp; Hit);\n\n&#x2F;**\n* 落地时调用，根据命中结果执行动作。 触发 OnLanded 事件。\n* 请注意，此活动期间移动模式仍为“下降”。 当前速度值是着陆时的速度。\n* 还要考虑 OnMovementModeChanged()，因为一旦移动模式更改为新模式（很可能是步行），就可以使用它。\n*\n* @param Hit Result 描述了导致有效着陆点的着陆。\n* @see OnMovementModeChanged()\n*&#x2F;\n\tFLandedSignature LandedDelegate;\t</code></pre>\n\n\n</li>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;FallingDamage&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nFVector2D LandedDamageVelocity;\n\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;FallingDamage&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nFVector2D LandedDamage;\n\nUFUNCTION()\nvoid OnGroundLanded(const FHitResult&amp; HitResult);</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void ASTUCharacterBase::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tLandedDelegate.AddDynamic(this, &amp;ASTUCharacterBase::OnGroundLanded);\n&#125;\n\nvoid ASTUCharacterBase::OnGroundLanded(const FHitResult&amp; HitResult)\n&#123;\n\tconst float FallVelocityZ &#x3D; -GetVelocity().Z;\n\n\tif (FallVelocityZ &lt; LandedDamageVelocity.X)&#123;return;&#125;\n\tconst float FinalDamage &#x3D; FMath::GetMappedRangeValueClamped(LandedDamageVelocity,\n\t\tLandedDamage, FallVelocityZ);\n\tTakeDamage(FinalDamage, FDamageEvent&#123;&#125;, nullptr, nullptr);\n&#125;\n\n\n# FMath::GetMappedRangeValueClamped() --&gt; UnrealMathUtility.h\n&#x2F;&#x2F; For the given Value clamped to the [Input:Range] inclusive, returns the corresponding percentage in [Output:Range] Inclusive\n&#x2F;&#x2F; 对于钳制到 [Input:Range] 的给定值，返回 [Output:Range] 包含的相应百分比</code></pre></li>\n</ul>\n<h3 id=\"21-FindAnimNotifyByClass\"><a href=\"#21-FindAnimNotifyByClass\" class=\"headerlink\" title=\"21. FindAnimNotifyByClass\"></a>21. FindAnimNotifyByClass</h3><p>情景：</p>\n<ul>\n<li>按类型<code>UAnimSequenceBase</code>中查找<code>FAnimNotifyEvent</code></li>\n<li>再绑定对应的通知事件</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>前提：</p>\n<p>创建<code>AnimNotifyEventUntility.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\nclass AnimNotifyEventUntility\n&#123;\npublic:\n\ttemplate&lt;typename T&gt;\n\tstatic T* FindNotifyByClass(UAnimSequenceBase* AnimSequenceBase)\n\t&#123;\n\t\tif (!AnimSequenceBase)&#123;return nullptr;&#125;\n\n\t\tconst auto NotifyEvents &#x3D; AnimSequenceBase-&gt;Notifies;\n\t\tfor (const auto&amp; NotifyEvent : NotifyEvents)\n\t\t&#123;\n\t\t\tif (const auto AnimNotify &#x3D; Cast&lt;T&gt;(NotifyEvent.Notify))\n\t\t\t&#123;\n\t\t\t\treturn AnimNotify;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn nullptr;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<p>创建<code>AnimNotifyBase.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Animation&#x2F;AnimNotifies&#x2F;AnimNotify.h&quot;\n#include &quot;STUAnimNotifyBase.generated.h&quot;\n\nclass USkeletalMeshComponent;\n\nDECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifySignature, USkeletalMeshComponent*)\n\nUCLASS()\nclass B_01_TPS_API UAnimNotifyBase : public UAnimNotify\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tvirtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation) override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\n\tFOnNotifySignature OnNotify;\t\n&#125;;\n\n# Notify\n&#x2F;&#x2F; 是 AnimNotify 自带的函数，同时不建议 UE5 使用</code></pre>\n\n\n\n<p>实现<code>AnimNotifyBase.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;AnimNotifyBase.h&quot;\n\nvoid USTUAnimNotifyBase::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation)\n&#123;\n\tSuper::Notify(MeshComp, Animation);\n\n\tOnNotify.Broadcast(MeshComp);\n&#125;</code></pre>\n\n\n\n\n</li>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nUAnimMontage *EquipAnimMontage;\n\nUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nbool IsEquipAnimInProgress;\n\nUFUNCTION()\nvoid InitAnimations();\n\nUFUNCTION()\nvoid OnEquipFinished(USkeletalMeshComponent* SkeletalMeshComponent);</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;AnimNotify&#x2F;AnimNotifyEventUntility.h&quot;\n\nvoid USTUWeaponActorComponent::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tInitAnimations();\n&#125;\n\nvoid USTUWeaponActorComponent::InitAnimations()\n&#123;\n\tif (const auto EquipFinishedNotify &#x3D; \n        AnimUtils::FindNotifyByClass&lt;USTUAnimNotifyEquipFinished&gt;(EquipAnimMontage))\n\t&#123;\n\t\tEquipFinishedNotify-&gt;OnNotify.AddUObject(this, &amp;USTUWeaponActorComponent::OnEquipFinished);\n\t&#125;\n\telse\n\t&#123;\n\t\tcheckNoEntry();\n\t&#125;\n&#125;\n\nvoid USTUWeaponActorComponent::OnEquipFinished(USkeletalMeshComponent* SkeletalMeshComponent)\n&#123;\n\tconst ASTUCharacterBase *Character &#x3D; Cast&lt;ASTUCharacterBase&gt;(GetOwner());\n\n\tif (!Character || !(Character-&gt;GetMesh() &#x3D;&#x3D; SkeletalMeshComponent))&#123;return;&#125;\n\tIsEquipAnimInProgress &#x3D; false;\n&#125;\n\n# USTUAnimNotifyEquipFinished\n&#x2F;&#x2F; 是AnimNotifyBase的子类\n&#x2F;&#x2F; 里面不用写东西\n&#x2F;&#x2F; 主要是用来：修改备注名，修改颜色，绑定事件</code></pre></li>\n</ul>\n<h3 id=\"22-类生成附加到插槽\"><a href=\"#22-类生成附加到插槽\" class=\"headerlink\" title=\"22. 类生成附加到插槽\"></a>22. 类生成附加到插槽</h3><p>情景：</p>\n<ul>\n<li><p>用指定的组件开始生成</p>\n</li>\n<li><p><code>BeginPlay()</code>时开始</p>\n</li>\n<li><p>指定要生成的<code>class</code></p>\n</li>\n<li><p>以有需要附加的插槽&#96;&#96;</p>\n</li>\n<li><p>将生成的对象附加到插槽上，并应用插槽的<code>transform</code></p>\n</li>\n<li><p><code>EndPlay()</code>结束后，生成的<code>Actor</code>也要销毁</p>\n</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：<code>UWeaponActorComponent.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UCLASS( ClassGroup&#x3D;(Custom), meta&#x3D;(BlueprintSpawnableComponent) )\nclass B_01_TPS_API USTUWeaponActorComponent : public UActorComponent\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUSTUWeaponActorComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\t\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;ASTUWeaponBase&gt; WeaponClass;\n    \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFName WeaponEquipSocketName;\n    \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tASTUWeaponBase *CurrentWeapon;\n    \n    &#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tvoid SpawnWeapons();\n    \n    UFUNCTION()\n\tvoid AttachWeaponToSocket(ASTUWeaponBase* Weapon, USceneComponent* SceneComponent, const FName&amp; SocketName);\n&#125;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">USTUWeaponActorComponent::USTUWeaponActorComponent()\n&#123;\n\tPrimaryComponentTick.bCanEverTick &#x3D; false;\n\n\tWeaponEquipSocketName &#x3D; TEXT(&quot;WeaponSocket&quot;);\n    WeaponClass &#x3D; nullptr\n\tCurrentWeapon &#x3D; nullptr;\n&#125;\n\nvoid USTUWeaponActorComponent::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tSpawnWeapons();\n&#125;\n\nvoid USTUWeaponActorComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)\n&#123;\n\tCurrentWeapon-&gt;DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);\n\tCurrentWeapon-&gt;Destroy();\n    CurrentWeapon &#x3D; nullptr;\n\n\tSuper::EndPlay(EndPlayReason);\n&#125;\n\nvoid USTUWeaponActorComponent::SpawnWeapons()\n&#123;\n\tif (!GetWorld())&#123;return;&#125;\n\tASTUCharacterBase *Character &#x3D; Cast&lt;ASTUCharacterBase&gt;(GetOwner());\n\n\tif (!Character)&#123;return;&#125;\n    const auto Weapon &#x3D; GetWorld()-&gt;SpawnActor&lt;ASTUWeaponBase&gt;(WeaponClass);\n    \n\tif (!Weapon)&#123;continue;&#125;\n    CurrentWeapon &#x3D; Weapon;\n    \n    &#x2F;&#x2F; 此处留一个伏笔，当前武器指定了 Onwer 是当前的玩家\n\tCurrentWeapon-&gt;SetOwner(Character);\n    \n\tAttachWeaponToSocket(CurrentWeapon, Character-&gt;GetMesh(), WeaponEquipSocketName);\n&#125;\n\nvoid USTUWeaponActorComponent::AttachWeaponToSocket(ASTUWeaponBase* Weapon, USceneComponent* SceneComponent,\n                                                    const FName&amp; SocketName)\n&#123;\n\tif (!Weapon || !SceneComponent)&#123;return;&#125;\n\tconst FAttachmentTransformRules AttachmentTransformRules(EAttachmentRule::SnapToTarget, false);\n\tWeapon-&gt;AttachToComponent(SceneComponent, AttachmentTransformRules, SocketName);\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"23-CameraShake\"><a href=\"#23-CameraShake\" class=\"headerlink\" title=\"23. CameraShake\"></a>23. CameraShake</h3><p>情景：</p>\n<ul>\n<li>在<code>UHealthActorComponent</code>中实现<code>CameraShake</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">public:\n\tUSTUHealthActorComponent();\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Camera&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;UCameraShakeBase&gt; CameraShake;\n\npublic:\n\tUFUNCTION()\n\tvoid PlayCameraShake();</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUHealthActorComponent.h&quot;\n\nUSTUHealthActorComponent::USTUHealthActorComponent()\n&#123;\n\tPrimaryComponentTick.bCanEverTick &#x3D; false;\n\n\tCameraShake &#x3D; nullptr;\n&#125;\n\nvoid USTUHealthActorComponent::PlayCameraShake()\n&#123;\n\tconst auto Player &#x3D; Cast&lt;APawn&gt;(GetOwner());\n\n\tif (!Player)&#123;return;&#125;\n\tconst auto Controller &#x3D; Player-&gt;GetController&lt;APlayerController&gt;();\n\n\tif (!Controller || !Controller-&gt;PlayerCameraManager)&#123;return;&#125;\n\tController-&gt;PlayerCameraManager-&gt;StartCameraShake(CameraShake);\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"24-HealthComponent\"><a href=\"#24-HealthComponent\" class=\"headerlink\" title=\"24. HealthComponent\"></a>24. HealthComponent</h3><p>情景：</p>\n<ul>\n<li>设计一个角色的生命组件</li>\n<li>有生命值</li>\n<li>有伤害处理</li>\n<li>呼吸回血效果</li>\n<li>有处理玩家死亡效果</li>\n</ul>\n<p>前提：</p>\n<ul>\n<li>定义玩家类：<code>ACharacterBase</code></li>\n<li>定义生命组件类：<code>UHealthComponent</code></li>\n</ul>\n<p>结构分析：</p>\n<ul>\n<li>玩家类中的<code>OnDead</code>效果对应于生命组件类中的<code>OnDead</code></li>\n<li>生命组件类：<ul>\n<li>可以通过蓝图获得<code>CurrentHP</code>，<code>MaxHP</code>，<code>IsDead</code></li>\n<li>通过<code>TimerHandle</code>实现呼吸回血效果</li>\n</ul>\n</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>生命组件类</p>\n</li>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">DECLARE_MULTICAST_DELEGATE(FOnDead);\nDECLARE_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float);\n\nstruct FTimerHandle;\n\nUCLASS( ClassGroup&#x3D;(Custom), meta&#x3D;(BlueprintSpawnableComponent) )\nclass B_01_TPS_API USTUHealthActorComponent : public UActorComponent\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUSTUHealthActorComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat MaxHealth;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Heal&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool IsAutoHeal;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Heal&quot;,\n\t\tmeta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;IsAutoHeal&quot;))\n\tfloat HealUpdateTime;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Heal&quot;,\n\tmeta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;IsAutoHeal&quot;))\n\tfloat HealDelayTime;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Heal&quot;,\n\tmeta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;IsAutoHeal&quot;))\n\tfloat HealModifierValue;\n\t\npublic:\n\tFTimerHandle HealTimerHandle;\n\tFOnDead OnDead;\n\tFOnHealthChanged OnHealthChanged;\n\t\n\t&#x2F;&#x2F; Function\t\npublic:\n\tUFUNCTION(BlueprintCallable)\n\tFORCEINLINE float GetHP() const &#123;return Health;&#125;\n\t\n\tUFUNCTION()\n\tvoid OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType,\n\t\tclass AController* InstigatedBy, AActor* DamageCauser);\n\t\n\tUFUNCTION(BlueprintCallable)\n\tbool IsDead() const &#123;return FMath::IsNearlyZero(Health);&#125;\n\n\tUFUNCTION()\n\tvoid HealUpdate();\n    \n\tUFUNCTION()\n\tvoid SetHealth(float NewHealth);\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUHealthActorComponent.h&quot;\n\nUSTUHealthActorComponent::USTUHealthActorComponent()\n&#123;\n\tPrimaryComponentTick.bCanEverTick &#x3D; false;\n\n\tHealth &#x3D; 0.f;\n\tMaxHealth &#x3D; 100.f;\n\n\tIsAutoHeal &#x3D; true;\n\tHealUpdateTime &#x3D; 1.f;\n\tHealDelayTime &#x3D; 4.f;\n\tHealModifierValue &#x3D; 10.f;\n&#125;\n\nvoid USTUHealthActorComponent::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n    SetHealth(MaxHealth);\n\n\tif (GetOwner())\n\t&#123;\n\t\tGetOwner()-&gt;OnTakeAnyDamage.AddDynamic(this, &amp;USTUHealthActorComponent::OnTakeAnyDamage);\n\t&#125;\n&#125;\n\n&#x2F;* My Code *&#x2F;\nvoid USTUHealthActorComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType,\n\tAController* InstigatedBy, AActor* DamageCauser)\n&#123;\n\tif (Health &lt;&#x3D; 0.f || IsDead() || !GetWorld())&#123;return;&#125;\n\tSetHealth(Health -  Damage);\n\n\tif (IsDead())\n\t&#123;\n\t\tOnDead.Broadcast();\n\t&#125;\n\telse if (IsAutoHeal)\n\t&#123;\n\t\tGetWorld()-&gt;GetTimerManager().SetTimer(HealTimerHandle, this, &amp;USTUHealthActorComponent::HealUpdate,\n\t\t\tHealUpdateTime, IsAutoHeal, HealDelayTime);\n\t&#125;\n&#125;\n\nvoid USTUHealthActorComponent::HealUpdate()\n&#123;\n\tSetHealth(Health +&#x3D; HealModifierValue);\n\n\tif (!FMath::IsNearlyEqual(Health, MaxHealth) || !GetWorld())&#123;return;&#125;\n\tGetWorld()-&gt;GetTimerManager().ClearTimer(HealTimerHandle);\n&#125;\n\nvoid USTUHealthActorComponent::SetHealth(float NewHealth)\n&#123;\n\tHealth &#x3D; FMath::Clamp(NewHealth, 0.f, MaxHealth);\n&#125;</code></pre>\n\n\n</li>\n<li><p>玩家类</p>\n</li>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class USTUHealthActorComponent;\n\npublic:\n\tASTUCharacterBase();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Component\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Component&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUSTUHealthActorComponent *HealthActorComponent;\n\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tvoid OnDead();</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUHealthActorComponent.h&quot;\n\nASTUCharacterBase::ASTUCharacterBase()\n&#123;\n    PrimaryActorTick.bCanEverTick &#x3D; false;\n    \n    HealthActorComponent &#x3D; CreateDefaultSubobject&lt;USTUHealthActorComponent&gt;(TEXT(&quot;HPComp&quot;));\n&#125;\n\nvoid ASTUCharacterBase::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tcheck(HealthActorComponent);\n\tHealthActorComponent-&gt;OnDead.AddUObject(this, &amp;ASTUCharacterBase::OnDead);\n&#125;\n\nvoid ASTUCharacterBase::OnDead()\n&#123;\n    &#x2F;&#x2F; OnDead Event\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"25-GetActorComponent\"><a href=\"#25-GetActorComponent\" class=\"headerlink\" title=\"25. GetActorComponent\"></a>25. GetActorComponent</h3><p>情景：</p>\n<ul>\n<li>需要通过已有的<code>Actor</code>获得其已添加的<code>Component</code></li>\n<li>将这个方法提取成一个<code>模板工具类</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\nclass FH_Utility\n&#123;\npublic:\n\ttemplate&lt;typename T&gt;\n\tFORCEINLINE static T* GetActorComponent(const AActor* Actor)\n\t&#123;\n\t\tif (!Actor)&#123;return nullptr;&#125;\n\t\tconst auto Component &#x3D; Actor-&gt;GetComponentByClass(T::StaticClass());\n\t\tT* ResultComponent &#x3D; Cast&lt;T&gt;(Component);\n\n\t\tif (!ResultComponent)&#123;return nullptr;&#125;\n\t\treturn ResultComponent;\n\t&#125;\n&#125;;</code></pre></li>\n</ul>\n<h3 id=\"26-设计结构体和委托\"><a href=\"#26-设计结构体和委托\" class=\"headerlink\" title=\"26. 设计结构体和委托\"></a>26. 设计结构体和委托</h3><p>情景：</p>\n<ul>\n<li>将一类<code>结构体</code>或<code>Delegate</code>写进单独的类中</li>\n<li>便于管理</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：<code>FH_CoreType.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;FH_CoreType.generated.h&quot; &#x2F;&#x2F; 因为使用了Delegate 和 USTRUCT，这里要手动加入\n\nclass ASTUWeaponBase;\nclass UAnimMontage;\n\n&#x2F;&#x2F; Delegate 的定义可以写在这里\nDECLARE_MULTICAST_DELEGATE(FOnDead);\nDECLARE_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float);\n\n&#x2F;&#x2F; 可以定义结构体，USTRCUT() 内加入 BlueprintType, 蓝图就可以或这个结构体\nUSTRUCT(BlueprintType)\nstruct FAmmoData\n&#123;\n\tGENERATED_USTRUCT_BODY() &#x2F;&#x2F; 原：GENERATED_BODY() 需改为 GENERATED_USTRUCT_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Ammo&quot;,  meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tint32 Bullets &#x3D; 0;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Ammo&quot;,\n\t\t\t  meta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;!IsInfinity&quot;))\n\tint32 Clips &#x3D; 0;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Ammo&quot;,  meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool IsInfinity &#x3D; false;\n&#125;;\n\nUSTRUCT(BlueprintType)\nstruct FWeaponData\n&#123;\n\tGENERATED_USTRUCT_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;ReloadWeapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;ASTUWeaponBase&gt; WeaponClass &#x3D; nullptr;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;ReloadWeapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUAnimMontage* ReloadAnimMontage &#x3D; nullptr;\n&#125;;</code></pre></li>\n</ul>\n<h3 id=\"27-AIPerception获得最近Actor\"><a href=\"#27-AIPerception获得最近Actor\" class=\"headerlink\" title=\"27. AIPerception获得最近Actor\"></a>27. AIPerception获得最近Actor</h3><p>情景：</p>\n<ul>\n<li><code>AI</code>绑定了<code>AIPerceptionComponent</code></li>\n<li>设置<code>AISense</code>：例如–目光<code>UAISense_Sight</code></li>\n<li>利用<code>GetCurrentlyPerceivedActors</code>获得目光内的有效<code>Actor</code></li>\n<li>通过<code>Actor</code>获得其前面<code>HealthComponent</code>，判断<code>Actor</code>是否符合需求</li>\n<li>最后通过算法，求得并返回离<code>AI</code>最近的<code>Actor</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Perception&#x2F;AIPerceptionComponent.h&quot;\n#include &quot;STUAIPerceptionComponent.generated.h&quot;\n\nUCLASS()\nclass B_01_TPS_API USTUAIPerceptionComponent : public UAIPerceptionComponent\n&#123;\n\tGENERATED_BODY()\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tAActor* GetClosetActor() const;\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUAIPerceptionComponent.h&quot;\n#include &quot;AIController.h&quot;\n#include &quot;STUHealthActorComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Dev&#x2F;STUUtils.h&quot;\n#include &quot;Perception&#x2F;AISense_Sight.h&quot;\n\nAActor* USTUAIPerceptionComponent::GetClosetActor() const\n&#123;\n\tTArray&lt;AActor*&gt; PerceptionActors;\n    \n    &#x2F;&#x2F; AIPerceptionComponent自带的函数，获得所有已经被感知的Actor\n\tGetCurrentlyPerceivedActors(UAISense_Sight::StaticClass(), PerceptionActors);\n\n    &#x2F;&#x2F; 判断组件的拥有AI是否有AIController\n\tif (PerceptionActors.Num() &lt;&#x3D; 0)&#123;return nullptr;&#125;\n\tconst auto Controller &#x3D; Cast&lt;AAIController&gt;(GetOwner());\n\n    &#x2F;&#x2F; 判断当前AI是否有效\n\tif (!Controller)&#123;return nullptr;&#125;\n\tconst auto Pawn &#x3D; Controller-&gt;GetPawn();\n\n    &#x2F;&#x2F; 开始计算最近的Actor\n\tif (!Pawn)&#123;return nullptr;&#125;\n    \n    &#x2F;&#x2F; MAX_FLT 是 UnrealEngine 自带的 UrealMathUtility 中的 宏\n    &#x2F;&#x2F; #define MAX_FLT 3.402823466e+38F\n    &#x2F;&#x2F; 表示可虚幻引擎可表达的 最大浮点数\n\tfloat NealDistance &#x3D; MAX_FLT;\n\tAActor* NealPawn &#x3D; nullptr;\n\tfor (const auto&amp; PerceptionActor : PerceptionActors)\n\t&#123;\n        &#x2F;&#x2F; 此处使用了前面创建的 HealthComponent 和 FH_Utility\n        &#x2F;&#x2F; 判断 感知到的Actor是否有生命组件，是否还活着\n\t\tconst auto HealthComp &#x3D; STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(PerceptionActor);\n\t\t\n        if (!HealthComp || HealthComp-&gt;IsDead())&#123;return nullptr;&#125;\n        const auto CurrentDistance &#x3D; (PerceptionActor-&gt;GetActorLocation() - Pawn-&gt;GetActorLocation()).Size();\n\t\t\n        &#x2F;&#x2F; 找出最近距离的Actor\n        if (CurrentDistance &lt; NealDistance)\n\t\t&#123;\n\t\t\tNealDistance &#x3D; CurrentDistance;\n\t\t\tNealPawn &#x3D; PerceptionActor;\n\t\t&#125;\n\t&#125;\n\treturn NealPawn;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"28-GameMode\"><a href=\"#28-GameMode\" class=\"headerlink\" title=\"28. GameMode\"></a>28. GameMode</h3><p>情景：</p>\n<ul>\n<li>通过<code>GameModeBase</code>进行初始化</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">ASTUGameModeBase::ASTUGameModeBase()\n&#123;\n\tDefaultPawnClass &#x3D; ASTUCharacterBase::StaticClass();\n\tPlayerControllerClass &#x3D; ASTUPlayerController::StaticClass();\n\tHUDClass &#x3D; ASTUGameHUD::StaticClass();\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"29-拾取物-PickUp\"><a href=\"#29-拾取物-PickUp\" class=\"headerlink\" title=\"29. 拾取物-PickUp\"></a>29. 拾取物-PickUp</h3><p>情景：</p>\n<ul>\n<li>创建<code>PickUpBase</code></li>\n<li>可被放置在场景中</li>\n<li>可以<code>Actor</code>重叠检查</li>\n<li>不与<code>Actor</code>产生<code>BlockHit</code></li>\n<li>拾取后不销毁，隐藏起来，一段时间重生，<code>TimerHandle</code></li>\n<li>物品默认旋转，拾取后关闭旋转，重生后开启旋转，<code>TimerHandle</code></li>\n<li>被拾取后，让拾取的<code>Actor</code>执行指定的<code>GivePickUpTo</code>，<code>Virtual Function</code></li>\n<li>具体执行的功能，通过子类去实现</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;Actor.h&quot;\n#include &quot;STUBasePickUp.generated.h&quot;\n\nclass USphereComponent;\nclass UStaticMeshComponent;\nstruct FTimerHandle;\n\nUCLASS()\nclass B_01_TPS_API ASTUBasePickUp : public AActor\n&#123;\n\tGENERATED_BODY()\n\t\npublic:\n\tASTUBasePickUp();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void NotifyActorBeginOverlap(AActor* OtherActor) override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;PickUp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat RespawnTime;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;PickUp&quot;, meta&#x3D;(ClampMin&#x3D;0.0333, ClampMax&#x3D;0.0083))\n\tfloat RotationYawRate;\n    \n    FTimerHandle RespawnHandle;\n\n\tFTimerHandle RotationYawHandle;\n\t\n\t&#x2F;&#x2F; Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;PickUp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUSphereComponent* CollisionComponent;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;PickUp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tvoid PickUpWasTaken();\n\n\tUFUNCTION()\n\tvoid Respawn();\n\n\tUFUNCTION()\n\tvoid LoopRotationYawHandle();\n\n\tUFUNCTION()\n\tvoid BeginRotationYaw();\n\n\tUFUNCTION()\n\tvirtual bool GivePickUpTo(APawn* PlayerPawn) &#123; return false; &#125;\n&#125;;\n\n# NotifyActorBeginOverlap(AActor* OtherActor)\n\t&#x2F;** \n\t *\tEvent when this actor overlaps another actor, for example a player walking into a trigger.\n\t *\tFor events when objects have a blocking collision, for example a player hitting a wall, see &#39;Hit&#39; events.\n\t *\t@note Components on both this and the other Actor must have bGenerateOverlapEvents set to true to generate overlap events.\n\t *&#x2F;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUBasePickUp.h&quot;\n#include &quot;Components&#x2F;SphereComponent.h&quot;\n\nASTUBasePickUp::ASTUBasePickUp()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n    RespawnTime &#x3D; 5.0f;\n\tRotationYawRate &#x3D; 0.0333f;\n    \n    CollisionComponent &#x3D; CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;CollisionComp&quot;));\n\tRootComponent &#x3D; CollisionComponent;\n\tCollisionComponent-&gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\n\tCollisionComponent-&gt;InitSphereRadius(50.f);\n\n\tStaticMeshComponent &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));\n\tStaticMeshComponent-&gt;SetupAttachment(RootComponent);\n\tStaticMeshComponent-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\tStaticMeshComponent-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);\n&#125;\n\nvoid ASTUBasePickUp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tcheck(CollisionComponent);\n\tcheck(StaticMeshComponent);\n\n\tLoopRotationYawHandle();\n&#125;\n\nvoid ASTUBasePickUp::NotifyActorBeginOverlap(AActor* OtherActor)\n&#123;\n\tSuper::NotifyActorBeginOverlap(OtherActor);\n\n\tconst auto Player &#x3D; Cast&lt;APawn&gt;(OtherActor);\n\t\n\tif (!GivePickUpTo(Player))&#123;return;&#125;\n\tPickUpWasTaken();\n&#125;\n\n&#x2F;* My Code *&#x2F;\nvoid ASTUBasePickUp::PickUpWasTaken()\n&#123;\n\tif (!GetRootComponent())&#123;return;&#125;\n\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);\n\tGetRootComponent()-&gt;SetVisibility(false, true);\n    \n\tGetWorldTimerManager().SetTimer(RespawnHandle, this, &amp;ASTUBasePickUp::Respawn, RespawnTime, false);\n\tGetWorldTimerManager().ClearTimer(RotationYawHandle);\n&#125;\n\nvoid ASTUBasePickUp::Respawn()\n&#123;\n\tif (!GetRootComponent())&#123;return;&#125;\n\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\n\tGetRootComponent()-&gt;SetVisibility(true, true);\n    \n\tGetWorldTimerManager().ClearTimer(RespawnHandle);\n\tLoopRotationYawHandle();\n&#125;\n\nvoid ASTUBasePickUp::LoopRotationYawHandle()\n&#123;\n\tif (!StaticMeshComponent &amp;&amp; !RespawnHandle.IsValid())&#123;return;&#125;\n\tGetWorldTimerManager().SetTimer(\n        RotationYawHandle, \n        this, \n        &amp;ASTUBasePickUp::BeginRotationYaw, \n        RotationYawRate, \n        true);\n&#125;\n\nvoid ASTUBasePickUp::BeginRotationYaw()\n&#123;\n\tStaticMeshComponent-&gt;AddRelativeRotation(FRotator(0, 1.f, 0.f));\n&#125;</code></pre>\n\n\n</li>\n<li><p>注意：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\"># 示例中是通过 AActor 自带的 NotifyActorBeginOverlap(AActor* OtherActor) 实现交互\n# 也可以通过 USphereComponent-&gt;UShapeComponent-&gt;UPrimitiveComponent 内的 FComponentHitSignature OnComponentHit; 实现交互\n\n################## 委托名称 ###############\n&#x2F;** \n\t *\tEvent called when a component hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with &#39;sweep&#39; enabled, or physics simulation.\n\t *\tFor events when objects overlap (e.g. walking into a trigger) see the &#39;Overlap&#39; event.\n\t *\n\t *\t@note For collisions during physics simulation to generate hit events, &#39;Simulation Generates Hit Events&#39; must be enabled for this component.\n\t *\t@note When receiving a hit from another object&#39;s movement, the directions of &#39;Hit.Normal&#39; and &#39;Hit.ImpactNormal&#39;\n\t *\twill be adjusted to indicate force from the other object against this object.\n\t *\t@note NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions.\n\t *&#x2F;\n\tUPROPERTY(BlueprintAssignable, Category&#x3D;&quot;Collision&quot;)\n\tFComponentHitSignature OnComponentHit;\n\n################### 委托绑定的函数参数列表 ##################\n\n&#x2F;**\n * Delegate for notification of blocking collision against a specific component.  \n * NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions. \n *&#x2F;\nDECLARE_DYNAMIC_MULTICAST_SPARSE_DELEGATE_FiveParams( FComponentHitSignature, UPrimitiveComponent, OnComponentHit, UPrimitiveComponent*, HitComponent, AActor*, OtherActor, UPrimitiveComponent*, OtherComp, FVector, NormalImpulse, const FHitResult&amp;, Hit );</code></pre></li>\n</ul>\n<h3 id=\"30-AIController\"><a href=\"#30-AIController\" class=\"headerlink\" title=\"30. AIController\"></a>30. AIController</h3><p>情景：</p>\n<ul>\n<li>与前面<code>AIPerception获得最近Actor</code>想关联</li>\n<li>利用<code>AIPerceptionComponent</code>获取<code>最近的Actor</code></li>\n<li>通过<code>TimerHandle</code>控制检测频率</li>\n<li>通过获得黑板组件，获得设置的<code>最近的Actor</code></li>\n<li>让<code>AIControlller</code>控制<code>AI</code>面向<code>最近的Actor</code></li>\n<li><code>AIController</code>获得自己绑定的<code>AI</code>，执行有效的<code>BehaviorTree</code></li>\n<li>通过<code>FName</code>手动指定获得黑板组件中指定的<code>Key</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;AIController.h&quot;\n#include &quot;STUAIController.generated.h&quot;\n\nclass USTUAIPerceptionComponent;\nstruct FTimerHandle;\n\nUCLASS()\nclass B_01_TPS_API ASTUAIController : public AAIController\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tASTUAIController();\n\t\nprotected:\n\tvirtual void OnPossess(APawn* InPawn) override;\n\tvirtual void BeginPlay() override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY()\n\tbool IsRunBehavior;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat CheckRate;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFName FocusOnKeyName;\n\t\npublic:\n\tFTimerHandle CheckClosetEnemyTimerHandle;\n\t\n\t&#x2F;&#x2F; Component\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUSTUAIPerceptionComponent* AIPerceptionComponent;\n\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tvoid OnCheckClosetEnemy();\n\n\tUFUNCTION()\n\tAActor* GetFocusOnActor() const;\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUAIController.h&quot;\n#include &quot;STUAI.h&quot;\n#include &quot;BehaviorTree&#x2F;BlackboardComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUAIPerceptionComponent.h&quot;\n\nASTUAIController::ASTUAIController()\n&#123;\n\tIsRunBehavior &#x3D; false;\n\tCheckRate &#x3D; 0.1f;\n    \n    &#x2F;&#x2F; 此处指定要访问 黑板组件 的 keyName\n\tFocusOnKeyName &#x3D; &quot;EnemyActor&quot;;\n\t\n    &#x2F;&#x2F; 此处指定初始化 AIPerceptionComponent\n\tAIPerceptionComponent &#x3D; CreateDefaultSubobject&lt;USTUAIPerceptionComponent&gt;(TEXT(&quot;AIPerceptionComp&quot;));\n\tif (AIPerceptionComponent)&#123;SetPerceptionComponent(*AIPerceptionComponent);&#125;\n&#125;\n\nvoid ASTUAIController::OnPossess(APawn* InPawn)\n&#123;\n\tSuper::OnPossess(InPawn);\n\n\tconst auto STUCharacter &#x3D; Cast&lt;ASTUAI&gt;(InPawn);\n\n    &#x2F;&#x2F; 此处执行 AI绑定的 BehaviorTree\n\tif (!STUCharacter || !STUCharacter-&gt;GetBehaviorTreeAsset())&#123;return;&#125;\n\tIsRunBehavior &#x3D; RunBehaviorTree(STUCharacter-&gt;GetBehaviorTreeAsset());\n&#125;\n\nvoid ASTUAIController::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n    &#x2F;&#x2F; 开始按频率 检测最近的Actor\n\tif (GetWorld() &amp;&amp; IsRunBehavior)\n\t&#123;\n\t\tGetWorldTimerManager().SetTimer(\n\t\t\tCheckClosetEnemyTimerHandle,\n\t\t\tthis,\n\t\t\t&amp;ASTUAIController::OnCheckClosetEnemy,\n\t\t\tCheckRate,\n\t\t\ttrue);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 设置 AI面向 最近的 Actor\nvoid ASTUAIController::OnCheckClosetEnemy()\n&#123;\n\tconst auto AimActor &#x3D; GetFocusOnActor();\n\tSetFocus(AimActor);\n&#125;\n\n&#x2F;&#x2F; 在黑板组件的指定key中 拿到以设置的 最近的Actor\nAActor* ASTUAIController::GetFocusOnActor() const\n&#123;\n\tif (!GetBlackboardComponent())&#123;return nullptr;&#125;\n\treturn Cast&lt;AActor&gt;(GetBlackboardComponent()-&gt;GetValueAsObject(FocusOnKeyName));\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"31-AI初始化和过渡旋转\"><a href=\"#31-AI初始化和过渡旋转\" class=\"headerlink\" title=\"31. AI初始化和过渡旋转\"></a>31. AI初始化和过渡旋转</h3><p>情景：</p>\n<ul>\n<li>初始化一个基本的<code>AI</code></li>\n<li>通过前面的<code>AIController</code>已经可以面向最近的<code>Actor</code>，但旋转没有过渡，需要实现过渡</li>\n<li>关联相应的<code>BehaviorTree</code></li>\n<li>有<code>Dead</code>相关函数，方便通过<code>AIcontroller</code>停止<code>AI</code>的行为</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;B_01_TPS&#x2F;Player&#x2F;STUCharacterBase.h&quot;\n#include &quot;STUAI.generated.h&quot;\n\nclass UBehaviorTree;\n\nUCLASS()\nclass B_01_TPS_API ASTUAI : public ASTUCharacterBase\n&#123;\n\tGENERATED_BODY()\n\nprotected:\n\tASTUAI(const FObjectInitializer&amp; ObjectInit);\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUBehaviorTree* BehaviorTreeAsset;\n\npublic:\n\tUFUNCTION()\n\tFORCEINLINE UBehaviorTree* GetBehaviorTreeAsset() const &#123;return BehaviorTreeAsset;&#125;\n\n\tvirtual void OnDead() override;\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUAI.h&quot;\n#include &quot;BrainComponent.h&quot;\n#include &quot;STUAIController.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUAIWeaponActorComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUCharacterMovementComponent.h&quot;\n\nASTUAI::ASTUAI(const FObjectInitializer&amp; ObjectInit) :\nSuper(ObjectInit.SetDefaultSubobjectClass&lt;USTUAIWeaponActorComponent&gt;(&quot;WeaponActorComponent&quot;))\n&#123;\n    &#x2F;&#x2F; 初始化 AI 和 AIController\n\tAutoPossessAI &#x3D; EAutoPossessAI::PlacedInWorldOrSpawned;\n\tAIControllerClass &#x3D; ASTUAIController::StaticClass();\n\t\n    &#x2F;&#x2F; 利用 CharacterMovementComponent 设置 AI 旋转面向 最近Actor 的过渡效果\n\tif (GetCharacterMovement())\n\t&#123;\n\t\tbUseControllerRotationYaw &#x3D; false;\n\t\tGetCharacterMovement()-&gt;bUseControllerDesiredRotation &#x3D; true;\n\t\tGetCharacterMovement()-&gt;RotationRate &#x3D; FRotator(0.f, 200.f, 0.f);\n\t&#125;\n&#125;\n\nvoid ASTUAI::OnDead()\n&#123;\n\tSuper::OnDead();\n\n    &#x2F;&#x2F; 通知 AIController 停止 AI行为\n\tconst auto STUController &#x3D; Cast&lt;AAIController&gt;(Controller);\n\tif (STUController &amp;&amp; STUController-&gt;BrainComponent)\n\t&#123;\n\t\tSTUController-&gt;BrainComponent-&gt;Cleanup();\n\t&#125;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"32-BeHaviorTree-Task\"><a href=\"#32-BeHaviorTree-Task\" class=\"headerlink\" title=\"32. BeHaviorTree Task\"></a>32. BeHaviorTree Task</h3><p>情景：</p>\n<ul>\n<li><code>AI Task</code>的关键信息是<code>AIController</code>和<code>BlackBoardComp</code></li>\n<li>通过<code>AIController</code>获得绑定的<code>AI Pawn</code></li>\n<li>通过<code>UNavigationSystemV1</code>获得场景的<code>NavMesh</code>导航</li>\n<li>利用<code>BlackBoardComp</code>获得和设置<code>Key</code>值</li>\n<li>以玩家随机进入下一个场景随机点为例</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;BehaviorTree&#x2F;BTTaskNode.h&quot;\n#include &quot;STUNextLocationTask.generated.h&quot;\n\nstruct FBlackboardKeySelector;\n\nUCLASS()\nclass B_01_TPS_API USTUNextLocationTask : public UBTTaskNode\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUSTUNextLocationTask();\n\nprotected:\n\tvirtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI|Task&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat Radius;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI|Task&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFBlackboardKeySelector AimLocationKey;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI|Task&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool IsSelfCenter;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI|Task&quot;,\n\t\tmeta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;!IsSelfCenter&quot;))\n\tFBlackboardKeySelector CenterActorKey;\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUNextLocationTask.h&quot;\n\n#include &quot;AIController.h&quot;\n#include &quot;NavigationSystem.h&quot;\n#include &quot;BehaviorTree&#x2F;BlackboardComponent.h&quot;\n\nUSTUNextLocationTask::USTUNextLocationTask()\n&#123;\n\tRadius &#x3D; 1000.f;\n\tNodeName &#x3D; &quot;Next Location&quot;;\n\tIsSelfCenter &#x3D; true;\n&#125;\n\nEBTNodeResult::Type USTUNextLocationTask::ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)\n&#123;\n    &#x2F;&#x2F; 获得 AIController 和 BlackBoardComp\n\tconst auto Controller &#x3D; OwnerComp.GetAIOwner();\n\tconst auto BlackBoard &#x3D; OwnerComp.GetBlackboardComponent();\n\n    &#x2F;&#x2F; 通过 AIController 获得 AI Pawn\n\tif (!Controller || !BlackBoard)&#123;return EBTNodeResult::Failed;&#125;\n\tconst auto Pawn &#x3D; Controller-&gt;GetPawn();\n\n    &#x2F;&#x2F; 获得场景中的 NavMeshSystem\n\tif (!Pawn)&#123;return EBTNodeResult::Failed;&#125;\n\tconst auto NavSys &#x3D; UNavigationSystemV1::GetCurrent(Pawn);\n\n    &#x2F;&#x2F; 先获得 AI 当前的位置\n\tif (!NavSys)&#123;return EBTNodeResult::Failed;&#125;\n\tFNavLocation NavLocation;\n\tauto Location &#x3D; Pawn-&gt;GetActorLocation();\n\n    &#x2F;&#x2F; 判断 AI 是否已经到达 随机的位置\n    &#x2F;&#x2F; 通过 黑板组件获得 指定位置的 AI 的 key值\n\tif (IsSelfCenter)&#123;return EBTNodeResult::Failed;&#125;\n\tconst auto CenterActor &#x3D; Cast&lt;AActor&gt;(BlackBoard-&gt;GetValueAsObject(CenterActorKey.SelectedKeyName));\n\n    &#x2F;&#x2F; 但 AI到达随机位置，设置下个随机点的 位置\n\tif (!CenterActor)&#123;return EBTNodeResult::Failed;&#125;\n\tLocation &#x3D; CenterActor-&gt;GetActorLocation();\n\tconst bool IsFound &#x3D; NavSys-&gt;GetRandomReachablePointInRadius(Location, Radius, NavLocation);\n\n    &#x2F;&#x2F; 设定好下个 随机位置，需要用 黑板组件 设置 新的位置 key值\n\tif (!IsFound)&#123;return EBTNodeResult::Failed;&#125;\n\tBlackBoard-&gt;SetValueAsVector(AimLocationKey.SelectedKeyName, NavLocation.Location);\n\treturn EBTNodeResult::Succeeded;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"33-BehaviorTree-Service\"><a href=\"#33-BehaviorTree-Service\" class=\"headerlink\" title=\"33. BehaviorTree Service\"></a>33. BehaviorTree Service</h3><p>情景：</p>\n<ul>\n<li>利用前面<code>AIPerceptionComponent</code>，设置新的目标<code>Actor</code></li>\n<li>以通过<code>AIPerceptionComponent</code>获得新目标，设置<code>黑板组件</code>为例</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;BehaviorTree&#x2F;BTService.h&quot;\n#include &quot;STUFindEnemyBTService.generated.h&quot;\n\nstruct FBlackboardKeySelector;\n\nUCLASS()\nclass B_01_TPS_API USTUFindEnemyBTService : public UBTService\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUSTUFindEnemyBTService();\n\nprotected:\n\tvirtual void TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFBlackboardKeySelector EnemyActorKey;\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUFindEnemyBTService.h&quot;\n#include &quot;AIController.h&quot;\n#include &quot;BehaviorTree&#x2F;BlackboardComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUAIPerceptionComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Dev&#x2F;STUUtils.h&quot;\n\nUSTUFindEnemyBTService::USTUFindEnemyBTService()\n&#123;\n\tNodeName &#x3D; &quot;Find Enemy&quot;;\n&#125;\n\nvoid USTUFindEnemyBTService::TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds)\n&#123;\n\tSuper::TickNode(OwnerComp, NodeMemory, DeltaSeconds);\n\n    &#x2F;&#x2F; 获得 黑板 和 AIController\n\tconst auto BlackBoard &#x3D; OwnerComp.GetBlackboardComponent();\n\n\tif (!BlackBoard)&#123;return;&#125;\n\tconst auto Controller &#x3D; OwnerComp.GetAIOwner();\n\n    &#x2F;&#x2F; 获得 PerceptionComponent\n\tif (!Controller)&#123;return;&#125;\n\tconst auto PerceptionComponent &#x3D; STUUtils::GetSTUPlayerComponent&lt;USTUAIPerceptionComponent&gt;(Controller);\n\n    &#x2F;&#x2F; 从 PerceptionComponent 得到新的 Actort 设置到 黑板 的 key值\n\tif (!PerceptionComponent)&#123;return;&#125;\n\tBlackBoard-&gt;SetValueAsObject(EnemyActorKey.SelectedKeyName, PerceptionComponent-&gt;GetClosetEnemy());\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"34-HUD生成Widget\"><a href=\"#34-HUD生成Widget\" class=\"headerlink\" title=\"34. HUD生成Widget\"></a>34. HUD生成Widget</h3><p>情景：</p>\n<ul>\n<li>设置自己的<code>HUD</code>生成指定<code>Widget</code></li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;HUD.h&quot;\n#include &quot;STUGameHUD.generated.h&quot;\n\nUCLASS()\nclass B_01_TPS_API ASTUGameHUD : public AHUD\n&#123;\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BeginPlay() override;\n\t\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Function\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;UI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;UUserWidget&gt; PlayerHUDWidgetClass;\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUGameHUD.h&quot;\n#include &quot;Blueprint&#x2F;UserWidget.h&quot;\n#include &quot;Engine&#x2F;Canvas.h&quot;\n\nvoid ASTUGameHUD::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tconst auto PlayerHUDWidget &#x3D; CreateWidget&lt;UUserWidget&gt;(GetWorld(), PlayerHUDWidgetClass);\n\n\tif (!PlayerHUDWidget)&#123;return;&#125;\n\tPlayerHUDWidget-&gt;AddToViewport();\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"35-HUD绘制准星\"><a href=\"#35-HUD绘制准星\" class=\"headerlink\" title=\"35. HUD绘制准星\"></a>35. HUD绘制准星</h3><p>情景：</p>\n<ul>\n<li>直接通过<code>HUD</code>生成静态准星</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;HUD.h&quot;\n#include &quot;STUGameHUD.generated.h&quot;\n\nUCLASS()\nclass B_01_TPS_API ASTUGameHUD : public AHUD\n&#123;\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void DrawHUD() override;\npublic:\n\tUFUNCTION()\n\tvoid DrawCrossHair();\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUGameHUD.h&quot;\n#include &quot;Blueprint&#x2F;UserWidget.h&quot;\n#include &quot;Engine&#x2F;Canvas.h&quot;\n\nvoid ASTUGameHUD::DrawHUD()\n&#123;\n\tSuper::DrawHUD();\n\n\tDrawCrossHair();\n&#125;\n\nvoid ASTUGameHUD::DrawCrossHair()\n&#123;\n\tconst TInterval&lt;float&gt; Center(Canvas-&gt;SizeX * 0.5f, Canvas-&gt;SizeY * 0.5f);\n\tconstexpr float HalfLineSize &#x3D; 10.f;\n\tconstexpr float LineThickness &#x3D; 2.f;\n\tconst FColor LineColor &#x3D; FColor::Green;\n\n\tDrawLine(\n\t\tCenter.Min - HalfLineSize,\n\t\tCenter.Max,\n\t\tCenter.Min + HalfLineSize,\n\t\tCenter.Max,\n\t\tLineColor,\n\t\tLineThickness);\n\tDrawLine(\n\t\tCenter.Min,\n\t\tCenter.Max - HalfLineSize,\n\t\tCenter.Min,\n\t\tCenter.Max + HalfLineSize,\n\t\tLineColor,\n\t\tLineThickness);\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"36-Widget创建蓝图可用函数\"><a href=\"#36-Widget创建蓝图可用函数\" class=\"headerlink\" title=\"36. Widget创建蓝图可用函数\"></a>36. Widget创建蓝图可用函数</h3><p>情景：</p>\n<ul>\n<li><code>C++</code>创建的<code>Widget</code></li>\n<li>创建<code>蓝图可调用</code>函数</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UCLASS()\nclass B_01_TPS_API USTUPlayerHUDWidget : public UUserWidget\n&#123;\n\tGENERATED_BODY()\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION(BlueprintCallable)\n\tfloat GetHealthPercent() const;\n\n\tUFUNCTION(BlueprintCallable)\n\tbool IsPlayerAlive() const;\n\n\tUFUNCTION(BlueprintCallable)\n\tbool IsPlayerSpectating() const;\n&#125;;</code></pre>\n\n\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;STUPlayerHUDWidget.h&quot;\n#include &quot;B_01_TPS&#x2F;Dev&#x2F;STUUtils.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUHealthActorComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUWeaponActorComponent.h&quot;\n\nfloat USTUPlayerHUDWidget::GetHealthPercent() const\n&#123;\n\tconst auto HealthComp &#x3D; STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(GetOwningPlayerPawn());\n\tif (!HealthComp)&#123;return 0.f;&#125;\n\treturn HealthComp-&gt;GetHPPercent();\n&#125;\n\nbool USTUPlayerHUDWidget::IsPlayerSpectating() const\n&#123;\n\tconst auto Controller &#x3D; GetOwningPlayer();\n\treturn Controller &amp;&amp; Controller-&gt;GetStateName() &#x3D;&#x3D; NAME_Spectating;\n&#125;\n\nbool USTUPlayerHUDWidget::IsPlayerAlive() const\n&#123;\n\tconst auto HealthComp &#x3D; STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(GetOwningPlayerPawn());\n\treturn HealthComp &amp;&amp; !HealthComp-&gt;IsDead();\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"37-UPROPERTY\"><a href=\"#37-UPROPERTY\" class=\"headerlink\" title=\"37. UPROPERTY()\"></a>37. UPROPERTY()</h3><p>情景：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>private</code>：需要在蓝图中<code>可读可写</code>，任意处编辑</p>\n<blockquote>\n<p>UPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))</p></blockquote>\n</blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>以 <code>bool IsTrue;</code>为判断标准，为<code>false</code>时，编辑器处为<code>不可编辑</code>状态</p>\n<blockquote>\n<p>UPROPERTY(EditAnywhere, meta&#x3D;(EditCondition&#x3D;”IsTrue”))</p></blockquote>\n</blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>float HP;</code>为例，在编辑器中设置的值要符合一个固定的范围</p>\n<blockquote>\n<p>UPROPERTY(EditAnywhere, meta&#x3D;(ClampMin&#x3D;0, ClampMax&#x3D;100))</p></blockquote>\n</blockquote>\n<h3 id=\"38-check-checkf-checkNoEntry\"><a href=\"#38-check-checkf-checkNoEntry\" class=\"headerlink\" title=\"38. check-checkf-checkNoEntry\"></a>38. check-checkf-checkNoEntry</h3><p>情景：</p>\n<ul>\n<li><p>需要在<code>BeginPlay()</code>检测组件是否有效</p>\n<p><code>check(GetMesh());</code>：如果<code>GetMesh()</code>无效，程序会中断</p>\n</li>\n<li><p>还需要通过条件判断是否有效，同时打印指定语句到日志</p>\n</li>\n<li><p>以<code>float HP;</code>为例，默认<code>BeginPlay()</code>时，<code>HP</code>应该<code>大于0</code></p>\n<p><code>checkf(HP &gt; 0.f, TEXT(&quot;HP Shound Great 0&quot;));</code></p>\n</li>\n<li><p>应用于不可到达的代码片段，当出现不应该出现的情况时，程序中断</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void Function(AActor* Actor)\n&#123;\n    if (Actor)\n    &#123;\n        ....\n    &#125;\n    else\n    &#123;\n        checkNoEntry();\n    &#125;\n&#125;</code></pre></li>\n</ul>\n","text":"UE4 功能整理1. SpawnActor情景： 我有一个Cpp类 这个Cpp类要生成一个其他Cpp或蓝图类 可以使用TSubclassOf&lt;&gt; 示例： 定义 private: UPROPERTY(EditDefaultsOnly, BlueprintReadWrit...","link":"","photos":[],"count_time":{"symbolsCount":"71k","symbolsTime":"1:04"},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/tags/UnrealEngine.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#UE4-%E5%8A%9F%E8%83%BD%E6%95%B4%E7%90%86\"><span class=\"toc-text\">UE4 功能整理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-SpawnActor\"><span class=\"toc-text\">1. SpawnActor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-LineTrace\"><span class=\"toc-text\">2. LineTrace</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-UWorld\"><span class=\"toc-text\">2.1 UWorld</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-Kismet\"><span class=\"toc-text\">2.2 Kismet</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-1-LineTraceSingle\"><span class=\"toc-text\">2.2.1 LineTraceSingle</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-2-LineTraceSingleForObjects\"><span class=\"toc-text\">2.2.2 LineTraceSingleForObjects</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-3-LineTraceSingleByProfile\"><span class=\"toc-text\">2.2.3 LineTraceSingleByProfile</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-SweepTrace\"><span class=\"toc-text\">3. SweepTrace</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-SphereTrace\"><span class=\"toc-text\">4. SphereTrace</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Character\"><span class=\"toc-text\">5. Character</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Pawn\"><span class=\"toc-text\">6. Pawn</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-Impulse-Force\"><span class=\"toc-text\">7. Impulse Force</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-Add-Force\"><span class=\"toc-text\">8. Add Force</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-Radia-Impulse-Force\"><span class=\"toc-text\">9. Radia Impulse Force</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-TimerHandle\"><span class=\"toc-text\">10. TimerHandle</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-Disable-Actor\"><span class=\"toc-text\">11. Disable Actor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-Hit-Event\"><span class=\"toc-text\">12. Hit Event</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-Set-Material\"><span class=\"toc-text\">13. Set Material</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-Dynamic-Material\"><span class=\"toc-text\">14. Dynamic Material</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-Interp-Target\"><span class=\"toc-text\">15. Interp Target</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-Lerp\"><span class=\"toc-text\">16. Lerp</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E9%BB%91%E6%B4%9E\"><span class=\"toc-text\">18. 黑洞</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-%E7%8E%A9%E5%AE%B6%E6%AD%BB%E4%BA%A1%E5%90%8E%E8%BF%9B%E5%85%A5%E8%A7%82%E5%AF%9F\"><span class=\"toc-text\">19. 玩家死亡后进入观察</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-%E9%AB%98%E5%A4%84%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3\"><span class=\"toc-text\">20. 高处坠落伤害</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-FindAnimNotifyByClass\"><span class=\"toc-text\">21. FindAnimNotifyByClass</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#22-%E7%B1%BB%E7%94%9F%E6%88%90%E9%99%84%E5%8A%A0%E5%88%B0%E6%8F%92%E6%A7%BD\"><span class=\"toc-text\">22. 类生成附加到插槽</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#23-CameraShake\"><span class=\"toc-text\">23. CameraShake</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#24-HealthComponent\"><span class=\"toc-text\">24. HealthComponent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#25-GetActorComponent\"><span class=\"toc-text\">25. GetActorComponent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#26-%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%A7%94%E6%89%98\"><span class=\"toc-text\">26. 设计结构体和委托</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#27-AIPerception%E8%8E%B7%E5%BE%97%E6%9C%80%E8%BF%91Actor\"><span class=\"toc-text\">27. AIPerception获得最近Actor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#28-GameMode\"><span class=\"toc-text\">28. GameMode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#29-%E6%8B%BE%E5%8F%96%E7%89%A9-PickUp\"><span class=\"toc-text\">29. 拾取物-PickUp</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#30-AIController\"><span class=\"toc-text\">30. AIController</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#31-AI%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%BF%87%E6%B8%A1%E6%97%8B%E8%BD%AC\"><span class=\"toc-text\">31. AI初始化和过渡旋转</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#32-BeHaviorTree-Task\"><span class=\"toc-text\">32. BeHaviorTree Task</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#33-BehaviorTree-Service\"><span class=\"toc-text\">33. BehaviorTree Service</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#34-HUD%E7%94%9F%E6%88%90Widget\"><span class=\"toc-text\">34. HUD生成Widget</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#35-HUD%E7%BB%98%E5%88%B6%E5%87%86%E6%98%9F\"><span class=\"toc-text\">35. HUD绘制准星</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#36-Widget%E5%88%9B%E5%BB%BA%E8%93%9D%E5%9B%BE%E5%8F%AF%E7%94%A8%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">36. Widget创建蓝图可用函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#37-UPROPERTY\"><span class=\"toc-text\">37. UPROPERTY()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#38-check-checkf-checkNoEntry\"><span class=\"toc-text\">38. check-checkf-checkNoEntry</span></a></li></ol></li></ol></li></ol>","author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"https://twitter.com/nUCFA2659We0pmu","stackoverflow":"https://stackoverflow.com/users/20173508/user20173508","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"UE4 联网和多人游戏","uid":"d2dc88f9aa1b74a2f377fe04af877f8c","slug":"7_UE4联网和多人游戏_05","date":"2022-10-06T07:28:25.963Z","updated":"2022-06-07T13:44:27.948Z","comments":true,"path":"api/articles/7_UE4联网和多人游戏_05.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN/Post_Img_mini/postImg_27.jpg","text":"UE4 联网和多人游戏复制Replication：在客户端服务器间同步数据和调用程序的过程 1. 网络概述1.1 尽早规划多人游戏 若项目可能需要多人游戏功能，则从项目开始阶段起，构建所有gameplay时都应将多人游戏功能考虑在内，便于进行调试和维护，且支持单人 若是单人游戏改...","link":"","photos":[],"count_time":{"symbolsCount":"56k","symbolsTime":"51 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/tags/UnrealEngine.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"https://twitter.com/nUCFA2659We0pmu","stackoverflow":"https://stackoverflow.com/users/20173508/user20173508","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"UE4 反射编程","uid":"cde83abaa86ff43674449a34230233bc","slug":"7_UE4反射编程_08","date":"2022-10-06T07:28:25.958Z","updated":"2022-06-30T10:20:42.628Z","comments":true,"path":"api/articles/7_UE4反射编程_08.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN/Post_Img_mini/postImg_30.jpg","text":"UE4 反射编程1. 准备工作 新建空白ue4 cpp项目：Reflective 打开ReflectiveGameModeBase.h #pragma once #include &quot;CoreMinimal.h&quot; #include &quot;GameFrame...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/tags/UnrealEngine.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"https://twitter.com/nUCFA2659We0pmu","stackoverflow":"https://stackoverflow.com/users/20173508/user20173508","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}