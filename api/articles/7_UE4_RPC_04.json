{"title":"UE4 RPC","uid":"01b2c0831f95e39e5fd56ec4f69b86cb","slug":"7_UE4_RPC_04","date":"2022-10-06T07:28:25.953Z","updated":"2022-05-19T04:30:28.043Z","comments":true,"path":"api/articles/7_UE4_RPC_04.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN/Post_Img_mini/postImg_26.jpg","content":"<h1 id=\"UE4-RPC\"><a href=\"#UE4-RPC\" class=\"headerlink\" title=\"UE4 RPC\"></a>UE4 RPC</h1><h3 id=\"1-RPC-架构\"><a href=\"#1-RPC-架构\" class=\"headerlink\" title=\"1. RPC 架构\"></a>1. RPC 架构</h3><h4 id=\"1-1-架构简介\"><a href=\"#1-1-架构简介\" class=\"headerlink\" title=\"1.1 架构简介\"></a>1.1 架构简介</h4><ul>\n<li>一个服务器， 一个或多个客户端</li>\n<li>不能信任客户端，所有重要信息都需要通过服务器验证</li>\n<li><code>Listen Server</code>监听服务器和<code>Dedicated Server</code>专有服务器</li>\n</ul>\n<h4 id=\"1-2-基本GamePlay结构\"><a href=\"#1-2-基本GamePlay结构\" class=\"headerlink\" title=\"1.2 基本GamePlay结构\"></a>1.2 基本GamePlay结构</h4><ul>\n<li><strong>Server</strong><ul>\n<li><code>GameMode</code> 仅存在于Server</li>\n<li><code>GameState</code> 同时存在与Server和Client</li>\n<li><code>Pawn_Server</code>, <code>Pawn_A</code>, <code>Pawn_B</code> 同时存在与Server和Client</li>\n<li><code>PlayerState_Server</code>, <code>PlayerState_A</code>, <code>PlayerState_B</code> 同时存在与Server和Client</li>\n<li><code>PlayerController_Server</code> 仅存在于Server</li>\n<li><code>PlayerController_A</code>, <code>PlayerController_B</code> 同时存在与Server和各自所拥有的Client</li>\n<li><code>GameInstance</code>, <code>UI</code> 同时存在与Server和各自所拥有的Client</li>\n</ul>\n</li>\n<li><strong>Client</strong><ul>\n<li>每个客户端都有独立的<code>PlayerController</code>和<code>UI</code></li>\n<li>其余与<code>Server</code>同时拥有</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-Listen-Server\"><a href=\"#2-Listen-Server\" class=\"headerlink\" title=\"2. Listen Server\"></a>2. Listen Server</h3><h4 id=\"2-1-Replication\"><a href=\"#2-1-Replication\" class=\"headerlink\" title=\"2.1 Replication\"></a>2.1 Replication</h4><ul>\n<li><strong>说明：</strong><ul>\n<li>信息从服务端同步到客户端<code>(单向)</code></li>\n<li><code>Actor</code>及其派生类才有<code>Replication</code>的能力</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-Replication类型\"><a href=\"#2-2-Replication类型\" class=\"headerlink\" title=\"2.2 Replication类型\"></a>2.2 Replication类型</h4><ul>\n<li><p><strong>类型：</strong></p>\n<ol>\n<li><code>Actor Replication</code></li>\n<li><code>Property Replication</code></li>\n<li><code>Component Replication</code></li>\n</ol>\n</li>\n<li><p>在服务端进行操作：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if (HasAuthority())\n&#123;\n\tTestNum &#x3D; 999.f;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"2-2-1-Actor-Replication\"><a href=\"#2-2-1-Actor-Replication\" class=\"headerlink\" title=\"2.2.1 Actor Replication\"></a>2.2.1 Actor Replication</h5><ul>\n<li><p><strong>两层意义：</strong></p>\n<ol>\n<li>服务端生成，客户端也跟着生成<code>(在服务端生成一个replication对象)</code></li>\n<li>当前<code>Actor</code>的所有属性复制，组件复制，RPC的总开关</li>\n</ol>\n</li>\n<li><p><strong>开启Replication</strong></p>\n<ul>\n<li><p>蓝图：勾选<code>Replicates</code></p>\n</li>\n<li><p>C++：在构造函数中实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bReplicates &#x3D; true;\nSetReplicates(true);\n\n其中Set要慢一点</code></pre></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-2-2-Property-Replication\"><a href=\"#2-2-2-Property-Replication\" class=\"headerlink\" title=\"2.2.2 Property Replication\"></a>2.2.2 Property Replication</h5><ul>\n<li><p><strong>开启方式：</strong></p>\n<ul>\n<li><p>前提：<code>Actor Replication</code>是<code>true</code></p>\n</li>\n<li><p>蓝图：<code>Replication</code>设置为<code>Replicated</code></p>\n</li>\n<li><p>C++：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UPROPERTY(Replicated)\nfloat TestNum;</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;Net&#x2F;UnrealNetwork.h&quot;\n\nvoid AMyActor::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n&#123;\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\t\n\tDOREPLIFETIME(AMyActor, TestNum);\n&#125;</code></pre>\n</li>\n<li><p><code>AMyActor</code>是需要复制属性的类</p>\n</li>\n<li><p><code>TestNum</code>是待复制的属性</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-2-3-Rep-Notify\"><a href=\"#2-2-3-Rep-Notify\" class=\"headerlink\" title=\"2.2.3 Rep Notify\"></a>2.2.3 Rep Notify</h5><ul>\n<li><p><strong>说明：</strong>变量设为<code>Rep_Notify</code>，当变量发生复制时，<code>服务端</code>和<code>收到的客户端</code>都可以<code>调用</code>一个<code>自定义的函数</code></p>\n</li>\n<li><p><strong>注意：</strong><code>C++中</code>，自定义函数<code>仅在客户端</code>中调用</p>\n</li>\n<li><p><strong>设置方式：</strong></p>\n<ul>\n<li><p>蓝图：<code>Replication</code>设置为<code>RepNotify</code>，会自动生成<code>OnRep_属性()</code>函数</p>\n</li>\n<li><p>C++：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UPROPERTY(ReplicatedUsing&#x3D;OnRep_TestNum, BlueprintReadWrite)\nint TestNum;\n\nUFUNCTION()\nvoid OnRep_TestNum();</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;MyActor.h&quot;\n#include &quot;Kismet&#x2F;KismetSystemLibrary.h&quot;\n#include &quot;Net&#x2F;UnrealNetwork.h&quot;\n\nAMyActor::AMyActor()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; true;\n\n\tbReplicates &#x3D; true;\n&#125;\n\nvoid AMyActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n&#125;\n\nvoid AMyActor::Tick(float DeltaTime)\n&#123;\n\tSuper::Tick(DeltaTime);\n\n\tif (HasAuthority())\n\t&#123;\n\t\t++TestNum;\n\t&#125;\n&#125;\n\nvoid AMyActor::OnRep_TestNum()\n&#123;\n\tif (HasAuthority())\n\t&#123;\n\t\tUKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT(&quot;%d&quot;), TestNum));\n\t&#125;\n\telse\n\t&#123;\n\t\tUKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT(&quot;%d&quot;), TestNum));\n\t&#125;\n&#125;\n\nvoid AMyActor::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n&#123;\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AMyActor, TestNum);\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-OwnerShip\"><a href=\"#2-3-OwnerShip\" class=\"headerlink\" title=\"2.3 OwnerShip\"></a>2.3 OwnerShip</h4><ul>\n<li><p><strong>作用：</strong></p>\n</li>\n<li><p>RPC需要确定哪个客户端将执行于客户端的RPC</p>\n</li>\n<li><p>Actor复制与连接相关性</p>\n</li>\n<li><p>在涉及所有者时的Actor属性复制条件</p>\n</li>\n<li><p><strong>说明：</strong></p>\n<ul>\n<li>当 Pawn Actor 被 PlayerController 拥有时，它们的所有者将是它们所拥有的 PlayerController。</li>\n<li>在此期间，它们归 PlayerController 的连接所有。</li>\n<li>Pawn 仅在同时由 PlayerController 拥有&#x2F;拥有时由该连接拥有。</li>\n<li>因此，一旦 PlayerController 不再拥有 Pawn，Pawn 就不再由连接拥有。</li>\n</ul>\n</li>\n<li><p><strong>注意：</strong></p>\n<ul>\n<li>连接所有权对于 RPC 之类的东西很重要，因为当在 Actor 上调用 RPC 函数时，除非 RPC 被标记为多播，否则它需要知道在哪个客户端上执行该 RPC。</li>\n<li>它通过查找拥有的连接来确定将 RPC 发送到的连接。</li>\n</ul>\n</li>\n<li><p><strong>使用：</strong></p>\n<ul>\n<li><p>蓝图</p>\n<ul>\n<li>设置<ul>\n<li>SpawnActor中又Owner可以引用</li>\n<li>SetOwner</li>\n</ul>\n</li>\n<li>改变<ul>\n<li>Possess(OnPossess &gt; PossessedBy &gt; SetOwner), UnPossess</li>\n</ul>\n</li>\n<li>获得<ul>\n<li>GetOwner</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>C++</p>\n<ul>\n<li><p>设置</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;SpawnParameters 内可以设置 Onwer\nGetWorld()-&gt;SpawnActor(Class, const* UserTransformPtr, const SpawnParameters);\n\t\n&#x2F;&#x2F; SetOwner\nSetOwner(NewOwner);</code></pre>\n</li>\n<li><p>获取</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">GetOwner();</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-4-Actor-Role\"><a href=\"#2-4-Actor-Role\" class=\"headerlink\" title=\"2.4 Actor Role\"></a>2.4 Actor Role</h4><ul>\n<li><p><strong>分类：</strong></p>\n<ol>\n<li>Authority 权威</li>\n<li>Simulated Proxy 模拟代理</li>\n<li>Autonomous Proxy 自主代理</li>\n</ol>\n</li>\n<li><p><strong>基本结构：</strong>A， B， C <code>A为房主</code></p>\n<ul>\n<li>ServerA：A, B, C <code>Authority</code></li>\n<li>ClientB：A, C <code>Simulated</code>, B <code>Autonomous</code></li>\n<li>ClentC: A, B <code>Simulated</code>, C <code>Autonomous</code></li>\n</ul>\n</li>\n<li><p><strong>说明：</strong>当涉及到复制时，actor 有两个很重要的属性。<code>Role</code>和<code>RemoteRole</code>。</p>\n</li>\n<li><p><strong>作用：</strong></p>\n<ul>\n<li>谁对演员有权力</li>\n<li>演员是否被复制</li>\n<li>复制模式</li>\n</ul>\n</li>\n<li><p>服务器复制到客户端的条件：<code>Role == ROLE_Authority</code>and <code>RemoteRole == ROLE_SimulatedProxy</code>or <code>ROLE_AutonomousProxy</code></p>\n</li>\n</ul>\n<h3 id=\"3-RPC介绍\"><a href=\"#3-RPC介绍\" class=\"headerlink\" title=\"3. RPC介绍\"></a>3. RPC介绍</h3><ul>\n<li><p>类似于函数调用，不过不一定是在本地执行</p>\n</li>\n<li><p>可以实现：</p>\n<ul>\n<li>客户端调用，服务端执行</li>\n<li>服务端调用，客户端执行</li>\n</ul>\n</li>\n<li><p>不可以有返回值</p>\n</li>\n<li><p>默认不可靠（可以设置成Reliable）</p>\n</li>\n</ul>\n<h4 id=\"3-1-RPC设置\"><a href=\"#3-1-RPC设置\" class=\"headerlink\" title=\"3.1 RPC设置\"></a>3.1 RPC设置</h4><p><strong>蓝图：</strong></p>\n<ul>\n<li>CustomEvent 的 Replicates 选项设置为其中一个<ul>\n<li>Run On Server</li>\n<li>Run On Owning Client</li>\n<li>Net MultiCast</li>\n</ul>\n</li>\n<li>要勾选<code>Reliable</code></li>\n</ul>\n<p><strong>C++：</strong></p>\n<ul>\n<li>将一个自定义的函数声明为RPC，需要添加反射<code>UFUNCTION()</code><ul>\n<li>Server</li>\n<li>Client</li>\n<li>NetMultiCast</li>\n</ul>\n</li>\n<li>额外添加<code>Reliable</code></li>\n</ul>\n<h4 id=\"3-2-RPC要求和注意\"><a href=\"#3-2-RPC要求和注意\" class=\"headerlink\" title=\"3.2 RPC要求和注意\"></a>3.2 RPC要求和注意</h4><p>要使 RPC 完全正常运行，需要满足一些要求：</p>\n<ul>\n<li>它们必须从 Actors 中调用</li>\n<li>必须复制 Actor</li>\n<li>如果从服务器调用 RPC 以在客户端上执行，则只有实际拥有该 Actor 的客户端将执行该函数</li>\n<li>如果从客户端调用 RPC 以在服务器上执行，则客户端必须拥有正在调用 RPC 的 Actor</li>\n<li>多播 RPC 是一个例外：<ul>\n<li>如果从服务器调用它们，服务器将在本地执行它们以及在所有当前连接的客户端上执行它们</li>\n<li>如果从客户端调用，它们只会在本地执行，不会在服务器上执行</li>\n<li>目前，我们有一个简单的多播事件限制机制：多播函数在给定 Actor 的网络更新周期内不会复制超过两次。从长远来看，我们希望对此进行改进，并为跨渠道流量管理和节流提供更好的支持</li>\n</ul>\n</li>\n</ul>\n<p>​\t</p>\n<p><strong>从Server调用RPC</strong></p>\n<table>\n<thead>\n<tr>\n<th>演员所有权</th>\n<th>未复制</th>\n<th><code>NetMulticast</code></th>\n<th><code>Server</code></th>\n<th><code>Client</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>客户拥有的演员</strong></td>\n<td>在服务器上运行</td>\n<td>在服务器和所有客户端上运行</td>\n<td>在服务器上运行</td>\n<td>在演员拥有的客户端上运行</td>\n</tr>\n<tr>\n<td><strong>服务器拥有的演员</strong></td>\n<td>在服务器上运行</td>\n<td>在服务器和所有客户端上运行</td>\n<td>在服务器上运行</td>\n<td>在服务器上运行</td>\n</tr>\n<tr>\n<td><strong>无名演员</strong></td>\n<td>在服务器上运行</td>\n<td>在服务器和所有客户端上运行</td>\n<td>在服务器上运行</td>\n<td>在服务器上运行</td>\n</tr>\n</tbody></table>\n<p><strong>从Client调用RPC</strong></p>\n<table>\n<thead>\n<tr>\n<th>演员所有权</th>\n<th>未复制</th>\n<th><code>NetMulticast</code></th>\n<th><code>Server</code></th>\n<th><code>Client</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>由调用客户端拥有</strong></td>\n<td>在调用客户端时运行</td>\n<td>在调用客户端时运行</td>\n<td>在服务器上运行</td>\n<td>在调用客户端时运行</td>\n</tr>\n<tr>\n<td><strong>由不同的客户拥有</strong></td>\n<td>在调用客户端时运行</td>\n<td>在调用客户端时运行</td>\n<td>掉落</td>\n<td>在调用客户端时运行</td>\n</tr>\n<tr>\n<td><strong>服务器拥有的演员</strong></td>\n<td>在调用客户端时运行</td>\n<td>在调用客户端时运行</td>\n<td>掉落</td>\n<td>在调用客户端时运行</td>\n</tr>\n<tr>\n<td><strong>无名演员</strong></td>\n<td>在调用客户端时运行</td>\n<td>在调用客户端时运行</td>\n<td>掉落</td>\n<td>在调用客户端时运行</td>\n</tr>\n</tbody></table>\n","text":"UE4 RPC1. RPC 架构1.1 架构简介 一个服务器， 一个或多个客户端 不能信任客户端，所有重要信息都需要通过服务器验证 Listen Server监听服务器和Dedicated Server专有服务器 1.2 基本GamePlay结构 Server GameMode ...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/tags/UnrealEngine.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#UE4-RPC\"><span class=\"toc-text\">UE4 RPC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-RPC-%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1. RPC 架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1.1 架构简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E5%9F%BA%E6%9C%ACGamePlay%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.2 基本GamePlay结构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Listen-Server\"><span class=\"toc-text\">2. Listen Server</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-Replication\"><span class=\"toc-text\">2.1 Replication</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-Replication%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.2 Replication类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-1-Actor-Replication\"><span class=\"toc-text\">2.2.1 Actor Replication</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-2-Property-Replication\"><span class=\"toc-text\">2.2.2 Property Replication</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-3-Rep-Notify\"><span class=\"toc-text\">2.2.3 Rep Notify</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-OwnerShip\"><span class=\"toc-text\">2.3 OwnerShip</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-Actor-Role\"><span class=\"toc-text\">2.4 Actor Role</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-RPC%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">3. RPC介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-RPC%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">3.1 RPC设置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-RPC%E8%A6%81%E6%B1%82%E5%92%8C%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">3.2 RPC要求和注意</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"FangH","slug":"blog-author","avatar":{"img":"/img/fh.png"},"link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"https://twitter.com/nUCFA2659We0pmu","stackoverflow":"https://stackoverflow.com/users/20173508/user20173508","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"UE4初始设置及个人使用崩溃记录","uid":"c7d8b276a0f55310d3a5259cec001a89","slug":"7_UE4初始设置及个人使用崩溃记录_01","date":"2022-10-06T07:28:25.955Z","updated":"2022-05-19T04:29:58.516Z","comments":true,"path":"api/articles/7_UE4初始设置及个人使用崩溃记录_01.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN/Post_Img_mini/postImg_10.jpg","text":"日志：1.第一次记录：2020.2.05 版本：4.24.2 UnrealEngine的初始设置1.在Epic中下载UnrealEngine4之后1-1. 首先：启动-选项 1-2. 接着 ：（勾选）输入调试用符号-应用以后出现新的崩溃问题，方便查看详细原因 2.进行UE4相关的...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/tags/UnrealEngine.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":{"img":"/img/fh.png"},"link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"https://twitter.com/nUCFA2659We0pmu","stackoverflow":"https://stackoverflow.com/users/20173508/user20173508","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"UE4 MySQL插件使用","uid":"392fe5e03b8c7afffa5955ae17305c17","slug":"7_MySQL插件使用_03","date":"2022-10-06T07:28:25.950Z","updated":"2022-05-19T04:29:51.469Z","comments":true,"path":"api/articles/7_MySQL插件使用_03.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN/Post_Img_mini/postImg_25.jpg","text":"UE4 MySQL插件使用1. 插件获取MySQL Plugin 提取码:17um 2. 插件安装 新建UE4项目，类型随意 在项目根目录中新建文件夹Plugins 将FH_MySQL复制到Plugins中 重新打开UE4项目 3. 插件API3.1 连接数据库 返回一个MySQ...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/tags/UnrealEngine.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":{"img":"/img/fh.png"},"link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"https://twitter.com/nUCFA2659We0pmu","stackoverflow":"https://stackoverflow.com/users/20173508/user20173508","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}