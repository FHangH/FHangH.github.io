{"title":"C++_模板和STL","uid":"85a2acfa491d3e6f2208fd787a774695","slug":"1_C++_模板和STL_05","date":"2022-10-06T07:28:25.920Z","updated":"2022-11-10T01:30:51.387Z","comments":true,"path":"api/articles/1_C++_模板和STL_05.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (5).webp","content":"<h1 id=\"C-模板和STL\"><a href=\"#C-模板和STL\" class=\"headerlink\" title=\"C++_模板和STL\"></a>C++_模板和STL</h1><p>[toc]</p>\n<ul>\n<li>记录C++泛型编程和STL的使用和原理</li>\n</ul>\n<h3 id=\"1-模板-Template\"><a href=\"#1-模板-Template\" class=\"headerlink\" title=\"1. 模板-Template\"></a>1. 模板-Template</h3><h4 id=\"1-1-模板概念\"><a href=\"#1-1-模板概念\" class=\"headerlink\" title=\"1.1 模板概念\"></a>1.1 模板概念</h4><ul>\n<li>作用：建立通用的模具，提高编程的复用性</li>\n<li>特点：<ul>\n<li>模板在实际项目中不可直接使用，它只是一个框架，需根据实际情况进行使用</li>\n<li>模板的通用不是万能的</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-函数模板\"><a href=\"#1-2-函数模板\" class=\"headerlink\" title=\"1.2 函数模板\"></a>1.2 函数模板</h4><ul>\n<li>C++提供了另一种编程思想，<code>泛型编程</code>，主要利用的技术就是模板<code>template</code></li>\n<li>C++提供了两种模板机制：<code>函数模板</code>和<code>类模板</code></li>\n</ul>\n<h5 id=\"1-2-1-函数模板语法\"><a href=\"#1-2-1-函数模板语法\" class=\"headerlink\" title=\"1.2.1 函数模板语法\"></a>1.2.1 函数模板语法</h5><ol>\n<li><p>函数模板的作用：</p>\n<ul>\n<li><p>建立一个通用函数，其函数返回值类型和形参类型可以不确定，是一个<code>虚拟的类型</code></p>\n</li>\n<li><p>当需要使用时，再根据实际情况进行声明或由编译器自行判断数据类型</p>\n</li>\n</ul>\n</li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template &lt;typename T&gt;\n函数的声明或定义</code></pre>\n\n\n</li>\n<li><p>解释：</p>\n<ul>\n<li><code>template</code>：声明创建模板</li>\n<li><code>typename</code>：表面后面的符号，代表着是一种数据类型，但不确定是哪种，也可以用<code>class</code>来代替</li>\n<li><code>T</code>：通用数据类型，是一个符号，可以换成别的代替，通常大写，并习惯写成<code>T</code></li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 13:35\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 函数模板\n&#x2F;&#x2F; 声明一个模板，通用数据符号 T， 防止编译器报错\ntemplate &lt;typename T&gt;\nvoid swap_T(T &amp;num1, T &amp;num2)\n&#123;\n    T tempNum &#x3D; num1;\n    num1 &#x3D; num2;\n    num2 &#x3D; tempNum;\n&#125;\n\nvoid demo1()\n&#123;\n    int num1 &#x3D; 10;\n    int num2 &#x3D; 20;\n    &#x2F;&#x2F; 自动类型推导\n    swap_T(num1, num2);\n    cout &lt;&lt; &quot;自动类型: &quot; ;\n    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;\n\n    &#x2F;&#x2F; 指定类型\n    swap_T&lt;int&gt;(num1, num2);\n    cout &lt;&lt; &quot;指定类型: &quot; ;\n    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>总结：</p>\n<ul>\n<li>函数模板的创建利用关键字<code>template</code></li>\n<li>使用函数模板有两种方式：<code>自动类型推导</code>和<code>显示指定类型</code></li>\n<li>模板的目的是提高复用性，将类型参数化</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"1-2-2-函数模板注意事项\"><a href=\"#1-2-2-函数模板注意事项\" class=\"headerlink\" title=\"1.2.2 函数模板注意事项\"></a>1.2.2 函数模板注意事项</h5><p>注意事项：</p>\n<ul>\n<li>自动类型推导：通用数据类型 <code>T</code> 必须推导出一致的类型，才能使用</li>\n<li>模板函数在使用时，无论哪种方式，必须确定了使用的数据类型，才能使用</li>\n</ul>\n<p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 13:55\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nvoid swap_T(T &amp;num1, T &amp;num2)\n&#123;\n    T tempNum &#x3D; num1;\n    num1 &#x3D; num2;\n    num2 &#x3D; tempNum;\n&#125;\n\nvoid demo1()\n&#123;\n    int num1 &#x3D; 10;\n    int num2 &#x3D; 20;\n    char c1 &#x3D; &#39;A&#39;;\n    &#x2F;&#x2F; 自动类型推导\n    &#x2F;&#x2F; num1 和 num2 都是 int 类型，可以自动推导出是一致类型\n    swap_T(num1, num2);\n\n    &#x2F;&#x2F; c1是char类型，是错误的使用方式\n    &#x2F;&#x2F; swap_T(c1, num2);\n    cout &lt;&lt; &quot;自动类型: &quot; ;\n    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;</code></pre>\n\n\n\n\n\n<h5 id=\"1-2-3-函数模板案例\"><a href=\"#1-2-3-函数模板案例\" class=\"headerlink\" title=\"1.2.3 函数模板案例\"></a>1.2.3 函数模板案例</h5><ul>\n<li><p>案例描述：</p>\n<ul>\n<li>利用函数模板封装一个排序函数，可以对不同类型数据进行排序</li>\n<li>排序规则：从大到小，排序算法为<code>选择排序</code></li>\n<li>分别利用<code>char</code>数组和<code>int</code>数组进行测试</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 14:01\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\ntemplate &lt;class T&gt;\nvoid swap_T(T &amp;a, T &amp;b)\n&#123;\n    T temp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; temp;\n&#125;\n\ntemplate &lt;class T&gt;\nvoid sort_T(T arr[], int length)\n&#123;\n    for (int i &#x3D; 0; i &lt; length; ++i)\n    &#123;\n        &#x2F;&#x2F; 假设最大值的下标，后面进行比较\n        int max &#x3D; i;\n        for (int j &#x3D; i + 1; j &lt; length; ++j)\n        &#123;\n            &#x2F;&#x2F; 将假设的下标对应的值和后面的值，比较\n            if (arr[max] &lt; arr[j])\n            &#123;\n                max &#x3D; j;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 上面的循环结束后，检查一开始假设的下标，是否是循环检查出的最大值下标\n        if (max !&#x3D; i)\n        &#123;\n            swap_T(arr[max], arr[i]);\n        &#125;\n    &#125;\n&#125;\n\ntemplate &lt;class T&gt;\nvoid print_T(T arr, int length)\n&#123;\n    cout &lt;&lt; &quot;从大到小排序后：&quot;;\n    for (int i &#x3D; 0; i &lt; length; ++i)\n    &#123;\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid sortCharDemo()\n&#123;\n    char c_Array[26];\n    int c_Length;\n\n    cout &lt;&lt; &quot;输入字符(a - z) &gt;&gt; &quot;;\n    cin &gt;&gt; c_Array;\n    &#x2F;&#x2F; 实际的字符后面有一个 &#96;\\0&#96;收尾,这获取长度方法不好\n    &#x2F;&#x2F;c_Length &#x3D; (sizeof(c_Array) &#x2F; sizeof(char));\n\n    &#x2F;&#x2F; strlen() 获取长度，读到&#96;\\0&#96;，就不读，适合这个项目的需求\n    &#x2F;&#x2F; 需要包含 &lt;cstring&gt;\n    c_Length &#x3D; strlen(c_Array);\n\n    sort_T(c_Array, c_Length);\n    print_T(c_Array, c_Length);\n&#125;\n\nvoid sortIntDemo()\n&#123;\n    int i_Array[10];\n    int i &#x3D; 0;\n    int i_Length;\n\n    cout &lt;&lt; &quot;输入数字(0 - 9) &gt;&gt; &quot;;\n    while (cin.peek() !&#x3D; &#39;\\n&#39;)\n    &#123;\n        cin &gt;&gt; i_Array[i++];\n        i_Length &#x3D; i;\n    &#125;\n\n    sort_T(i_Array, i_Length);\n    print_T(i_Array, i_Length);\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; sortCharDemo();\n    sortIntDemo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"1-2-4-普通和模板函区别\"><a href=\"#1-2-4-普通和模板函区别\" class=\"headerlink\" title=\"1.2.4 普通和模板函区别\"></a>1.2.4 普通和模板函区别</h5><ul>\n<li><p>区别：</p>\n<ol>\n<li>普通函数调用时，可以发生自动类型转换 <code>(隐式类型转换)</code></li>\n<li>函数模板调用时，利用自动类型转换，不会发生<code>(隐式类型转换)</code></li>\n<li>如果利用显示指定类型的方式，可以发生<code>(隐式类型转换)</code></li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 15:54\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint add(int a,  int b)\n&#123;\n    return a + b;\n&#125;\n\ntemplate &lt;class T&gt;\nT add_T(T a, T b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    &#x2F;&#x2F; c -&gt; ASCII &#x3D; 97\n    char c &#x3D; &#39;a&#39;;\n\n    &#x2F;&#x2F; 普通函数 可以隐式类型转换\n    cout &lt;&lt; add(a, c) &lt;&lt; endl;\n\n    &#x2F;&#x2F; 模板函数 自动类型转换 无法隐式类型转换\n    &#x2F;&#x2F; cout &lt;&lt; add_T(a, c) &lt;&lt; endl;\n    &#x2F;&#x2F; 指定类型转换 可以隐式类型转换\n    cout &lt;&lt; add_T&lt;int&gt;(a, c) &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：建议使用<code>显示指定类型</code>的方式调用函数模板，可以自己确定通用类型<code>T</code></p>\n</li>\n</ul>\n<h5 id=\"1-2-5-普通和模板函数调用\"><a href=\"#1-2-5-普通和模板函数调用\" class=\"headerlink\" title=\"1.2.5 普通和模板函数调用\"></a>1.2.5 普通和模板函数调用</h5><ul>\n<li><p>调用规则：</p>\n<ol>\n<li>如果函数模板和普通函数都能实现，优先调用普通函数</li>\n<li>可以通过空模板参数列表来，强制调用函数模板</li>\n<li>函数模板可以发生重载</li>\n<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 16:18\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid print(int a, int b)\n&#123;\n    cout &lt;&lt; &quot;普通函数调用&quot; &lt;&lt; endl;\n&#125;\n\ntemplate &lt;class T&gt;\nT print(T a, T b)\n&#123;\n    cout &lt;&lt; &quot;模板函数调用&quot; &lt;&lt; endl;\n&#125;\n\ntemplate &lt;class T&gt;\nT print(T a, T b, T c)\n&#123;\n    cout &lt;&lt; &quot;模板函数重载调用&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 1. 如果函数模板和普通函数都能实现，优先调用普通函数\n    print(1, 2);\n\n    &#x2F;&#x2F; 2. 可以通过空模板参数列表来，强制调用函数模板\n    print&lt;&gt;(1, 2);\n\n    &#x2F;&#x2F; 3. 函数模板可以发生重载\n    print(1, 2, 3);\n\n    &#x2F;&#x2F; 4. 如果函数模板可以产生更好的匹配，优先调用函数模板\n    &#x2F;&#x2F; 因为 a， b为char，隐式类型转换调用普通函数，不如直接自动类型转换调用模板函数调用来的方便\n    print(&#39;a&#39;, &#39;b&#39;);\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：如果需要使用模板函数，就不用提供声明普通函数，以免产生<code>二义性</code></p>\n</li>\n</ul>\n<h5 id=\"1-2-6-模板的局限性\"><a href=\"#1-2-6-模板的局限性\" class=\"headerlink\" title=\"1.2.6 模板的局限性\"></a>1.2.6 模板的局限性</h5><ul>\n<li><p>局限性：模板的通用性，并非万能</p>\n</li>\n<li><p>代码示例_1：如果传入的 <code>a</code> 和 <code>b</code>是数组，该模板函数无法实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template &lt;class T&gt;\nvoid func(T a, T b)\n&#123;\n    a &#x3D; b;\n&#125;</code></pre>\n</li>\n<li><p>代码示例_2：传入的是自定义类型数据，同样无法实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template &lt;class T&gt;\nvoid func(T a, T b)\n&#123;\n    if (a &gt; b)\n    &#123;......&#125;\n&#125;</code></pre>\n\n\n</li>\n<li><p>解决方法：C++为了解决这个问题，提供模板的重载，可以为<code>特定的类型</code>提供<code>具体化的模板</code></p>\n</li>\n<li><p>代码示例_3：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 16:44\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 自定义的结构体数据类型\nstruct Person\n&#123;\n    Person(int age, string name)\n    &#123;\n        this-&gt;age &#x3D; age;\n        this-&gt;name &#x3D; name;\n    &#125;\n    int age;\n    string name;\n&#125;;\n\ntemplate &lt;class T&gt;\nbool compare_T(T &amp;a, T &amp;b)\n&#123;\n    return a &#x3D;&#x3D; b;\n&#125;\n\n&#x2F;&#x2F; 具体化模板函数的实现，当传入参数类型为 Person，优先调用这个模板函数\ntemplate&lt;&gt; bool compare_T(Person &amp;p1, Person &amp;p2)\n&#123;\n    return p1.age &#x3D;&#x3D; p2.age &amp;&amp; p1.name &#x3D;&#x3D; p2.name;\n&#125;\n\nvoid demo1()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n    bool rel &#x3D; compare_T(a, b);\n    string printInfo &#x3D; rel ? &quot;a &#x3D; b&quot; : &quot;a !&#x3D; b&quot;;\n    cout &lt;&lt; printInfo &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    Person p1(10, &quot;fh&quot;);\n    Person p2(10, &quot;fh&quot;);\n    bool rel &#x3D; compare_T(p1, p2);\n    string printInfo &#x3D; rel ? &quot;p1 &#x3D; p2&quot; : &quot;p1 !&#x3D; p2&quot;;\n    cout &lt;&lt; printInfo &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：</p>\n<ol>\n<li>利用具体化模板函数，可以解决自定义类型的通用化</li>\n<li>学习模板并非是为了写模板，而是能够在STL中使用系统提供的模板</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-3-类模板\"><a href=\"#1-3-类模板\" class=\"headerlink\" title=\"1.3 类模板\"></a>1.3 类模板</h4><h5 id=\"1-3-1-类模板语法\"><a href=\"#1-3-1-类模板语法\" class=\"headerlink\" title=\"1.3.1 类模板语法\"></a>1.3.1 类模板语法</h5><ul>\n<li><p>类模板作用：建立一个通用类，类的成员数据类型可以不具体声明，用<code>虚拟类型</code>代替</p>\n</li>\n<li><p>类模板语法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template &lt;class name_T, class age_T&gt;\nclass 类名\n&#123;\npublic:\n    name_T name;\n    age_T age;\n&#125;;</code></pre>\n</li>\n<li><p>代码示例：<code>类</code>和<code>结构体</code>都可以</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 17:17\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 类和结构体都可以这么用\ntemplate &lt;class name_T, class age_T&gt;\nstruct Person\n&#123;\n    name_T name;\n    age_T age;\n\n    Person(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Person&lt;string, int&gt;(&quot;fh&quot;, 24);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"1-3-2-类和模板区别\"><a href=\"#1-3-2-类和模板区别\" class=\"headerlink\" title=\"1.3.2 类和模板区别\"></a>1.3.2 类和模板区别</h5><ul>\n<li><p>区别：</p>\n<ol>\n<li>类模板没有自动类型推导的使用方式</li>\n<li>类模板在模板参数列表中，可以有默认参数</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;11 7:40\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nstruct Person01\n&#123;\n    name_T name;\n    age_T age;\n\n    Person01(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n    ~Person01()\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 用结构体来代替类了\n&#x2F;&#x2F; 类模板中，可以在参数列表中，指明默认参数类型，生成对象时，不需要再显示指定类型\ntemplate &lt;class name_T &#x3D; string, class age_T &#x3D; int&gt;\nstruct Person02\n&#123;\n    name_T name;\n    age_T age;\n\n    Person02(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n    ~Person02()\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo_P1()\n&#123;\n    &#x2F;&#x2F; 类模板没有自动类型推导，所以这个写法是错误的\n    &#x2F;&#x2F; Person01&lt;&gt; person01(&quot;FH&quot;, 24);\n\n    &#x2F;&#x2F; 需要显示指定类型\n    Person01&lt;string, int&gt; person01(&quot;FH&quot;, 24);\n&#125;\n\nvoid demo_P2()\n&#123;\n    Person02&lt;&gt; person02(&quot;XX&quot;, 24);\n&#125;\n\nint main()\n&#123;\n    demo_P1();\n    demo_P2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"1-3-3-类模板中成员函数创建时机\"><a href=\"#1-3-3-类模板中成员函数创建时机\" class=\"headerlink\" title=\"1.3.3 类模板中成员函数创建时机\"></a>1.3.3 类模板中成员函数创建时机</h5><ul>\n<li><p>类模板中和普通类中的成员函数创建时机存在区别</p>\n<ol>\n<li>普通类中的成员函数一开始就可以创建</li>\n<li>类模板中的成员函数在调用时才会创建</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 13:51\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person1\n&#123;\npublic:\n    void showPerson1()\n    &#123;\n        cout &lt;&lt; &quot;Show Person 1&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Person2\n&#123;\npublic:\n    void showPerson2()\n    &#123;\n        cout &lt;&lt; &quot;Show Person 2&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\ntemplate &lt;class class_T&gt;\nclass Person_T\n&#123;\npublic:\n    class_T person;\n\n    &#x2F;&#x2F; 传入的类型不确定，所以默认情况下，编译器不会保错\n    &#x2F;&#x2F; 此时，类模板中的函数不会被创建，当正确调用类模板时，才会创建\n    void showFunc1()\n    &#123;\n        person.showPerson1();\n    &#125;\n    void showFunc2()\n    &#123;\n        person.showPerson2();\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Person_T&lt;Person1&gt; p1;\n    p1.showFunc1();\n    &#x2F;&#x2F; 传入的是Person1，所以编译时，编译器创建类模板内的成员函数时，找不到可以调用的showPerson2()\n    &#x2F;&#x2F; p1.showFunc2();\n    \n    &#x2F;&#x2F; 传入Person2，才能调用showPerson2()，但同样也找不到showPerson1()\n    Person_T&lt;Person2&gt; p2;\n    p2.showFunc2();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"1-3-4-类模板对象做函数参数\"><a href=\"#1-3-4-类模板对象做函数参数\" class=\"headerlink\" title=\"1.3.4 类模板对象做函数参数\"></a>1.3.4 类模板对象做函数参数</h5><ul>\n<li><p>说明：类模板实例化出对象，向函数传参的方式</p>\n</li>\n<li><p>三种传入方式：</p>\n<ol>\n<li>指定传入类型：直接显示对象的数据类型</li>\n<li>参数模板化：将对象中的参数变为模板进行传递</li>\n<li>整个类模板化：将对象类型模板化进行传递</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 14:08\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\npublic:\n    name_T name;\n    age_T age;\n\n    Person(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n\n    void showPerson()\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 1. 指定传入类型：直接显示对象的数据类型\nvoid print1(Person&lt;string, int&gt; &amp;person)\n&#123;\n    person.showPerson();\n&#125;\n\nvoid demo1()\n&#123;\n    Person&lt;string, int&gt; person(&quot;FH&quot;, 24);\n    print1(person);\n&#125;\n\n&#x2F;&#x2F; 2. 参数模板化：将对象中的参数变为模板进行传递\ntemplate &lt;class string_T, class int_T&gt;\nvoid print2(Person&lt;string_T, int_T&gt; &amp;person)\n&#123;\n    person.showPerson();\n&#125;\n\nvoid demo2()\n&#123;\n    Person&lt;string, int&gt; person(&quot;FF&quot;, 22);\n    print2(person);\n&#125;\n\n&#x2F;&#x2F; 3. 整个类模板化：将对象类型模板化进行传递\ntemplate &lt;class person_T&gt;\nvoid print3(person_T &amp;person)\n&#123;\n    person.showPerson();\n&#125;\n\nvoid demo3()\n&#123;\n    Person&lt;string, int&gt; person(&quot;HH&quot;, 20);\n    print3(person);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    demo3();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"1-3-5-类模板与继承\"><a href=\"#1-3-5-类模板与继承\" class=\"headerlink\" title=\"1.3.5 类模板与继承\"></a>1.3.5 类模板与继承</h5><ul>\n<li><p>当类模板遇到需要继承时，需注意：</p>\n<ol>\n<li>当子类继承的父类是模板时，子类在声明时，需要指出父类中 <code>T</code> 的类型</li>\n<li>如果不指定，编译器无法给子类分配内存</li>\n<li>如果要灵活指定父类中的 <code>T</code> 类型，子类也需变成类模板</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 14:34\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class class_T&gt;\nclass Base\n&#123;\npublic:\n    class_T base_Info;\n&#125;;\n\nclass Derived_1 : Base&lt;int&gt; &#123;&#125;;\n\ntemplate &lt;class deClass_T, class baseClass_T&gt;\nclass Derived_2 : Base&lt;baseClass_T&gt;\n&#123;\npublic:\n    deClass_T derived_Info;\n\n    Derived_2()\n    &#123;\n        cout &lt;&lt; &quot;deClass_T: &quot; &lt;&lt; typeid(deClass_T).name() &lt;&lt; endl;\n        cout &lt;&lt; &quot;baseClass_T: &quot; &lt;&lt; typeid(baseClass_T).name() &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Derived_2&lt;int, char&gt; derived2;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"1-3-6-类模板成员函数类外实现\"><a href=\"#1-3-6-类模板成员函数类外实现\" class=\"headerlink\" title=\"1.3.6 类模板成员函数类外实现\"></a>1.3.6 类模板成员函数类外实现</h5><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 15:04\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\npublic:\n    name_T name;\n    age_T age;\n\n    &#x2F;&#x2F; 类模板 内 声明\n    Person(name_T name, age_T age);\n    void showPerson();\n&#125;;\n\n&#x2F;&#x2F; 类模板 外 实现\ntemplate &lt;class name_T, class age_T&gt;\nPerson&lt;name_T, age_T&gt;::Person(name_T name, age_T age)\n&#123;\n    this-&gt;name &#x3D; name;\n    this-&gt;age &#x3D; age;\n&#125;\n\ntemplate &lt;class name_T, class age_T&gt;\nvoid Person&lt;name_T, age_T&gt;::showPerson()\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);\n    person.showPerson();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"1-3-7-类模板分文件编写\"><a href=\"#1-3-7-类模板分文件编写\" class=\"headerlink\" title=\"1.3.7 类模板分文件编写\"></a>1.3.7 类模板分文件编写</h5><ul>\n<li><p>说明：掌握类模板成员函数分文件编写产生的问题及解决方式</p>\n</li>\n<li><p>问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p>\n</li>\n<li><p>解决：</p>\n<ol>\n<li>直接包含 <code>.cpp</code>文件</li>\n<li>将声明和实现写在同一个文件中，并改名为<code>.hpp</code>，是约定的标准名称，并非强制要求</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<ol>\n<li><p>第一种：直接包含 <code>.cpp</code>文件</p>\n<p><code>person.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;12.\n&#x2F;&#x2F;\n\n#ifndef TEMPLATE_STL_PERSON_H\n#define TEMPLATE_STL_PERSON_H\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\npublic:\n    name_T name;\n    age_T age;\n\n    Person(name_T name, age_T age);\n    void showPerson();\n&#125;;\n\n#endif &#x2F;&#x2F;TEMPLATE_STL_PERSON_H</code></pre>\n\n<p><code>person.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;12.\n&#x2F;&#x2F;\n\n#include &quot;person.h&quot;\n\ntemplate &lt;class name_T, class age_T&gt;\nPerson&lt;name_T, age_T&gt;::Person(name_T name, age_T age)\n&#123;\n    this-&gt;name &#x3D; name;\n    this-&gt;age &#x3D; age;\n&#125;\n\ntemplate &lt;class name_T, class age_T&gt;\nvoid Person&lt;name_T, age_T&gt;::showPerson()\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n&#125;</code></pre>\n\n<p><code>person_Main.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 15:30\n&#x2F;&#x2F;\n\n&#x2F;&#x2F; 包含头文件 不管用 因为类模板的成员函数 只在调用时创建 所以编译时无法链接到外部文件\n&#x2F;&#x2F; #include &quot;person.h&quot;\n\n&#x2F;&#x2F; 第一种：直接包含 .cpp 文件\n&#x2F;&#x2F; 直接包含 源文件 源文件中包含头文件 同时实现了 类模板的成员函数\n#include &quot;person.cpp&quot;\n\nvoid demo()\n&#123;\n    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);\n    person.showPerson();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>第二种：将声明和实现写在同一个文件中，并改名为<code>.hpp</code></p>\n<p><code>person.hpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;12.\n&#x2F;&#x2F;\n\n#ifndef TEMPLATE_STL_PERSON_H\n#define TEMPLATE_STL_PERSON_H\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\npublic:\n    name_T name;\n    age_T age;\n\n    Person(name_T name, age_T age);\n    void showPerson();\n&#125;;\n\ntemplate &lt;class name_T, class age_T&gt;\nPerson&lt;name_T, age_T&gt;::Person(name_T name, age_T age)\n&#123;\n    this-&gt;name &#x3D; name;\n    this-&gt;age &#x3D; age;\n&#125;\n\ntemplate &lt;class name_T, class age_T&gt;\nvoid Person&lt;name_T, age_T&gt;::showPerson()\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n&#125;\n\n#endif &#x2F;&#x2F;TEMPLATE_STL_PERSON_H</code></pre>\n\n<p><code>person_Main.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 15:47\n&#x2F;&#x2F;\n#include &quot;person.hpp&quot;\n\nvoid demo()\n&#123;\n    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);\n    person.showPerson();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ul>\n<h5 id=\"1-3-8-类模板与友元\"><a href=\"#1-3-8-类模板与友元\" class=\"headerlink\" title=\"1.3.8 类模板与友元\"></a>1.3.8 类模板与友元</h5><ul>\n<li><p>说明：类模板配合友元函数的类内和类外实现</p>\n</li>\n<li><p>实现：</p>\n<ol>\n<li>全局函数类内实现：直接在类内声明友元</li>\n<li>全局函数类外实现：需要让编译器提前知道全局函数的存在</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 15:57\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 全局函数 类外实现\ntemplate &lt;class name_T, class age_T&gt;\nclass Person;\n\ntemplate &lt;class name_T, class age_T&gt;\nvoid showPerson_2(Person&lt;name_T, age_T&gt; &amp;person)\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt;person.age &lt;&lt; endl;\n&#125;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\n    &#x2F;&#x2F; 全局函数 类内实现\n    friend void showPerson_1(Person&lt;name_T, age_T&gt; &amp;person)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt;person.age &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; 全局函数 类外实现\n    friend void showPerson_2&lt;&gt;(Person&lt;name_T, age_T&gt; &amp;person);\n\nprivate:\n    name_T name;\n    age_T age;\n\npublic:\n    Person(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;全局函数，类内实现: &quot;;\n    Person&lt;string, int&gt; person(&quot;FH&quot;, 24);\n    showPerson_1(person);\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;全局函数，类外实现: &quot;;\n    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);\n    showPerson_2(person);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"1-3-9-类模板案例\"><a href=\"#1-3-9-类模板案例\" class=\"headerlink\" title=\"1.3.9 类模板案例\"></a>1.3.9 类模板案例</h5><ul>\n<li><p>案例要求：实现一个通用的数组类</p>\n</li>\n<li><p>案例功能：</p>\n<ol>\n<li>可以对内置类型和自定义类型进行存储</li>\n<li>将数组的数据存储到堆区</li>\n<li>构造函数可以传入数组的容量</li>\n<li>提供拷贝函数及<code>operator=</code>防止浅拷贝问题</li>\n<li>提供尾差法和尾删法对数组中的数据进行增删</li>\n<li>通过下标访问数组中的元素</li>\n<li>获取数组中的元素个数和数组容量</li>\n</ol>\n</li>\n<li><p>代码示例：(初期)</p>\n<p><code>fArray.hpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;13.\n&#x2F;&#x2F;\n\n#ifndef TEMPLATE_STL_FARRAY_HPP\n#define TEMPLATE_STL_FARRAY_HPP\n\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class array_T&gt;\nclass FArray\n&#123;\nprivate:\n    array_T *arrayAddress; &#x2F;&#x2F; 指针指向堆区开辟的数组首地址\n    int arrayCapacity; &#x2F;&#x2F; 数组容量\n    int arraySize; &#x2F;&#x2F; 数组大小\n\npublic:\n    &#x2F;&#x2F; 初始化 数组的容量 大小 和 在堆区创建\n    FArray(int capacity)\n    &#123;\n        this-&gt;arrayCapacity &#x3D; capacity;\n        this-&gt;arraySize &#x3D; 0;\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n\n        cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;\n    &#125;\n    &#x2F;&#x2F; 释放堆区的数组\n    ~FArray()\n    &#123;\n        if (this-&gt;arrayAddress !&#x3D; nullptr)\n        &#123;\n            delete[] this-&gt;arrayAddress;\n            this-&gt;arrayAddress &#x3D; nullptr;\n\n            cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 拷贝构造函数，解决浅拷贝问题\n    FArray(const FArray &amp;fArray)\n    &#123;\n        this-&gt;arrayCapacity &#x3D; fArray.arrayCapacity;\n        this-&gt;arraySize &#x3D; fArray.arraySize;\n\n        &#x2F;&#x2F; 这是编译器默认的浅拷贝，在析构函数执行后，因为地址始终不为null，所以会重复释放\n        &#x2F;&#x2F; this-&gt;arrayAddress &#x3D; fArray.arrayAddress;\n        &#x2F;&#x2F; 重新开辟空间，解决浅拷贝问题\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n        &#x2F;&#x2F; 将 fArray的数据拷贝进新的空间中\n        for (int i &#x3D; 0; i &lt; this-&gt;arraySize; ++i)\n        &#123;\n            this-&gt;arrayAddress[i] &#x3D; fArray.arrayAddress[i];\n        &#125;\n\n        cout &lt;&lt; &quot;拷贝函数调用&quot; &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; operator&#x3D; 解决浅拷贝问题\n    FArray &amp;operator&#x3D;(const FArray &amp;fArray)\n    &#123;\n        &#x2F;&#x2F; 先判断堆区是否存在，存在就先释放\n        if (this-&gt;arrayAddress !&#x3D; nullptr)\n        &#123;\n            delete[] this-&gt;arrayAddress;\n            this-&gt;arrayAddress &#x3D; nullptr;\n            this-&gt;arrayCapacity &#x3D; 0;\n            this-&gt;arraySize &#x3D; 0;\n        &#125;\n\n        &#x2F;&#x2F; 深拷贝\n        this-&gt;arrayCapacity &#x3D; fArray.arrayCapacity;\n        this-&gt;arraySize &#x3D; fArray.arraySize;\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n\n        for (int i &#x3D; 0; i &lt; this-&gt;arraySize; ++i)\n        &#123;\n            this-&gt;arrayAddress[i] &#x3D; fArray.arrayAddress[i];\n        &#125;\n\n        cout &lt;&lt; &quot;operator&#x3D;函数调用&quot; &lt;&lt; endl;\n        return *this;\n    &#125;\n&#125;;\n\n#endif &#x2F;&#x2F;TEMPLATE_STL_FARRAY_HPP</code></pre>\n\n<p><code>fArray_Main.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;13 14:36\n&#x2F;&#x2F;\n#include &quot;fArray.hpp&quot;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 测试 初期，创建一个容量5的int类型数组\n    &#x2F;&#x2F; 测试 构造函数和析构函数\n    FArray&lt;int&gt; fArray1(5);\n\n    &#x2F;&#x2F; 测试 拷贝构造函数\n    FArray&lt;int&gt; fArray2(fArray1);\n\n    &#x2F;&#x2F; 测试 operator&#x3D; 函数\n    FArray&lt;int&gt; fArray3(10);\n    fArray3 &#x3D; fArray1;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>代码示例：（后期）</p>\n<p><code>fArray.hpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;13.\n&#x2F;&#x2F;\n\n#ifndef TEMPLATE_STL_FARRAY_HPP\n#define TEMPLATE_STL_FARRAY_HPP\n\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class array_T&gt;\nclass FArray\n&#123;\nprivate:\n    array_T *arrayAddress; &#x2F;&#x2F; 指针指向堆区开辟的数组首地址\n    int arrayCapacity; &#x2F;&#x2F; 数组容量\n    int arraySize; &#x2F;&#x2F; 数组大小\n\npublic:\n    &#x2F;&#x2F; 初始化 数组的容量 大小 和 在堆区创建\n    FArray(int capacity)\n    &#123;\n        this-&gt;arrayCapacity &#x3D; capacity;\n        this-&gt;arraySize &#x3D; 0;\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n\n        &#x2F;&#x2F; cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;\n    &#125;\n    &#x2F;&#x2F; 释放堆区的数组\n    ~FArray()\n    &#123;\n        if (this-&gt;arrayAddress !&#x3D; nullptr)\n        &#123;\n            delete[] this-&gt;arrayAddress;\n            this-&gt;arrayAddress &#x3D; nullptr;\n\n            &#x2F;&#x2F; cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 拷贝构造函数，解决浅拷贝问题\n    FArray(const FArray &amp;fArray)\n    &#123;\n        this-&gt;arrayCapacity &#x3D; fArray.arrayCapacity;\n        this-&gt;arraySize &#x3D; fArray.arraySize;\n\n        &#x2F;&#x2F; 这是编译器默认的浅拷贝，在析构函数执行后，因为地址始终不为null，所以会重复释放\n        &#x2F;&#x2F; this-&gt;arrayAddress &#x3D; fArray.arrayAddress;\n        &#x2F;&#x2F; 重新开辟空间，解决浅拷贝问题\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n        &#x2F;&#x2F; 将 fArray的数据拷贝进新的空间中\n        for (int i &#x3D; 0; i &lt; this-&gt;arraySize; ++i)\n        &#123;\n            this-&gt;arrayAddress[i] &#x3D; fArray.arrayAddress[i];\n        &#125;\n\n        &#x2F;&#x2F; cout &lt;&lt; &quot;拷贝函数调用&quot; &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; operator&#x3D; 解决浅拷贝问题\n    FArray &amp;operator&#x3D;(const FArray &amp;fArray)\n    &#123;\n        &#x2F;&#x2F; 先判断堆区是否存在，存在就先释放\n        if (this-&gt;arrayAddress !&#x3D; nullptr)\n        &#123;\n            delete[] this-&gt;arrayAddress;\n            this-&gt;arrayAddress &#x3D; nullptr;\n            this-&gt;arrayCapacity &#x3D; 0;\n            this-&gt;arraySize &#x3D; 0;\n        &#125;\n\n        &#x2F;&#x2F; 深拷贝\n        this-&gt;arrayCapacity &#x3D; fArray.arrayCapacity;\n        this-&gt;arraySize &#x3D; fArray.arraySize;\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n\n        for (int i &#x3D; 0; i &lt; this-&gt;arraySize; ++i)\n        &#123;\n            this-&gt;arrayAddress[i] &#x3D; fArray.arrayAddress[i];\n        &#125;\n\n        &#x2F;&#x2F; cout &lt;&lt; &quot;operator&#x3D;函数调用&quot; &lt;&lt; endl;\n        return *this;\n    &#125;\n\n    &#x2F;&#x2F; 返回数组大小\n    int getArraySize()\n    &#123;\n        return this-&gt;arraySize;\n    &#125;\n\n    &#x2F;&#x2F; 返回数组容量\n    int getArrayCapacity()\n    &#123;\n        return this-&gt;arrayCapacity;\n    &#125;\n\n    &#x2F;&#x2F; 尾插法\n    void tail_Insertion(const array_T &amp;arrayValue)\n    &#123;\n        &#x2F;&#x2F; 先判断数组容量是否够\n        if (this-&gt;arrayCapacity &#x3D;&#x3D; this-&gt;arraySize)\n        &#123;\n            return;\n        &#125;\n\n        this-&gt;arrayAddress[this-&gt;arraySize] &#x3D; arrayValue; &#x2F;&#x2F; 将数据插入到数组的尾部\n        this-&gt;arraySize++; &#x2F;&#x2F; 更新数组的大小\n    &#125;\n\n    &#x2F;&#x2F; 尾删法\n    void tail_Deletion()\n    &#123;\n        &#x2F;&#x2F; 让用户无法访问最后一个元素，逻辑删除\n        if (this-&gt;arraySize &#x3D;&#x3D; 0)\n        &#123;\n            return;\n        &#125;\n\n        this-&gt;arraySize--;\n    &#125;\n\n    &#x2F;&#x2F; 通过小标访问数组元素 自定义的数据类型，内置的[]不能用，需要重载[]\n    array_T &amp;operator[](int fArray_Index)\n    &#123;\n        return this-&gt;arrayAddress[fArray_Index];\n    &#125;\n&#125;;\n\n#endif &#x2F;&#x2F;TEMPLATE_STL_FARRAY_HPP</code></pre>\n\n<p><code>fArray.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;13 14:36\n&#x2F;&#x2F;\n#include &quot;fArray.hpp&quot;\n\nint arrayIntCount &#x3D; 0;\nint arrayPersonCount &#x3D; 0;\n\n&#x2F;&#x2F; 打印int类型数组\nvoid printIntArray(FArray&lt;int&gt; &amp;fArray)\n&#123;\n    arrayIntCount++;\n    cout &lt;&lt; &quot;数组&quot; &lt;&lt; arrayIntCount &lt;&lt; &quot;：[ &quot;;\n    for (int i &#x3D; 0; i &lt; fArray.getArraySize(); ++i)\n    &#123;\n        cout &lt;&lt; fArray[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 前期测试：创建到堆区，拷贝构造函数，operator&#x3D; 函数\nvoid test1()\n&#123;\n    &#x2F;&#x2F; 测试 初期，创建一个容量5的int类型数组\n    &#x2F;&#x2F; 测试 构造函数和析构函数\n    FArray&lt;int&gt; fArray1(5);\n\n    &#x2F;&#x2F; 测试 拷贝构造函数\n    FArray&lt;int&gt; fArray2(fArray1);\n\n    &#x2F;&#x2F; 测试 operator&#x3D; 函数\n    FArray&lt;int&gt; fArray3(10);\n    fArray3 &#x3D; fArray1;\n&#125;\n\n&#x2F;&#x2F; 后期测试：尾插法，容量，大小\nvoid test2()\n&#123;\n    &#x2F;&#x2F; 创建数组 和 容量\n    FArray&lt;int&gt; fArray1(10);\n\n    &#x2F;&#x2F; 用尾插法插入数据\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        fArray1.tail_Insertion(i);\n    &#125;\n    &#x2F;&#x2F; 打印数组\n    printIntArray(fArray1);\n\n    &#x2F;&#x2F; 查看数组 容量 大小\n    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray1.getArrayCapacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray1.getArraySize() &lt;&lt; endl;\n\n    &#x2F;&#x2F; 尾删法 测试\n    FArray&lt;int&gt; fArray2(fArray1);\n    printIntArray(fArray2);\n\n    fArray2.tail_Deletion();\n    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray2.getArrayCapacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray2.getArraySize() &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 后期测试 自定义数据类型\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person()&#123;&#125;;\n    Person(string name, int age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 打印Person类型数组\nvoid printPersonArray(FArray&lt;Person&gt; &amp;fArray)\n&#123;\n    arrayPersonCount++;\n    cout &lt;&lt; &quot;数组&quot; &lt;&lt; arrayPersonCount &lt;&lt; &quot;：[ &quot;;\n    for (int i &#x3D; 0; i &lt; fArray.getArraySize(); ++i)\n    &#123;\n        cout &lt;&lt; fArray[i].name &lt;&lt; &quot; &quot; &lt;&lt; fArray[i].age &lt;&lt; &quot; - &quot;;\n    &#125;\n    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;\n&#125;\n\nvoid test3()\n&#123;\n    FArray&lt;Person&gt; fArray(3);\n    Person person1(&quot;FH&quot;, 24);\n    Person person2(&quot;HH&quot;, 22);\n\n    fArray.tail_Insertion(person1);\n    fArray.tail_Insertion(person2);\n\n    printPersonArray(fArray);\n\n    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray.getArrayCapacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray.getArraySize() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; test1();\n    &#x2F;&#x2F; test2();\n    test3();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"2-STL基础\"><a href=\"#2-STL基础\" class=\"headerlink\" title=\"2. STL基础\"></a>2. STL基础</h3><h4 id=\"2-1-STL的诞生\"><a href=\"#2-1-STL的诞生\" class=\"headerlink\" title=\"2.1 STL的诞生\"></a>2.1 STL的诞生</h4><ul>\n<li>C++的面向对象和泛型编程思想，目的是复用性</li>\n<li>大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li>\n<li>为了建立数据结构和算法的标准，诞生了STL</li>\n</ul>\n<h4 id=\"2-2-STL基本概念\"><a href=\"#2-2-STL基本概念\" class=\"headerlink\" title=\"2.2 STL基本概念\"></a>2.2 STL基本概念</h4><ul>\n<li>STL(Standard Template Library，标准模板库)</li>\n<li>STL广义上分为：<code>容器(container)</code>，<code>算法(algorithm)</code>，<code>迭代器(iterator)</code></li>\n<li>容器和算法之间通过迭代器进行连接</li>\n<li>STL激活所有的代码都采用了模板类或模板函数</li>\n</ul>\n<h4 id=\"2-3-STL六大组件\"><a href=\"#2-3-STL六大组件\" class=\"headerlink\" title=\"2.3 STL六大组件\"></a>2.3 STL六大组件</h4><ul>\n<li>STL大体分为六个组件：<ul>\n<li>容器</li>\n<li>算法</li>\n<li>迭代器</li>\n<li>仿函数</li>\n<li>适配器(配接器)</li>\n<li>空间配置器</li>\n</ul>\n</li>\n<li>组件介绍：<ol>\n<li>容器：各种数据结构，如<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>等，用来存放数据</li>\n<li>算法：各种常用的算法，如<code>sort</code>、<code>find</code>、<code>copy</code>、<code>for_each</code>等</li>\n<li>迭代器：扮演了容器和算法之间的胶合剂</li>\n<li>仿函数：行为类似函数，可作为算法的某种策略</li>\n<li>适配器：一种修饰容器或仿函数或迭代器接口</li>\n<li>空间配置器：负责空间的配置和管理</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-4-STL容器-算法-迭代器\"><a href=\"#2-4-STL容器-算法-迭代器\" class=\"headerlink\" title=\"2.4 STL容器\\算法\\迭代器\"></a>2.4 STL容器\\算法\\迭代器</h4><ul>\n<li><p>容器：存放数据，将运用最广泛的一些数据结构实现出来</p>\n<ul>\n<li>常用数据结构：数组，链表，树，栈，队列，集合，映射表 等</li>\n<li>容器分为：<code>序列式容器</code>和<code>关联式容器</code><ul>\n<li>序列式容器：强调值的排序，序列容器中的每个元素均有固定的位置</li>\n<li>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>算法：解决问题，有限的步骤，解决逻辑或数学上的问题</p>\n<ul>\n<li>算法分为：<code>质变算法</code>和<code>非质变算法</code><ul>\n<li>质变算法：值运算过程中会更改区间内的元素的内容，例如：拷贝，替换，删除等</li>\n<li>非质变算法：值运算过程中不会更改区间内的元素内容，例如：查找，计数，遍历，寻找极值等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>迭代器：容器和算法之间胶合剂</p>\n<ul>\n<li><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表示方式</p>\n</li>\n<li><p>每个容器都有自己的专属迭代器</p>\n</li>\n<li><p>迭代器使用类似指针</p>\n</li>\n<li><p>迭代器的种类：</p>\n<table>\n<thead>\n<tr>\n<th>种类</th>\n<th>功能</th>\n<th>支持算法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>输入迭代器</td>\n<td>对数据只读访问</td>\n<td>只读，支持 ++，&#x3D;&#x3D;，!&#x3D;</td>\n</tr>\n<tr>\n<td>输出迭代器</td>\n<td>对数据只写访问</td>\n<td>只写，支持 ++</td>\n</tr>\n<tr>\n<td>前向迭代器</td>\n<td>读写操作，并能向前推进迭代器</td>\n<td>读写，支持 ++，&#x3D;&#x3D;，!&#x3D;</td>\n</tr>\n<tr>\n<td>双向迭代器</td>\n<td>读写操作，并能向前和向后操作</td>\n<td>读写，支持 ++，–</td>\n</tr>\n<tr>\n<td>随机访问迭代器</td>\n<td>读写操作，可以跳跃访问任意数据</td>\n<td>读写，支持 ++，–，[n]，-n，&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D;</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>常用的容器这迭代器种类为<code>双向迭代器</code>和<code>随机访问迭代器</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-5-容器-算法-迭代器基础\"><a href=\"#2-5-容器-算法-迭代器基础\" class=\"headerlink\" title=\"2.5 容器\\算法\\迭代器基础\"></a>2.5 容器\\算法\\迭代器基础</h4><h5 id=\"2-5-1-vector存放内置数据类型\"><a href=\"#2-5-1-vector存放内置数据类型\" class=\"headerlink\" title=\"2.5.1 vector存放内置数据类型\"></a>2.5.1 vector存放内置数据类型</h5><ul>\n<li><p>容器：<code>vector</code></p>\n</li>\n<li><p>算法：<code>for_each</code></p>\n</li>\n<li><p>迭代器：<code>vector&lt;int&gt;::iterator</code></p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;19 14:23\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvoid fPrint(int value)\n&#123;\n    cout &lt;&lt; value &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 创建一个vector容器\n    vector&lt;int&gt; v;\n\n    &#x2F;&#x2F; 插入数据\n    v.push_back(10);\n    v.push_back(11);\n    v.push_back(12);\n    v.push_back(13);\n\n    &#x2F;&#x2F; 通过创建迭代器访问容器中的数据\n    vector&lt;int&gt;::iterator iBegin &#x3D; v.begin(); &#x2F;&#x2F; 起始地迭代器 指向容器中的第一个元素\n    vector&lt;int&gt;::iterator iEnd &#x3D; v.end(); &#x2F;&#x2F; 指向容器最后一个元素 之后的地址\n\n    &#x2F;&#x2F; 第一种遍历方式\n&#x2F;&#x2F;    while (iBegin !&#x3D; iEnd)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; *iBegin &lt;&lt; endl;\n&#x2F;&#x2F;        iBegin++;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F; 第二种遍历方式\n&#x2F;&#x2F;    for (vector&lt;int&gt;::iterator i &#x3D; v.begin(); i !&#x3D; v.end(); ++i)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; *i &lt;&lt; endl;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F; 第三种遍历方式\n    for_each(v.begin(), v.end(), fPrint);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"2-5-2-vector存放自定义数据类型\"><a href=\"#2-5-2-vector存放自定义数据类型\" class=\"headerlink\" title=\"2.5.2 vector存放自定义数据类型\"></a>2.5.2 vector存放自定义数据类型</h5><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;19 14:49\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(string name, int age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;&lt; --demo1-- &gt;&quot; &lt;&lt; endl;\n    vector&lt;Person&gt; v_P;\n\n    Person p1(&quot;fh&quot;, 24);\n    Person p2(&quot;ff&quot;, 22);\n    Person p3(&quot;hh&quot;, 20);\n\n    v_P.push_back(p1);\n    v_P.push_back(p2);\n    v_P.push_back(p3);\n\n    for (vector&lt;Person&gt;::iterator it_P &#x3D; v_P.begin(); it_P !&#x3D; v_P.end(); ++it_P)\n    &#123;\n        cout &lt;&lt; it_P-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; it_P-&gt;age &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;&lt; --demo2-- &gt;&quot; &lt;&lt; endl;\n    vector&lt;Person *&gt; v_P;\n\n    Person p1(&quot;fh&quot;, 24);\n    Person p2(&quot;ff&quot;, 22);\n    Person p3(&quot;hh&quot;, 20);\n\n    v_P.push_back(&amp;p1);\n    v_P.push_back(&amp;p2);\n    v_P.push_back(&amp;p3);\n\n    for (vector&lt;Person *&gt;::iterator it_P &#x3D; v_P.begin(); it_P !&#x3D; v_P.end(); ++it_P)\n    &#123;\n        cout &lt;&lt; (*it_P)-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; (*it_P)-&gt;age &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"2-5-3-vector容器嵌套容器\"><a href=\"#2-5-3-vector容器嵌套容器\" class=\"headerlink\" title=\"2.5.3 vector容器嵌套容器\"></a>2.5.3 vector容器嵌套容器</h5><ul>\n<li><p>容器中嵌套容器，将数据进行遍历打印</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;19 15:07\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 创建大容器\n    vector&lt;vector&lt;int&gt;&gt; v_Big;\n    &#x2F;&#x2F; 创建小容器\n    vector&lt;int&gt; v_S1;\n    vector&lt;int&gt; v_S2;\n    vector&lt;int&gt; v_S3;\n    vector&lt;int&gt; v_S4;\n    &#x2F;&#x2F; 向小容器中添加数据\n    for (int i &#x3D; 0; i &lt; 4; ++i)\n    &#123;\n        v_S1.push_back(i + 1);\n        v_S2.push_back(i + 2);\n        v_S3.push_back(i + 3);\n        v_S4.push_back(i + 4);\n    &#125;\n    &#x2F;&#x2F; 将小容器插入大容器\n    v_Big.push_back(v_S1);\n    v_Big.push_back(v_S2);\n    v_Big.push_back(v_S3);\n    v_Big.push_back(v_S4);\n    &#x2F;&#x2F; 遍历大容器\n    for (vector&lt;vector&lt;int&gt;&gt;::iterator it_Big &#x3D; v_Big.begin(); it_Big !&#x3D; v_Big.end(); ++it_Big)\n    &#123;\n        &#x2F;&#x2F; (*it_Big)是小容器 vector&lt;int&gt;\n        &#x2F;&#x2F; 遍历小容器\n        for (vector&lt;int&gt;::iterator it_Small &#x3D; (*it_Big).begin(); it_Small !&#x3D; (*it_Big).end(); ++it_Small)\n        &#123;\n            cout &lt;&lt; *it_Small &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"3-STL常用容器\"><a href=\"#3-STL常用容器\" class=\"headerlink\" title=\"3. STL常用容器\"></a>3. STL常用容器</h3><h4 id=\"3-1-string容器\"><a href=\"#3-1-string容器\" class=\"headerlink\" title=\"3.1 string容器\"></a>3.1 string容器</h4><h5 id=\"3-1-1-string基本概念\"><a href=\"#3-1-1-string基本概念\" class=\"headerlink\" title=\"3.1.1 string基本概念\"></a>3.1.1 string基本概念</h5><ul>\n<li>本质：<code>string</code>是C++的风格字符串，而<code>string</code>本质是一个类</li>\n<li><code>string</code>和<code>char *</code> 区别：<ol>\n<li><code>char *</code> 是指针</li>\n<li><code>string</code> 是指针，内部封装了 <code>char *</code> ，管理这个字符串，是一个 <code>char * </code>的容器</li>\n</ol>\n</li>\n<li>特点：<ol>\n<li><code>string</code>内部封装了很多的成员方法</li>\n<li>查找 <code>find</code>，拷贝 <code>copy</code>，删除 <code>delete</code>，替换 <code>replace</code>，插入 <code>insert</code></li>\n<li><code>string</code>管理 <code>char *</code> 所分配的内存，不用担心复制越界和取值越界，由类内部进行负责</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"3-1-2-string构造函数\"><a href=\"#3-1-2-string构造函数\" class=\"headerlink\" title=\"3.1.2 string构造函数\"></a>3.1.2 string构造函数</h5><ul>\n<li><p>构造函数原型：</p>\n<table>\n<thead>\n<tr>\n<th><code>string();</code></th>\n<th>创建一个空的字符串</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>string(const char *s);</code></td>\n<td>使字符串初始化</td>\n</tr>\n<tr>\n<td><code>string(const string &amp;s);</code></td>\n<td>用一个string对象初始化另一个string对象</td>\n</tr>\n<tr>\n<td><code>string(int n, char c);</code></td>\n<td>使用n个字符c，初始化</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;20 9:43\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 创建一个空的字符串\n    string string1;\n\n    &#x2F;&#x2F; 使字符串初始化\n    const char *str &#x3D; &quot;HelloWorld&quot;;\n    string string2(str);\n    cout &lt;&lt; &quot;string2 &#x3D; &quot; &lt;&lt; string2 &lt;&lt; endl;\n\n    &#x2F;&#x2F; 用一个string对象初始化另一个string对象\n    string string3(string2);\n    cout &lt;&lt; &quot;string3 &#x3D; &quot; &lt;&lt; string3 &lt;&lt; endl;\n\n    &#x2F;&#x2F; 使用n个字符c，初始化\n    string string4(10, &#39;a&#39;);\n    cout &lt;&lt; &quot;string4 &#x3D; &quot; &lt;&lt; string4 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-1-3-string赋值操作\"><a href=\"#3-1-3-string赋值操作\" class=\"headerlink\" title=\"3.1.3 string赋值操作\"></a>3.1.3 string赋值操作</h5><ul>\n<li><p>功能描述：给<code>string</code>字符串赋值</p>\n<table>\n<thead>\n<tr>\n<th>赋值的函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>string &amp;operator=(const char *s)</code>;</td>\n<td>char *类型字符串，赋值给当前的字符串</td>\n</tr>\n<tr>\n<td><code>string &amp;operator=(const string &amp;s);</code></td>\n<td>字符串s，赋值给当前的字符串</td>\n</tr>\n<tr>\n<td><code>string &amp;operator=(char c);</code></td>\n<td>字符，赋值给当前字符串</td>\n</tr>\n<tr>\n<td><code>string &amp;assign(const char *s);</code></td>\n<td>字符串s，赋值给当前的字符串</td>\n</tr>\n<tr>\n<td><code>string &amp;assign(const char *s, int n);</code></td>\n<td>字符串s的前n个字符，赋值给当前的字符串</td>\n</tr>\n<tr>\n<td><code>string &amp;assign(const string &amp;s);</code></td>\n<td>字符串s，赋值给当前的字符串</td>\n</tr>\n<tr>\n<td><code>string &amp;assign(int n, char c);</code></td>\n<td>用n个字符c，赋值给当前字符串</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 14:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    string string1;\n    string1 &#x3D; &quot;hello world&quot;;\n    cout &lt;&lt; &quot;string1 &#x3D; &quot; &lt;&lt; string1 &lt;&lt; endl;\n\n    string string2;\n    string2 &#x3D; string1;\n    cout &lt;&lt; &quot;string2 &#x3D; &quot; &lt;&lt; string2 &lt;&lt; endl;\n\n    string string3;\n    string3 &#x3D; &quot;A&quot;;\n    cout &lt;&lt; &quot;string3 &#x3D; &quot; &lt;&lt; string3 &lt;&lt; endl;\n\n    string string4;\n    string4.assign(&quot;hello world&quot;);\n    cout &lt;&lt; &quot;string4 &#x3D; &quot; &lt;&lt; string4 &lt;&lt; endl;\n\n    string string5;\n    string5.assign(&quot;hello world&quot;, 3);\n    cout &lt;&lt; &quot;string5 &#x3D; &quot; &lt;&lt; string5 &lt;&lt; endl;\n\n    string string6;\n    string6.assign(6, &#39;a&#39;);\n    cout &lt;&lt; &quot;string6 &#x3D; &quot; &lt;&lt; string6 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-1-4-string字符拼接\"><a href=\"#3-1-4-string字符拼接\" class=\"headerlink\" title=\"3.1.4 string字符拼接\"></a>3.1.4 string字符拼接</h5><ul>\n<li><p>功能描述：实现字符串末尾拼接字符串</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>string &amp;operator+=(const char *str);</code></td>\n<td>重载+&#x3D;操作符</td>\n</tr>\n<tr>\n<td><code>string &amp;operator+=(const char c);</code></td>\n<td>重载+&#x3D;操作符</td>\n</tr>\n<tr>\n<td><code>string &amp;operator+=(const string &amp;str);</code></td>\n<td>重载+&#x3D;操作符</td>\n</tr>\n<tr>\n<td><code>string &amp;append(const char *s);</code></td>\n<td>字符串s，连接到当前字符串的末尾</td>\n</tr>\n<tr>\n<td><code>string &amp;append(const char *s, int n);</code></td>\n<td>字符串s的前n个字符，连接到当前字符串的末尾</td>\n</tr>\n<tr>\n<td><code>string &amp;append(const string &amp;s);</code></td>\n<td>等同于，<code>string &amp;operator+=(const string &amp;str);</code></td>\n</tr>\n<tr>\n<td><code>string &amp;append(const string &amp;s, int pos, int n);</code></td>\n<td>字符串s中从pos开始取n个字符，连接到当前字符串的末尾</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 15:12\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    string string1 &#x3D; &quot;Hello &quot;;\n    string1 +&#x3D; &quot;World&quot;;\n    cout &lt;&lt; &quot;String1 &#x3D; &quot; &lt;&lt; string1 &lt;&lt; endl;\n\n    string string2 &#x3D; &quot;Hi &quot;;\n    string2 +&#x3D; string1;\n    cout &lt;&lt; &quot;String2 &#x3D; &quot; &lt;&lt; string2 &lt;&lt; endl;\n\n    string string3 &#x3D; &quot;Age &quot;;\n    string3 +&#x3D; &#39;8&#39;;\n    cout &lt;&lt; &quot;String3 &#x3D; &quot; &lt;&lt; string3 &lt;&lt; endl;\n\n    string string4 &#x3D; &quot;Hello &quot;;\n    string4.append(&quot;World&quot;);\n    cout &lt;&lt; &quot;String4 &#x3D; &quot; &lt;&lt; string4 &lt;&lt; endl;\n\n    string string5 &#x3D; &quot;Hi &quot;;\n    string5.append(string4);\n    cout &lt;&lt; &quot;String5 &#x3D; &quot; &lt;&lt; string5 &lt;&lt; endl;\n\n    string string6;\n    string6.append(&quot;Hello World&quot;, 4);\n    cout &lt;&lt; &quot;String6 &#x3D; &quot; &lt;&lt; string6 &lt;&lt; endl;\n\n    string string7 &#x3D; string5;\n    string7.append(&quot;Hello World&quot;, 5, 6);\n    cout &lt;&lt; &quot;String7 &#x3D; &quot; &lt;&lt; string7 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-1-5-string查找替换\"><a href=\"#3-1-5-string查找替换\" class=\"headerlink\" title=\"3.1.5 string查找替换\"></a>3.1.5 string查找替换</h5><ul>\n<li><p>功能描述：</p>\n<ol>\n<li><p>查找：查找指定字符串是否存在</p>\n</li>\n<li><p>替换：在指定的位置替换字符串</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>int find(const string &amp;str, int pos = 0) const;</code></td>\n<td>查找str第一次出现的位置，默认pos从头开始</td>\n</tr>\n<tr>\n<td><code>int find(const char *s, int pos = 0) const;</code></td>\n<td>查找s第一次出现的位置，默认pos从头开始</td>\n</tr>\n<tr>\n<td><code>int find(const char *s, int pos, int n) const;</code></td>\n<td>从pos查找s的前n个字符第一次位置</td>\n</tr>\n<tr>\n<td><code>int find(const char *c, int pos = 0) const;</code></td>\n<td>查找字符c第一次出现位置</td>\n</tr>\n<tr>\n<td><code>int rfind(const string &amp;str, int pos = npos) const;</code></td>\n<td>查找str最后一次位置，从pos开始找</td>\n</tr>\n<tr>\n<td><code>int rfind(const char *s, int pos = npos) const;</code></td>\n<td>查找s最后一次位置，从pos开始找</td>\n</tr>\n<tr>\n<td><code>int rfind(const char *s, int pos, int n) const;</code></td>\n<td>从pos查找s的前n个字符最后一次位置</td>\n</tr>\n<tr>\n<td><code>int rfind(const char *c, int pos = 0) const;</code></td>\n<td>查找字符c最后一次出现位置</td>\n</tr>\n<tr>\n<td><code>string &amp;replace(int pos, int n, const string &amp;str) const;</code></td>\n<td>替换从pos开始n个字符为字符串str</td>\n</tr>\n<tr>\n<td><code>string &amp;replace(int pos, int n, const char *s) const;</code></td>\n<td>替换从pos开始n个字符为字符串s</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 15:46\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid findString()\n&#123;\n    string string1 &#x3D; &quot;AABBCCBBAA&quot;;\n    int pos1 &#x3D; string1.find(&quot;BB&quot;);\n    cout &lt;&lt; &quot;BB pos1 &#x3D; &quot; &lt;&lt; pos1 &lt;&lt; endl;\n\n    int pos2 &#x3D; string1.rfind(&quot;BB&quot;);\n    cout &lt;&lt; &quot;BB pos2 &#x3D; &quot; &lt;&lt; pos2 &lt;&lt; endl;\n&#125;\n\nvoid replaceString()\n&#123;\n    string string1 &#x3D; &quot;ABCDE&quot;;\n    string1.replace(2, 3, &quot;123&quot;);\n    cout &lt;&lt; &quot;String1 &#x3D; &quot; &lt;&lt; string1 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    findString();\n    replaceString();\n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>总结：</p>\n<ul>\n<li><code>find</code>是从左往右查，<code>rfind</code>是从右往左查</li>\n<li><code>find</code>查到字符后，返回字符的位置，找不到返回-1</li>\n<li><code>replace</code>在替换时，需指定起始位置，替换字符数，替换字符</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-1-6-string字符比较\"><a href=\"#3-1-6-string字符比较\" class=\"headerlink\" title=\"3.1.6 string字符比较\"></a>3.1.6 string字符比较</h5><ul>\n<li><p>功能描述：字符串之间比较</p>\n</li>\n<li><p>比较方式：按照字符编码ACSII进行比较</p>\n<ul>\n<li><code>=</code> 返回 <code>0</code></li>\n<li><code>&gt;</code> 返回 <code>1</code></li>\n<li><code>&lt;</code> 返回 <code>-1</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>int compare(const string &amp;str) const;</code></td>\n<td>与字符串str比较</td>\n</tr>\n<tr>\n<td><code>int compare(const char *s) const;</code></td>\n<td>与字符串s比较</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 16:12\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    string string1 &#x3D; &quot;Hello&quot;;\n    string string2 &#x3D; &quot;World&quot;;\n\n    if (string1.compare(string2) &#x3D;&#x3D; 0)\n    &#123;\n        cout &lt;&lt; &quot;string1 string2&quot; &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;string1 string2&quot; &lt;&lt; &quot; !&#x3D; &quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-1-7-string字符存取\"><a href=\"#3-1-7-string字符存取\" class=\"headerlink\" title=\"3.1.7 string字符存取\"></a>3.1.7 string字符存取</h5><ul>\n<li><p><code>string</code>中单个字符串存取方式有两种：</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>char &amp;operator[](int n);</code></td>\n<td>通过<code>[]</code>方式取字符</td>\n</tr>\n<tr>\n<td><code>char &amp;at(int n);</code></td>\n<td>通过<code>at</code>取字符</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 16:23\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstring string1 &#x3D; &quot;ABCDEFG&quot;;\n\nvoid demo1()\n&#123;\n    for (int i &#x3D; 0; i &lt; string1.size(); ++i)\n    &#123;\n        cout &lt;&lt; string1[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    for (int i &#x3D; 0; i &lt; string1.size(); ++i)\n    &#123;\n        cout &lt;&lt; string1.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-1-8-string插入删除\"><a href=\"#3-1-8-string插入删除\" class=\"headerlink\" title=\"3.1.8 string插入删除\"></a>3.1.8 string插入删除</h5><ul>\n<li><p>功能描述：对<code>string</code>字符串进行<code>插入</code>和<code>删除</code>字符操作</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>string &amp;insert(int pos, const char *s);</code></td>\n<td>插入字符串</td>\n</tr>\n<tr>\n<td><code>string &amp;insert(int pos, const string &amp;str);</code></td>\n<td>插入字符串</td>\n</tr>\n<tr>\n<td><code>string &amp;insert(int pos, int n, char c);</code></td>\n<td>在指定位置插入n个字符c</td>\n</tr>\n<tr>\n<td><code>string &amp;erase(int pos, int n = npos);</code></td>\n<td>删除从pos开始的n个字符</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 16:35\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demoInsert()\n&#123;\n    string str1 &#x3D; &quot;Hello &quot;;\n    string str2 &#x3D; &quot;world &quot;;\n\n    str1.insert(6, &quot;world &quot;);\n    cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    str1.insert(12, str2);\n    cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    str1.insert(18, 6, &#39;!&#39;);\n    cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;\n&#125;\n\nvoid demoDelete()\n&#123;\n    string str3 &#x3D; &quot;Hello World&quot;;\n    str3.erase(5, 6);\n    cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demoInsert();\n    demoDelete();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：插入<code>insert()</code>和删除<code>erase()</code>都是从下标0开始的</p>\n</li>\n</ul>\n<h5 id=\"3-1-9-string获取字串\"><a href=\"#3-1-9-string获取字串\" class=\"headerlink\" title=\"3.1.9 string获取字串\"></a>3.1.9 string获取字串</h5><ul>\n<li><p>功能描述：从字符串中获得想要的一段子字符串</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>string substr(int pos = 0, int n = npos) const;</code></td>\n<td>返回由pos开始的n个字符组成的字符串</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;5 14:59\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid subStringDemo()\n&#123;\n    string str1 &#x3D; &quot;Hello World&quot;;\n\n    str1 &#x3D; str1.substr(0, 5);\n    cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;\n&#125;\n\nvoid getEmailTypeInfo()\n&#123;\n    string str2 &#x3D; &quot;752972182@qq.com&quot;;\n\n    int pos &#x3D; str2.find(&quot;@&quot;);\n    string str3 &#x3D; str2.substr(pos + 1, 2);\n    str2 &#x3D; str2.substr(0, pos);\n\n    cout &lt;&lt; &quot;str2 email user &#x3D; &quot; &lt;&lt; str2 &lt;&lt; endl;\n    cout &lt;&lt; &quot;str3 email type &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    subStringDemo();\n    getEmailTypeInfo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-2-vector容器\"><a href=\"#3-2-vector容器\" class=\"headerlink\" title=\"3.2 vector容器\"></a>3.2 vector容器</h4><h5 id=\"3-2-1-vector基本概念\"><a href=\"#3-2-1-vector基本概念\" class=\"headerlink\" title=\"3.2.1 vector基本概念\"></a>3.2.1 vector基本概念</h5><ul>\n<li><p>功能：<code>vector</code>数据结构和<code>数组</code>非常相似，也称为<code>单端数组</code></p>\n</li>\n<li><p>与数组的区别：<code>数组</code>是静态空间，<code>vector</code>可以动态扩展</p>\n</li>\n<li><p>动态扩展：并非是在原有的空间后面，连续开辟新空间；而是在另一个更大的内存空间中<code>重新开辟</code>，并<code>拷贝</code>原来的容器数据，同时<code>释放原容器</code></p>\n</li>\n<li><p><code>vector</code>容器的迭代器是支持随机访问的迭代器</p>\n<table>\n<thead>\n<tr>\n<th>vector迭代器方法介绍 <code>vector&lt;T&gt; v;</code></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>v.rend();</code></td>\n<td>容器第一个元素之前的地址</td>\n</tr>\n<tr>\n<td><code>v.end();</code></td>\n<td>容器最后一个元素之后的地址</td>\n</tr>\n<tr>\n<td><code>v.begin();</code></td>\n<td>容器第一个元素自身的地址</td>\n</tr>\n<tr>\n<td><code>v.rbegin();</code></td>\n<td>容器最后一个元素之前的地址</td>\n</tr>\n<tr>\n<td><code>v.insert();</code></td>\n<td>容器中插入一个元素</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h5 id=\"3-2-2-vector构造函数\"><a href=\"#3-2-2-vector构造函数\" class=\"headerlink\" title=\"3.2.2 vector构造函数\"></a>3.2.2 vector构造函数</h5><ul>\n<li><p>功能描述：创建<code>vector</code>容器</p>\n<table>\n<thead>\n<tr>\n<th>函数原型 <code>vector&lt;T&gt; v;</code></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>vector&lt;T&gt; v;</code></td>\n<td>采用模板类实现，默认构造函数</td>\n</tr>\n<tr>\n<td><code>vector(v.begin(), v.end());</code></td>\n<td>将 <code>[ v.begin(), v.end() )</code> 之间的元素拷贝给自身<code> [闭 开)区间</code></td>\n</tr>\n<tr>\n<td><code>vector(n, elem);</code></td>\n<td>构造函数将 n个 元素拷贝给自身</td>\n</tr>\n<tr>\n<td><code>vector(const vector &amp;vec);</code></td>\n<td>拷贝构造函数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;5 15:37\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    &#x2F;&#x2F; 默认构造（无参）\n    vector&lt;int&gt; v1;\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    &#x2F;&#x2F; 通过 [ ) 构造\n    vector&lt;int&gt; v2(v1.begin(), v1.end());\n    printVector(v2);\n\n    &#x2F;&#x2F; n个 elem构造\n    vector&lt;int&gt; v3(10, 1);\n    printVector(v3);\n\n    &#x2F;&#x2F; 拷贝构造\n    vector&lt;int&gt; v4(v1);\n    printVector(v4);\n&#125;\n\nint main()\n&#123;\n    demo1();\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-2-3-vector赋值操作\"><a href=\"#3-2-3-vector赋值操作\" class=\"headerlink\" title=\"3.2.3 vector赋值操作\"></a>3.2.3 vector赋值操作</h5><ul>\n<li><p>功能描述：给容器赋值</p>\n<table>\n<thead>\n<tr>\n<th>函数原型 <code>vector&lt;T&gt; v;</code></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>vetor &amp;operator=(const vector &amp;vec);</code></td>\n<td>重载<code>=</code> 操作符</td>\n</tr>\n<tr>\n<td><code>v.assign(v.begin, v.end);</code></td>\n<td>将 <code>[begin, end)</code>区间中的数据拷贝到自身</td>\n</tr>\n<tr>\n<td><code>v.assign(n, elem);</code></td>\n<td>将 n个 elem拷贝赋值给自身</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;5 16:08\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    vector&lt;int&gt; v2 &#x3D; v1;\n    printVector(v2);\n\n    vector&lt;int&gt; v3(v1.begin(), v1.end());\n    printVector(v3);\n\n    vector&lt;int&gt; v4(10, 1);\n    printVector(v4);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-2-4-vector容量大小\"><a href=\"#3-2-4-vector容量大小\" class=\"headerlink\" title=\"3.2.4 vector容量大小\"></a>3.2.4 vector容量大小</h5><ul>\n<li><p>功能描述：对<code>vector</code>容器的容量和大小进行操作</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>empty();</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>capacity();</code></td>\n<td>获取容器的容量</td>\n</tr>\n<tr>\n<td><code>size();</code></td>\n<td>获取容器中的元素个数</td>\n</tr>\n<tr>\n<td><code>resize(int num);</code></td>\n<td>重新指定容器长度，若变长，默认填充；若变短，删除末尾超出容器长度的元素</td>\n</tr>\n<tr>\n<td><code>resize(int num, elem);</code></td>\n<td>重新指定容器长度，若变长，elem填充；若变短，删除末尾超出容器长度的元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;5 16:18\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    if (v1.empty())\n    &#123;\n        cout &lt;&lt; &quot;v1 is empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;v1 not empty&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;v1 size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl;\n        cout &lt;&lt; &quot;v1 capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;\n    &#125;\n\n    v1.resize(10);\n    printVector(v1);\n\n    v1.resize(15, 1);\n    printVector(v1);\n\n    v1.resize(2);\n    printVector(v1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-2-5-vector插入删除\"><a href=\"#3-2-5-vector插入删除\" class=\"headerlink\" title=\"3.2.5 vector插入删除\"></a>3.2.5 vector插入删除</h5><ul>\n<li><p>功能描述：对<code>vector</code>容器进行插入、删除操作</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_back(elem);</code></td>\n<td>尾部插入元素 <code>elem</code></td>\n</tr>\n<tr>\n<td><code>pop_back();</code></td>\n<td>删除最后一个元素</td>\n</tr>\n<tr>\n<td><code>insert(const_iterator pos, elem);</code></td>\n<td>迭代器指向位置<code>pos</code>，插入元素<code>elem</code></td>\n</tr>\n<tr>\n<td><code>insert(const_iterator pos, int count, elem);</code></td>\n<td>迭代器指向位置<code>pos</code>，插入<code>count</code>个元素<code>elem</code></td>\n</tr>\n<tr>\n<td><code>erase(const_iterator pos);</code></td>\n<td>删除迭代器指向位置<code>pos</code>的元素</td>\n</tr>\n<tr>\n<td><code>erase(const_iterator start, const_iterator end);</code></td>\n<td>删除迭代器选择的<code>start</code>到<code>end</code>之间的元素</td>\n</tr>\n<tr>\n<td><code>clear();</code></td>\n<td>清空容器</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;10 15:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator iterator &#x3D; v.begin(); iterator !&#x3D; v.end(); ++iterator)\n    &#123;\n        cout &lt;&lt; *iterator &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    &#x2F;&#x2F; 尾插入\n    vector&lt;int&gt; v1;\n    v1.push_back(1);\n    v1.push_back(2);\n    v1.push_back(3);\n    v1.push_back(4);\n    v1.push_back(5);\n    printVector(v1);\n\n    &#x2F;&#x2F; 尾删除\n    v1.pop_back();\n    printVector(v1);\n\n    &#x2F;&#x2F; 迭代器指定位置插入\n    v1.insert(v1.begin(), 0);\n    printVector(v1);\n\n    &#x2F;&#x2F; 迭代器指定位置插入 指定数量 元素\n    v1.insert(v1.end(), 3, 5);\n    printVector(v1);\n\n    &#x2F;&#x2F; 删除迭代器指向位置的元素\n    v1.erase(v1.end() - 1);\n    printVector(v1);\n\n    &#x2F;&#x2F; 删除迭代器选择的start到end之间的元素\n    v1.erase(v1.begin() + 1, v1.end() - 2);\n    printVector(v1);\n\n    &#x2F;&#x2F; clear\n    v1.clear();\n    printVector(v1);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-2-6-vector数据存取\"><a href=\"#3-2-6-vector数据存取\" class=\"headerlink\" title=\"3.2.6 vector数据存取\"></a>3.2.6 vector数据存取</h5><ul>\n<li><p>功能描述：<code>vector</code>中的数据存取操作</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>at(int index);</code></td>\n<td>返回索引<code>index</code>所指的数据</td>\n</tr>\n<tr>\n<td><code>operator[];</code></td>\n<td>返回索引<code>index</code>所指的数据</td>\n</tr>\n<tr>\n<td><code>front();</code></td>\n<td>返回容器中第一个数据元素</td>\n</tr>\n<tr>\n<td><code>back();</code></td>\n<td>返回容器中最后一个数据元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;10 16:20\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    for (int i &#x3D; 0; i &lt; v.size(); ++i)\n    &#123;\n        cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (int i &#x3D; 0; i &lt; v.size(); ++i)\n    &#123;\n        cout &lt;&lt; v.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;Vector Front Elem: &quot; &lt;&lt; v.front() &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;Vector Back Elem: &quot; &lt;&lt; v.back() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-2-7-vector互换容器\"><a href=\"#3-2-7-vector互换容器\" class=\"headerlink\" title=\"3.2.7 vector互换容器\"></a>3.2.7 vector互换容器</h5><ul>\n<li><p>功能描述：实现两个容器内元素的互换</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>swap(otherVector);</code></td>\n<td>将otherVector与本身的元素互换</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;10 16:30\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid debugVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid debugVectorInfo(vector&lt;int&gt; &amp;v)\n&#123;\n    cout &lt;&lt; &quot;Vector Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;Vector Size: &quot; &lt;&lt; v.size() &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n\n    for (int i &#x3D; 5; i &gt; 0; --i)\n    &#123;\n        v2.push_back(i);\n    &#125;\n\n    v1.swap(v2);\n\n    debugVector(v1);\n    debugVector(v2);\n&#125;\n\nvoid demo2()\n&#123;\n    vector&lt;int&gt; v3;\n    for (int i &#x3D; 0; i &lt; 1000000; ++i)\n    &#123;\n        v3.push_back(i);\n    &#125;\n    debugVectorInfo(v3);\n\n    &#x2F;&#x2F; 巧用 swap() 收缩容器的容量大小0\n    v3.resize(10);\n    vector&lt;int&gt;(v3).swap(v3);\n    debugVectorInfo(v3);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：swap还可以收缩容器的容量大小</p>\n</li>\n</ul>\n<h5 id=\"3-2-8-vector预留空间\"><a href=\"#3-2-8-vector预留空间\" class=\"headerlink\" title=\"3.2.8 vector预留空间\"></a>3.2.8 vector预留空间</h5><ul>\n<li><p>功能描述：减少<code>vector</code>在动态扩展容器时的扩展次数</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>reserve(int length);</code></td>\n<td>容器预留<code>length</code>个元素长度，预留位置不初始化，元素不可访问</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;10 16:54\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid demo1()\n&#123;\n    int count &#x3D; 0;\n    int *p &#x3D; nullptr;\n\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt; 10000000; ++i)\n    &#123;\n        v.push_back(i);\n        if (p !&#x3D; &amp;v[0])\n        &#123;\n            p &#x3D; &amp;v[0];\n            ++count;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;Number Of Extensions: &quot; &lt;&lt; count &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    int count &#x3D; 0;\n    int *p &#x3D; nullptr;\n\n    vector&lt;int&gt; v;\n    v.reserve(10000001);\n\n    for (int i &#x3D; 0; i &lt; 10000000; ++i)\n    &#123;\n        v.push_back(i);\n        if (p !&#x3D; &amp;v[0])\n        &#123;\n            p &#x3D; &amp;v[0];\n            ++count;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;Reserve Number Of Extensions: &quot; &lt;&lt; count &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：如果一开始容器需要插入足够大的数据时，可以通过<code>reserve</code>的方式提前预留，已减少容器扩展的次数</p>\n</li>\n</ul>\n<h4 id=\"3-3-deque容器\"><a href=\"#3-3-deque容器\" class=\"headerlink\" title=\"3.3 deque容器\"></a>3.3 deque容器</h4><h5 id=\"3-3-1-deque基本概念\"><a href=\"#3-3-1-deque基本概念\" class=\"headerlink\" title=\"3.3.1 deque基本概念\"></a>3.3.1 deque基本概念</h5><ul>\n<li><p>功能：双端数组，可以对容器头端进行<code>插入</code>、<code>删除</code>操作</p>\n</li>\n<li><p><code>deque</code>与<code>vector</code>的区别：</p>\n<ol>\n<li><code>vector</code>头部插入、删除效率低，数据量越大，效率越低</li>\n<li><code>vector</code>访问元素比<code>deque</code>快，源于内部实现的区别</li>\n</ol>\n</li>\n<li><p><code>deque</code>功能介绍：</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_front();</code></td>\n<td>头部插入</td>\n</tr>\n<tr>\n<td><code>pop_front();</code></td>\n<td>头部删除</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>deque</code>内部工作原理：</p>\n<ul>\n<li><code>deque</code>内部有一个<code>中控器</code>，维护每段<code>缓冲区</code>的内容，缓冲区存放真实数据</li>\n<li>中控器维护的是<code>缓冲区的地址</code>，使得<code>deque</code>在使用时，像是<code>连续的内存空间</code></li>\n<li><code>deque</code>容器的<code>迭代器</code>支持<code>随机访问</code></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-3-2-deque构造函数\"><a href=\"#3-3-2-deque构造函数\" class=\"headerlink\" title=\"3.3.2 deque构造函数\"></a>3.3.2 deque构造函数</h5><ul>\n<li><p>功能描述：<code>deque</code>容器构造</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>deque&lt;T&gt; dequeT;</code></td>\n<td>默认构造形式</td>\n</tr>\n<tr>\n<td><code>deque(begin, end);</code></td>\n<td>构造函数将 <code>[begin, end)</code>区间中的元素拷贝给自身</td>\n</tr>\n<tr>\n<td><code>deque(n, elem);</code></td>\n<td>构造函数将<code>n</code>个<code>elem</code>拷贝给自身</td>\n</tr>\n<tr>\n<td><code>deque(const deque &amp;deque);</code></td>\n<td>拷贝构造函数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;14 12:27\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; const 修饰 该容器为只可 读\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    &#x2F;&#x2F; 无参构造\n    deque&lt;int&gt; d1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        d1.push_back(i);\n    &#125;\n    printDeque(d1);\n\n    &#x2F;&#x2F; 区间构造\n    deque&lt;int&gt; d2(d1.begin(), d1.end());\n    printDeque(d2);\n\n    &#x2F;&#x2F; n个元素构造\n    deque&lt;int&gt; d3(10, 1);\n    printDeque(d3);\n\n    &#x2F;&#x2F; 拷贝构造\n    deque&lt;int&gt; d4(d3);\n    printDeque(d4);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：<code>deque</code>与<code>vector</code>相似，灵活使用即可</p>\n</li>\n</ul>\n<h5 id=\"3-3-3-deque赋值操作\"><a href=\"#3-3-3-deque赋值操作\" class=\"headerlink\" title=\"3.3.3 deque赋值操作\"></a>3.3.3 deque赋值操作</h5><ul>\n<li><p>功能描述：给<code>deque</code>容器赋值</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>deque &amp;operator=(const deque &amp;deque);</code></td>\n<td>重载等号操作</td>\n</tr>\n<tr>\n<td><code>assign(begin, end);</code></td>\n<td>将 <code>[begin, end)</code>区间中的数据拷贝赋值给本身</td>\n</tr>\n<tr>\n<td><code>assign(n, elem);</code></td>\n<td>将<code>n</code>个<code>elem</code>拷贝赋值给本身</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;14 13:13\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nvoid printDeque(deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    deque&lt;int&gt; deque1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    &#x2F;&#x2F; operator&#x3D;\n    deque&lt;int&gt; deque2 &#x3D; deque1;\n    printDeque(deque2);\n\n    &#x2F;&#x2F; assign(begin, end)\n    deque&lt;int&gt; deque3;\n    deque3.assign(deque1.begin(), deque1.end());\n    printDeque(deque3);\n\n    &#x2F;&#x2F; assign(n, elem)\n    deque&lt;int&gt; deque4;\n    deque4.assign(10, 1);\n    printDeque(deque4);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-3-4-deque大小操作\"><a href=\"#3-3-4-deque大小操作\" class=\"headerlink\" title=\"3.3.4 deque大小操作\"></a>3.3.4 deque大小操作</h5><ul>\n<li><p>功能描述：对<code>deque</code>容器的大小进行操作</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>deque.empty();</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>deque.size();</code></td>\n<td>获取容器中元素个数</td>\n</tr>\n<tr>\n<td><code>deque.resize(num);</code></td>\n<td>重新指定容器长度为<code>num</code>，容器过长以默认值填充，容器过短，删除末尾多余元素</td>\n</tr>\n<tr>\n<td><code>deque.resize(num, elem)</code></td>\n<td>重新指定容器长度为<code>num</code>，容器过长以<code>elem</code>填充，容器过短，删除末尾多余元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;17 15:17\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt;&quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 初始化 deque1\n    deque&lt;int&gt; deque1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    &#x2F;&#x2F; 判断deque1是否为空，不为空，打印出容器大小\n    if (deque1.empty())\n    &#123;\n        cout &lt;&lt; &quot;deque1 is empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;deque1 size: &quot; &lt;&lt; deque1.size() &lt;&lt; endl;\n        &#x2F;&#x2F; deque 没有容量的概念(capacity)\n    &#125;\n\n    &#x2F;&#x2F; deque1 大小重置\n    deque1.resize(12);\n    printDeque(deque1);\n\n    deque1.resize(15, 1);\n    printDeque(deque1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：</p>\n<ol>\n<li><code>deque</code>没有容量的概念</li>\n<li><code>empty</code>判断是否为空</li>\n<li><code>size</code>获取容器的大小</li>\n<li><code>resize</code>重置容器大小</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"3-3-5-deque插入删除\"><a href=\"#3-3-5-deque插入删除\" class=\"headerlink\" title=\"3.3.5 deque插入删除\"></a>3.3.5 deque插入删除</h5><ul>\n<li><p>功能描述：向<code>deque</code>容器插入和删除数据</p>\n</li>\n<li><p>函数原型：</p>\n<table>\n<thead>\n<tr>\n<th>两端插入caoz</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_back(elem);</code></td>\n<td>容器尾部添加一个数据</td>\n</tr>\n<tr>\n<td><code>push_front(elem);</code></td>\n<td>容器头部插入一个数据</td>\n</tr>\n<tr>\n<td><code>pop_back();</code></td>\n<td>删除容器最后一个数据</td>\n</tr>\n<tr>\n<td><code>pop_front();</code></td>\n<td>删除容器开头一个数据</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>指定位置操作</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>insert(pos, elem);</code></td>\n<td>在<code>pos</code>位置插入一个<code>elem</code>元素的拷贝，返回新数据的位置</td>\n</tr>\n<tr>\n<td><code>insert(pos, n, elem);</code></td>\n<td>在<code>pos</code>位置插入<code>n</code>个<code>elem</code>元素的拷贝，无返回值</td>\n</tr>\n<tr>\n<td><code>insert(pos, begin, end);</code></td>\n<td>在<code>pos</code>位置插入<code>[begin, end)</code>区间的数据，无返回值</td>\n</tr>\n<tr>\n<td><code>clear();</code></td>\n<td>清空容器所有数据</td>\n</tr>\n<tr>\n<td><code>erase(begin, end);</code></td>\n<td>删除<code>[begin, end)</code>区间的数据，返回下一个数据的位置</td>\n</tr>\n<tr>\n<td><code>erase(pos);</code></td>\n<td>删除<code>pos</code>位置的数据，返回下一个数据的位置</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;17 15:38\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    deque&lt;int&gt; deque1;\n\n    &#x2F;&#x2F; push_back()\n    deque1.push_back(1);\n    deque1.push_back(2);\n\n    &#x2F;&#x2F; push_front()\n    deque1.push_front(0);\n    deque1.push_front(0);\n    printDeque(deque1);\n\n    &#x2F;&#x2F; pop_back()\n    deque1.pop_back();\n\n    &#x2F;&#x2F; pop_front()\n    deque1.pop_front();\n    printDeque(deque1);\n\n    &#x2F;&#x2F; insert(pos, elem)\n    deque1.insert(deque1.begin(), 0);\n\n    &#x2F;&#x2F; insert(pos, n, elem)\n    deque1.insert(deque1.end(), 2, 2);\n    printDeque(deque1);\n\n    &#x2F;&#x2F; clear()\n    deque1.clear();\n    printDeque(deque1);\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    &#x2F;&#x2F; erase(begin, end)\n    deque1.erase(deque1.begin(), deque1.end() - 7);\n    printDeque(deque1);\n\n    &#x2F;&#x2F; erase(pos)\n    deque1.erase(deque1.begin() + 1);\n    printDeque(deque1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-3-6-deque数据存取\"><a href=\"#3-3-6-deque数据存取\" class=\"headerlink\" title=\"3.3.6 deque数据存取\"></a>3.3.6 deque数据存取</h5><ul>\n<li><p>功能描述：的<code>deque</code>中的数据的存取操作</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>at(int index);</code></td>\n<td>返回索引<code>index</code>所指的数据</td>\n</tr>\n<tr>\n<td><code>operator[index];</code></td>\n<td>返回索引<code>index</code>所指的数据</td>\n</tr>\n<tr>\n<td><code>front();</code></td>\n<td>返回容器中第一个数据</td>\n</tr>\n<tr>\n<td><code>back();</code></td>\n<td>返回容器这最后一个数据</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;17 15:57\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    deque&lt;int&gt; deque1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    &#x2F;&#x2F; at(int index)\n    cout &lt;&lt; deque1.at(1) &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator[]\n    cout &lt;&lt; deque1[1] &lt;&lt; endl;\n\n    &#x2F;&#x2F; front()\n    cout &lt;&lt; deque1.front() &lt;&lt; endl;\n\n    &#x2F;&#x2F; back()\n    cout &lt;&lt; deque1.back() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-3-7-deque容器排序\"><a href=\"#3-3-7-deque容器排序\" class=\"headerlink\" title=\"3.3.7 deque容器排序\"></a>3.3.7 deque容器排序</h5><ul>\n<li><p>功能描述：利用算法实现<code>deque</code>容器进行排序</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>sort(iterator begin, iterator end);</code></td>\n<td>对<code>begin, end</code>区间的数据进行排序</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;17 16:05\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    deque&lt;int&gt; deque1;\n    for (int i &#x3D; 20; i &gt; 0; i -&#x3D; 2)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    std::sort(deque1.begin(), deque1.end());\n    printDeque(deque1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：使用<code>sort</code>排序，需引入头文件<code>algorithm</code></p>\n</li>\n</ul>\n<h4 id=\"3-4-案例-评委打分\"><a href=\"#3-4-案例-评委打分\" class=\"headerlink\" title=\"3.4 案例-评委打分\"></a>3.4 案例-评委打分</h4><h5 id=\"3-4-1-案例描述\"><a href=\"#3-4-1-案例描述\" class=\"headerlink\" title=\"3.4.1 案例描述\"></a>3.4.1 案例描述</h5><ul>\n<li>5名选上ABCDE，10名评委分别对每一名选手打分，去除最高分和最低分，取平均分</li>\n</ul>\n<h5 id=\"3-4-2-实现步骤\"><a href=\"#3-4-2-实现步骤\" class=\"headerlink\" title=\"3.4.2 实现步骤\"></a>3.4.2 实现步骤</h5><ol>\n<li>创建5名选手，存入<code>vector</code>容器中</li>\n<li>遍历<code>vector</code>容器，获取每一名选手，使用<code>for</code>循环，把10名评委的打分存入<code>deque</code>容器中</li>\n<li><code>sort</code>算法对<code>deque</code>容器中分数排序，去除最高和最低分</li>\n<li><code>deque</code>容器遍历一遍，累加总分</li>\n<li>获取平均分</li>\n</ol>\n<h5 id=\"3-4-3-示例代码\"><a href=\"#3-4-3-示例代码\" class=\"headerlink\" title=\"3.4.3 示例代码\"></a>3.4.3 示例代码</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;20 14:26\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nclass Player\n&#123;\npublic:\n    string playerName;\n    int playerScore;\n\n    Player(string name, int score)\n    &#123;\n        this-&gt;playerName &#x3D; name;\n        this-&gt;playerScore &#x3D; score;\n    &#125;\n&#125;;\n\n&#x2F;*Test Code*&#x2F;\n&#x2F;*void printVector(vector&lt;Player&gt; &amp;v_Player)\n&#123;\n    for (vector&lt;Player&gt;::iterator it &#x3D; v_Player.begin(); it !&#x3D; v_Player.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; (*it).playerName &lt;&lt; &quot; Score: &quot; &lt;&lt; (*it).playerScore &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printPlayerScores(vector&lt;Player&gt; &amp;v_Player, deque&lt;int&gt; &amp;d_Scores)\n&#123;\n    for (vector&lt;Player&gt;::iterator v_it &#x3D; v_Player.begin(); v_it !&#x3D; v_Player.end(); ++v_it)\n    &#123;\n        cout &lt;&lt; v_it-&gt;playerName &lt;&lt; endl;\n        for (deque&lt;int&gt;::iterator d_it &#x3D; d_Scores.begin(); d_it !&#x3D; d_Scores.end(); ++d_it)\n        &#123;\n            cout &lt;&lt; *d_it &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;*&#x2F;\n\n&#x2F;*Program Code*&#x2F;\nvector&lt;Player&gt; createPlayers()\n&#123;\n    int score &#x3D; 0;\n    string nameSeed &#x3D; &quot;ABCDE&quot;;\n    vector&lt;Player&gt; v_Player;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        string name &#x3D; &quot;player&quot;;\n        name +&#x3D; nameSeed[i];\n        Player player(name, score);\n        v_Player.push_back(player);\n    &#125;\n\n    &#x2F;&#x2F; printVector(v_Player);\n\n    return v_Player;\n&#125;\n\nint playerScoreSortAndDeal(deque&lt;int&gt; &amp;d_Scores)\n&#123;\n    float averageScore;\n    int allScore &#x3D; 0;\n\n    std::sort(d_Scores.begin(), d_Scores.end());\n    d_Scores.pop_front();\n    d_Scores.pop_back();\n\n    for (deque&lt;int&gt;::iterator it &#x3D; d_Scores.begin(); it !&#x3D; d_Scores.end(); ++it)\n    &#123;\n        allScore +&#x3D; (*it);\n    &#125;\n    averageScore &#x3D; allScore &#x2F; d_Scores.size();\n    return averageScore;\n&#125;\n\nvoid setPlayerScore(vector&lt;Player&gt; &amp;v_Player)\n&#123;\n    for (vector&lt;Player&gt;::iterator it &#x3D; v_Player.begin(); it !&#x3D; v_Player.end(); ++it)\n    &#123;\n        deque&lt;int&gt; d_Scores;\n\n        for (int i &#x3D; 0; i &lt; 10; ++i)\n        &#123;\n            int score &#x3D; (rand() % 71) + 30;\n            d_Scores.push_back(score);\n        &#125;\n\n        it-&gt;playerScore &#x3D; playerScoreSortAndDeal(d_Scores);\n\n        &#x2F;&#x2F; printPlayerScores(v_Player, d_Scores);\n    &#125;\n&#125;\n\nvoid showPlayerAverageScore(vector&lt;Player&gt; &amp;v_Player)\n&#123;\n    for (vector&lt;Player&gt;::iterator it &#x3D; v_Player.begin(); it !&#x3D; v_Player.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; + it-&gt;playerName &lt;&lt; &quot; AverageScore: &quot; &lt;&lt; it-&gt;playerScore &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int) time(NULL));\n\n    vector&lt;Player&gt; v_Player &#x3D; createPlayers();\n    setPlayerScore(v_Player);\n    showPlayerAverageScore(v_Player);\n\n    return 0;\n&#125;</code></pre>\n\n\n\n\n\n<h4 id=\"3-5-stack容器\"><a href=\"#3-5-stack容器\" class=\"headerlink\" title=\"3.5 stack容器\"></a>3.5 stack容器</h4><h5 id=\"3-5-1-stack基本概念\"><a href=\"#3-5-1-stack基本概念\" class=\"headerlink\" title=\"3.5.1 stack基本概念\"></a>3.5.1 stack基本概念</h5><ul>\n<li>概念：<code>stack</code>是一种<code>先进后出(First In Last out : FILO)</code>的数据结构，它只有<code>一个出口</code></li>\n<li><code>栈底</code>存放<code>首个元素</code>，后续<code>其它元素</code>都在<code>栈顶</code>依次加入</li>\n<li>栈中的元素，只有<code>栈顶的元素</code>可以<code>被外界使用</code>，也因此<code>不支持遍历</code>的行为</li>\n<li><code>push()</code>入栈，<code>pop()</code>出栈，<code>empty()</code>判断栈是否为空，<code>size()</code>获取栈大小</li>\n</ul>\n<h5 id=\"3-5-2-stack常用接口\"><a href=\"#3-5-2-stack常用接口\" class=\"headerlink\" title=\"3.5.2 stack常用接口\"></a>3.5.2 stack常用接口</h5><ul>\n<li><p>功能描述：栈容器常用的对外口</p>\n</li>\n<li><p>构造函数：</p>\n<ul>\n<li><code>stack&lt;T&gt; stk;</code> 采用<code>模板类</code>实现，<code>stack</code>对象的默认构造形式</li>\n<li><code>stack(const stack &amp;stk);</code> 拷贝构造函数</li>\n</ul>\n</li>\n<li><p>赋值操作：</p>\n<ul>\n<li><code>stack &amp;operator=(const stack &amp;stk);</code> 重载等号操作</li>\n</ul>\n</li>\n<li><p>数据存取：</p>\n<ul>\n<li><code>push(elem);</code> 向栈顶添加元素</li>\n<li><code>pop();</code> 移除栈顶的元素</li>\n<li><code>top();</code> 返回栈顶的元素</li>\n</ul>\n</li>\n<li><p>大小操作：</p>\n<ul>\n<li><code>empty();</code> 判断栈是否为空</li>\n<li><code>size()</code> 获取栈大小</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;20 16:13\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    stack&lt;int&gt; stk;\n\n    stk.push(10);\n    stk.push(20);\n    stk.push(30);\n\n    while (!stk.empty())\n    &#123;\n        cout &lt;&lt; &quot;Stack Size: &quot; &lt;&lt; stk.size() &lt;&lt; endl;\n        cout &lt;&lt; &quot;Stack Top Element: &quot; &lt;&lt; stk.top() &lt;&lt; endl;\n        stk.pop();\n    &#125;\n    cout &lt;&lt; &quot;Stack Size: &quot; &lt;&lt; stk.size() &lt;&lt; endl;\n    cout &lt;&lt; &quot;Stack Top Element: &quot; &lt;&lt; stk.top() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-6-queue容器\"><a href=\"#3-6-queue容器\" class=\"headerlink\" title=\"3.6 queue容器\"></a>3.6 queue容器</h4><h5 id=\"3-6-1-queue基本概念\"><a href=\"#3-6-1-queue基本概念\" class=\"headerlink\" title=\"3.6.1 queue基本概念\"></a>3.6.1 queue基本概念</h5><ul>\n<li>概念：<code>queue</code>是<code>先进先出(First In Frist Out : FIFO)</code>的数据结构，它有两个出口</li>\n<li>队列容器只能队尾加入元素，对头删除元素</li>\n<li>队列容器只有头和尾可被外界使用，因此不支持遍历行为</li>\n<li>队列中进数据：入队<code>push</code></li>\n<li>队列中出数据：出队<code>pop</code></li>\n</ul>\n<h5 id=\"3-6-2-queue常用接口\"><a href=\"#3-6-2-queue常用接口\" class=\"headerlink\" title=\"3.6.2 queue常用接口\"></a>3.6.2 queue常用接口</h5><ul>\n<li><p>功能描述：栈容器常用的对外接口</p>\n</li>\n<li><p>构造函数：</p>\n<ul>\n<li><code>queue&lt;T&gt; que;</code> 采用<code>模板类</code>实现，<code>queue</code>对象的默认构造形式</li>\n<li><code>queue(const queue &amp;que);</code> 拷贝构造函数</li>\n</ul>\n</li>\n<li><p>赋值操作：</p>\n<ul>\n<li><code>queue&amp;operator=(const queue &amp;que);</code> 重载等号操作</li>\n</ul>\n</li>\n<li><p>数据存取：</p>\n<ul>\n<li><code>push(elem);</code> 向队尾添加元素</li>\n<li><code>pop();</code> 移除队头元素</li>\n<li><code>back();</code> 返回最后一个元素</li>\n<li><code>front();</code> 返回第一个元素</li>\n</ul>\n</li>\n<li><p>大小操作：</p>\n<ul>\n<li><code>empty();</code> 判断栈是否为空</li>\n<li><code>size()</code> 获取栈大小</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;20 16:37\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(string name, int age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    queue&lt;Person&gt; q;\n\n    Person p1(&quot;QQ&quot;, 10);\n    Person p2(&quot;WW&quot;, 20);\n    Person p3(&quot;EE&quot;, 30);\n    Person p4(&quot;RR&quot;, 40);\n\n    q.push(p1);\n    q.push(p2);\n    q.push(p3);\n    q.push(p4);\n\n    cout &lt;&lt; &quot;Queue Size: &quot; &lt;&lt; q.size() &lt;&lt; endl;\n\n    while (!q.empty())\n    &#123;\n        cout &lt;&lt; &quot;Front Name: &quot; + q.front().name + &quot; Front Age: &quot; &lt;&lt; q.front().age &lt;&lt; endl;\n        cout &lt;&lt; &quot;Back Name: &quot; + q.back().name + &quot; Back Age: &quot; &lt;&lt; q.back().age &lt;&lt; endl;\n\n        q.pop();\n    &#125;\n\n    cout &lt;&lt; &quot;Queue Size: &quot; &lt;&lt; q.size() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-7-list容器\"><a href=\"#3-7-list容器\" class=\"headerlink\" title=\"3.7 list容器\"></a>3.7 list容器</h4><h5 id=\"3-7-1-list基本概念\"><a href=\"#3-7-1-list基本概念\" class=\"headerlink\" title=\"3.7.1 list基本概念\"></a>3.7.1 list基本概念</h5><ul>\n<li><p>功能：将数据进行<code>链式</code>存储</p>\n</li>\n<li><p>链表：是一种<code>物理存储单元</code>上<code>非连续</code>的存储结构，数据元素的<code>逻辑顺序</code>是通过链表中的<code>指针链</code>实现的</p>\n</li>\n<li><p>链表的组成：链表由一系列<code>结点</code>组成</p>\n</li>\n<li><p>结点的组成：一个是存储数据元素的<code>数据域</code>，另一个是存储下一个结点地址的<code>指针域</code></p>\n</li>\n<li><p>STL中的链表是一个<code>双向循环链表</code></p>\n</li>\n<li><p>优点：可以对任意位置进行快速插入或删除元素</p>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>链表容器遍历元素比数组慢</li>\n<li>占用空间比数组大</li>\n</ul>\n</li>\n<li><p>STL链表的结构：<code>双向循环链表</code></p>\n</li>\n<li><p>结点：</p>\n<ul>\n<li><code>data区</code>：存储数据</li>\n<li><code>pionter区</code>：(默认指向null，则是<code>不循环双向链表</code>)<ul>\n<li><code>prev</code>：指向上一个结点的首地址(第一个结点默认指向最后一个结点的首地址)</li>\n<li><code>next</code>：指向下一个结点的首地址(最后一个结点默认指向第一个结点的首地址)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>方法：</p>\n<ul>\n<li><code>push_front()</code>：添加一个新结点做为首结点</li>\n<li><code>pop_front()</code>：删除首结点</li>\n<li><code>push_back()</code>：添加一个新结点做为尾结点</li>\n<li><code>pop_back()</code>：删除尾结点</li>\n</ul>\n</li>\n<li><p>迭代器：</p>\n<ul>\n<li><code>begin()</code>：获得首结点的地址</li>\n<li><code>insert()</code>：获得指定的结点的地址</li>\n<li><code>end()</code>：获得尾结点的地址</li>\n</ul>\n</li>\n<li><p>补充：由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<code>双向迭代器</code></p>\n</li>\n<li><p>list的优点：</p>\n<ul>\n<li>采用动态存储分配，不会造成内存浪费和溢出</li>\n<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>\n</ul>\n</li>\n<li><p>list的缺点：</p>\n<ul>\n<li>链表的灵活带来的是空间(指针域)和时间(遍历)的额外消费较大</li>\n</ul>\n</li>\n<li><p>list的重要性质：插入和删除操作都不会造成原有list容器迭代器的失效(vector中会失效)</p>\n</li>\n<li><p>总结：STL中的<code>lsit</code>和<code>vector</code>是两个常用的容器，各有优缺点</p>\n</li>\n</ul>\n<h5 id=\"3-7-2-list构造函数\"><a href=\"#3-7-2-list构造函数\" class=\"headerlink\" title=\"3.7.2 list构造函数\"></a>3.7.2 list构造函数</h5><ul>\n<li><p>功能描述：创建<code>list</code>容器</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>list&lt;T&gt; list;</code></td>\n<td>list采用模板类实现，对象的默认构造函数形式</td>\n</tr>\n<tr>\n<td><code>list(begin, end);</code></td>\n<td>构造函数将<code>[begin, end)</code>区间中的元素拷贝给自身</td>\n</tr>\n<tr>\n<td><code>list(n, elem);</code></td>\n<td>构造函数将<code>n</code>个<code>elem</code>拷贝给自身</td>\n</tr>\n<tr>\n<td><code>list(const list &amp;list);</code></td>\n<td>拷贝构造函数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;27 14:37\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;otherList)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; otherList.begin(); it !&#x3D; otherList.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; list1;\n    list1.push_back(1);\n    list1.push_back(2);\n    list1.push_back(3);\n    list1.push_back(4);\n\n    printList(list1);\n\n    &#x2F;&#x2F; 区间构造\n    list&lt;int&gt; list2(list1.begin(), list1.end());\n    printList(list2);\n\n    &#x2F;&#x2F; 拷贝构造\n    list&lt;int&gt; list3(list2);\n    printList(list3);\n\n    &#x2F;&#x2F; n 个 elem\n    list&lt;int&gt; list4(4, 0);\n    printList(list4);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-7-3-list赋值交换\"><a href=\"#3-7-3-list赋值交换\" class=\"headerlink\" title=\"3.7.3 list赋值交换\"></a>3.7.3 list赋值交换</h5><ul>\n<li><p>功能描述：给<code>list</code>容器进行赋值，以及容器<code>list</code>交换</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>assign(begin, end);</code></td>\n<td>将<code>[begin, end)</code>区间中的数据拷贝赋值给自身</td>\n</tr>\n<tr>\n<td><code>assign(n, elem);</code></td>\n<td><code>n</code>个<code>elem</code>拷贝赋值给自身</td>\n</tr>\n<tr>\n<td><code>list &amp;operator=(const list &amp;list);</code></td>\n<td>重载<code>=</code>操作符</td>\n</tr>\n<tr>\n<td><code>swap(list);</code></td>\n<td>将<code>list</code>与自身的元素互换</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;27 14:49\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;Demo1 &gt;&gt;&quot; &lt;&lt; endl;\n    list&lt;int&gt; l1(4, 1);\n    printList(l1);\n\n    &#x2F;&#x2F; operator&#x3D;\n    list&lt;int&gt; l2 &#x3D; l1;\n    printList(l2);\n\n    &#x2F;&#x2F; assign(begin, end)\n    list&lt;int&gt; l3;\n    l3.assign(l1.begin(), l1.end());\n    printList(l3);\n\n    &#x2F;&#x2F; assign(n, elem)\n    list&lt;int&gt; l4;\n    l4.assign(4, 0);\n    printList(l4);\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;Demo2 &gt;&gt;&quot; &lt;&lt; endl;\n    list&lt;int&gt; list1(4, 0);\n    list&lt;int&gt; list2(4, 9);\n\n    cout &lt;&lt; &quot;Swap List Before &gt;&gt;&quot; &lt;&lt; endl;\n    printList(list1);\n    printList(list2);\n\n    cout &lt;&lt; &quot;Swap List Last &gt;&gt;&quot; &lt;&lt; endl;\n    list1.swap(list2);\n    printList(list1);\n    printList(list2);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-7-4-list大小操作\"><a href=\"#3-7-4-list大小操作\" class=\"headerlink\" title=\"3.7.4 list大小操作\"></a>3.7.4 list大小操作</h5><ul>\n<li><p>功能描述：对<code>list</code>容器的大小进行操作</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>size();</code></td>\n<td>返回容器中元素个数</td>\n</tr>\n<tr>\n<td><code>empty();</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>resize();</code></td>\n<td>重新指定容器长度为<code>num</code>，容器过长以默认值填充，容器过短，删除末尾多余元素</td>\n</tr>\n<tr>\n<td><code>resize(num, elem);</code></td>\n<td>重新指定容器长度为<code>num</code>，容器过长以<code>elem</code>填充，容器过短，删除末尾多余元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;27 15:06\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; list1(5, 1);\n\n    if (list1.empty())\n    &#123;\n        cout &lt;&lt; &quot;List1 Is Empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;List1 Size: &quot; &lt;&lt; list1.size() &lt;&lt; endl;\n    &#125;\n\n    list1.resize(10, 2);\n    printList(list1);\n\n    list1.resize(5);\n    printList(list1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-7-5-list插入删除\"><a href=\"#3-7-5-list插入删除\" class=\"headerlink\" title=\"3.7.5 list插入删除\"></a>3.7.5 list插入删除</h5><ul>\n<li><p>功能描述：对<code>list</code>容器进行数据的插入和删除</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_back(elem);</code></td>\n<td>在容器尾部加入一个元素</td>\n</tr>\n<tr>\n<td><code>pop_back();</code></td>\n<td>删除容器中最后一个元素</td>\n</tr>\n<tr>\n<td><code>push_front(elem);</code></td>\n<td>在容器开头加入一个元素</td>\n</tr>\n<tr>\n<td><code>pop_front();</code></td>\n<td>删除容器开头的一个元素</td>\n</tr>\n<tr>\n<td><code>insert(pos, elem);</code></td>\n<td>在<code>pos</code>的位置插入<code>elem</code>元素的拷贝，返回新数据的位置</td>\n</tr>\n<tr>\n<td><code>insert(pos, n, elem);</code></td>\n<td>在<code>pos</code>位置插入<code>n</code>个<code>elem</code>元素，无返回值</td>\n</tr>\n<tr>\n<td><code>insert(pos, begin, end);</code></td>\n<td>在<code>pos</code>位置插入<code>[begin, end)</code>区间的数据，无返回值</td>\n</tr>\n<tr>\n<td><code>clear();</code></td>\n<td>移除容器中所有的元素</td>\n</tr>\n<tr>\n<td><code>erase(begin, end);</code></td>\n<td>删除<code>[begin, end)</code>区间的数据，返回下一个数据的位置</td>\n</tr>\n<tr>\n<td><code>erase(pos);</code></td>\n<td>删除<code>pos</code>位置的数据，返回下一个数据的位置</td>\n</tr>\n<tr>\n<td><code>remove(elem);</code></td>\n<td>删除容器中所有与<code>elem</code>元素匹配的元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;29 14:54\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; l1;\n\n    &#x2F;&#x2F; push_back()\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        l1.push_back(i);\n    &#125;\n    printList(l1);\n\n    &#x2F;&#x2F; push_front()\n    for (int i &#x3D; 1; i &lt;5; ++i)\n    &#123;\n        l1.push_front(1);\n    &#125;\n    printList(l1);\n\n    &#x2F;&#x2F; pop_back()\n    l1.pop_back();\n    printList(l1);\n\n    &#x2F;&#x2F; pop_front()\n    l1.pop_front();\n    printList(l1);\n\n    &#x2F;&#x2F; insert(pos, elem)\n    l1.insert(l1.begin(), 0);\n    printList(l1);\n\n    &#x2F;&#x2F; insert(pos, n, elem)\n    l1.insert(l1.end(), 3, 5);\n    printList(l1);\n\n    &#x2F;&#x2F; insert(pos, begin, end);\n    list&lt;int&gt; l2(3, 9);\n    l1.insert(l1.end(), l2.begin(), l2.end());\n    printList(l1);\n\n    &#x2F;&#x2F; erase(pos)\n    l1.erase(++l1.begin());\n    printList(l1);\n\n    &#x2F;&#x2F; remove(elem)\n    l1.remove(5);\n    printList(l1);\n\n    &#x2F;&#x2F; clear()\n    l1.clear();\n    l1.push_front(9);\n    printList(l1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-7-6-list数据存取\"><a href=\"#3-7-6-list数据存取\" class=\"headerlink\" title=\"3.7.6 list数据存取\"></a>3.7.6 list数据存取</h5><ul>\n<li><p>功能描述：对<code>list</code>容器数据进行存取</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>front();</code></td>\n<td>返回第一个元素</td>\n</tr>\n<tr>\n<td><code>back();</code></td>\n<td>返回最后一个元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>补充：<code>list&lt;int&gt; l1;</code></p>\n<ul>\n<li><code>l1[0];</code></li>\n<li><code>l1.at(0);</code></li>\n<li>原因：<code>list</code>容器本质是<code>链表</code>，空间不连续，无法使用数组下标的方式获得数值，<code>迭代器</code>也不支持随机访问</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;29 15:33\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; l1;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        l1.push_back(i);\n    &#125;\n    printList(l1);\n\n    cout &lt;&lt; &quot;l1 first&gt;&gt; &quot; &lt;&lt; l1.front() &lt;&lt; endl;\n    cout &lt;&lt; &quot;l1 back&gt;&gt; &quot; &lt;&lt; l1.back() &lt;&lt; endl;\n\n    &#x2F;&#x2F; 双向访问\n    list&lt;int&gt;::iterator it1 &#x3D; ++l1.begin();\n    list&lt;int&gt;::iterator it2 &#x3D; --l1.end();\n    l1.erase(it1, it2);\n    printList(l1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-7-7-list容器排序\"><a href=\"#3-7-7-list容器排序\" class=\"headerlink\" title=\"3.7.7 list容器排序\"></a>3.7.7 list容器排序</h5><ul>\n<li><p>功能描述：将容器中的元素反转，以及元素排序</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>reverse();</code></td>\n<td>反转链表</td>\n</tr>\n<tr>\n<td><code>sort();</code></td>\n<td>链表排序</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;29 15:54\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nbool upSort(int &amp;list1, int &amp;list2)\n&#123;\n    return list1 &gt; list2;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; list1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        list1.push_back(i);\n    &#125;\n    printList(list1);\n\n    &#x2F;&#x2F; reverse()\n    list1.reverse();\n    printList(list1);\n\n    &#x2F;&#x2F; sort() -- 默认从小到大\n    list1.sort();\n    printList(list1);\n\n    &#x2F;&#x2F; sort() -- 改为从大到小\n    list1.sort(upSort);\n    printList(list1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-8-案例-自定义数据排序\"><a href=\"#3-8-案例-自定义数据排序\" class=\"headerlink\" title=\"3.8 案例-自定义数据排序\"></a>3.8 案例-自定义数据排序</h4><ul>\n<li><p>案例描述：将<code>Person</code>自定义数据类型进行排序，<code>Person</code>中属性有：姓名，年龄，身高</p>\n</li>\n<li><p>排序规则：按照年龄进行升序<code>(年龄小的放在前面)</code>，如果年龄相同，按照身高进行降序<code>(身高低的放在前面)</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;29 16:15\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n    int height;\n\n    Person(const string &amp;name, int age, int height)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n        this-&gt;height &#x3D; height;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; Debug\nvoid printPersonList(const list&lt;Person&gt; &amp;other)\n&#123;\n    for (list&lt;Person&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot; Height:&quot; &lt;&lt; it-&gt;height &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nbool sortRule(Person &amp;person1, Person &amp;person2)\n&#123;\n    if (person1.age &#x3D;&#x3D; person2.age)\n    &#123;\n        return person1.height &lt; person2.height;\n    &#125;\n    else\n    &#123;\n        return person1.age &lt; person2.age;\n    &#125;\n&#125;\n\nlist&lt;Person&gt; createPersonList()\n&#123;\n    list&lt;Person&gt; l1;\n\n    Person person1(&quot;QQ&quot;, 10, 160);\n    Person person2(&quot;WW&quot;, 20, 150);\n    Person person3(&quot;EE&quot;, 20, 170);\n    Person person4(&quot;RR&quot;, 70, 175);\n    Person person5(&quot;TT&quot;, 30, 180);\n\n    l1.push_back(person1);\n    l1.push_back(person2);\n    l1.push_back(person3);\n    l1.push_back(person4);\n    l1.push_back(person5);\n\n    printPersonList(l1);\n\n    return l1;\n&#125;\n\nvoid upSort(list&lt;Person&gt; &amp;other)\n&#123;\n    cout &lt;&lt; &quot;UpSort&gt;&gt; By Age And Height&quot; &lt;&lt; endl;\n    other.sort(sortRule);\n    printPersonList(other);\n&#125;\n\nint main()\n&#123;\n    list&lt;Person&gt; l1 &#x3D; createPersonList();\n    upSort(l1);\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-9-set-x2F-multiset容器\"><a href=\"#3-9-set-x2F-multiset容器\" class=\"headerlink\" title=\"3.9 set&#x2F;multiset容器\"></a>3.9 set&#x2F;multiset容器</h4><h5 id=\"3-9-1-set基本概念\"><a href=\"#3-9-1-set基本概念\" class=\"headerlink\" title=\"3.9.1 set基本概念\"></a>3.9.1 set基本概念</h5><ul>\n<li>简介：所有元素被插入时，容器都会进行一次自动排序</li>\n<li>本质：<code>set/multiset</code>属于<code>关联容器</code>，底层结构是<code>二叉树</code>实现</li>\n<li><code>set</code>和<code>multiset</code>的区别：<ul>\n<li><code>set</code>不允许容器中有重复的元素</li>\n<li><code>multiset</code>允许容器中有重复的元素</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-9-2-set构造赋值\"><a href=\"#3-9-2-set构造赋值\" class=\"headerlink\" title=\"3.9.2 set构造赋值\"></a>3.9.2 set构造赋值</h5><ul>\n<li><p>功能描述：创建<code>set</code>容器并赋值</p>\n<table>\n<thead>\n<tr>\n<th>构造</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>set&lt;T&gt; st;</code></td>\n<td>默认构造函数</td>\n</tr>\n<tr>\n<td><code>set(const set &amp;st);</code></td>\n<td>拷贝构造函数</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>赋值</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>set &amp;operator=(const set &amp;st);</code></td>\n<td>重载等号操作符</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 14:49\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printSet(const set&lt;int&gt; &amp;st)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; st.begin(); it !&#x3D; st.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; st1;\n    &#x2F;&#x2F; set 只能用 insert插入数据，且不插入重复数据\n    &#x2F;&#x2F; set 会自动排序插入的数据\n    st1.insert(1);\n    st1.insert(1);\n    st1.insert(1);\n    st1.insert(4);\n    st1.insert(3);\n    st1.insert(2);\n    printSet(st1);\n\n    &#x2F;&#x2F; 默认构造\n    set&lt;int&gt; st2(st1);\n    printSet(st2);\n\n    &#x2F;&#x2F; 赋值拷贝构造\n    set&lt;int&gt; st3 &#x3D; st1;\n    printSet(st3);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>总结：<code>set</code> 只能用 <code>insert</code>插入数据，且不插入重复数据</p>\n</li>\n</ul>\n<h5 id=\"3-9-3-set大小交换\"><a href=\"#3-9-3-set大小交换\" class=\"headerlink\" title=\"3.9.3 set大小交换\"></a>3.9.3 set大小交换</h5><ul>\n<li><p>功能描述：统计<code>set</code>容器大小，以及交换<code>set</code>容器</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>size();</code></td>\n<td>返回容器中元素个数</td>\n</tr>\n<tr>\n<td><code>empty();</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>swap(st);</code></td>\n<td>交换两个容器的元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 15:00\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printSet(const set&lt;int&gt; &amp;st)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; st.begin(); it !&#x3D; st.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; st1;\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        st1.insert(i);\n    &#125;\n\n    if (st1.empty())\n    &#123;\n        cout &lt;&lt; &quot;Set1 Is Empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;\n        printSet(st1);\n        cout &lt;&lt; &quot;Set1 Size&gt;&gt;&quot; &lt;&lt; st1.size() &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid demo2()\n&#123;\n    set&lt;int&gt; st1;\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        st1.insert(i);\n    &#125;\n\n    set&lt;int&gt; st2;\n    for (int i &#x3D; 9; i &gt;&#x3D; 5 ; --i)\n    &#123;\n        st2.insert(i);\n    &#125;\n\n    cout &lt;&lt; &quot;Swap Before&gt;&gt;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;\n    printSet(st1);\n    cout &lt;&lt; &quot;Set2&gt;&gt;&quot;;\n    printSet(st2);\n\n    cout &lt;&lt; &quot;Swap Last&gt;&gt;&quot; &lt;&lt; endl;\n    st1.swap(st2);\n    cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;\n    printSet(st1);\n    cout &lt;&lt; &quot;Set2&gt;&gt;&quot;;\n    printSet(st2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-9-4-set插入删除\"><a href=\"#3-9-4-set插入删除\" class=\"headerlink\" title=\"3.9.4 set插入删除\"></a>3.9.4 set插入删除</h5><ul>\n<li><p>功能描述：<code>set</code>容器进行插入和删除数据</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>insert(elem);</code></td>\n<td>在容器中插入元素</td>\n</tr>\n<tr>\n<td><code>clear();</code></td>\n<td>清除所有元素</td>\n</tr>\n<tr>\n<td><code>erase(pos);</code></td>\n<td>删除迭代器<code>pos</code>所指的元素，返回下一个元素的迭代器</td>\n</tr>\n<tr>\n<td><code>erase(begin, end);</code></td>\n<td>删除<code>[begin, end)</code>区间内的元素，返回下一个元素的迭代器</td>\n</tr>\n<tr>\n<td><code>erase(elem);</code></td>\n<td>删除容器中的所有<code>elem</code>元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 15:14\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printSet(const set&lt;int&gt; &amp;st)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; st.begin(); it !&#x3D; st.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; st1;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        st1.insert(i);\n    &#125;\n    printSet(st1);\n\n    &#x2F;&#x2F; erase(pos)\n    st1.erase(st1.begin());\n    printSet(st1);\n\n    &#x2F;&#x2F; erase(elem)\n    st1.erase(9);\n    printSet(st1);\n\n    &#x2F;&#x2F; erase(begin, end);\n    st1.erase(++st1.begin(), --st1.end());\n    printSet(st1);\n\n    &#x2F;&#x2F; clear()\n    st1.clear();\n    st1.insert(0);\n    printSet(st1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-9-5-set查找统计\"><a href=\"#3-9-5-set查找统计\" class=\"headerlink\" title=\"3.9.5 set查找统计\"></a>3.9.5 set查找统计</h5><ul>\n<li><p>功能描述：对容器内的元素进行查找和统计</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>find(key);</code></td>\n<td>查找<code>key</code>是否存在，存在则返回该元素的迭代器，不存在则返回<code>set.end();</code></td>\n</tr>\n<tr>\n<td><code>count(key);</code></td>\n<td>统计<code>key</code>的个数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 15:25\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printSet(const set&lt;int&gt; &amp;st)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; st.begin(); it !&#x3D; st.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; st1;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        st1.insert(i);\n    &#125;\n    printSet(st1);\n\n    &#x2F;&#x2F; find(key)\n    set&lt;int&gt;::const_iterator it &#x3D; st1.find(3);\n    if (it !&#x3D; st1.end())\n    &#123;\n        cout &lt;&lt; &quot;Set1 Find&gt;&gt;&quot; &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Set1 Not Find&quot; &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; count(key)\n    set&lt;int&gt; st2;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        st2.insert(0);\n    &#125;\n    printSet(st2);\n    cout &lt;&lt; &quot;Set2 Count 0&gt;&gt;&quot; &lt;&lt; st2.count(0) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-9-6-set-x2F-multiset区别\"><a href=\"#3-9-6-set-x2F-multiset区别\" class=\"headerlink\" title=\"3.9.6 set&#x2F;multiset区别\"></a>3.9.6 set&#x2F;multiset区别</h5><ul>\n<li><p>区别：</p>\n<ol>\n<li><code>set</code>不可以插入重复的元素，<code>multiset</code>可以</li>\n<li><code>set</code>插入数据同时返回插入结果，表示插入成功</li>\n<li><code>multiset</code>不会检查插入数据，所以可以重复插入</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 15:58\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printMultiSet(const multiset&lt;int&gt; &amp;multiset1)\n&#123;\n    for (multiset&lt;int&gt;::const_iterator it &#x3D; multiset1.begin(); it !&#x3D; multiset1.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; set1;\n    pair&lt;set&lt;int&gt;::iterator, bool&gt; pairResult;\n    pairResult &#x3D; set1.insert(1);\n    cout &lt;&lt; &quot;First&gt;&gt; &quot; &lt;&lt; endl;\n    if (pairResult.second)\n    &#123;\n        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Succeed&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Error&quot; &lt;&lt; endl;\n    &#125;\n\n    pairResult &#x3D; set1.insert(1);\n    cout &lt;&lt; &quot;Second&gt;&gt; &quot; &lt;&lt; endl;\n    if (pairResult.second)\n    &#123;\n        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Succeed&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Error&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid demo2()\n&#123;\n    multiset&lt;int&gt; multiset1;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        multiset1.insert(9);\n    &#125;\n    printMultiSet(multiset1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-9-7-pair对组创建\"><a href=\"#3-9-7-pair对组创建\" class=\"headerlink\" title=\"3.9.7 pair对组创建\"></a>3.9.7 pair对组创建</h5><ul>\n<li><p>功能描述：成对出现的数据组，利用对组可以返回两个数据</p>\n</li>\n<li><p>创建方式：</p>\n<ol>\n<li><code>pair&lt;type1, type2&gt; p(value1, value2);</code></li>\n<li><code>pair&lt;type1, type2&gt; p = make_pair(value1, value2);</code></li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 16:18\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printPair(const pair&lt;string, int&gt; &amp;other)\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; other.first &lt;&lt; &quot; Age: &quot; &lt;&lt; other.second &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    pair&lt;string, int&gt; pair1(&quot;FF&quot;, 22);\n    printPair(pair1);\n\n    pair&lt;string, int&gt; pair2 &#x3D; make_pair(&quot;QQ&quot;, 20);\n    printPair(pair2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-9-8-set容器排序\"><a href=\"#3-9-8-set容器排序\" class=\"headerlink\" title=\"3.9.8 set容器排序\"></a>3.9.8 set容器排序</h5><ul>\n<li><p>默认排序：<code>set</code>容器<code>默认</code>排序是<code>从小到大</code></p>\n</li>\n<li><p>排序目标：掌握自定义排序规则</p>\n</li>\n<li><p>使用方法：利用<code>仿函数</code>，改变排序规则</p>\n</li>\n<li><p>代码示例一：<code>set</code>存放内置数据类型，从大到小排序</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 16:30\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nclass DownSort\n&#123;\npublic:\n    bool operator()(int value1, int value2)\n    &#123;\n        return value1 &gt; value2;\n    &#125;\n&#125;;\n\nvoid printSet(const set&lt;int&gt; &amp;other)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printSet(const set&lt;int, DownSort&gt; &amp;other)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; set1;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        set1.insert(i);\n    &#125;\n    printSet(set1);\n\n    set&lt;int, DownSort&gt; set2;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        set2.insert(i);\n    &#125;\n    printSet(set2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>代码示例二：自定义数据类型，从大到小排序</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 16:42\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(string name, int age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nclass DownSort\n&#123;\npublic:\n    bool operator()(const Person &amp;p1, const Person &amp;p2)\n    &#123;\n        return p1.age &gt; p2.age;\n    &#125;\n&#125;;\n\nvoid printSet(const set&lt;Person, DownSort&gt; &amp;other)\n&#123;\n    for (set&lt;Person, DownSort&gt;::iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; Age: &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    Person p1(&quot;QQ&quot;, 10);\n    Person p2(&quot;WW&quot;, 40);\n    Person p3(&quot;EE&quot;, 20);\n    Person p4(&quot;RR&quot;, 30);\n\n    set&lt;Person, DownSort&gt; set1;\n    set1.insert(p1);\n    set1.insert(p2);\n    set1.insert(p3);\n    set1.insert(p4);\n\n    printSet(set1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-10-map-x2F-multimap容器\"><a href=\"#3-10-map-x2F-multimap容器\" class=\"headerlink\" title=\"3.10 map&#x2F;multimap容器\"></a>3.10 map&#x2F;multimap容器</h4><h5 id=\"3-10-1-map基本概念\"><a href=\"#3-10-1-map基本概念\" class=\"headerlink\" title=\"3.10.1 map基本概念\"></a>3.10.1 map基本概念</h5><ul>\n<li>简介：<ul>\n<li><code>map</code>中所有的元素都是<code>pair</code></li>\n<li><code>pair</code>中第一个元素为<code>key(键值)</code>，起到索引作用，第二元素为<code>value(实值)</code></li>\n<li>所有元素都会根据元素的键值自动排序</li>\n</ul>\n</li>\n<li>本质：<ul>\n<li><code>map/multimap</code>属于<code>关联式容器</code>，底层结构是用<code>二叉树</code>实现</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>可以根据<code>key</code>值快速找到<code>value</code>值</li>\n</ul>\n</li>\n<li><code>map/multimap</code>的区别：<ul>\n<li><code>map</code>不允许有重复的元素</li>\n<li><code>multimap</code>允许重复的元素</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-10-2-map构造赋值\"><a href=\"#3-10-2-map构造赋值\" class=\"headerlink\" title=\"3.10.2 map构造赋值\"></a>3.10.2 map构造赋值</h5><ul>\n<li><p>功能描述：对map容器进行构造和赋值操作</p>\n<table>\n<thead>\n<tr>\n<th>构造</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>map&lt;T1, T2&gt; mp;</code></td>\n<td><code>map</code>默认构造函数</td>\n</tr>\n<tr>\n<td><code>map(const map &amp;mp);</code></td>\n<td>拷贝构造函数</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>赋值</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>map &amp;operator=(const map &amp;mp);</code></td>\n<td>重载等号操作符</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;31 16:34\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid printMap(const map&lt;int, string&gt; &amp;other)\n&#123;\n    for (map&lt;int, string&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;ID: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Name: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, string&gt; map1;\n\n    map1.insert(pair&lt;int, string&gt;(1, &quot;QQ&quot;));\n    map1.insert(pair&lt;int, string&gt;(4, &quot;WW&quot;));\n    map1.insert(pair&lt;int, string&gt;(2, &quot;EE&quot;));\n    map1.insert(pair&lt;int, string&gt;(5, &quot;RR&quot;));\n    map1.insert(pair&lt;int, string&gt;(3, &quot;TT&quot;));\n\n    printMap(map1);\n\n    &#x2F;&#x2F; 拷贝构造\n    map&lt;int, string&gt; map2(map1);\n    printMap(map2);\n\n    &#x2F;&#x2F; 赋值\n    map&lt;int, string&gt; map3 &#x3D; map1;\n    printMap(map3);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-10-3-map大小交换\"><a href=\"#3-10-3-map大小交换\" class=\"headerlink\" title=\"3.10.3 map大小交换\"></a>3.10.3 map大小交换</h5><ul>\n<li><p>功能描述：统计<code>map</code>容器大小以及交换<code>map</code>容器</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>size();</code></td>\n<td>返回容器中的元素的数目</td>\n</tr>\n<tr>\n<td><code>empty();</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>swap(st);</code></td>\n<td>交换两个集合容器</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 15:12\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid printMap(const map&lt;int, int&gt; &amp;other)\n&#123;\n    for (map&lt;int, int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, int&gt; map1;\n    map1.insert(pair&lt;int, int&gt;(1, 10));\n    map1.insert(pair&lt;int, int&gt;(2, 20));\n    map1.insert(pair&lt;int, int&gt;(3, 30));\n\n    if (map1.empty())\n    &#123;\n        cout &lt;&lt; &quot;Map1 Is Empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Map1 Size &quot; &lt;&lt; map1.size() &lt;&lt; endl;\n    &#125;\n\n    map&lt;int, int&gt; map2;\n    map2.insert(pair&lt;int, int&gt;(4, 40));\n    map2.insert(pair&lt;int, int&gt;(5, 50));\n    map2.insert(pair&lt;int, int&gt;(6, 60));\n\n    map1.swap(map2);\n\n    printMap(map1);\n    printMap(map2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-10-4-map插入删除\"><a href=\"#3-10-4-map插入删除\" class=\"headerlink\" title=\"3.10.4 map插入删除\"></a>3.10.4 map插入删除</h5><ul>\n<li><p>功能描述：<code>map</code>容器进行插入和删除操作</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>insert(pair&lt;type1, type2&gt;(key, value));</code></td>\n<td>在容器中插入元素</td>\n</tr>\n<tr>\n<td><code>clear();</code></td>\n<td>清空容器</td>\n</tr>\n<tr>\n<td><code>erase(pos);</code></td>\n<td>删除<code>pos</code>迭代器所指位置的元素，返回下一个元素的迭代器</td>\n</tr>\n<tr>\n<td><code>erase(begin, end);</code></td>\n<td>删除<code>[begin, end]</code>之间的元素，返回下一个元素的迭代器</td>\n</tr>\n<tr>\n<td><code>erase(key);</code></td>\n<td>删除<code>key</code>指定索引位置的元素</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 15:31\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid printMap(const map&lt;int, int&gt; &amp;other)\n&#123;\n    for (map&lt;int, int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, int&gt; map1;\n    map1.insert(pair&lt;int, int&gt;(1, 10));\n    map1.insert(make_pair(2, 20));\n    map1.insert(map&lt;int, int&gt;::value_type(3, 30));\n\n    &#x2F;&#x2F; 不建议使用该方法插入，但可以通过这个方法利用 key 访问 value\n    map1[4] &#x3D; 40;\n\n    map1.insert(pair&lt;int, int&gt;(5, 50));\n    map1.insert(pair&lt;int, int&gt;(6, 60));\n    map1.insert(pair&lt;int, int&gt;(7, 70));\n\n    &#x2F;&#x2F; map[5]在容器中不存在，所以默认直接在容器中添加了一个，默认value为0\n    cout &lt;&lt; map1[8] &lt;&lt; endl;\n\n    printMap(map1);\n\n    map1.erase(map1.begin());\n    printMap(map1);\n\n    map1.erase(8);\n    printMap(map1);\n\n    map1.erase(++map1.begin(), --map1.end());\n    printMap(map1);\n\n    map1.clear();\n    printMap(map1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-10-5-map查找统计\"><a href=\"#3-10-5-map查找统计\" class=\"headerlink\" title=\"3.10.5 map查找统计\"></a>3.10.5 map查找统计</h5><ul>\n<li><p>功能描述：对<code>map</code>容器进行查找数据以及数据统计</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>find(key);</code></td>\n<td>查找<code>key</code>是否存在，若存在返回<code>key</code>键的元素迭代器；不存在，返回<code>set.end();</code></td>\n</tr>\n<tr>\n<td><code>count(key);</code></td>\n<td>统计<code>key</code>的元素的个数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 16:34\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid printMap(const map&lt;int, int&gt; &amp;other)\n&#123;\n    for (map&lt;int, int&gt;::const_iterator it &#x3D; other.cbegin(); it !&#x3D; other.cend(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, int&gt; map1;\n    map1.insert(pair&lt;int, int&gt;(1, 10));\n    map1.insert(pair&lt;int, int&gt;(2, 20));\n    map1.insert(pair&lt;int, int&gt;(3, 30));\n\n    map&lt;int, int&gt;::const_iterator itPos &#x3D; map1.find(3);\n\n    &#x2F;&#x2F; map.end() 返回的是迭代器所指位置的 “下一个”迭代器的位置\n    if (itPos !&#x3D; map1.cend())\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; itPos-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; itPos-&gt;second &lt;&lt; endl;\n        cout &lt;&lt; &quot;End Key: &quot; &lt;&lt; map1.cend()-&gt;first &lt;&lt; &quot; End Value: &quot; &lt;&lt; map1.cend()-&gt;second &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Can Find Key&quot; &lt;&lt; endl;\n    &#125;\n\n    map1.insert(pair&lt;int, int&gt;(3, 90));\n    int count &#x3D; map1.count(3);\n    cout &lt;&lt; &quot;End Key: &quot; &lt;&lt; map1.cend()-&gt;first &lt;&lt; &quot; End Value: &quot; &lt;&lt; map1.cend()-&gt;second &lt;&lt; endl;\n    cout &lt;&lt; count &lt;&lt; endl;\n\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-10-6-map容器排序\"><a href=\"#3-10-6-map容器排序\" class=\"headerlink\" title=\"3.10.6 map容器排序\"></a>3.10.6 map容器排序</h5><ul>\n<li><p>目标：</p>\n<ol>\n<li><code>map</code>容器默认排序规则，按照<code>key</code>值进行，从小到大的排序</li>\n<li>掌握自定义排序规则</li>\n</ol>\n</li>\n<li><p>主要技术点：利用仿函数，改变排序规则</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 18:08\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nclass DownSort\n&#123;\npublic:\n    bool operator()(int value1, int value2)\n    &#123;\n        return value1 &gt; value2;\n    &#125;\n&#125;;\n\nvoid printMap(const map&lt;int, int, DownSort&gt; &amp;other)\n&#123;\n    for (map&lt;int, int&gt;::const_iterator it &#x3D; other.cbegin(); it !&#x3D; other.cend(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, int, DownSort&gt; map1;\n    map1.insert(pair&lt;int, int&gt;(1, 10));\n    map1.insert(pair&lt;int, int&gt;(2, 20));\n    map1.insert(pair&lt;int, int&gt;(3, 30));\n    map1.insert(pair&lt;int, int&gt;(4, 40));\n    map1.insert(pair&lt;int, int&gt;(5, 50));\n\n    printMap(map1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-11-案例-员工分组\"><a href=\"#3-11-案例-员工分组\" class=\"headerlink\" title=\"3.11 案例-员工分组\"></a>3.11 案例-员工分组</h4><h5 id=\"3-11-1-案例描述\"><a href=\"#3-11-1-案例描述\" class=\"headerlink\" title=\"3.11.1 案例描述\"></a>3.11.1 案例描述</h5><ul>\n<li>10名员工（ABCDEFGHIJ），需要分配部门</li>\n<li>员工信息：姓名，工资</li>\n<li>部门：策划，美术，研发</li>\n<li>随机给10名员工分配工资和部门</li>\n<li>通过<code>multimap</code>进行信息插入：<code>key</code>部门编号，<code>value</code>员工</li>\n<li>分部门显示员工信息</li>\n</ul>\n<h5 id=\"3-11-2-实现步骤\"><a href=\"#3-11-2-实现步骤\" class=\"headerlink\" title=\"3.11.2 实现步骤\"></a>3.11.2 实现步骤</h5><ol>\n<li>创建10个员工对象，存入<code>vector</code>容器中</li>\n<li>遍历<code>vector</code>，取出每个员工，进行随机分组</li>\n<li>分组后，将<code>key</code>部门编号，<code>value</code>员工，存放到<code>multimap</code></li>\n<li>分部门显示员工信息</li>\n</ol>\n<h5 id=\"3-11-3-案例代码\"><a href=\"#3-11-3-案例代码\" class=\"headerlink\" title=\"3.11.3 案例代码\"></a>3.11.3 案例代码</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 19:05\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\n#define PLAN 0\n#define ART 1\n#define RD 2\n\nclass Staff\n&#123;\npublic:\n    string staff_Name;\n    int staff_Salary;\n&#125;;\n\nvoid printVector(const vector&lt;Staff&gt; &amp;other)\n&#123;\n    for (vector&lt;Staff&gt;::const_iterator it &#x3D; other.cbegin(); it !&#x3D; other.cend(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; it-&gt;staff_Name &lt;&lt; &quot; Salary: &quot; &lt;&lt; it-&gt;staff_Salary &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid creatStaff(vector&lt;Staff&gt; &amp;v_Staff)\n&#123;\n    string staffNameSeed &#x3D; &quot;ABCDEFGHIJ&quot;;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        Staff staff;\n        staff.staff_Name &#x3D; &quot;Staff_&quot;;\n        staff.staff_Name +&#x3D; staffNameSeed[i];\n        staff.staff_Salary &#x3D; rand() % 10000 + 10000;\n\n        v_Staff.push_back(staff);\n    &#125;\n&#125;\n\nvoid setStaffGroup(vector&lt;Staff&gt; &amp;v_Staff, multimap&lt;int, Staff&gt; &amp;map_Depart)\n&#123;\n    for (vector&lt;Staff&gt;::iterator it &#x3D; v_Staff.begin(); it !&#x3D; v_Staff.end(); ++it)\n    &#123;\n        int depart_ID &#x3D; rand() % 3;\n        map_Depart.insert(pair&lt;int, Staff&gt;(depart_ID, *it));\n    &#125;\n&#125;\n\nvoid checkStaffByGroup(multimap&lt;int, Staff&gt;::const_iterator &amp;itPos, const multimap&lt;int, Staff&gt; &amp;map_Depart, const int count)\n&#123;\n    for (int index &#x3D; 0; itPos !&#x3D; map_Depart.cend() &amp;&amp; index &lt; count; ++itPos, ++index)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; itPos-&gt;second.staff_Name &lt;&lt; &quot; Salary: &quot; &lt;&lt; itPos-&gt;second.staff_Salary &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid showStaffInfoByGroup(multimap&lt;int, Staff&gt; &amp;map_Depart)\n&#123;\n    int countStaff_PLAN &#x3D; map_Depart.count(PLAN);\n    int countStaff_ART &#x3D; map_Depart.count(ART);\n    int countStaff_RD &#x3D; map_Depart.count(RD);\n\n    multimap&lt;int, Staff&gt;::const_iterator itPos_Plan &#x3D; map_Depart.find(PLAN);\n    multimap&lt;int, Staff&gt;::const_iterator itPos_Art &#x3D; map_Depart.find(ART);\n    multimap&lt;int, Staff&gt;::const_iterator itPos_RD &#x3D; map_Depart.find(RD);\n\n    cout &lt;&lt; &quot;Plan Department&gt;&gt;&quot; &lt;&lt; endl;\n    checkStaffByGroup(itPos_Plan, map_Depart, countStaff_PLAN);\n\n    cout &lt;&lt; &quot;Art Department&gt;&gt;&quot; &lt;&lt; endl;\n    checkStaffByGroup(itPos_Art, map_Depart, countStaff_ART);\n\n    cout &lt;&lt; &quot;R&amp;D Department&gt;&gt;&quot; &lt;&lt; endl;\n    checkStaffByGroup(itPos_RD, map_Depart, countStaff_RD);\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int)time(NULL));\n\n    vector&lt;Staff&gt; v_Staff;\n    creatStaff(v_Staff);\n    printVector(v_Staff);\n\n    multimap&lt;int, Staff&gt; map_Depart;\n    setStaffGroup(v_Staff, map_Depart);\n\n    showStaffInfoByGroup(map_Depart);\n\n    return 0;\n&#125;</code></pre>\n\n\n\n","text":"C++_模板和STL[toc] 记录C++泛型编程和STL的使用和原理 1. 模板-Template1.1 模板概念 作用：建立通用的模具，提高编程的复用性 特点： 模板在实际项目中不可直接使用，它只是一个框架，需根据实际情况进行使用 模板的通用不是万能的 1.2 函数模板 C+...","link":"","photos":[],"count_time":{"symbolsCount":"99k","symbolsTime":"1:30"},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E6%A8%A1%E6%9D%BF%E5%92%8CSTL\"><span class=\"toc-text\">C++_模板和STL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%A8%A1%E6%9D%BF-Template\"><span class=\"toc-text\">1. 模板-Template</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E6%A8%A1%E6%9D%BF%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 模板概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">1.2 函数模板</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">1.2.1 函数模板语法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">1.2.2 函数模板注意事项</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-3-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">1.2.3 函数模板案例</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-4-%E6%99%AE%E9%80%9A%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%87%BD%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.2.4 普通和模板函区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-5-%E6%99%AE%E9%80%9A%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">1.2.5 普通和模板函数调用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7\"><span class=\"toc-text\">1.2.6 模板的局限性</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">1.3 类模板</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-1-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">1.3.1 类模板语法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-2-%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.3.2 类和模板区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">1.3.3 类模板中成员函数创建时机</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-4-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">1.3.4 类模板对象做函数参数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-5-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">1.3.5 类模板与继承</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-6-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">1.3.6 类模板成员函数类外实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-7-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99\"><span class=\"toc-text\">1.3.7 类模板分文件编写</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-8-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">1.3.8 类模板与友元</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-9-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">1.3.9 类模板案例</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-STL%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">2. STL基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-STL%E7%9A%84%E8%AF%9E%E7%94%9F\"><span class=\"toc-text\">2.1 STL的诞生</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.2 STL基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">2.3 STL六大组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-STL%E5%AE%B9%E5%99%A8-%E7%AE%97%E6%B3%95-%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">2.4 STL容器\\算法\\迭代器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E5%AE%B9%E5%99%A8-%E7%AE%97%E6%B3%95-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">2.5 容器\\算法\\迭代器基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-5-1-vector%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.5.1 vector存放内置数据类型</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-5-2-vector%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.5.2 vector存放自定义数据类型</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-5-3-vector%E5%AE%B9%E5%99%A8%E5%B5%8C%E5%A5%97%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">2.5.3 vector容器嵌套容器</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3. STL常用容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-string%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.1 string容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-1-string%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.1.1 string基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-2-string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.1.2 string构造函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-3-string%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.1.3 string赋值操作</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-4-string%E5%AD%97%E7%AC%A6%E6%8B%BC%E6%8E%A5\"><span class=\"toc-text\">3.1.4 string字符拼接</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-5-string%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2\"><span class=\"toc-text\">3.1.5 string查找替换</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-6-string%E5%AD%97%E7%AC%A6%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">3.1.6 string字符比较</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-7-string%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96\"><span class=\"toc-text\">3.1.7 string字符存取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-8-string%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">3.1.8 string插入删除</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-9-string%E8%8E%B7%E5%8F%96%E5%AD%97%E4%B8%B2\"><span class=\"toc-text\">3.1.9 string获取字串</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-vector%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.2 vector容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-1-vector%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.2.1 vector基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-2-vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.2.2 vector构造函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-3-vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.2.3 vector赋值操作</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-4-vector%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">3.2.4 vector容量大小</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-5-vector%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">3.2.5 vector插入删除</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-6-vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\"><span class=\"toc-text\">3.2.6 vector数据存取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-7-vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.2.7 vector互换容器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-8-vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">3.2.8 vector预留空间</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-deque%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.3 deque容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-1-deque%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.3.1 deque基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-2-deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.3.2 deque构造函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-3-deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.3.3 deque赋值操作</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-4-deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.3.4 deque大小操作</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-5-deque%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">3.3.5 deque插入删除</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-6-deque%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\"><span class=\"toc-text\">3.3.6 deque数据存取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-7-deque%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3.3.7 deque容器排序</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E6%A1%88%E4%BE%8B-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86\"><span class=\"toc-text\">3.4 案例-评委打分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-4-1-%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">3.4.1 案例描述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-4-2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">3.4.2 实现步骤</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-4-3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">3.4.3 示例代码</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-stack%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.5 stack容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-5-1-stack%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.5.1 stack基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-5-2-stack%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">3.5.2 stack常用接口</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-6-queue%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.6 queue容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-6-1-queue%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.6.1 queue基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-6-2-queue%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">3.6.2 queue常用接口</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-7-list%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.7 list容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7-1-list%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.7.1 list基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7-2-list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.7.2 list构造函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7-3-list%E8%B5%8B%E5%80%BC%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">3.7.3 list赋值交换</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7-4-list%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.7.4 list大小操作</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7-5-list%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">3.7.5 list插入删除</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7-6-list%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\"><span class=\"toc-text\">3.7.6 list数据存取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7-7-list%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3.7.7 list容器排序</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-8-%E6%A1%88%E4%BE%8B-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3.8 案例-自定义数据排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-9-set-x2F-multiset%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.9 set&#x2F;multiset容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-1-set%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.9.1 set基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-2-set%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">3.9.2 set构造赋值</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-3-set%E5%A4%A7%E5%B0%8F%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">3.9.3 set大小交换</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-4-set%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">3.9.4 set插入删除</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-5-set%E6%9F%A5%E6%89%BE%E7%BB%9F%E8%AE%A1\"><span class=\"toc-text\">3.9.5 set查找统计</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-6-set-x2F-multiset%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3.9.6 set&#x2F;multiset区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-7-pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">3.9.7 pair对组创建</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-8-set%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3.9.8 set容器排序</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-10-map-x2F-multimap%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3.10 map&#x2F;multimap容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-10-1-map%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.10.1 map基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-10-2-map%E6%9E%84%E9%80%A0%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">3.10.2 map构造赋值</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-10-3-map%E5%A4%A7%E5%B0%8F%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">3.10.3 map大小交换</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-10-4-map%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">3.10.4 map插入删除</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-10-5-map%E6%9F%A5%E6%89%BE%E7%BB%9F%E8%AE%A1\"><span class=\"toc-text\">3.10.5 map查找统计</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-10-6-map%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3.10.6 map容器排序</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-11-%E6%A1%88%E4%BE%8B-%E5%91%98%E5%B7%A5%E5%88%86%E7%BB%84\"><span class=\"toc-text\">3.11 案例-员工分组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-11-1-%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">3.11.1 案例描述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-11-2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">3.11.2 实现步骤</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-11-3-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">3.11.3 案例代码</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++_通讯录管理系统","uid":"ece0e381639ba808e0c15b18566061ec","slug":"1_C++_通讯录管理系统_02","date":"2022-10-06T07:28:25.923Z","updated":"2022-11-10T01:31:00.635Z","comments":true,"path":"api/articles/1_C++_通讯录管理系统_02.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (2).webp","text":"C++_通讯录管理系统[toc] 1. 系统需求 添加联系人：向通讯录中添加联系人，联系人信息（姓名，性别，年龄，联系电话，家庭住址），最多记录1000人 显示联系人：显示通讯录中所有联系人信息 删除联系人：按照姓名进行删除指定联系人 查找联系人：按照姓名查找指定联系人信息 修改...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"C++_基础","uid":"c90c4a4848e304bff822a98a4aa17a84","slug":"1_C++_基础_01","date":"2022-10-06T07:28:25.915Z","updated":"2022-11-10T01:30:30.467Z","comments":true,"path":"api/articles/1_C++_基础_01.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (1).webp","text":"C++_基础[toc] 1. 第一阶段1. HelloWorld#include &lt;iostream&gt; using namespace std; void main() &#123; cout &lt;&lt; &quot;hello world&quot; &lt;...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}