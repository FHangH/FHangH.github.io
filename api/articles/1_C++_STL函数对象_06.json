{"title":"C++_STL函数对象","uid":"29cfc82accb2b6a310cfbec39b1d8603","slug":"1_C++_STL函数对象_06","date":"2022-10-06T07:28:25.907Z","updated":"2022-10-07T12:54:09.443Z","comments":true,"path":"api/articles/1_C++_STL函数对象_06.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (6).webp","content":"<h1 id=\"C-STL函数对象\"><a href=\"#C-STL函数对象\" class=\"headerlink\" title=\"C++_STL函数对象\"></a>C++_STL函数对象</h1><h3 id=\"1-函数对象\"><a href=\"#1-函数对象\" class=\"headerlink\" title=\"1. 函数对象\"></a>1. 函数对象</h3><h4 id=\"1-1-函数对象概念\"><a href=\"#1-1-函数对象概念\" class=\"headerlink\" title=\"1.1 函数对象概念\"></a>1.1 函数对象概念</h4><ul>\n<li>概念：<ul>\n<li>重载<code>函数调用操作符</code>的类，其对象常称为<code>函数对象</code></li>\n<li><code>函数对象</code>使用重载的<code>()</code>时，行为类似函数调用，也叫<code>仿函数</code></li>\n</ul>\n</li>\n<li>本质：<ul>\n<li>函数对象(仿函数)是一个类，不是一个函数</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-函数对象使用\"><a href=\"#1-2-函数对象使用\" class=\"headerlink\" title=\"1.2 函数对象使用\"></a>1.2 函数对象使用</h4><ul>\n<li><p>特点：</p>\n<ul>\n<li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li>\n<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>\n<li>函数对象可以作为参数传递</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 15:17\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值\nclass Fh_Add\n&#123;\npublic:\n    int operator()(int value1, int value2)\n    &#123;\n        return value1 + value2;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 函数对象超出普通函数的概念，函数对象可以有自己的状态\nclass Fh_Print\n&#123;\npublic:\n    int transferCount;\n\n    Fh_Print()\n    &#123;\n        this-&gt;transferCount &#x3D; 0;\n    &#125;\n\n    void operator()(const string &amp;printStr)\n    &#123;\n        cout &lt;&lt; printStr &lt;&lt; endl;\n        this-&gt;transferCount++;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    Fh_Add fhAdd;\n    cout &lt;&lt; &quot;Fh_Add&gt;&gt; &quot; &lt;&lt; fhAdd(1, 2) &lt;&lt; endl;\n\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    Fh_Print fhPrint;\n    fhPrint(&quot;Hello World&quot;);\n    fhPrint(&quot;Hello World&quot;);\n    fhPrint(&quot;Hello World&quot;);\n    cout &lt;&lt; &quot;Fh_Print Transfer Count&gt;&gt; &quot; &lt;&lt; fhPrint.transferCount &lt;&lt; endl;\n\n    cout &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 函数对象可以作为参数传递\nvoid doPrint(Fh_Print &amp;fhPrint, const string &amp;printStr)\n&#123;\n    fhPrint(printStr);\n&#125;\n\nvoid demo3()\n&#123;\n    Fh_Print fhPrint;\n    doPrint(fhPrint, &quot;Hello World&quot;);\n\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    demo3();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"2-谓词\"><a href=\"#2-谓词\" class=\"headerlink\" title=\"2. 谓词\"></a>2. 谓词</h3><h4 id=\"2-1-谓词基本概念\"><a href=\"#2-1-谓词基本概念\" class=\"headerlink\" title=\"2.1 谓词基本概念\"></a>2.1 谓词基本概念</h4><ul>\n<li>概念：<ul>\n<li>返回<code>bool</code>类型的仿函数称为<code>谓词</code></li>\n<li>如果<code>operator()</code>接受一个参数，为<code>一元谓词</code></li>\n<li>如果<code>operator()</code>接受二个参数，为<code>二元谓词</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-一元谓词\"><a href=\"#2-2-一元谓词\" class=\"headerlink\" title=\"2.2 一元谓词\"></a>2.2 一元谓词</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 16:09\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass DownSort\n&#123;\npublic:\n    bool operator()(const int &amp;value1, const int &amp;value2)\n    &#123;\n        return value1 &gt; value2;\n    &#125;\n&#125;;\n\nvoid printVector(const vector&lt;int&gt; &amp;other)\n&#123;\n    for (int it : other)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 1; i &lt; 6; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n    printVector(v);\n\n    sort(v.begin(), v.end(), DownSort());\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"3-内建函数对象\"><a href=\"#3-内建函数对象\" class=\"headerlink\" title=\"3. 内建函数对象\"></a>3. 内建函数对象</h3><h4 id=\"3-1-内建函数对象意义\"><a href=\"#3-1-内建函数对象意义\" class=\"headerlink\" title=\"3.1 内建函数对象意义\"></a>3.1 内建函数对象意义</h4><ul>\n<li>概念：<ul>\n<li>STL内建一些函数对象</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>算术仿函数</li>\n<li>关系仿函数</li>\n<li>逻辑仿函数</li>\n</ul>\n</li>\n<li>用法：<ul>\n<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>\n<li>使用内建函数对象，需要引入头文件<code>#include&lt;functional&gt;</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-算术仿函数\"><a href=\"#3-2-算术仿函数\" class=\"headerlink\" title=\"3.2 算术仿函数\"></a>3.2 算术仿函数</h4><ul>\n<li><p>功能描述：</p>\n<ul>\n<li>实现四则运算</li>\n<li>其中<code>negate</code>是<code>一元运算</code>，其它的都是<code>二元运算</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>仿函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>template&lt;class T&gt; T plus&lt;T&gt;</code></td>\n<td>加法仿函数</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; T minus&lt;T&gt;</code></td>\n<td>减法仿函数</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code></td>\n<td>乘法仿函数</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; T divides&lt;T&gt;</code></td>\n<td>除法仿函数</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; T modulus&lt;T&gt;</code></td>\n<td>取模仿函数</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; T negate&lt;T&gt;</code></td>\n<td>取反仿函数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 16:45\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nusing namespace std;\n\nvoid demo1()\n&#123;\n    negate&lt;&gt; negate1;\n    cout &lt;&lt; negate1(10) &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    plus&lt;&gt; plus1;\n    cout &lt;&lt; plus1(10, 20) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-3-关系仿函数\"><a href=\"#3-3-关系仿函数\" class=\"headerlink\" title=\"3.3 关系仿函数\"></a>3.3 关系仿函数</h4><ul>\n<li><p>功能描述：实现关系对比</p>\n<table>\n<thead>\n<tr>\n<th>仿函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code></td>\n<td>等于</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code></td>\n<td>不等于</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; bool greater&lt;T&gt;</code></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; bool less&lt;T&gt;</code></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code></td>\n<td>小于等于</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 16:58\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v)\n&#123;\n    for (int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 1; i &lt; 6; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    printVector(v);\n\n    sort(v.begin(),  v.end(), greater&lt;&gt;());\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-4-逻辑仿函数\"><a href=\"#3-4-逻辑仿函数\" class=\"headerlink\" title=\"3.4 逻辑仿函数\"></a>3.4 逻辑仿函数</h4><ul>\n<li><p>功能描述：实现逻辑运算</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code></td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code></td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code></td>\n<td>逻辑非</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 17:43\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;bool&gt; &amp;v)\n&#123;\n    for (bool it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;bool&gt; v1;\n    for (int i &#x3D; 1; i &lt; 5; ++i)\n    &#123;\n        v1.push_back(rand()%2);\n    &#125;\n\n    printVector(v1);\n\n    vector&lt;bool&gt; v2;\n    v2.resize(v1.size());\n\n    transform(v1.begin(), v1.end(), v2.begin(), logical_not&lt;bool&gt;());\n    printVector(v2);\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int)time(NULL));\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n","text":"C++_STL函数对象1. 函数对象1.1 函数对象概念 概念： 重载函数调用操作符的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质： 函数对象(仿函数)是一个类，不是一个函数 1.2 函数对象使用 特点： 函数对象在使用时，可以像普通函数...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-STL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">C++_STL函数对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1. 函数对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 函数对象概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.2 函数对象使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%B0%93%E8%AF%8D\"><span class=\"toc-text\">2. 谓词</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.1 谓词基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D\"><span class=\"toc-text\">2.2 一元谓词</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3. 内建函数对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">3.1 内建函数对象意义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E7%AE%97%E6%9C%AF%E4%BB%BF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.2 算术仿函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.3 关系仿函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.4 逻辑仿函数</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++_STL算法","uid":"1314ed16965aff00f28615c8023e8a57","slug":"1_C++_STL算法_07","date":"2022-10-06T07:28:25.910Z","updated":"2022-10-07T12:54:13.448Z","comments":true,"path":"api/articles/1_C++_STL算法_07.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (7).webp","text":"C++_STL算法概述： 算法主要是头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt; 组成 &lt;algorithm&gt; 是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等到 &l...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{}}