{"title":"C++_面向对象反汇编补充","uid":"e614b361765c5cfea11849494ca08809","slug":"1_C++_面向对象反汇编补充_08","date":"2022-10-06T07:28:25.917Z","updated":"2022-10-07T13:58:04.499Z","comments":true,"path":"api/articles/1_C++_面向对象反汇编补充_08.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (8).webp","content":"<h1 id=\"C-面向对象反汇编补充\"><a href=\"#C-面向对象反汇编补充\" class=\"headerlink\" title=\"C++_面向对象反汇编补充\"></a>C++_面向对象反汇编补充</h1><h3 id=\"1-类\"><a href=\"#1-类\" class=\"headerlink\" title=\"1. 类\"></a>1. 类</h3><h4 id=\"1-1-类的定义\"><a href=\"#1-1-类的定义\" class=\"headerlink\" title=\"1.1 类的定义\"></a>1.1 类的定义</h4><ul>\n<li>C++中可以使用 <code>struct</code>，<code>class</code>来定义类</li>\n</ul>\n<h4 id=\"1-2-struct和class区别\"><a href=\"#1-2-struct和class区别\" class=\"headerlink\" title=\"1.2 struct和class区别\"></a>1.2 struct和class区别</h4><ul>\n<li><code>struct</code>默认成员权限是<code>public</code></li>\n<li><code>class</code>默认成员权限是<code>private</code></li>\n</ul>\n<h5 id=\"1-2-1-定义和访问\"><a href=\"#1-2-1-定义和访问\" class=\"headerlink\" title=\"1.2.1 定义和访问\"></a>1.2.1 定义和访问</h5><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Person\n&#123;\n    int m_Age;\n    \n    void run()\n    &#123;\n        cout &lt;&lt; &quot;m_Age: &quot; &lt;&lt; m_Age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Person\n&#123;\npublic:    \n    int m_Age;\n    \n    void run()\n    &#123;\n        cout &lt;&lt; &quot;m_Age: &quot; &lt;&lt; m_Age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nPerson person;\n&#x2F;&#x2F; 通过对象访问\nperson.m_Age &#x3D; 20;\nperson.run();\n\n&#x2F;&#x2F; 通过指针访问\nPerson *ptr_Person &#x3D; &amp;person;\nptr_Person -&gt;m_Age &#x3D; 20;\nptr_Person -&gt;run();</code></pre>\n</li>\n<li><p><code>对象person</code> 和 <code>指针ptr_Person</code>的内存都是在函数的栈空间中，自动分配和回收</p>\n</li>\n<li><p><code>对象person</code>只有一个<code>int类型</code>的成员变量，所以是<code>4字节</code></p>\n</li>\n<li><p><code>指针ptr_Person</code>在 <code>32位</code>占用<code>4字节</code>，<code>64位</code>占用<code>8字节</code></p>\n</li>\n</ul>\n<h5 id=\"1-2-2-反汇编查看区别\"><a href=\"#1-2-2-反汇编查看区别\" class=\"headerlink\" title=\"1.2.2 反汇编查看区别\"></a>1.2.2 反汇编查看区别</h5><ul>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Car\n&#123;\npublic:\n    int m_price;\n    \n    void run()\n    &#123;\n        cout &lt;&lt; &quot;Car::run() &quot; &lt;&lt; m_price &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Car car1;\n    car1.m_price &#x3D; 10;\n    car1.run();\n    \n    Car car2;\n    car2.m_price &#x3D; 20;\n    car2.run();\n    \n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; 查看核心部分汇编代码\n\nmov dword ptr[car1], 0Ah &#x2F;&#x2F; 由此可得，对象占用4字节，成员变量占用4字节，所以第一个成员变量的内存地址就是对象的地址\n&#x2F;&#x2F; Car car1;\n&#x2F;&#x2F; car1.m_price &#x3D; 10;\n\nlea ecx, [car1]\ncall 0086141A &#x2F;&#x2F; 此处 call run()\n&#x2F;&#x2F; car1.run();\n    \nmov dword ptr[car2], 14h\n&#x2F;&#x2F; Car car2;\n\nlea ecx, [car2]\ncall 0086141A &#x2F;&#x2F; 此处 call run()\n&#x2F;&#x2F; car2.m_price &#x3D; 20;\n&#x2F;&#x2F; car2.run();\n\n&#x2F;&#x2F; 由上可以等到，两个对象 car1 和 car2 的成员变量是不同的\n&#x2F;&#x2F; 但它们调用的函数的地址是同一个</code></pre>\n</li>\n<li><p>对象内的函数不占用对象的内存大小：</p>\n<ul>\n<li>类中的函数在编译阶段，会将函数的地址存放到单独的一段内存中</li>\n<li>当两个函数完全相同时，会去重，仅保留一个函数地址</li>\n<li>一个类生成的多个对象中，只有成员变量是每个对象各自拥有的，而成员方法则是统一去重存储在<code>方法列表</code>中</li>\n</ul>\n</li>\n<li><p>补充：</p>\n<ul>\n<li>无论函数和变量存在于什么地方，如果没有在其它地方使用或调用</li>\n<li>该函数和变量，在编译阶段会被优化，也就是根本不存在</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-3-对象的内存布局\"><a href=\"#1-3-对象的内存布局\" class=\"headerlink\" title=\"1.3 对象的内存布局\"></a>1.3 对象的内存布局</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Person\n&#123;\n  int m_age;\n  int m_id;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    person.m_age &#x3D; 10;\n    person.m_id &#x3D; 100;\n    \n    cout &lt;&lt; &quot;&amp;person &#x3D; &quot; &lt;&lt; &amp;person &lt;&lt; endl;\n    cout &lt;&lt; &quot;&amp;person.m_age &#x3D; &quot; &lt;&lt; &amp;person.m_age &lt;&lt; endl;\n    cout &lt;&lt; &quot;&amp;person.m_id &#x3D; &quot; &lt;&lt; &amp;person.m_id &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>运行结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">&amp;person &#x3D; 0x7bfe18\n&amp;person.m_age &#x3D; 0x7bfe18   \n&amp;person.m_id &#x3D; 0x7bfe1c  </code></pre></li>\n</ul>\n<h3 id=\"2-this\"><a href=\"#2-this\" class=\"headerlink\" title=\"2. this\"></a>2. this</h3><ul>\n<li><p>隐式参数</p>\n</li>\n<li><p>存储着函数调用者的地址</p>\n</li>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Person\n&#123;\n  int m_age;\n  \n  void run()\n  &#123;\n    &#x2F;&#x2F; 编译器会隐式传参\n    &#x2F;&#x2F; this &#x3D; &amp;person1\n      this-&gt;m_age &#x3D; 3;\n  &#125;\n&#125;;\n\nint main()\n&#123;\n    Person person1;\n    person1.m_age &#x3D; 10;\n    person1.run();\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编分析：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; ebp-8 是 this 的地址\n&#x2F;&#x2F; eax 是 person1 的地址\n\n&#x2F;&#x2F; Person person1;\n&#x2F;&#x2F; person1.m_age &#x3D; 10;\nmov dword ptr [ebp-0Ch], 0Ah\n\n&#x2F;&#x2F; person.run();\nlea ecx, [ebp-0Ch]\ncall 00181366\n\tmov dword ptr [ebp-8], ecx\n\t\n\t&#x2F;&#x2F; this-&gt;m_age &#x3D; 3;\n\tmov eax. dword ptr [ebp-8]\n\tmov dword ptr [eax], 3</code></pre>\n\n\n\n\n</li>\n<li><p>代码示例2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Person\n&#123;\n  int m_age;\n  int m_id;\n  \n  void run()&#123;&#125;\n&#125;;\n\nint main()\n&#123;\n    Person person1;\n    person1.m_age &#x3D; 10;\n    person1.m_id &#x3D; 20;\n    person1.run();\n\t\n    Person *person2 &#x3D; &amp;person1;\n    person2-&gt;m_age &#x3D; 10;\n    person2-&gt;m_id &#x3D; 10;\n    person2-&gt;run();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编分析：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; Person person1;\n&#x2F;&#x2F; person1.m_age &#x3D; 10;\nmov dword ptr [ebp-14h], 0Ah\n\n&#x2F;&#x2F; person1.m_id &#x3D; 20;\nmov dword ptr [ebp-10h], 14h\n\n&#x2F;&#x2F; person1.run();\nlea ecx, [ebp-14h]\ncall 00FA141F\n\t\n&#x2F;&#x2F; Person *person2 &#x3D; &amp;person1;\nlea eax, [ebp-14h] &#x2F;&#x2F; [ebp-14h]是person1的地址\nmov dword ptr [ebp-20h], eax &#x2F;&#x2F; [ebp-20h]是指针变量person2的地址\n\n&#x2F;&#x2F; person2-&gt;m_age &#x3D; 10;\nmov eax, dword ptr [ebp-20h] &#x2F;&#x2F; eax存储的是person1的地址值\nmov dword ptr [eax], 0Ah \n\n&#x2F;&#x2F; person2-&gt;m_id &#x3D; 10;\nmov eax, dword ptr [ebp-20h]\nmov dword ptr [eax+4], 0Ah \n\n&#x2F;&#x2F; person2-&gt;run();\nmov ecx, dword ptr [ebp-20h] &#x2F;&#x2F; 将person1地址隐式传给this\ncall 003B141F</code></pre>\n\n\n</li>\n<li><p>代码示例3：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Person\n&#123;\n  int m_age;\n  int m_id;\n  int m_height;  \n  \n  void run()\n  &#123;\n      cout &lt;&lt; m_age &lt;&lt; &quot;+&quot; &lt;&lt; m_id &lt;&lt; &quot;+&quot; &lt;&lt; m_height &lt;&lt; endl;\n  &#125;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    person.m_age &#x3D; 10;\n    person.m_id &#x3D; 20;\n    person.m_height &#x3D; 30;\n\t\n    Person *p &#x3D; (Person *) &amp;person.m_age;\n    p-&gt;m_age &#x3D; 0;\n    p-&gt;m_id &#x3D; 0;\n    \n    &#x2F;&#x2F; 注意：这里用的 person，不是 p\n    person.run();\n    return 0;\n&#125;\n\n# 打印结果：\n# 10+0+0</code></pre>\n</li>\n<li><p>反汇编分析：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; Person *p &#x3D; (Person *) &amp;person.m_id;\n&#x2F;&#x2F; eax &#x3D;&#x3D; &amp;person.m_id &#x3D;&#x3D; person+4\n\n&#x2F;&#x2F; p-&gt;m_age &#x3D; 0;\nmov eax, dword ptr [p]\nmov dword ptr [eax + 0], 0h\n\n&#x2F;&#x2F; p-&gt;m_id &#x3D; 0;\nmov eax, dword ptr [p]\nmov dword ptr [eax + 4], 0h\n\n&#x2F;&#x2F; 在栈空间中&gt;&gt; &amp;person &#x3D;&#x3D; &amp;person.m_age\n&#x2F;&#x2F; 改程序中 eax 的存储的地址是 &amp;person.m_id &#x3D;&#x3D; &amp;person+4\n&#x2F;&#x2F; 所以&gt;&gt; \n&#x2F;&#x2F; p-&gt;m_age &#x3D; 0; 修改的是 m_id\n&#x2F;&#x2F; p-&gt;m_id &#x3D; 0; 修改的是 m_height</code></pre>\n</li>\n<li><p>思考：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Person *p &#x3D; (Person *) &amp;person.m_age;\np-&gt;m_age &#x3D; 0;\np-&gt;m_id &#x3D; 0;\n\n&#x2F;&#x2F; person 对象的地址传递给 run 的this\nperson.run();\n&#x2F;&#x2F; 改为\n&#x2F;&#x2F; 将指针 p 里存储的地址值传给 run 的this &#x3D;&#x3D; &amp;person.m_id 传递给 this\np-&gt;run();\n\n# 打印结果\n# 40+50+-858993460\n# -858993460 &#x3D;&#x3D; Oxcccccccc</code></pre>\n</li>\n<li><p>补充：</p>\n</li>\n<li><p>上面的程序打印结果：<code>Oxcccccccc</code></p>\n</li>\n<li><p>由来：函数调用是，开辟栈空间，调用结束，用<code>cccccccc</code>来填充内存空间</p>\n</li>\n<li><p>原因：</p>\n<ul>\n<li><code>cc</code>的汇编是<code>int3</code>：断点</li>\n<li><code>int</code>是<code>硬件中断</code></li>\n</ul>\n</li>\n<li><p>作用：防止<code>指针</code>或<code>jump</code>之类的指令，指向错误的内存地址，可能造成系统安全问题，所以用硬件中断指令填充被释放的栈空间</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; p-&gt;run();\n&#x2F;&#x2F; 汇编中有一条指令\nmov eax, 0cccccccch\nrep stos dword ptr es:[edi]</code></pre></li>\n</ul>\n<h3 id=\"3-内存空间的布局\"><a href=\"#3-内存空间的布局\" class=\"headerlink\" title=\"3. 内存空间的布局\"></a>3. 内存空间的布局</h3><ul>\n<li>每个应用都有自己独立的内存空间：<ul>\n<li>代码区(代码段)：用于存放代码</li>\n<li>全局区(数据段)：用于存放全局变量等</li>\n<li>栈空间：<ul>\n<li>每调用一个函数就会给它分配一个连续的栈空间，等函数调用完毕后会自动回收这段栈空间</li>\n<li>自动分配和回收</li>\n</ul>\n</li>\n<li>堆空间：需要主动去申请和释放</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-1-代码区\"><a href=\"#3-1-代码区\" class=\"headerlink\" title=\"3.1 代码区\"></a>3.1 代码区</h4><ul>\n<li>只读</li>\n<li>存放CPU指令(机器码)</li>\n</ul>\n<h4 id=\"3-2-全局区\"><a href=\"#3-2-全局区\" class=\"headerlink\" title=\"3.2 全局区\"></a>3.2 全局区</h4><ul>\n<li>程序结束，全局区的数据才会清空</li>\n</ul>\n<h4 id=\"3-3-堆空间\"><a href=\"#3-3-堆空间\" class=\"headerlink\" title=\"3.3 堆空间\"></a>3.3 堆空间</h4><ul>\n<li>在程序运行过程中，为了能自由控制内存的生命周期，大小，会经常使用堆空间的内存</li>\n</ul>\n<h5 id=\"3-3-1-堆空间申请和释放\"><a href=\"#3-3-1-堆空间申请和释放\" class=\"headerlink\" title=\"3.3.1 堆空间申请和释放\"></a>3.3.1 堆空间申请和释放</h5><ul>\n<li><p>堆空间的申请和释放：(<code>C/C++语言 =&gt; malloc() / free()</code>)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void demo()\n&#123;\n    &#x2F;&#x2F; malloc(4) 申请4字节堆空间，返回 void *，强转成 int *\n    int *p &#x3D; (int *)malloc(4);\n    &#x2F;&#x2F; int * 占用4个字节，所以 10 赋值给4个字节空间\n    *p &#x3D; 10;\n    &#x2F;&#x2F; 释放 p 申请的所有空间\n    free(p);\n    \n    char *p &#x3D; (char *)malloc(4);\n    &#x2F;&#x2F; char * 占用1个字节空间，所以 10 赋值给 p地址的第一个字节，另外3个字节是空的\n    *p &#x3D; 10;\n    *(p + 1) &#x3D; 11;\n    *(p + 2) &#x3D; 12;\n    *(p + 3) &#x3D; 13;\n    &#x2F;&#x2F; 等价于\n    p[0] &#x3D; 10;\n    p[1] &#x3D; 11;\n    p[2] &#x3D; 12;\n    p[3] &#x3D; 13;\n    \n    free(p);\n&#125;</code></pre>\n</li>\n<li><p>分析上面代码的内存分布：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int *p &#x3D; (int *)malloc(4);\n*p &#x3D; 10;\n\n&#x2F;&#x2F; X86 -- 32bit ，int 指针占用 4 字节，64bit 占用 8字节\n&#x2F;&#x2F; 栈空间\n# 地址：0x111\n# 占用：4字节\n# p &#x3D; 0x999\n\n&#x2F;&#x2F; 堆空间\n# 地址：0x999\n# 占用：4字节\n# 值：10</code></pre>\n\n\n\n\n</li>\n<li><p>堆空间的申请和释放：(<code>C++语言-新 =&gt; new / delete</code>)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void demo()\n&#123;\n    int *p &#x3D; new int; &#x2F;&#x2F; 等价于  int *p &#x3D; (int *)malloc(4);\n    *p &#x3D; 10;\n    \n    &#x2F;&#x2F; 释放\n    delete p;\n&#125;</code></pre>\n</li>\n<li><p>(<code>new[] / delete []</code>)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void demo()\n&#123;\n    char *p &#x3D; new char[4]; &#x2F;&#x2F; 等价于  char *p &#x3D; (char *)malloc(4);\n    *p &#x3D; 10;\n    \n    &#x2F;&#x2F; 释放\n    delete p; &#x2F;&#x2F; 错误：此时 只会 释放地址p的第一个字节空间，后面3个字节没有释放\n    delete[] p; &#x2F;&#x2F; 正确：释放 p 申请的所有空间\n&#125;</code></pre>\n\n\n</li>\n<li><p>注意：</p>\n<ul>\n<li>申请堆空间成功后，会返回那一段空间的地址</li>\n<li>申请和释放必须是一一对应的，不然会造成内存泄露</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-3-2-堆空间初始化\"><a href=\"#3-3-2-堆空间初始化\" class=\"headerlink\" title=\"3.3.2 堆空间初始化\"></a>3.3.2 堆空间初始化</h5><ul>\n<li><p>简单示例：(<code>memset == memory set</code>)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int *p1 &#x3D; (int *)malloc(sizeof(int)); &#x2F;&#x2F; *p1 未初始化\n\nint *p2 &#x3D; (int *)malloc(sizeof(int));\nmemset(p2, 0, sizeof(int)); &#x2F;&#x2F; *p2 的每个字节初始化为0</code></pre>\n\n\n</li>\n<li><p>其它初始化方式：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int *p &#x3D; new int; &#x2F;&#x2F; 未初始化\nint *p &#x3D; new int(); &#x2F;&#x2F; 每个字节初始化为0\n&#x2F;&#x2F; mov __memset(0), eax\n\nint *p &#x3D; new int(5); &#x2F;&#x2F; 每个字节初始化为5\n\nint *p &#x3D; new int[3]; &#x2F;&#x2F; 数组三个元素未初始化\nint *p &#x3D; new int[3](); &#x2F;&#x2F; 数组三个元素初始化为0\nint *p &#x3D; new int[3]&#123;&#125;; &#x2F;&#x2F; 数组三个元素初始化为0\nint *p &#x3D; new int[3]&#123;5&#125;; &#x2F;&#x2F; 数组首元素初始化为5，其它元素初始化为0</code></pre></li>\n</ul>\n<h6 id=\"3-3-2-1-memset\"><a href=\"#3-3-2-1-memset\" class=\"headerlink\" title=\"3.3.2.1 memset\"></a>3.3.2.1 memset</h6><ul>\n<li><p>memset 函数将较大的数据结构(<code>对象，数组等等</code>)内存清零的比较快的方式</p>\n</li>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Person person;\nperson.id &#x3D; 1;\nperson.age &#x3D; 2;\nperson.height &#x3D; 3;\n\nmemset(&amp;person, 0, sizeof(person));</code></pre>\n\n\n</li>\n<li><p>代码示例2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Person persons[] &#x3D; &#123;&#123;1, 2, 3&#125;, &#123;1, 2, 3&#125;, &#123;1, 2, 3&#125;&#125;;\nmemset(persons, 0, sizeof(persons));</code></pre></li>\n</ul>\n<h4 id=\"3-4-对象的内存\"><a href=\"#3-4-对象的内存\" class=\"headerlink\" title=\"3.4 对象的内存\"></a>3.4 对象的内存</h4><ul>\n<li><p>对象可以存在于3个地方</p>\n<ol>\n<li>全局区(数据段)：全局变量</li>\n<li>栈空间：函数里面的局部变量</li>\n<li>堆空间：动态申请内存(malloc, new等)</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 全局区\nPerson person;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 栈空间\n    Person person;\n    \n    &#x2F;&#x2F; 堆空间\n    Person *person &#x3D; new Person;\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"4-构造函数\"><a href=\"#4-构造函数\" class=\"headerlink\" title=\"4. 构造函数\"></a>4. 构造函数</h3><ul>\n<li><p>类的默认构造函数，无论其对象在什么地方创建，都会调用构造函数</p>\n</li>\n<li><p>但存在特殊情况，在堆中创建对象，构造函数不会调用</p>\n</li>\n<li><p>通过<code>malloc()</code>，不会调用构造函数</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Person *person &#x3D; (Person *)malloc(sizeof(Person));\nfree(person);\n&#x2F;&#x2F; malloc 不会调用构造函数\n\nPerson *person &#x3D; new Person;\ndelete person;\n&#x2F;&#x2F; 这个 new 会调用构造函数</code></pre></li>\n</ul>\n<h4 id=\"4-1-构造函数的错误概念\"><a href=\"#4-1-构造函数的错误概念\" class=\"headerlink\" title=\"4.1 构造函数的错误概念\"></a>4.1 构造函数的错误概念</h4><ul>\n<li><p>错误概念：当类内<code>没有自己定义</code>构造函数，编译器会默认添加一个<code>空实现的，无参的，默认构造函数</code></p>\n</li>\n<li><p>正确理解：在特定情况下，编译器才会为类生成<code>空的无参构造函数</code></p>\n</li>\n<li><p>具体情况：后面的<code>虚函数</code>会总结</p>\n</li>\n<li><p>代码示例：(<code>定义了构造函数</code>)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\n    int m_age;\n    \n    Person()&#123;&#125;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编分析：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\"># Person person;\nlea ecx, [person]\ncall Person::Person (0A914BFh)\n&#x2F;&#x2F; 定义了构造函数时，对象创建会调用构造函数</code></pre>\n\n\n</li>\n<li><p>代码示例：(<code>没定义构造函数</code>)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\n    int m_age;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    person.m_age &#x3D; 10;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编分析：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\"># Person person;\n# person.m_age &#x3D; 10;\nmov dword ptr[person], 0Ah\n&#x2F;&#x2F; 类没有定义构造函数时，编译时也不会创建所谓的：空实现的，无参的，默认构造函数</code></pre>\n\n\n</li>\n<li><p>代码示例：(<code>没定义构造函数，但类中静态初始化了成员变量</code>)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\n    int m_age &#x3D; 0;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    person.m_age &#x3D; 10;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编分析：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\"># Person person;\nlea ecx, [person]\ncall Person::Person (0314C4h)\n# person.m_age &#x3D; 10;\nmov dword ptr[person], 0Ah\n\n&#x2F;&#x2F; 没定义构造函数，但类中静态初始化了成员变量，此时编译器会创建：空实现的，无参的，默认构造函数</code></pre></li>\n</ul>\n<h4 id=\"4-2-构造函数的调用\"><a href=\"#4-2-构造函数的调用\" class=\"headerlink\" title=\"4.2 构造函数的调用\"></a>4.2 构造函数的调用</h4><ul>\n<li><p>通过多种创建对象的方式，判读是否调用了类的构造函数</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\npublic:\n    int m_age;\n\n    Person()\n    &#123;\n        m_age &#x3D; 0;\n        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int age)\n    &#123;\n        m_age &#x3D; age;\n        cout &lt;&lt; &quot;Person(int)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nPerson g_person0; &#x2F;&#x2F; Person()\nPerson g_person1(); &#x2F;&#x2F; 这是 g_person1() 函数的声明或定义，不会调用构造函数\nPerson g_person2(10); &#x2F;&#x2F; Person(int)\n\nint main()\n&#123;\n    Person person0; &#x2F;&#x2F; Person()\n    Person person1(); &#x2F;&#x2F; 这是 g_person1() 函数的声明或定义，不会调用构造函数\n    Person person2(20); &#x2F;&#x2F; Person(int)\n\n    Person *p0 &#x3D; new Person; &#x2F;&#x2F; Person()\n    Person *p1 &#x3D; new Person(); &#x2F;&#x2F; Person() ，这是在堆空间中创建对象\n    Person *p2 &#x3D; new Person(30); &#x2F;&#x2F; Person(int)\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo1\nPerson()\nPerson(int)\nPerson()\nPerson(int)\nPerson()\nPerson()\nPerson(int)</code></pre></li>\n</ul>\n<h4 id=\"4-3-构造函数的成员变量初始化\"><a href=\"#4-3-构造函数的成员变量初始化\" class=\"headerlink\" title=\"4.3 构造函数的成员变量初始化\"></a>4.3 构造函数的成员变量初始化</h4><ul>\n<li><p>默认情况下，没有自定义构造函数时，只有全局区和堆区的对象创建，会初始化为0，其余栈空间不会初始化成员变量</p>\n</li>\n<li><p>如果自定义了构造函数，除了全局区，其它内存空间的成员变量默认都不会被初始化，需要手动初始化</p>\n</li>\n<li><p>代码示例1：<code>(无自定义构造函数)</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\npublic:    \n    int m_age;\n&#125;;\n\n&#x2F;&#x2F; 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0\nPerson g_person;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 栈空间的对象直接被编译器优化了，不会初始化成员变量\n    &#x2F;&#x2F; Person person;\n\n    &#x2F;&#x2F; 没有初始化\n    Person *p0 &#x3D; new Person;\n\n    &#x2F;&#x2F; 初始化\n    Person *p1 &#x3D; new Person();\n\n    cout &lt;&lt; g_person.m_age &lt;&lt; endl;\n    cout &lt;&lt; p0-&gt;m_age &lt;&lt; endl;\n    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo2\n0\n14184048\n0</code></pre>\n</li>\n<li><p>得出结论：</p>\n<ol>\n<li><code>全局区</code>内，内存值默认全是 <code>0</code></li>\n<li><code>堆空间</code>内，通过 <code>()</code> 申请的内存，默认初始化为 <code>0</code></li>\n<li><code>栈空间</code>内，默认初始化为 <code>cccccccc</code></li>\n</ol>\n</li>\n<li><p>代码示例2：<code>(有自定义构造函数) -&gt; 空实现</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\npublic:    \n    int m_age;\n    \n    Person()&#123;&#125;\n&#125;;\n\n&#x2F;&#x2F; 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0\nPerson g_person;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 没有初始化\n    Person *p0 &#x3D; new Person;\n\n    &#x2F;&#x2F; 没有初始化，初始化工作交给自定义构造函数，然而自定义构造函数是空实现，所以没有初始化\n    Person *p1 &#x3D; new Person();\n\n    cout &lt;&lt; g_person.m_age &lt;&lt; endl;\n    cout &lt;&lt; p0-&gt;m_age &lt;&lt; endl;\n    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo2\n0\n14184048\n14184048</code></pre></li>\n</ul>\n<h4 id=\"4-4-构造函数的集体初始化\"><a href=\"#4-4-构造函数的集体初始化\" class=\"headerlink\" title=\"4.4 构造函数的集体初始化\"></a>4.4 构造函数的集体初始化</h4><ul>\n<li><p>通过<code>memset()</code>方法实现</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    int m_age;\n\n    Person()\n    &#123;\n        &#x2F;&#x2F; memset() 方法，方便用于类成员变量集体初始化或清零\n        memset(this, 0, sizeof(Person));\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Person *p1 &#x3D; new Person();\n\n    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo3\n0</code></pre></li>\n</ul>\n<h3 id=\"5-析构函数\"><a href=\"#5-析构函数\" class=\"headerlink\" title=\"5. 析构函数\"></a>5. 析构函数</h3><ul>\n<li>又名<code>析构器</code>，在对象销毁时自动调用，一般用于完成对象的清理工作</li>\n<li>没有返回值，不能重载</li>\n<li>通过<code>malloc()</code>分配的对象，<code>free()</code>时，不会调用析构函数</li>\n<li>类中的构造函数和析构函数，需要<code>public:</code>修饰后，才能被外界调用</li>\n<li>全局区的对象，不会调用析构函数</li>\n</ul>\n<h4 id=\"5-1-malloc与析构函数\"><a href=\"#5-1-malloc与析构函数\" class=\"headerlink\" title=\"5.1 malloc与析构函数\"></a>5.1 malloc与析构函数</h4><ul>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\npublic:    \n    int m_age;\n\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;\n    &#125;\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; malloc 的 对象不会调用 构造函数 和 析构函数\n    Person *p0 &#x3D; (Person *)malloc(sizeof(Person));\n    free(p0);\n\n    Person *p1 &#x3D; new Person();\n    delete p1;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo4\nPerson()\n~Person()</code></pre></li>\n</ul>\n<h4 id=\"5-2-对象内申请的堆区对象\"><a href=\"#5-2-对象内申请的堆区对象\" class=\"headerlink\" title=\"5.2 对象内申请的堆区对象\"></a>5.2 对象内申请的堆区对象</h4><ul>\n<li><p>对象析构时，只会回收对象，如果对象的成员变量指向堆空间，需要手动释放，否则会造成<code>内存泄漏</code></p>\n</li>\n<li><p>内存泄漏：该释放的内存，没有去释放</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Car\n&#123;\npublic:\n    int m_price;\n\n    Car()\n    &#123;\n        cout &lt;&lt; &quot;Car()&quot; &lt;&lt; endl;\n    &#125;   \n    ~Car()\n    &#123;\n        cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;\n    &#125; \n&#125;;\n\nclass Person\n&#123;\npublic:    \n    int m_age;\n    Car *m_car;\n\n    Person()\n    &#123;\n        &#x2F;&#x2F; 此处的 m_car是在堆空间中声明，需要delete才能回收\n        &#x2F;&#x2F; 如果是栈空间声明，person在调用析构函数时，会先回收m_car\n        m_car &#x3D; new Car;\n        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;\n    &#125;\n    ~Person()\n    &#123;\n        delete m_car;\n        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo5\nCar()\nPerson()\n~Car()\n~Person()</code></pre></li>\n</ul>\n<h3 id=\"6-声明和实现\"><a href=\"#6-声明和实现\" class=\"headerlink\" title=\"6. 声明和实现\"></a>6. 声明和实现</h3><ul>\n<li>类的定义和声明分离，分别在 <code>.h</code>和<code>.cpp</code>中实现</li>\n</ul>\n<h4 id=\"6-1-具体演示\"><a href=\"#6-1-具体演示\" class=\"headerlink\" title=\"6.1 具体演示\"></a>6.1 具体演示</h4><p><code>Person.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    Person();\n    ~Person();\n\n    void set_Age(int age);\n    int get_Age();\n&#125;;</code></pre>\n\n\n\n<p><code>Person.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Person::Person()\n&#123;\n    cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;\n&#125;\nPerson::~Person()\n&#123;\n    cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;\n&#125;\n\nvoid Person::set_Age(int age)\n&#123;\n    m_age &#x3D; age;\n&#125;\nint Person::get_Age()\n&#123;\n    return m_age;\n&#125;</code></pre>\n\n\n\n<p><code>main.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    Person person;\n    person.set_Age(10);\n    int age &#x3D; person.get_Age();\n\n    cout &lt;&lt; age &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n\n\n\n<ul>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo2&gt; .\\demo1.exe\nPerson()\n10\n~Person()</code></pre></li>\n</ul>\n<h3 id=\"7-命名空间\"><a href=\"#7-命名空间\" class=\"headerlink\" title=\"7. 命名空间\"></a>7. 命名空间</h3><ul>\n<li>作用：<ul>\n<li>解决重复命名的问题</li>\n<li>命名空间不影响内存布局和结构</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-1-命名空间的基本用法\"><a href=\"#7-1-命名空间的基本用法\" class=\"headerlink\" title=\"7.1 命名空间的基本用法\"></a>7.1 命名空间的基本用法</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace fh1\n&#123;\n    class Person\n    &#123;\n    private:\n        int m_age;\n\n    public:\n        Person();\n        ~Person();\n    &#125;;\n&#125;\n\nnamespace fh2\n&#123;\n    class Person\n    &#123;\n    private:\n        int m_age;\n\n    public:\n        Person();\n        ~Person();\n    &#125;;\n&#125;\n\nint main()\n&#123;\n    fh1::Person person1;\n    fh2::Person person2;\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"7-2-命名空间的嵌套\"><a href=\"#7-2-命名空间的嵌套\" class=\"headerlink\" title=\"7.2 命名空间的嵌套\"></a>7.2 命名空间的嵌套</h4><ul>\n<li><p>命名空间可以一直嵌套</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace fh1\n&#123;\n    namespace fh2\n    &#123;\n        class Person\n        &#123;\n        private:\n            int m_age;\n\n        public:\n            Person();\n            ~Person();\n        &#125;;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    fh1::fh2::Person person;\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"7-3-存在最大默认命名空间\"><a href=\"#7-3-存在最大默认命名空间\" class=\"headerlink\" title=\"7.3 存在最大默认命名空间\"></a>7.3 存在最大默认命名空间</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace fh\n&#123;\n    void func()\n    &#123;\n        cout &lt;&lt; &quot;fh::func()&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid func()\n&#123;\n    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    fh::func();\n    &#x2F;&#x2F; 通过默认的全局命名空间，访问 fh\n    ::fh::func();\n\n    func();\n    \n   \t&#x2F;&#x2F; 通过默认的全局命名空间，访问 func()\n    ::func();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo2&gt; .\\demo4.exe\nfh::func()\nfh::func()\nfunc()\nfunc()</code></pre></li>\n</ul>\n<h3 id=\"8-继承\"><a href=\"#8-继承\" class=\"headerlink\" title=\"8. 继承\"></a>8. 继承</h3><ul>\n<li>继承可以让子类拥有父类的所有成员</li>\n</ul>\n<h4 id=\"8-1-继承的内存布局\"><a href=\"#8-1-继承的内存布局\" class=\"headerlink\" title=\"8.1 继承的内存布局\"></a>8.1 继承的内存布局</h4><ul>\n<li><p>子对象中的成员变量分布：最上层的父类的成员变量在子对象的首地址，依次向下排列</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int height;    \n&#125;;\n\nclass Student : public Person\n&#123;\npublic:\n    int age;    \n&#125;;\n\nclass My : public Student\n&#123;\npublic:\n    int id;    \n&#125;;\n\nint main()\n&#123;\n    Person person;\n    Student student;\n    My my;\n    my.height &#x3D; 9;\n    my.age &#x3D; 10;\n    my.id &#x3D; 11;\n\n    cout &lt;&lt; &quot;Person: &quot; &lt;&lt; sizeof(person) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Student: &quot; &lt;&lt; sizeof(student) &lt;&lt; endl;\n    cout &lt;&lt; &quot;My: &quot; &lt;&lt; sizeof(my) &lt;&lt; endl;\n    \n    cout &lt;&lt; &amp;my.height &lt;&lt; endl;\n    cout &lt;&lt; &amp;my.age &lt;&lt; endl;\n    cout &lt;&lt; &amp;my.id &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo1.exe\nPerson: 4\nStudent: 8\nMy: 12\n0x7bfe08\n0x7bfe0c\n0x7bfe10</code></pre>\n</li>\n<li><p>总结：父类的成员变量在前面，子类的在后面</p>\n</li>\n<li><p>补充：父类的成员变量，子类中没有使用，子类的对象大小依然不变，编译器不会去优化，所以要合理设计类</p>\n</li>\n</ul>\n<h4 id=\"8-2-成员访问权限\"><a href=\"#8-2-成员访问权限\" class=\"headerlink\" title=\"8.2 成员访问权限\"></a>8.2 成员访问权限</h4><ul>\n<li><p>成员访问权限、继承方式有3种：</p>\n<ol>\n<li><code>public</code>：公共的，任何地方都可以访问（<code>struct默认</code>）</li>\n<li><code>private</code>：私有的，只有当前类内部可以访问（<code>class默认</code>）</li>\n<li><code>protected</code>：子类内部和当前类可以访问</li>\n</ol>\n</li>\n<li><p>子类在继承父类时，使用了权限修饰：子类内部访问父类成员的权限，是一下两项中权限最小的</p>\n<ol>\n<li>成员本身的访问权限</li>\n<li>上一级父类的继承方式</li>\n</ol>\n</li>\n<li><p>开发中最多的继承方式是<code>public</code>继承，保留父类原来的成员访问权限</p>\n</li>\n<li><p>访问权限，不影响对象的内存布局</p>\n</li>\n</ul>\n<h3 id=\"9-初始化列表\"><a href=\"#9-初始化列表\" class=\"headerlink\" title=\"9. 初始化列表\"></a>9. 初始化列表</h3><ul>\n<li><p>特点：</p>\n<ul>\n<li>一种便捷的初始化成员变量的方式</li>\n<li>只用于构造函数</li>\n<li>初始化顺序，只跟成员变量的声明顺序有关</li>\n</ul>\n</li>\n<li><p>补充：</p>\n<ul>\n<li>如果构造函数的声明和实现分离，初始化列表只能写在实现中</li>\n</ul>\n</li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\nprivate:    \n    int m_age;\n    int m_height;\n\npublic:\n    &#x2F;&#x2F; 普通写法\n    Person(int age, int height)\n    &#123;\n        m_age &#x3D; age;\n        m_height &#x3D; height;\n    &#125;\n\n    &#x2F;&#x2F; 初始化列表\n    Person(int age, int height) : m_age(age), m_height(height)\n    &#123;\n    &#125;\n&#125;;</code></pre>\n</li>\n<li><p>两种写法完全等价：(反汇编查看)</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; 普通构造函数\n&#x2F;&#x2F; m_age &#x3D; age;\nmov eax, dword ptr[this]\nmov ecx, dword ptr[age]\nmov dword ptr[eax], ecx\n\n&#x2F;&#x2F; m_height &#x3D; height;\nmov eax, dword ptr[this]\nmov ecx, dword ptr[height]\nmov dword ptr [eax+4], ecx\n\n&#x2F;&#x2F; 初始化列表\n&#x2F;&#x2F; m_age(age)\nmov eax, dword ptr[this]\nmov ecx, dword ptr[age]\nmov dword ptr[eax], ecx\n\n&#x2F;&#x2F; m_height(height)\nmov eax, dword ptr[this]\nmov ecx, dword ptr[height]\nmov dword ptr [eax+4], ecx</code></pre></li>\n</ul>\n<h3 id=\"10-构造函数互调\"><a href=\"#10-构造函数互调\" class=\"headerlink\" title=\"10. 构造函数互调\"></a>10. 构造函数互调</h3><h4 id=\"10-1-互调语法\"><a href=\"#10-1-互调语法\" class=\"headerlink\" title=\"10.1 互调语法\"></a>10.1 互调语法</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:    \n    int m_age;\n    int m_height;\n\npublic:\n    &#x2F;&#x2F; 错误的写法\n    &#x2F;&#x2F; Person() &#123;Person(10, 20);&#125;\n    \n    &#x2F;&#x2F; 正确的写法\n    Person() : Person(0, 0)&#123;&#125;\n\n    Person(int age, int height)\n    &#123;\n        m_age &#x3D; age;\n        m_height &#x3D; height;\n\n        cout &lt;&lt; m_age &lt;&lt; &quot; &quot; &lt;&lt; m_height &lt;&lt; endl;\n    &#125;\n&#125;;\n\n\nint main()\n&#123;\n    Person person1;\n    Person person2(10, 20);\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo3.exe\n0 0\n10 20</code></pre></li>\n</ul>\n<h4 id=\"10-2-语法分析\"><a href=\"#10-2-语法分析\" class=\"headerlink\" title=\"10.2 语法分析\"></a>10.2 语法分析</h4><ul>\n<li><p>通过反汇编分析两种写法的正确性</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; 错误的写法\n&#x2F;&#x2F; 原因：在函数体中写的 Person(0, 0); 是创建临时Person的对象，0 赋值给了临时的Person对象\n&#x2F;&#x2F; Person() &#123;Person(0, 0);&#125;\nlea ecx, [person1]\ncall Person::Person(0E61118h)\n\nmov dword ptr [this], ecx\npush 14h\npush 0Ah\n\nlea ecx, [person] &#x2F;&#x2F; person是临时对象\ncall Person::Person(0E61311h)\n\nmov dword ptr[this], ecx\n\n&#x2F;&#x2F; 正确的写法\n&#x2F;&#x2F; Person() : Person(0, 0)&#123;&#125;\nlea ecx, [person2]\ncall Person::Person(01221118h)\n\nmov dword ptr [this], ecx\npush 14h\npush 0Ah\n\nmov dword ptr[this], ecx\ncall Person::Person(01221311h)\n\nmov dword ptr[this], ecx</code></pre></li>\n</ul>\n<h4 id=\"10-3-父类的构造函数\"><a href=\"#10-3-父类的构造函数\" class=\"headerlink\" title=\"10.3 父类的构造函数\"></a>10.3 父类的构造函数</h4><ul>\n<li><p>子类的构造函数默认会调用父类的无参构造函数</p>\n</li>\n<li><p>子类的构造函数主动调用了父类的有参构造函数，则父类的无参构造函数不会被调用</p>\n</li>\n<li><p>如果父类缺少无参构造函数，子类构造函数就必须显式调用父类的有参构造函数</p>\n</li>\n<li><p>代码示例1：(默认会调用父类的无参构造函数)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic:    \n    Student()\n    &#123;\n        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Student student;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo4.exe\nPerson::Person()\nStudent::Student()</code></pre>\n\n\n</li>\n<li><p>代码示例2：(主动调用了父类的有参构造函数)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int age)\n    &#123;\n        cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic:    \n    Student() : Person(10)\n    &#123;\n        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Student student;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo4.exe\nPerson::Person(int)\nStudent::Student()</code></pre></li>\n</ul>\n<h4 id=\"10-4-构造和析构的顺序\"><a href=\"#10-4-构造和析构的顺序\" class=\"headerlink\" title=\"10.4 构造和析构的顺序\"></a>10.4 构造和析构的顺序</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;\n    &#125;\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic:    \n    Student()\n    &#123;\n        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;\n    &#125;\n    ~Student()\n    &#123;\n        cout &lt;&lt; &quot;Student::~Student()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Student student;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo5.exe\nPerson::Person()\nStudent::Student()\nStudent::~Student()\nPerson::~Person()</code></pre></li>\n</ul>\n<h3 id=\"11-多态\"><a href=\"#11-多态\" class=\"headerlink\" title=\"11. 多态\"></a>11. 多态</h3><ul>\n<li><p>默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态</p>\n</li>\n<li><p>多态是面向对象非常重要的特性</p>\n<ul>\n<li>同一个操作，用于不同的对象，可以有不同的解释，产生不同的结果</li>\n<li>在运行时，可以识别出真正的对象类型，调用对应子类中的函数</li>\n</ul>\n</li>\n<li><p>多态的要素：</p>\n<ul>\n<li>子类重写父类的成员函数<code>(override)</code></li>\n<li>父类指针指向子类</li>\n<li>利用父类指针调用重写的成员函数</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-1-父类和子类指针\"><a href=\"#11-1-父类和子类指针\" class=\"headerlink\" title=\"11.1 父类和子类指针\"></a>11.1 父类和子类指针</h4><ul>\n<li><p>父类指针指向子类对象是安全的，子类的继承方式是<code>public</code></p>\n</li>\n<li><p>子类指针指向父类对象是不安全的</p>\n</li>\n<li><p>代码示例1：父类指针指向子类对象</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Person\n&#123;\n    int m_age;\n&#125;;\n\nstruct Student : Person\n&#123;\n    int m_score;\n&#125;;\n\nint main()\n&#123;\n    Person *person &#x3D; new Student;\n    person-&gt;m_age &#x3D; 10;\n    cout &lt;&lt; &quot;person-&gt;m_age: &quot; &lt;&lt; person-&gt;m_age &lt;&lt; &quot;\\n&quot;;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exe\nperson-&gt;m_age: 10</code></pre>\n</li>\n<li><p>总结：</p>\n<ul>\n<li>父类指针指向子类对象，这样用父类指针使用成员变量时，会很<code>安全</code>，不会影响到子类独有的成员变量</li>\n<li>父类的成员变量存在得到内存空间，肯定在子类对象的内存范围内，不会超出子类对象的内存范围，所以<code>安全</code></li>\n</ul>\n</li>\n<li><p>代码示例2：子类指针指向父类对象</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Person\n&#123;\n    int m_age;\n&#125;;\n\nstruct Student : Person\n&#123;\n    int m_score;\n&#125;;\n\nint main()\n&#123;    \n    Student *student &#x3D; (Student *)new Person;\n    student-&gt;m_age &#x3D; 10;\n    student-&gt;m_score &#x3D; 100;\n    \n    cout &lt;&lt; &quot;m_age: &quot; &lt;&lt; student-&gt;m_age &lt;&lt; &quot;\\n&quot; \n         &lt;&lt; &quot;m_score: &quot; &lt;&lt; student-&gt;m_score &lt;&lt; &quot;\\n&quot;;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exe\nm_age: 10\nm_score: 100</code></pre>\n</li>\n<li><p>总结：</p>\n<ul>\n<li>子类指针指向父类的对象，子类指针指向的成员变量，可能会超出父类对象内存范围内的成员变量，<code>不安全</code></li>\n<li>因为可能会覆盖掉，别的子类对象内存范围内的成员变量的值</li>\n</ul>\n</li>\n<li><p>代码示例3：通过反汇编查看强制类型转换</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n\tCat *animal &#x3D; (Cat *)new Dog;\n    animal-&gt;speak();\n    animal-&gt;run();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exe\nCat::speak()\nCat::run()</code></pre>\n</li>\n<li><p>查看反汇编结果：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; Cat *animal &#x3D; (Cat *)new Dog;\nmov dword ptr[ebp-0DCh], 0\nmov ecx, dword ptr[ebp-0DCh]\nmov dword ptr[animal], ecx\n\n&#x2F;&#x2F; animal-&gt;speak();\nmov ecx, dword ptr[animal]\ncall Cat::speak(0F714F6h)\n\n&#x2F;&#x2F; animal-&gt;run();\nmov ecx, dword ptr[animal]\ncall Cat::run(0F714F1h)</code></pre>\n</li>\n<li><p>总结：</p>\n<ul>\n<li>由上面的<code>示例3</code>可知：指针的类型决定了，指针所能访问的内存范围</li>\n<li>此时还未实现<code>多态</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-2-虚函数实现多态\"><a href=\"#11-2-虚函数实现多态\" class=\"headerlink\" title=\"11.2 虚函数实现多态\"></a>11.2 虚函数实现多态</h4><ul>\n<li><p>通过虚函数<code>(virtual function)</code>实现多态</p>\n</li>\n<li><p>虚函数：被<code>virtual</code>修饰的成员函数</p>\n</li>\n<li><p>在<code>父类</code>中声明为<code>虚函数</code>，子类中<code>重写</code>的成员函数会自动<code>转成虚函数</code></p>\n</li>\n<li><p>代码示例：</p>\n</li>\n</ul>\n  <pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    virtual void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;\n    virtual void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nvoid playAnimal(Animal *animal)\n&#123;\n    animal-&gt;speak();\n    animal-&gt;run();\n&#125;\n\nint main()\n&#123;\n    playAnimal(new Dog);\n    playAnimal(new Cat);\n    return 0;\n&#125;</code></pre>\n\n<ul>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo2.exe\nDog::speak()\nDog::run()\nCat::speak()\nCat::run()</code></pre></li>\n</ul>\n<h4 id=\"11-3-虚表\"><a href=\"#11-3-虚表\" class=\"headerlink\" title=\"11.3 虚表\"></a>11.3 虚表</h4><ul>\n<li>虚函数的实现原理是<code>虚表</code>，这个虚表里存储着最终需要调用的<code>虚函数地址</code>，这个虚表也叫虚函数表</li>\n</ul>\n<h5 id=\"11-3-1-虚表的大小\"><a href=\"#11-3-1-虚表的大小\" class=\"headerlink\" title=\"11.3.1 虚表的大小\"></a>11.3.1 虚表的大小</h5><ul>\n<li><p>前提：</p>\n<ul>\n<li>类中的普通函数，在对象中不占用空间，因为函数存在代码区中，而对象在栈区中，只有成员变量占用空间</li>\n<li>父类的虚函数，在子类重写后，这些函数会存入一个虚函数表中，虚函数表占用子类对象的内存空间</li>\n<li>x86环境，指针是4字节</li>\n<li>x64环境，指针是8字节</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    int m_age;\n    virtual void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;\n    virtual void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    int m_height;\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Cat\n&#123; \npublic:\n    int m_health;\n    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Cat::sizeof()&#x3D; &quot; &lt;&lt; sizeof(Cat) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Dog::sizeof()&#x3D; &quot; &lt;&lt; sizeof(Dog) &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .&#x2F;demo3.exe\nCat::sizeof()&#x3D; 4\nDog::sizeof()&#x3D; 16</code></pre>\n</li>\n<li><p>结果分析：</p>\n<ul>\n<li>Dog对象，继承了父类Animal，对象类有<code>两个int类型</code>成员变量：<code>8字节</code></li>\n<li>父类还<code>有虚函数</code>的存在，所以需要在Dog对象内<code>创建虚函数表</code>：<code>x86是4字节</code>，<code>x64是8字节</code></li>\n<li>Dog对象重写的父类的方法，存在代码区中，不和对象一起在栈区中，所以不占用对象内存</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"11-3-2-反汇编分析虚表\"><a href=\"#11-3-2-反汇编分析虚表\" class=\"headerlink\" title=\"11.3.2 反汇编分析虚表\"></a>11.3.2 反汇编分析虚表</h5><ul>\n<li><p>x86环境中，内存的布局</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int main()\n&#123;\n    Animal *animal &#x3D; new Dog();\n    animal-&gt;m_age &#x3D; 20;\n    return 0;\n&#125;</code></pre>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>内存地址</th>\n<th>内存数据</th>\n<th>内存地址</th>\n<th>内存数据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dog</code></td>\n<td><code>0x00E69B60</code></td>\n<td><code>0x00B89B64</code>&#x3D;&#x3D;<code>虚表内存地址</code></td>\n<td><code>0x00B89B64</code></td>\n<td><code>0x00B814E7</code>&#x3D;&#x3D;<code>Dog::speak()的调用地址</code></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B61</td>\n<td></td>\n<td>0x00B89B65</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B62</td>\n<td></td>\n<td>0x00B89B66</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B63</td>\n<td></td>\n<td>0x00B89B67</td>\n<td></td>\n</tr>\n<tr>\n<td><code>&amp;m_age</code></td>\n<td><code>0x00E69B64</code></td>\n<td><code>20</code></td>\n<td><code>0x00B89B68</code></td>\n<td><code>0x00B814CE</code>&#x3D;&#x3D;<code>Dog::run()的调用地址</code></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B65</td>\n<td></td>\n<td>0x00B89B69</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B66</td>\n<td></td>\n<td>0x00B89B6A</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B67</td>\n<td></td>\n<td>0x00B89B6B</td>\n<td></td>\n</tr>\n<tr>\n<td><code>&amp;m_height</code></td>\n<td><code>0x00E69B68</code></td>\n<td><code>0</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B69</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B6A</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0x00E69B6B</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>总结：</p>\n<ul>\n<li>可以看到，<code>父类</code>中有<code>虚函数</code>，<code>子类对象</code>从<code>首地址开始</code>，<code>存放虚函数表</code></li>\n<li><code>虚函数表</code>内<code>存放着内存地址</code>，而这个内存地址<code>指向</code>的是<code>代码区的地址</code>，也正是子类对象内重写父类方法的地址</li>\n<li>所以实现多态后，父类指针指向子类对象时，可以<code>通过虚函数表</code>，使得<code>指针调用子类</code>的方法，以达到多态的目的</li>\n</ul>\n</li>\n<li><p>反汇编查看：</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int main()\n&#123;\n    Animal *animal &#x3D; new Dog();\n    animal-&gt;m_age &#x3D; 20;\n    animal-&gt;speak();\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; animal-&gt;m_age &#x3D; 20;\nmov eax, dword ptr[animal] &#x2F;&#x2F; animal &#x3D;&#x3D; ebp-8 是指针变量，eax 是Dog对象的地址，里面存放着虚表的地址值\nmov dword ptr[eax+4], 14h\n\n&#x2F;&#x2F; animal-&gt;speak();\nmov eax, dword ptr[animal]\nmov edx, dword ptr[eax] &#x2F;&#x2F; 从Dog对象的地址开始往后4个字节内的数据存入到 寄存器edx 中，edx 得到 虚表的地址\n\nmov esi, esp\nmov ecx, dword ptr[animal]\nmov eax, dword ptr[edx] &#x2F;&#x2F; 从 edx 中取4个字节，eax 得到虚表中存放 Dog对象方法的地址，(但不是方法的真正地址，需要jump到真正地址)\n\ncall eax &#x2F;&#x2F; 调用 Dog对象的方法</code></pre></li>\n</ul>\n<h5 id=\"11-3-3-虚表的设计思想\"><a href=\"#11-3-3-虚表的设计思想\" class=\"headerlink\" title=\"11.3.3 虚表的设计思想\"></a>11.3.3 虚表的设计思想</h5><ul>\n<li>前提：项目中实现了多态，其父类指针多次指向不同的子类对象，且父类的方法用<code>virtual修饰</code></li>\n<li>原理：<ul>\n<li>编译器在<code>编译时</code>，并<code>不知道</code>，项目中父类指针多次指向不同的子类对象</li>\n<li>即便<code>父类指针</code>指向的对象是<code>自己本身</code>的对象，也<code>一样生成</code>用于<code>存放虚表地址</code>的<code>内存空间</code></li>\n<li><code>编译文件</code>是<code>静态</code>的，而程序在内存中<code>执行</code>是<code>动态</code>过程</li>\n</ul>\n</li>\n<li>目的：<ul>\n<li>多态中，每个<code>子对象</code>都要有一个<code>虚函数表</code></li>\n<li>实现程序在内存中<code>执行</code>的<code>动态性</code></li>\n</ul>\n</li>\n<li>虚表的相关优化：<ul>\n<li>当父类指针多次指向<code>多个</code>子类对象，且都是<code>同一个类</code>的对象</li>\n<li>此时，这些对象依然有<code>各自独立</code>存放<code>虚表地址</code>的内存空间</li>\n<li>这些子类对象的<code>前4字节</code>空间中存放的<code>虚表地址值</code>(对象的方法所在代码区的地址)是<code>相等</code>的</li>\n</ul>\n</li>\n<li>总结：相同类的对象，不管在什么区中，共用一份虚表</li>\n</ul>\n<h5 id=\"11-3-4-多态实现的需求\"><a href=\"#11-3-4-多态实现的需求\" class=\"headerlink\" title=\"11.3.4 多态实现的需求\"></a>11.3.4 多态实现的需求</h5><ul>\n<li><p>实现需求：大致两种</p>\n<ol>\n<li>完全重写父类的成员函数</li>\n<li>在父类的成员函数基础上，利用多态附加子类对象的成员函数</li>\n</ol>\n</li>\n<li><p>代码示例1：第一种<code>(完全重写)</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    &#x2F;&#x2F; 子类会完全重写的虚函数是 可以 为空实现\n    virtual void speak()&#123;cout &lt;&lt; &quot;Animal&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog;\n    animal-&gt;speak();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .&#x2F;demo4.exe\nDog::speak()</code></pre>\n\n\n</li>\n<li><p>代码示例2：第二种<code>(父类的方法实现基础上附加子类的实现)</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    &#x2F;&#x2F; 父类的方法实现基础上附加子类的实现，此处的父类虚函数实现 可以 不为空实现\n    virtual void speak()&#123;cout &lt;&lt; &quot;Animal&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        Animal::speak();\n        cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog;\n    animal-&gt;speak();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .&#x2F;demo4.exe\nAnimal\nDog::speak()</code></pre></li>\n</ul>\n<h4 id=\"11-4-虚析构函数\"><a href=\"#11-4-虚析构函数\" class=\"headerlink\" title=\"11.4 虚析构函数\"></a>11.4 虚析构函数</h4><ul>\n<li><p>父类指针指向子类对象，含有虚函数的父类，应该将析构函数声明为虚函数(虚析构函数)</p>\n</li>\n<li><p><code>delete</code>父类指针，才会调用子类的析构函数，保证析构的完整型</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    Animal()&#123;cout &lt;&lt; &quot;Animal::Animal()&quot; &lt;&lt; endl;&#125;\n    virtual ~Animal()&#123;cout &lt;&lt; &quot;Animal::~Animal()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    Dog()&#123;cout &lt;&lt; &quot;Dog::Dog()&quot; &lt;&lt; endl;&#125;\n    ~Dog()&#123;cout &lt;&lt; &quot;Dog::~Dog()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog;\n    delete animal;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .&#x2F;demo5.exe\nAnimal::Animal()\nDog::Dog()\nDog::~Dog()\nAnimal::~Animal()</code></pre>\n</li>\n<li><p>补充：</p>\n<ul>\n<li>先构造父类，再构造子类</li>\n<li>先析构子类，再析构父类</li>\n<li>父类构造可以不用<code>virtual</code>修饰</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-5-纯虚函数\"><a href=\"#11-5-纯虚函数\" class=\"headerlink\" title=\"11.5 纯虚函数\"></a>11.5 纯虚函数</h4><ul>\n<li><p>定义：没有函数体其初始化为0的虚函数，用来定义接口规范</p>\n</li>\n<li><p>抽象类（<code>Abstract Class</code>）</p>\n<ul>\n<li>含有纯虚函数的类，不可以实例化（<code>不可以创建对象</code>）</li>\n<li>抽象类也可以是包含非纯虚函数，成员变量</li>\n<li>如果父类是抽象类，子类没有完全实现纯虚函数，那么这个子类依然是抽象类</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    int m_age;\n    virtual void speak() &#x3D; 0;\n    virtual void run() &#x3D; 0;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog();\n    cout &lt;&lt; animal-&gt;m_age &lt;&lt; endl;\n    animal-&gt;run();\n    animal-&gt;speak();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo1.exe\n0\nDog::run()\nDog::speak()</code></pre></li>\n</ul>\n<h4 id=\"11-6-多继承\"><a href=\"#11-6-多继承\" class=\"headerlink\" title=\"11.6 多继承\"></a>11.6 多继承</h4><h5 id=\"11-6-1-多继承概念\"><a href=\"#11-6-1-多继承概念\" class=\"headerlink\" title=\"11.6.1 多继承概念\"></a>11.6.1 多继承概念</h5><ul>\n<li><p>C++允许一个类，继承多个类（<code>不建议使用</code>）</p>\n</li>\n<li><p>如果子类继承的<code>多个父类</code>都有虚函数，那么子类对象会产生对应的<code>多张虚函数表</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Student\n&#123;\npublic:\n    int m_score;\n&#125;;\n\nclass Worker\n&#123;\npublic:\n    int m_salary;\n&#125;;\n\nclass Undergraduate : public Student, public Worker\n&#123;\npublic:\n    int m_grade;\n&#125;;\n\n\nint main()\n&#123;\n    Undergraduate under;\n    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(under) &lt;&lt; endl;\n    under.m_score &#x3D; 100;\n    under.m_salary &#x3D; 2000;\n    under.m_grade &#x3D; 4;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo2.exe\nsizeof: 12</code></pre>\n\n\n</li>\n<li><p>内存布局：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th>内存地址</th>\n<th>内存数据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&amp;under</code></td>\n<td><code>&amp;m_score</code></td>\n<td><code>0x00E69B60</code></td>\n<td>100</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B61</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B62</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B63</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>&amp;m_salary</code></td>\n<td><code>0x00E69B64</code></td>\n<td>2000</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B65</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B66</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B67</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>&amp;m_grade</code></td>\n<td><code>0x00E69B68</code></td>\n<td>4</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B69</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B6A</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>0x00E69B6B</td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h5 id=\"11-6-2-同名成员函数-x2F-变量\"><a href=\"#11-6-2-同名成员函数-x2F-变量\" class=\"headerlink\" title=\"11.6.2 同名成员函数&#x2F;变量\"></a>11.6.2 同名成员函数&#x2F;变量</h5><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal_A\n&#123;\npublic:\n    int m_age;\n    void run()&#123;cout &lt;&lt; &quot;Animal_A::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Animal_B\n&#123;\npublic:\n    int m_age;\n    void run()&#123;cout &lt;&lt; &quot;Animal_B::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal_A, public Animal_B\n&#123;\npublic:\n    int m_age;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Dog dog;\n\n    dog.m_age &#x3D; 10;\n    dog.Animal_A::m_age &#x3D; 11;\n    dog.Animal_B::m_age &#x3D; 12;\n    dog.Dog::m_age &#x3D; 13;\n    \n    dog.run();\n    dog.Animal_A::run();\n    dog.Animal_B::run();\n    dog.Dog::run();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo3.exe\nDog::run()\nAnimal_A::run()\nAnimal_B::run()\nDog::run()</code></pre></li>\n</ul>\n<h5 id=\"11-6-3-菱形继承\"><a href=\"#11-6-3-菱形继承\" class=\"headerlink\" title=\"11.6.3 菱形继承\"></a>11.6.3 菱形继承</h5><h6 id=\"11-6-3-1-菱形继承结构\"><a href=\"#11-6-3-1-菱形继承结构\" class=\"headerlink\" title=\"11.6.3.1 菱形继承结构\"></a>11.6.3.1 菱形继承结构</h6><ul>\n<li><p>基本结构：</p>\n<ul>\n<li>定义一个类：A</li>\n<li>定义类B1，继承A；定义类B2，继承A</li>\n<li>定义类C，继承B1，B2</li>\n</ul>\n</li>\n<li><p>菱形继承的问题：</p>\n<ul>\n<li>最底层的对象，从基类继承的成员变量冗余，重复</li>\n<li>最底层的对象，无法访问基类的成员变量，存在二义性</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n&#123;\n    int a;\n&#125;;\n\nclass B1 : A &#x2F;&#x2F; 继承A的成员变量，2*int &#x3D; 8字节\n&#123;\n    int b1;\n&#125;;\n\nclass B2 : A &#x2F;&#x2F; 同理，2*int &#x3D; 8字节\n&#123;\n    int b2;\n&#125;;\n\nclass C : B1, B2 &#x2F;&#x2F; 继承B1，B2，加上自身成员变量，2+2+1 int &#x3D; 20字节\n&#123;\n    int c;\n&#125;;\n\nint main()\n&#123;\n    C c;\n    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo4.exe\nsizeof: 20</code></pre></li>\n</ul>\n<h6 id=\"11-6-3-2-虚继承\"><a href=\"#11-6-3-2-虚继承\" class=\"headerlink\" title=\"11.6.3.2 虚继承\"></a>11.6.3.2 虚继承</h6><ul>\n<li><p>解决菱形继承带来的底层对象的成员变量冗余，重复和二义性</p>\n</li>\n<li><p>基本结构：</p>\n<ul>\n<li>定义一个类：A</li>\n<li>定义类B1，继承 <code>virtual A</code>；定义类B2，继承 <code>virtual A</code></li>\n<li>定义类C，继承B1，B2</li>\n</ul>\n</li>\n<li><p>此时，A为 <code>虚基类</code></p>\n</li>\n<li><p>作用：B1，B2会共同继承同一份 A 的成员，而不是各自继承一份，解决了底层对象的成员冗余</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A\n&#123;\n    int a;\n&#125;;\n\nstruct B1 : virtual A &#x2F;&#x2F; 虚表8字节，成员变量4字节，12\n&#123;\n    int b1;\n&#125;;\n\nstruct B2 : virtual A &#x2F;&#x2F; 虚表8字节，成员变量4字节，12\n&#123;\n    int b2;\n&#125;;\n\nstruct C : B1, B2 &#x2F;&#x2F; 2*12 &#x3D; 24，虚表8字节，成员变量4字节，虚基类成员变量4字节 &#x3D; 24 + 8 + 4 + 4 &#x3D; 40\n&#123;\n    int c;\n&#125;;\n\nint main()\n&#123;\n    C c;\n    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo4.exe\nsizeof: 40</code></pre>\n</li>\n<li><p>虚继承的类结构：</p>\n<ul>\n<li>首地址存放虚指针和偏移量</li>\n<li>存放自己的成员变量</li>\n<li>存放虚基类的成员变量</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"12-静态成员\"><a href=\"#12-静态成员\" class=\"headerlink\" title=\"12. 静态成员\"></a>12. 静态成员</h3><h4 id=\"12-1-静态成员基本定义\"><a href=\"#12-1-静态成员基本定义\" class=\"headerlink\" title=\"12.1 静态成员基本定义\"></a>12.1 静态成员基本定义</h4><ul>\n<li><p>定义：<code>static</code>修饰的成员变量&#x2F;函数</p>\n<ul>\n<li>可以通过<code>对象.静态成员</code>，<code>对象指针-&gt;静态成员</code>，<code>类名::静态成员变量</code>，进行访问</li>\n</ul>\n</li>\n<li><p>静态成员变量：</p>\n<ul>\n<li>存储在数据段（<code>全局区，类似全局变量</code>），整个程序运行过程中只有一份内存</li>\n<li>对比全局变量，它可以设定访问权限（<code>public</code>, <code>protected</code>, <code>private</code>），达到局部共享的目的</li>\n<li>必须初始化，必须在类外面初始化，初始化不能带<code>static</code>，如果类的声明和实现分离（<code>在实现中初始化</code>）</li>\n</ul>\n</li>\n<li><p>静态成员函数：</p>\n<ul>\n<li>内部不能使用<code>this</code>指针（<code>this</code>指针只能用于非静态成员函数内部）</li>\n<li>不能是虚函数（<code>虚函数只能是非静态成员函数</code>）</li>\n<li>内部不能访问非静态成员变量\\函数，只能访问静态成员变量\\函数</li>\n<li>构造函数和析构函数不可以是静态的</li>\n<li>当声明和实现分离，实现不能带<code>static</code></li>\n</ul>\n</li>\n<li><p>总结：</p>\n<ul>\n<li>涉及到，通过<code>对象</code>来管理，调用成员的变量和函数，都不可以用<code>static</code>修饰</li>\n<li><code>static</code>修饰的成员变量&#x2F;函数只能通过类，利用作用域使用，或者在静态的函数内使用静态成员变量</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    \n    static int m_price;\n\n    static void byCar();\n&#125;;\n\nint Car::m_price &#x3D; 1000;\n\nvoid Car::byCar()\n&#123;\n    cout &lt;&lt; &quot;Car is running&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Car price: &quot; &lt;&lt; Car::m_price &lt;&lt; endl;\n    Car::byCar();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo1.exe\nCar price: 1000\nCar is running</code></pre></li>\n</ul>\n<h4 id=\"12-2-反汇编分析静态成员\"><a href=\"#12-2-反汇编分析静态成员\" class=\"headerlink\" title=\"12.2 反汇编分析静态成员\"></a>12.2 反汇编分析静态成员</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    int m_age;\n    static int m_price;\n&#125;;\n\nint Car::m_price &#x3D; 0;\n\nint g_age;\n\nint main()\n&#123;\n    Car car1;\n    Car car2;\n    \n    g_age &#x3D; 0;\n    car1.m_age &#x3D; 1;\n    car1.m_price &#x3D; 2;\n    car2.m_price &#x3D; 3;\n        \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编分析，静态成员变量</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; g_age &#x3D; 0;\nmov dword ptr ds:[00A9A318h], 0\t&#x3D;&gt; ds 数据段\n\n&#x2F;&#x2F; car1.m_age &#x3D; 1;\nmov dword ptr[car], 1\t&#x3D;&gt; mov dword ptr[ebp-8], 1\n\n&#x2F;&#x2F; car1.m_price &#x3D; 2;\nmov dword ptr[Car::m_price 00A9A314h)], 2\t&#x3D;&gt; mov dword ptr ds:[00A9A314h], 2\n\n&#x2F;&#x2F; car2.m_price &#x3D; 3;\nmov dword ptr[Car::m_price (00A9A314h)], 3\t&#x3D;&gt; mov dword ptr ds:[00A9A314h], 3</code></pre>\n</li>\n<li><p>总结：</p>\n<ul>\n<li>全局变量和类中的静态变量，都存放在数据区内，且程序运行时，仅有一份</li>\n<li>静态变量和全局变量的区别：<ul>\n<li>静态变量可以在类中定义，同时通过<code>public</code>, <code>protected</code>, <code>private</code>修饰其访问权限</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"12-3-静态成员应用\"><a href=\"#12-3-静态成员应用\" class=\"headerlink\" title=\"12.3 静态成员应用\"></a>12.3 静态成员应用</h4><h5 id=\"12-3-1-统计对象个数\"><a href=\"#12-3-1-统计对象个数\" class=\"headerlink\" title=\"12.3.1 统计对象个数\"></a>12.3.1 统计对象个数</h5><ul>\n<li><p>应用：无论在那个区域增加或删除对象，都能有一个唯一值去统计当前的对象个数</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    static int ms_count;\n\npublic:\n    Car()&#123;++ms_count;&#125;\n    ~Car()&#123;--ms_count;&#125;\n\n    static int getCount()&#123;return ms_count;&#125;\n&#125;;\nint Car::ms_count &#x3D; 0;\n\nCar g_car; &#x2F;&#x2F; 1\n\nint main()\n&#123;\n    Car car; &#x2F;&#x2F; 2\n    Car *p_car &#x3D; new Car; &#x2F;&#x2F; 3\n\n    cout &lt;&lt; Car::getCount() &lt;&lt; endl;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo2.exe\n3</code></pre></li>\n</ul>\n<h5 id=\"12-3-2-单例模式\"><a href=\"#12-3-2-单例模式\" class=\"headerlink\" title=\"12.3.2 单例模式\"></a>12.3.2 单例模式</h5><ul>\n<li><p>单例模式的构建：</p>\n<ul>\n<li>构造&#x2F;析构函数，私有化</li>\n<li>定义一个私有化的 static成员变量指向唯一得到单例对象</li>\n<li>提供一个公共的访问单例对象的接口</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Rocket\n&#123;\nprivate:\n    &#x2F;&#x2F; 构造&#x2F;析构函数，私有化\n    Rocket()&#123;&#125;\n    ~Rocket()&#123;&#125;\n\n    &#x2F;&#x2F; 定义一个私有化的 static成员变量指向唯一得到单例对象\n    static Rocket* ms_rocket;\n\npublic:\n    &#x2F;&#x2F; 提供一个公共的访问单例对象的接口\n    static Rocket* sharedRocket()\n    &#123;\n        &#x2F;&#x2F; 需要考虑多线程安全\n        if (ms_rocket &#x3D;&#x3D; NULL)\n        &#123;\n            ms_rocket &#x3D; new Rocket();\n        &#125;\n        return ms_rocket;\n    &#125;\n\n    &#x2F;&#x2F; 提供一个公共的访问单例对象的接口\n    static void deleteRocket()\n    &#123;\n        &#x2F;&#x2F; 需要考虑多线程安全\n        if (ms_rocket !&#x3D; NULL)\n        &#123;\n            ms_rocket &#x3D; NULL;\n            delete ms_rocket;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 测试用函数\n    void startRocket()&#123;cout &lt;&lt; &quot;Start Rocket&quot; &lt;&lt; endl;&#125;    \n&#125;;\nRocket* Rocket::ms_rocket &#x3D; NULL;\n\nint main()\n&#123;\n    Rocket *p_rocket_1 &#x3D; Rocket::sharedRocket();\n    Rocket *p_rocket_2 &#x3D; Rocket::sharedRocket();\n    Rocket *p_rocket_3 &#x3D; Rocket::sharedRocket();\n\n    cout &lt;&lt; p_rocket_1 &lt;&lt; &quot;\\n&quot; &lt;&lt; p_rocket_2 &lt;&lt; &quot;\\n&quot; &lt;&lt; p_rocket_3 &lt;&lt; endl;\n    p_rocket_1-&gt;startRocket();\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo3.exe\n0x8e6b80\n0x8e6b80\n0x8e6b80\nStart Rocket</code></pre>\n</li>\n<li><p>总结：由打印结果可看出，指向堆区的对象指针的地址始终不变，对象的单例模型已经实现</p>\n</li>\n<li><p>补充：delete</p>\n<ul>\n<li><code>new</code>是堆空间，开辟一块区域，用来存放数据</li>\n<li><code>delete</code>是删除堆空间开辟的区域，使得这片区域<code>可以被别的new使用</code>，但里面的数据<code>没有变化</code>，</li>\n<li>需要在delete之前或之后，使其初始化为<code>null</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"13-const成员\"><a href=\"#13-const成员\" class=\"headerlink\" title=\"13. const成员\"></a>13. const成员</h3><ul>\n<li><p>被<code>const修饰</code>的<code>成员</code>变量、<code>非静态</code>成员<code>函数</code></p>\n</li>\n<li><p><code>const</code>成员变量：</p>\n<ul>\n<li><code>必须</code>在<code>类内部初始化</code>，可以在声明时，直接赋值</li>\n<li><code>非static</code>的<code>const成员变量</code>还可以在初始化列表中初始化</li>\n</ul>\n</li>\n<li><p><code>const</code>成员函数：</p>\n<ul>\n<li><code>const</code>关键字写在参数列表后面，函数的声明和实现都要写<code>const</code><ul>\n<li>内部不能修改<code>非static</code>成员变量</li>\n<li>内部只能调用<code>const修饰</code>的成员函数，<code>static</code>成员函数</li>\n<li><code>非const</code>成员函数可以调用<code>const</code>成员函数</li>\n</ul>\n</li>\n<li><code>const</code>成员函数和<code>非const</code>成员函数<code>构成重载</code><ul>\n<li><code>非const</code>对象（<code>指针</code>）优先调用<code>非const</code>成员函数</li>\n</ul>\n</li>\n<li><code>const</code>对象（<code>指针</code>）只能调用<code>const</code>成员函数，<code>static</code>成员函数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"14-引用类型成员\"><a href=\"#14-引用类型成员\" class=\"headerlink\" title=\"14. 引用类型成员\"></a>14. 引用类型成员</h3><ul>\n<li>引用类型成员变量必须初始化（不考虑static）<ul>\n<li>在声明的时候直接初始化</li>\n<li>通过初始化列表初始化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-拷贝构造函数\"><a href=\"#15-拷贝构造函数\" class=\"headerlink\" title=\"15. 拷贝构造函数\"></a>15. 拷贝构造函数</h3><ul>\n<li>拷贝构造函数是构造函数的一种</li>\n<li>当利用已经存在的对象创建一个新对象时（类似于拷贝），就会调用对象的拷贝构造函数进行初始化</li>\n<li>拷贝构造函数的格式是固定的，接收一个<code>const</code>修饰的<code>引用类型</code>参数</li>\n</ul>\n<h4 id=\"15-1-默认拷贝构造函数\"><a href=\"#15-1-默认拷贝构造函数\" class=\"headerlink\" title=\"15.1 默认拷贝构造函数\"></a>15.1 默认拷贝构造函数</h4><ul>\n<li><p>代码示例：(默认拷贝构造函数)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    int m_price;\n    int m_length;\n\npublic:\n    Car(int price &#x3D; 0, int lenght &#x3D; 0) : m_price(price), m_length(lenght)&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;    \n\n    void display()&#123;cout &lt;&lt; &quot;price:&quot; &lt;&lt; m_price &lt;&lt; &quot; length: &quot; &lt;&lt; m_length &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Car car1(1, 1);\n    car1.display();\n\n    Car car2(car1);\n    car2.display();\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo1.exe\nCar::Car()\nprice:1 length: 1\nprice:1 length: 1</code></pre>\n</li>\n<li><p>反汇编查看原理：（默认构造函数）</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; x86环境\n&#x2F;&#x2F; Car car2(car1);\nmov eax, dword ptr[ebp-10h] &#x3D;&gt; 10h &#x3D; 16\nmov dword ptr[ebp-20h], eax &#x3D;&gt; 20h &#x3D; 32\n&#x2F;&#x2F; &#x3D;&gt; car2.m_prcie &#x3D; car1.m_price;\n\nmov ecx, dword ptr[ebp-0Ch] &#x3D;&gt; 0Ch &#x3D; 12\nmov dword ptr[ebo-1Ch], ecx &#x3D;&gt; 1Ch &#x3D; 28\n&#x2F;&#x2F; &#x3D;&gt; car2.m_length &#x3D; car1.m_length;\n\n&#x2F;&#x2F; car2.display();\nlea ecx, [ebp-20h]\ncall 0024141A\n\n\n&#x2F;&#x2F; x64环境\n&#x2F;&#x2F; Car car2(car1);\nmov rax, qword ptr[rbp+8] &#x3D;&gt; 8h &#x3D; 8\nmov qword ptr[rbp+28h], rax &#x3D;&gt; 28h &#x3D; 40\n\n&#x2F;&#x2F; car2.display();\nlea rcx, [rbp+28h]\ncall 00007FF685AF12FD</code></pre></li>\n</ul>\n<h4 id=\"15-2-自定义拷贝构造函数\"><a href=\"#15-2-自定义拷贝构造函数\" class=\"headerlink\" title=\"15.2 自定义拷贝构造函数\"></a>15.2 自定义拷贝构造函数</h4><ul>\n<li><p>代码示例：（自定义拷贝构造函数）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    int m_price;\n    int m_length;\n\npublic:\n    Car(int price &#x3D; 0, int lenght &#x3D; 0) : m_price(price), m_length(lenght)&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;    \n    Car(const Car &amp;car) : m_price(car.m_price), m_length(car.m_length)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;\n\n    void display()&#123;cout &lt;&lt; &quot;price:&quot; &lt;&lt; m_price &lt;&lt; &quot; length: &quot; &lt;&lt; m_length &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Car car1(1, 1);\n    car1.display();\n\n    Car car2(car1);\n    car2.display();\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo1.exe\nCar::Car()\nprice:1 length: 1\nCar::Car(const)\nprice:1 length: 1</code></pre></li>\n</ul>\n<h4 id=\"15-3-调用父类拷贝构造函数\"><a href=\"#15-3-调用父类拷贝构造函数\" class=\"headerlink\" title=\"15.3 调用父类拷贝构造函数\"></a>15.3 调用父类拷贝构造函数</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int m_age;\n\n    Person(int age) : m_age(age)&#123;&#125;;\n    Person(const Person &amp;person) : m_age(person.m_age)&#123;&#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic:\n    int m_score;\n    \n    Student(int age, int score) : Person(age), m_score(score)&#123;&#125;       \n    Student(const Student &amp;student) : Person(student), m_score(student.m_score)&#123;&#125;\n&#125;;\n\nint main()\n&#123;\n    Student stu1(1, 100);\n    Student stu2(stu1);\n\n    cout &lt;&lt; stu2.m_age &lt;&lt; &quot; &quot; &lt;&lt; stu2.m_score &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo2.exe\n1 100</code></pre>\n</li>\n<li><p>补充：如果是完全拷贝对象内的数据，可以直接使用默认拷贝构造函数</p>\n</li>\n</ul>\n<h4 id=\"15-4-浅复制\"><a href=\"#15-4-浅复制\" class=\"headerlink\" title=\"15.4 浅复制\"></a>15.4 浅复制</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Student\n&#123;\npublic:\n    int m_score;\n    \n    Student(int score &#x3D; 0) : m_score(score)&#123;cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;&#125;       \n    Student(const Student &amp;student) : m_score(student.m_score)&#123;cout &lt;&lt; &quot;Student::Student(const Student &amp;student)&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 默认构造\n    Student s1(10);\n    \n    &#x2F;&#x2F; 拷贝构造\n    Student s2(s1);\n    &#x2F;&#x2F; 拷贝构造 &#x3D;&gt; 创建对象的同时，将 s2 的数据给 s3，符合拷贝构造\n    Student s3 &#x3D; s2;\n    \n    &#x2F;&#x2F; 浅复制 &#x3D;&gt; 创建了对象，但没有利用已经存在的对象进赋值，所以是 默认构造\n    Student s4;\n    s4 &#x3D; s3; &#x2F;&#x2F; 此时的两个对象都是 已经存在的对象，不是拷贝g\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo3.exe\nStudent::Student()\nStudent::Student(const Student &amp;student)\nStudent::Student(const Student &amp;student)\nStudent::Student()</code></pre></li>\n</ul>\n<h4 id=\"15-5-浅-x2F-深拷贝\"><a href=\"#15-5-浅-x2F-深拷贝\" class=\"headerlink\" title=\"15.5 浅&#x2F;深拷贝\"></a>15.5 浅&#x2F;深拷贝</h4><h5 id=\"15-5-1-解决浅拷贝问题\"><a href=\"#15-5-1-解决浅拷贝问题\" class=\"headerlink\" title=\"15.5.1 解决浅拷贝问题\"></a>15.5.1 解决浅拷贝问题</h5><ul>\n<li><p>编译器默认的都是浅拷贝</p>\n</li>\n<li><p>浅拷贝的缺点：</p>\n<ul>\n<li>如果出现堆空间指向栈空间，那么浅拷贝后，堆空间内存储着栈空间的地址</li>\n<li>栈空间的生命周期是不可控制的，可能会使得堆空间指向栈空间的指针变成野指针</li>\n</ul>\n</li>\n<li><p>代码示例：解决浅拷贝的问题</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    int m_price;\n    char *m_name;\n\npublic:\n    Car(int price &#x3D; 0, const char *name &#x3D; nullptr) : m_price(price)\n    &#123;\n        if (name &#x3D;&#x3D; nullptr)&#123;return;&#125;\n\n        m_name &#x3D; new char[strlen(name) + 1]&#123;&#125;;\n        strcpy(m_name, name);\n    &#125;    \n    ~Car()\n    &#123;\n        if (m_name &#x3D;&#x3D; nullptr)&#123;return;&#125;\n        m_name &#x3D; nullptr;\n        delete[] m_name;\n    &#125;\n\n    void printInfo()&#123;cout &lt;&lt; m_price &lt;&lt; &quot; &quot; &lt;&lt; m_name &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    char name[] &#x3D; &#123;&#39;b&#39;, &#39;w&#39;, &#39;m&#39;, &#39;\\0&#39;&#125;;\n    Car *car &#x3D; new Car(100, name);\n    car-&gt;printInfo();\n\n    Car *car2 &#x3D; new Car(200, &quot;bwm&quot;);\n    car2-&gt;printInfo();\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo4.exe\n100 bwm\n200 bwm</code></pre></li>\n</ul>\n<h5 id=\"15-5-2-深拷贝\"><a href=\"#15-5-2-深拷贝\" class=\"headerlink\" title=\"15.5.2 深拷贝\"></a>15.5.2 深拷贝</h5><ul>\n<li><p>使用深拷贝的原因：</p>\n<ul>\n<li>当类中有数据会在堆空间中开辟，且在类的对象析构时释放时</li>\n<li>此时这个类已有一个对象，而新的对象利用已有的对象进行默认的拷贝构造（浅拷贝）</li>\n<li>此时，两个对象的某一个指向堆空间的成员变量，所指的地址相同</li>\n<li>当其中一个对象释放，另一个对象中的某个指向堆空间的成员变量也会被释放，使得另一个对象中的成员变量无效化</li>\n<li>如果两个对象都释放，则会出现同一个堆空间，两次释放</li>\n</ul>\n</li>\n<li><p>深拷贝定义：</p>\n<ul>\n<li>将指针指向的内容拷贝到新的存储空间</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    int m_price;\n    char *m_name;\n    void copy(const char *name &#x3D; nullptr)\n    &#123;\n        if (name &#x3D;&#x3D; nullptr)&#123;return;&#125;\n\n        m_name &#x3D; new char[strlen(name) + 1]&#123;&#125;;\n        strcpy(m_name, name);\n    &#125;\n\npublic:\n    Car(int price &#x3D; 0, const char *name &#x3D; nullptr) : m_price(price)&#123;copy(name);&#125;    \n    Car(const Car &amp;car) : m_price(car.m_price)&#123;copy(car.m_name);&#125;\n    ~Car()\n    &#123;\n        if (m_name &#x3D;&#x3D; nullptr)&#123;return;&#125;\n        m_name &#x3D; nullptr;\n        delete[] m_name;\n    &#125;\n\n    void printInfo()&#123;cout &lt;&lt; m_price &lt;&lt; &quot; &quot; &lt;&lt; m_name &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Car car1(100, &quot;bwm&quot;);\n    Car car2 &#x3D; car1;\n    car2.printInfo();\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo5.exe\n100 bwm</code></pre></li>\n</ul>\n<h3 id=\"16-对象类型参数和返回值\"><a href=\"#16-对象类型参数和返回值\" class=\"headerlink\" title=\"16. 对象类型参数和返回值\"></a>16. 对象类型参数和返回值</h3><ul>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    Car()&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;\n    Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;    \n&#125;;\n\nvoid test(Car car)&#123;&#125;\n\nint main()\n&#123;\n    Car car1;\n    test(car1);\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo6.exe\nCar::Car() &#x2F;&#x2F; Car car1;\nCar::Car(const) &#x2F;&#x2F; Car car &#x3D; car1;</code></pre>\n\n\n\n\n\n\n</li>\n<li><p>代码示例2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    Car()&#123;cout &lt;&lt; &quot;Car::Car() &quot;&lt;&lt; this &lt;&lt; endl;&#125;    \n    Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const) &quot; &lt;&lt; this &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test1(Car car)&#123;&#125;\n\nCar test2()\n&#123;\n    Car car;\n    return car;\n&#125;\n\nint main()\n&#123;\n    Car car;\n    test1(car);\n\n    cout &lt;&lt; endl;\n\n    Car car1;\n    car1 &#x3D; test2();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo6.exe\nCar::Car() 0x7bfe1d\nCar::Car(const) 0x7bfe1e\n\nCar::Car() 0x7bfe1c\nCar::Car() 0x7bfe1f</code></pre></li>\n</ul>\n<h3 id=\"17-匿名对象\"><a href=\"#17-匿名对象\" class=\"headerlink\" title=\"17. 匿名对象\"></a>17. 匿名对象</h3><ul>\n<li><p>又名：临时对象</p>\n</li>\n<li><p>没有名称，不被指针指向，一次性使用，立即销毁</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    Car()&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;\n    Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;    \n    ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test(Car car)&#123;&#125;\n\nint main()\n&#123;\n    test(Car());\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo1.exe\nCar::Car()\nCar::~Car()</code></pre></li>\n</ul>\n<h3 id=\"18-隐式构造\"><a href=\"#18-隐式构造\" class=\"headerlink\" title=\"18. 隐式构造\"></a>18. 隐式构造</h3><ul>\n<li><p>又名：转换构造</p>\n</li>\n<li><p>在某些情况下，会隐式调用单参数的构造函数</p>\n</li>\n<li><p>通过关键字<code>explicit</code>禁用隐式构造</p>\n</li>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:\n    int m_age;    \npublic:\n    Person()&#123;cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;&#125;\n    Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Car::Car(int)&quot; &lt;&lt; endl;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test(Person person)&#123;&#125;\nPerson test2()&#123;return 40;&#125;\n\nint main()\n&#123;\n    Person p1 &#x3D; 20;\n    test2();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; g++ demo2.cpp -o demo2; .\\demo2\nCar::Car(int)\nCar::Car(int)\nPerson::~Person()\nPerson::~Person()</code></pre>\n\n\n\n\n</li>\n<li><p>代码示例2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:\n    int m_age;    \npublic:\n    Person()&#123;cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;&#125;\n    explicit Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Car::Car(int)&quot; &lt;&lt; endl;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test(Person person)&#123;&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; Person p1 &#x3D; 20; &#x2F;&#x2F; 此时这样的写法被 禁用\n    Person p1(20);\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; g++ demo3.cpp -o demo3; .\\demo3\nCar::Car(int)\nPerson::~Person()</code></pre></li>\n</ul>\n<h3 id=\"19-编译器自动生成的构造函数\"><a href=\"#19-编译器自动生成的构造函数\" class=\"headerlink\" title=\"19. 编译器自动生成的构造函数\"></a>19. 编译器自动生成的构造函数</h3><ul>\n<li><p>C++编译器会在特定的情况下，会给类自动生成无参的构造函数</p>\n<ul>\n<li>成员变量在声明时，初始化</li>\n<li>有定义虚函数</li>\n<li>虚继承了其它类</li>\n<li>包含了对象类型的成员，且这个成员有构造函数（可以是编译器自动生成的，或自定义的）</li>\n</ul>\n</li>\n<li><p>总结：</p>\n<ul>\n<li>对象创建后，需要进行一些额外的操作（内存操作，函数调用，成员变量初始化，虚函数，虚继承，调用父类构造等等）</li>\n<li>编译器都会自动生成无参的构造函数</li>\n</ul>\n</li>\n<li><p>代码示例1：成员变量在声明时，初始化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    int m_age &#x3D; 5;    \n&#125;;\n\n&#x2F;&#x2F; 此段代码 完全等价 上面的写法\n&#x2F;*\nclass Car\n&#123;\npublic:\n    int m_age &#x3D; 5;    \n    Car()&#123;m_age &#x3D; 5;&#125;\n&#125;;\n*&#x2F;\n\nint main()\n&#123;\n    Car car;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编查看：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; Car car;\nlea ecx, [car]\ncall Car::Car(0A1384h)\n\nmov dword ptr[eax], 5\nmov eax, dword ptr[this]</code></pre>\n\n\n\n\n</li>\n<li><p>代码示例2：有定义虚函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    int m_age;  \n    virtual void run()&#123;&#125;\n&#125;;\n\nint main()\n&#123;\n    Car car;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编查看：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">lea ecx, [car]\ncall Car::Car(0E5111Dh)\n\nmov dword ptr[this], ecx\nmov eax, dword ptr[this]\nmov dword ptr[eax], offset Car::&#96;vftable&#96;(0E57B34h) &#x2F;&#x2F; vftable &#x3D;&#x3D; virtual function table 虚函数表\nmov eax, dword ptr[this]</code></pre>\n\n\n\n\n</li>\n<li><p>代码示例3：虚继承了其它类</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int m_age;  \n    void run()&#123;&#125;\n&#125;;\n\nclass Student : virtual public Person\n&#123;\npublic:\n    int m_score;\n&#125;;\n\nint main()\n&#123;\n    Student student;\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编查看：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">lea ecx, [student]\ncall Student::Student(012213A7h)\n\nmov eax, dword ptr[this]\nmov dword ptr[eax], offset Student::&#96;vftable&#96;(01227B30h)\nmov eax, dword ptr[this]</code></pre></li>\n</ul>\n<h3 id=\"20-友元\"><a href=\"#20-友元\" class=\"headerlink\" title=\"20. 友元\"></a>20. 友元</h3><ul>\n<li><p>友元包括：</p>\n<ul>\n<li>友元函数<ul>\n<li>如果将函数A（非成员函数）声明为类B的友元函数，那么函数A内部可以直接访问类B对象的所有成员</li>\n</ul>\n</li>\n<li>友元类<ul>\n<li>类A内声明了类B的友元，类B可以访问类A的所有成员</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>代码示例1：友元函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\n    &#x2F;&#x2F; 声明 友元函数\n    friend Point add_P(Point &amp;, Point &amp;);  \n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n    void printPoint()&#123;cout &lt;&lt; m_x &lt;&lt; &quot; &quot; &lt;&lt; m_y &lt;&lt; endl;&#125;    \n&#125;;\n\n&#x2F;&#x2F; 实现 友元函数\nPoint add_P(Point &amp;p1, Point &amp;p2)\n&#123;\n    return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);\n&#125;\n\nint main()\n&#123;\n    Point p1(10, 10);\n    Point p2(20, 20);\n    Point p3(add_P(p1, p2));\n    p3.printPoint();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo5\n30 30</code></pre>\n\n\n\n\n</li>\n<li><p>代码示例2：友元类</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n    \n    &#x2F;&#x2F; 声明 友元类\n    friend class FH_Math;\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n    void printPoint()&#123;cout &lt;&lt; m_x &lt;&lt; &quot; &quot; &lt;&lt; m_y &lt;&lt; endl;&#125;    \n&#125;;\n\n&#x2F;&#x2F; 实现 友元类\nclass FH_Math\n&#123;\npublic:    \n    Point add_P(Point &amp;p1, Point &amp;p2)\n    &#123;\n        return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Point p1(10, 10);\n    Point p2(20, 20);\n    Point p3 &#x3D; FH_Math().add_P(p1, p2);\n    p3.printPoint();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo6\n30 30</code></pre></li>\n</ul>\n<h3 id=\"21-内部类\"><a href=\"#21-内部类\" class=\"headerlink\" title=\"21. 内部类\"></a>21. 内部类</h3><h4 id=\"21-1-内部类的定义\"><a href=\"#21-1-内部类的定义\" class=\"headerlink\" title=\"21.1 内部类的定义\"></a>21.1 内部类的定义</h4><ul>\n<li><p>定义：</p>\n<ul>\n<li>类B定义在类A中，B就是A的内部类（嵌套类）</li>\n<li>类A就是B的外部类</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<ul>\n<li>支持：<code>public</code>, <code>protected</code>, <code>private</code>权限</li>\n<li>内部类成员函数可以访问外部类所有成员</li>\n<li>外部类则无法访问内部类的成员</li>\n<li>成员函数可以直接不带类名，对象名访问其外部类的<code>static修饰</code>的成员</li>\n<li>不会影响外部类的内存布局</li>\n</ul>\n</li>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    void test1()&#123;cout &lt;&lt; &quot;Person::test1()&quot; &lt;&lt; endl;&#125;\n    static void test2()&#123;cout &lt;&lt; &quot;Person::test2(static)&quot; &lt;&lt; endl;&#125;\n\npublic:\n    class Student\n    &#123;\n    private:\n        int m_id;\n\n    public:        \n        void test3()&#123;test2();&#125;        \n    &#125;;\n&#125;;\n\n\nint main()\n&#123;\n    Person::Student s;\n    s.test3();\n\n    cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n    cout &lt;&lt; sizeof(Person::Student) &lt;&lt; endl;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo1\nPerson::test2(static)\n4\n4</code></pre></li>\n</ul>\n<h4 id=\"21-2-内部类声明与实现分离\"><a href=\"#21-2-内部类声明与实现分离\" class=\"headerlink\" title=\"21.2 内部类声明与实现分离\"></a>21.2 内部类声明与实现分离</h4><ul>\n<li>跟正常的函数声明和实现分离差不多</li>\n<li>标明类的作用域就可以了</li>\n</ul>\n<h3 id=\"22-局部类\"><a href=\"#22-局部类\" class=\"headerlink\" title=\"22. 局部类\"></a>22. 局部类</h3><ul>\n<li>在一个函数中定义一个类：局部类</li>\n<li>特点：<ul>\n<li>作用域仅限于所在的函数内部，不允许<code>static修饰</code>成员</li>\n<li>局部类的成员函数不能直接访问所在函数的局部变量（<code>static</code>可以）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"23-运算符重载\"><a href=\"#23-运算符重载\" class=\"headerlink\" title=\"23. 运算符重载\"></a>23. 运算符重载</h3><ul>\n<li>注意：<ul>\n<li>有些运算符不可以重载：<ul>\n<li>对象成员访问运算符<code>.</code></li>\n<li>域运算符<code>::</code></li>\n<li>三目运算符<code>?</code></li>\n<li><code>sizeof</code></li>\n</ul>\n</li>\n<li>有些运算符只能重载为成员函数：<ul>\n<li>赋值运算符<code>=</code></li>\n<li>下标运算符<code>[]</code></li>\n<li>函数运算符<code>()</code></li>\n<li>指针访问成员<code>-&gt;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"23-1-基本运算符重载\"><a href=\"#23-1-基本运算符重载\" class=\"headerlink\" title=\"23.1 基本运算符重载\"></a>23.1 基本运算符重载</h4><ul>\n<li><p>作用：给运算符增加一些新的功能</p>\n</li>\n<li><p>设计思路：</p>\n<ul>\n<li>如果仅和类相关，重载运算符函数优先写在类里面</li>\n<li>如果是<code>&lt;&lt;</code>，<code>&gt;&gt;</code>的重载，尽量写成全局函数</li>\n</ul>\n</li>\n<li><p>代码示例1：<code>+, -</code>, <code>+=, -=</code>, <code>==, !=</code>, <code>-</code>, <code>++, --</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n\n    void showPoint()&#123;cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;         \n\n    &#x2F;&#x2F; operator +, -\n    const Point operator+(const Point &amp;point) const\n    &#123;\n        return Point(this-&gt;m_x + point.m_x, this-&gt;m_y + point.m_y);\n    &#125;\n\n    &#x2F;&#x2F; operator +&#x3D;, -&#x3D;\n    Point &amp;operator+&#x3D;(const Point &amp;point)\n    &#123;\n        this-&gt;m_x +&#x3D; point.m_x;\n        this-&gt;m_y +&#x3D; point.m_y;\n        return *this;\n    &#125;\n\n    &#x2F;&#x2F; operator &#x3D;&#x3D;, !&#x3D;\n    const bool operator&#x3D;&#x3D;(const Point &amp;point)\n    &#123;\n        return (this-&gt;m_x &#x3D;&#x3D; point.m_x &amp;&amp; this-&gt;m_y &#x3D;&#x3D; point.m_y);\n    &#125;\n\n    &#x2F;&#x2F; operator -\n    const Point operator-() const\n    &#123;\n        return Point(-m_x, -m_y);\n    &#125;\n\n    &#x2F;&#x2F; operator ++, --\n    Point &amp;operator++()\n    &#123;\n        ++this-&gt;m_x;\n        ++this-&gt;m_y;\n        return *this;\n    &#125;\n    const Point operator++(int)\n    &#123;\n        Point origin_P(this-&gt;m_x, this-&gt;m_y);\n        ++this-&gt;m_x;\n        ++this-&gt;m_y;\n        return origin_P;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; operator +, -\n    cout &lt;&lt; &quot;operator +, -&quot; &lt;&lt; endl;\n    Point p1(10, 10);\n    Point p2(20, 20);\n    Point p3 &#x3D; p1 + p2;\n    Point p4 &#x3D; p1 + p2 + p3;\n    p4.showPoint();\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator +&#x3D;, -&#x3D;\n    cout &lt;&lt; &quot;operator +&#x3D;, -&#x3D;&quot; &lt;&lt; endl;\n    Point p5(1, 1);\n    Point p6(2, 2);\n    Point p7;\n    (p7 +&#x3D; p5) &#x3D; p6;\n    p4.showPoint();\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator &#x3D;&#x3D;, !&#x3D;\n    cout &lt;&lt; &quot;operator &#x3D;&#x3D;, !&#x3D;&quot; &lt;&lt; endl;\n    Point p8(1, 1);\n    Point p9(1, 1);\n    cout &lt;&lt; (p1 &#x3D;&#x3D; p2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator -\n    cout &lt;&lt; &quot;operator -&quot; &lt;&lt; endl;\n    Point p10(1, 1);\n    Point p11(0, 0);\n    Point p12;\n    p11 &#x3D; -p10;\n    p10.showPoint();\n    p11.showPoint();\n    p12 &#x3D; -(-p1);\n    p12.showPoint();\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator ++, --\n    cout &lt;&lt; &quot;&#x2F;&#x2F; operator ++, --&quot; &lt;&lt; endl;\n    Point p13(1, 1);\n    Point p14(0, 0);\n    Point p15(2, 2);\n    ++p13;\n    p13++;\n    p13.showPoint();\n    p14 &#x3D; (p13++) + p15;\n    p14.showPoint();\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo3\noperator +, -\n(60, 60)\n---------\noperator +&#x3D;, -&#x3D;\n(60, 60)\n---------\noperator &#x3D;&#x3D;, !&#x3D;\nfalse\n---------\noperator -\n(1, 1)\n(-1, -1)\n(10, 10)\n---------\n&#x2F;&#x2F; operator ++, --\n(3, 3)\n(5, 5)\n---------</code></pre>\n\n\n</li>\n<li><p>代码示例2：<code>&lt;&lt;</code> <code>&gt;&gt;</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n \n    &#x2F;&#x2F; operator &lt;&lt;, &gt;&gt;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);\n    friend istream &amp;operator&gt;&gt;(istream &amp;cin, Point &amp;point);\n&#125;;\n\nostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)\n&#123;\n    cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;\n    return cout;\n&#125;\n\nistream &amp;operator&gt;&gt;(istream &amp;cin, Point &amp;point)\n&#123;\n    cout &lt;&lt; &quot;input m_x: &quot;;\n    cin &gt;&gt; point.m_x;\n\n    cout &lt;&lt; &quot;input m_y: &quot;;\n    cin &gt;&gt; point.m_y;\n    return cin;\n\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; operator &lt;&lt;, &gt;&gt;\n    cout &lt;&lt; &quot;operator &lt;&lt;&quot; &lt;&lt; endl;\n    Point p1(10, 10);\n    cout &lt;&lt; p1 &lt;&lt; endl;\n    cout &lt;&lt; p1 &lt;&lt; p1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;operator &gt;&gt;&quot; &lt;&lt; endl;\n    Point p2;\n    Point p3;\n    cin &gt;&gt; p2 &gt;&gt; p3;\n    cout &lt;&lt; p2 &lt;&lt; &quot;\\n&quot; &lt;&lt; p3 &lt;&lt; endl;\n    cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo4    \noperator &lt;&lt;\n(10, 10)\n(10, 10)(10, 10)\n--------\noperator &gt;&gt;\ninput m_x: 1\ninput m_y: 1\ninput m_x: 2\ninput m_y: 2\n(1, 1)\n(2, 2)\n--------</code></pre></li>\n</ul>\n<h4 id=\"23-2-调用父类的运算符重载\"><a href=\"#23-2-调用父类的运算符重载\" class=\"headerlink\" title=\"23.2 调用父类的运算符重载\"></a>23.2 调用父类的运算符重载</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    int m_age;\n\n    Person &amp;operator&#x3D;(const Person &amp;person)\n    &#123;\n        this-&gt;m_age &#x3D; person.m_age;\n        return *this;\n    &#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic: \n    int m_score;\n\n    Student &amp;operator&#x3D;(const Student &amp;student)\n    &#123;\n        Person::operator&#x3D;(student);\n        this-&gt;m_score &#x3D; student.m_score;\n        return *this;\n    &#125;\n\n    void showInfo()\n    &#123;\n        cout &lt;&lt; m_age &lt;&lt; &quot; &quot; &lt;&lt; m_score &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Student s1;\n    s1.m_age &#x3D; 10;\n    s1.m_score &#x3D; 20;\n\n    Student s2 &#x3D; s1;\n    s2.showInfo();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo5\n10 20</code></pre></li>\n</ul>\n<h4 id=\"23-3-仿函数\"><a href=\"#23-3-仿函数\" class=\"headerlink\" title=\"23.3 仿函数\"></a>23.3 仿函数</h4><ul>\n<li><p>定义：</p>\n<ul>\n<li>仿函数(<code>functor</code>)，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个<code>operator</code>这个类就有了类似函数的行为</li>\n<li>将一个对象，作为一个函数来使用</li>\n<li>对比普通的函数，仿函数可以保存状态</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Sum\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    int operator()(int a &#x3D; 0, int b &#x3D; 0)\n    &#123;\n        return a + b;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Sum s1;\n    cout &lt;&lt; s1(10, 20) &lt;&lt; endl;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印示例：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo1\n30</code></pre></li>\n</ul>\n<h3 id=\"24-模板\"><a href=\"#24-模板\" class=\"headerlink\" title=\"24. 模板\"></a>24. 模板</h3><ul>\n<li>泛型：一种类型参数化以达到代码复用的技术</li>\n<li>种类：<code>函数模板</code>，<code>类模板</code></li>\n<li>模板没有被使用，不会被实例化</li>\n</ul>\n<h4 id=\"24-1-函数模板定义\"><a href=\"#24-1-函数模板定义\" class=\"headerlink\" title=\"24.1 函数模板定义\"></a>24.1 函数模板定义</h4><ul>\n<li><p>代码示例：<code>函数模板</code>, <code>多参数函数模板</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n\n    Point operator+(const Point &amp;point)\n    &#123;\n        return Point(this-&gt;m_x + point.m_x, this-&gt;m_y + point.m_y);\n    &#125;         \n&#125;;\n\nostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)\n&#123;\n    return cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;\n&#125;\n\n&#x2F;&#x2F; 函数模板\ntemplate&lt;typename T&gt;\nT add(T a, T b)\n&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 多参数函数模板\ntemplate&lt;typename T_int, typename T_double&gt;\nT_double add(T_int a, T_double b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; add&lt;int&gt;(1, 2) &lt;&lt; endl;\n    cout &lt;&lt; add&lt;int, double&gt;(1, 2.1) &lt;&lt; endl;\n    cout &lt;&lt; add&lt;Point&gt;(Point(1, 1), Point(2, 2)) &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo1\n3\n3.1\n(3, 3)</code></pre></li>\n</ul>\n<h4 id=\"24-2-函数模板分离\"><a href=\"#24-2-函数模板分离\" class=\"headerlink\" title=\"24.2 函数模板分离\"></a>24.2 函数模板分离</h4><ul>\n<li><p>编译基本过程：</p>\n<ul>\n<li>先把<code>A.cpp</code>包含的<code>A.h</code>的内容复制到<code>A.cpp</code>中<code>(声明和实现回到同一个cpp文件中)</code></li>\n<li>再编译<code>main.cpp</code>和<code>A.cpp</code>成<code>main.obj</code>和<code>A.obj</code></li>\n<li>再通过<code>main.ilk</code>链接<code>main.cpp</code>和<code>A.cpp</code></li>\n<li>修正了<code>main.cpp</code>中调用<code>A.cpp</code>中函数时，<code>call的函数地址</code></li>\n<li>最后生成<code>main.exe</code></li>\n</ul>\n</li>\n<li><p>代码示例：<code>模板的错误编译</code></p>\n</li>\n<li><p><code>add.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template&lt;typename T&gt;\nT add(T a, T b);</code></pre>\n</li>\n<li><p><code>add.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &#39;add.h&#39;\n\nT add(T a, T b)\n&#123;\n    return a + b;\n&#125;</code></pre>\n</li>\n<li><p><code>main.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &#39;add.h&#39;\nusing namespace std;\n\nint main()\n&#123;\n    add(1, 2);\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>以上代码编译不会报错，但<code>链接</code>报错，不会生成<code>.exe</code></p>\n</li>\n<li><p>原因：</p>\n<ul>\n<li><code>模板没有被使用，不会被实例化</code></li>\n<li>所以<code>add.cpp</code>在编译过程中，编译器未发现在<code>add.cpp</code>中有使用<code>add()</code>模板函数的地方</li>\n<li>于是，便将<code>add.h</code>和<code>add.cpp</code>中未被使用的<code>add()</code>模板函数优化了<code>(即便链接后，add()在main.cpp中被使用)</code></li>\n<li>链接后，<code>main.cpp</code>中调用<code>add()</code>函数，得不到有效的<code>函数实现地址(此时main.cpp中是有函数声明的，因为包含了add.h)</code>，所以会报错</li>\n</ul>\n</li>\n<li><p>代码示例：<code>正确的写法</code></p>\n</li>\n<li><p><code>add.h</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template&lt;typename T&gt;\nT add(T a, T b)\n&#123;\n    return a + b;\n&#125;</code></pre>\n</li>\n<li><p><code>main.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &#39;add.h&#39;\nusing namespace std;\n\nint main()\n&#123;\n    add(1, 2);\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>写模板函数时，不要进行声明实现分离，全部写在<code>.h</code>中，正规的方式是<code>.hpp</code></p>\n</li>\n</ul>\n<h4 id=\"24-3-类模板的定义\"><a href=\"#24-3-类模板的定义\" class=\"headerlink\" title=\"24.3 类模板的定义\"></a>24.3 类模板的定义</h4><ul>\n<li><p>注意：类模板中的友元函数声明</p>\n<ul>\n<li>需先声明类和友元函数的模板</li>\n<li>再实现友元函数</li>\n<li>且最好友元函数的模板参数和类模板的参数类型不同</li>\n<li>另一种方式：声明和实现中都要在<code>&lt;&lt;</code>后加入<code>&lt;&gt;</code><ul>\n<li><code>ostream &amp;operator&lt;&lt; &lt;&gt;(ostream &amp;cout, const Array&lt;Arr&gt; &amp;arr);</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n</li>\n<li><p><code>array.hpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2022&#x2F;3&#x2F;9 14:06\n&#x2F;&#x2F;\n#ifndef INC_8_CPP_STRUCTURE_SEQLIST_HPP\n#define INC_8_CPP_STRUCTURE_SEQLIST_HPP\n\nusing std::cout;\nusing std::endl;\n\n#define MAXSIZE 100\n\ntemplate&lt;typename tab_T&gt;\nclass SeqList;\ntemplate&lt;typename T&gt;\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab);\n\ntemplate &lt;typename tab_T&gt;\nclass SeqList\n&#123;\nprivate:\n    tab_T *m_tabData;\n    int m_capacity;\n    int m_size;\n\npublic:\n    explicit SeqList(int capacity);\n    ~SeqList();\n\n    int size() const;\n    tab_T get(int index) const;\n    void add(tab_T value);\n    void insert(int i, tab_T value);\n    void remove(int i);\n    void removeByRange(int i, int range);\n    void replaceByValue(tab_T tagValue, tab_T newValue);\n\n    tab_T operator[](int index) const;\n    template&lt;typename T&gt;\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab);\n&#125;;\n\ntemplate&lt;typename tab_T&gt;\nSeqList&lt;tab_T&gt;::SeqList(int capacity)\n&#123;\n    m_capacity &#x3D; (capacity &gt; 0) ? capacity : MAXSIZE;\n    m_tabData &#x3D; new tab_T[m_capacity];\n    if (m_tabData &#x3D;&#x3D; nullptr)&#123;return;&#125;\n    else&#123;cout &lt;&lt; &quot;&lt;-- SeqList Created --&gt;\\n&quot;;&#125;\n    m_size &#x3D; 0;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nSeqList&lt;tab_T&gt;::~SeqList()\n&#123;\n    if (m_tabData &#x3D;&#x3D; nullptr)&#123;return;&#125;\n    else&#123;cout &lt;&lt; &quot;&lt;-- SeqList Deleted --&gt;\\n&quot;;&#125;\n    delete[] m_tabData;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nint SeqList&lt;tab_T&gt;::size() const\n&#123;\n    return m_size;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\ntab_T SeqList&lt;tab_T&gt;::get(int index) const\n&#123;\n    if (index &lt; 0 || index &gt;&#x3D; m_size)\n    &#123;\n        throw(&quot;&lt;&lt; !!! 数组下标越界 !!! &gt;&gt;&quot;);\n    &#125;\n    return m_tabData[index];\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::add(tab_T value)\n&#123;\n    if (m_size &gt;&#x3D; m_capacity)\n    &#123;\n        &#x2F;&#x2F;TODO Reset Capacity\n    &#125;\n    m_tabData[m_size] &#x3D; value;\n    ++m_size;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::insert(int i, tab_T value)\n&#123;\n    if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;\n    if (m_size &#x3D;&#x3D; MAXSIZE)&#123;return;&#125;\n\n    for (int j &#x3D; m_size - 1; j &gt;&#x3D; i - 1; --j)\n    &#123;\n        m_tabData[j + 1] &#x3D; m_tabData[j];\n    &#125;\n    m_tabData[i] &#x3D; value;\n    ++m_size;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::remove(int i)\n&#123;\n    if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;\n    \n    for (int j &#x3D; i; j &lt;&#x3D; m_size -1; ++j)\n    &#123;\n        m_tabData[j] &#x3D; m_tabData[j + 1];\n    &#125;\n    --m_size;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::removeByRange(int i, int range)\n&#123;\n     if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;\n\n     for (int j &#x3D; i; j &lt;&#x3D; m_size - 1; ++j)\n     &#123;\n         m_tabData[j] &#x3D; m_tabData[j + range];\n     &#125;\n     m_size -&#x3D; range;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::replaceByValue(tab_T tagValue, tab_T newValue)\n&#123;\n    for (int i &#x3D; 0; i &lt; m_size; ++i)\n    &#123;\n        if (m_tabData[i] &#x3D;&#x3D; tagValue)\n        &#123;\n            m_tabData[i] &#x3D; newValue;\n        &#125;\n    &#125;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\ntab_T SeqList&lt;tab_T&gt;::operator[](int index) const\n&#123;\n    return get(index);\n&#125;\n\ntemplate&lt;typename T&gt;\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab)\n&#123;\n    int size &#x3D; tab.size();\n    f_cout &lt;&lt; &quot;[&quot;;\n    for (int i &#x3D; 0; i &lt; size; ++i)\n    &#123;\n        if (i !&#x3D; 0)&#123;f_cout &lt;&lt; &quot;,&quot;;&#125;\n        f_cout &lt;&lt; tab[i];\n    &#125;\n    return f_cout &lt;&lt; &quot;]&quot;;\n&#125;\n\n#endif &#x2F;&#x2F;INC_8_CPP_STRUCTURE_SEQLIST_HPP</code></pre>\n\n\n\n<p><code>Main.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2022&#x2F;3&#x2F;9 14:06\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &quot;SeqList.hpp&quot;\n\nint main()\n&#123;\n    SeqList&lt;int&gt; seqList(10);\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        seqList.add(1);\n    &#125;\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    seqList.insert(2, 9);\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    seqList.remove(2);\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    seqList.removeByRange(2, 3);\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    seqList.replaceByValue(1, 9);\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n\n\n\n\n</li>\n<li><p><code>demo2.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;array.hpp&quot;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;      \n\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);\n&#125;;\n\nostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)\n&#123;\n    return cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;----Array&lt;int&gt;----&quot; &lt;&lt; endl;\n    Array&lt;int&gt; array(3);\n    array.add(1);\n    array.add(2);\n    array.add(3);\n    array.add(4);\n    cout &lt;&lt; &quot;arr[0]: &quot; &lt;&lt; array.get(0) &lt;&lt; endl;\n    cout &lt;&lt; &quot;arr[1]: &quot; &lt;&lt; array[1] &lt;&lt; endl;\n    cout &lt;&lt; &quot;size: &quot; &lt;&lt; array.size() &lt;&lt; endl;\n    cout &lt;&lt; &quot;arr: &quot; &lt;&lt; array &lt;&lt; endl;\n    cout &lt;&lt; &quot;\\n&quot;;\n\n    cout &lt;&lt; &quot;----Array&lt;Point&gt;----&quot; &lt;&lt; endl;\n    Array&lt;Point&gt; arr_Point(2);\n    arr_Point.add(Point(1, 1));\n    arr_Point.add(Point(2, 2));\n    cout &lt;&lt; &quot;arr_Point: &quot; &lt;&lt; arr_Point &lt;&lt; endl;\n    cout &lt;&lt; &quot;\\n&quot;;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo2\n----Array&lt;int&gt;----\nsize not free\narr[0]: 1\narr[1]: 2\nsize: 3\narr: [1, 2, 3]\n\n----Array&lt;Point&gt;----\narr_Point: [(1, 1), (2, 2)]</code></pre></li>\n</ul>\n<h3 id=\"25-其它语法-特性\"><a href=\"#25-其它语法-特性\" class=\"headerlink\" title=\"25. 其它语法-特性\"></a>25. 其它语法-特性</h3><h4 id=\"25-1-类型转换\"><a href=\"#25-1-类型转换\" class=\"headerlink\" title=\"25.1 类型转换\"></a>25.1 类型转换</h4><ul>\n<li><p>C语言风格的类型转换符</p>\n<ul>\n<li><code>(type)expression</code></li>\n<li><code>type(expression)</code></li>\n</ul>\n</li>\n<li><p>C++四种转换</p>\n<ul>\n<li><p><code>static_cast</code></p>\n</li>\n<li><p><code>dynamic_cast</code></p>\n</li>\n<li><p><code>reinterpret_cast</code></p>\n</li>\n<li><p><code>const_cast</code></p>\n<p>使用格式：<code>xx_cast&lt;type&gt;(expression)</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"25-1-1-const-cast\"><a href=\"#25-1-1-const-cast\" class=\"headerlink\" title=\"25.1.1 const_cast\"></a>25.1.1 const_cast</h5><ul>\n<li><p>一般用于去除<code>const</code>属性，将<code>const</code>转换成<code>非const</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person&#123;&#125;;\n\nint main()\n&#123;\n    const Person *p1 &#x3D; new Person;\n    &#x2F;&#x2F; 两种写法完全等价\n    Person *p2 &#x3D; const_cast&lt;Person *&gt;(p1);\n    Person *p3 &#x3D; (Person *)p1;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编查看</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; Person *p2 &#x3D; const_cast&lt;Person *&gt;(p1);\nmov eax, dword ptr[p1]\nmov dword ptr[p2], eax\n\n&#x2F;&#x2F; Person *p3 &#x3D; (Person *)p1;\nmov eax, dword ptr[p1]\nmov dword ptr[p3], eax</code></pre></li>\n</ul>\n<h5 id=\"25-1-2-dynamic-cast\"><a href=\"#25-1-2-dynamic-cast\" class=\"headerlink\" title=\"25.1.2 dynamic_cast\"></a>25.1.2 dynamic_cast</h5><ul>\n<li><p>一般用于多态类型转换，有运行时的安全检测</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\n    virtual void run();\n&#125;;\n\nclass Student : public Person\n&#123;&#125;;\n\nint main()\n&#123;\n    Person *p1 &#x3D; new Person;\n    Person *p2 &#x3D; new Student;\n\n    &#x2F;&#x2F; 两种写法完全等价\n    Student *s1 &#x3D; (Student *)p1; &#x2F;&#x2F; 不安全\n    Student *s1 &#x3D; dynamic_cast&lt;Student *&gt;(p1); &#x2F;&#x2F; 不安全\n    \n    Student *s2 &#x3D; dynamic_cast&lt;Student *&gt;(p2); &#x2F;&#x2F; 安全\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>反汇编查看：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; Student *s1 &#x3D; dynamic_cast&lt;Student *&gt;(p1);\nmov eax, dword ptr[p1]\ncall __RTDynamicCast(0C14ABh)\nmov dword ptr[s1], eax</code></pre></li>\n</ul>\n<h5 id=\"25-1-3-static-cast\"><a href=\"#25-1-3-static-cast\" class=\"headerlink\" title=\"25.1.3 static_cast\"></a>25.1.3 static_cast</h5><ul>\n<li><p>对比<code>dynamic_cast</code>确实安全检测</p>\n</li>\n<li><p>不能交叉转换（不是同一继承体系的，无法转换）</p>\n</li>\n<li><p>常用于基本数据类型转换，<code>非const</code>转换<code>const</code></p>\n</li>\n<li><p>代码示例：<code>交叉转换</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person&#123;&#125;;\n\nclass Car&#123;&#125;;\n\nint main()\n&#123;\n    Person *p1 &#x3D; new Person;\n    \n    &#x2F;&#x2F; 两个类之间完全没有关系，强行转化：交叉转换\n    Car *c1 &#x3D; (Car *)p1;\n    Car *c2 &#x3D; dynamic_cast&lt;Car *&gt;(p1);\n    \n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>代码示例：<code>非const</code>转换<code>const</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person&#123;&#125;;\n\nint main()\n&#123;\n    Person *p1 &#x3D; new Person;\n    const Person *p2 &#x3D; static_cast&lt;Person *&gt;(p1);\n    \n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"25-1-4-reinterpret-cast\"><a href=\"#25-1-4-reinterpret-cast\" class=\"headerlink\" title=\"25.1.4 reinterpret_cast\"></a>25.1.4 reinterpret_cast</h5><ul>\n<li><p>属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅只是简单的二进制数据拷贝</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    \n    &#x2F;&#x2F; C语言的隐式转换\n    double b &#x3D; a;\n    \n    double d &#x3D; reinterpret_cast&lt;double&amp;&gt;(a);\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>内存分析：反汇编</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">int a &#x3D; 10;\n&#x2F;&#x2F; 二进制：00001010 00000000 00000000 00000000\n&#x2F;&#x2F; 十六进制：0A 00 00 00\n&#x2F;&#x2F; 小段模式：int类型4字节，从右往左读取\n\ndouble b &#x3D; a;\n&#x2F;&#x2F; 00 00 00 00 00 00 24 40\n&#x2F;&#x2F; cvtsi2sd xmm0, dword ptr[a]\n&#x2F;&#x2F; movsd mmword ptr[d], xmm0\n\ndouble d &#x3D; reinterpret_cast&lt;double&amp;&gt;(a);\n&#x2F;&#x2F; 0A 00 00 00 cc cc cc cc\n&#x2F;&#x2F; movsd xmm0, mmword ptr[a]\n&#x2F;&#x2F; movsd mmword ptr[d], xmm0</code></pre></li>\n</ul>\n<h4 id=\"25-2-C-11特性\"><a href=\"#25-2-C-11特性\" class=\"headerlink\" title=\"25.2 C++11特性\"></a>25.2 C++11特性</h4><ul>\n<li><p><code>auto</code>：</p>\n<ul>\n<li><p>可以初始化表达式中推断出变量的类型，提高开发效率</p>\n</li>\n<li><p>属于编译器特性，不影响最终的机器码质量，不影响运行效率</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto i &#x3D; 10; &#x2F;&#x2F; int\nauto str &#x3D; &quot;c++&quot;; &#x2F;&#x2F; const char *\nauto p &#x3D; new Person; &#x2F;&#x2F; Person *</code></pre></li>\n</ul>\n</li>\n<li><p><code>decltype</code>:</p>\n<ul>\n<li><p>可以获取变量的类型</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int a &#x3D; 10;\ndecltype(a) b &#x3D; 20;</code></pre></li>\n</ul>\n</li>\n<li><p><code>nullptr</code>:</p>\n<ul>\n<li><p>可以解决<code>NULL</code>的二义性问题</p>\n</li>\n<li><p><code>NULL</code>本质是<code>define NULL 0</code></p>\n</li>\n<li><p>在<code>c++98</code>中<code>void fun(int)&#123;&#125;``void fun(int *)&#123;&#125;</code>时会遇到二义性，在<code>c++11</code>之后，默认为<code>0</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nvoid func(int a)&#123;cout &lt;&lt; &quot;func(int): &quot; &lt;&lt; a &lt;&lt; endl;&#125;\n\nvoid func(int *a)&#123;cout &lt;&lt; &quot;func(int *): &quot; &lt;&lt; a &lt;&lt; endl;&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; func(NULL);\n    func(nullptr);\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo3\nfunc(int *): 0</code></pre></li>\n</ul>\n</li>\n<li><p><code>快速遍历</code>：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int arr[] &#x3D; &#123;&#125;;\nfor (int a : arr)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;</code></pre></li>\n</ul>\n<h4 id=\"25-3-Lambda表达式\"><a href=\"#25-3-Lambda表达式\" class=\"headerlink\" title=\"25.3 Lambda表达式\"></a>25.3 Lambda表达式</h4><ul>\n<li>lambda表达式：<ul>\n<li>本质是函数</li>\n<li>完整结构：<code>[capture list] (params list) mutable exception -&gt; return type &#123;function body&#125;;</code><ul>\n<li><code>capture list</code>：捕获外部变量列表</li>\n<li><code>params list</code>：形参列表，不能使用默认参数，不能省略参数名</li>\n<li><code>mutable</code>：用于说明是否可以修改捕获的变量</li>\n<li><code>exception </code>：异常设定</li>\n<li><code>return type</code>：返回值类型</li>\n<li><code>function body</code>：函数体</li>\n</ul>\n</li>\n<li>省略的写法：<ul>\n<li><code>[capture list] (params list) -&gt; return type &#123;function body&#125;;</code></li>\n<li><code>[capture list] (params list)&#123;function body&#125;; </code></li>\n<li><code>[capture list]&#123;function body&#125;; </code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"25-3-1-lambda基本用法\"><a href=\"#25-3-1-lambda基本用法\" class=\"headerlink\" title=\"25.3.1 lambda基本用法\"></a>25.3.1 lambda基本用法</h5><ul>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 无参，无返回值，默认调用\n    ([]\n    &#123;\n        cout &lt;&lt; &quot;func() - 1&quot; &lt;&lt; endl;\n    &#125;)();\n\n    &#x2F;&#x2F; 可以用指针存储\n    void (*p)() &#x3D; []\n    &#123;\n        cout &lt;&lt; &quot;func() - p&quot; &lt;&lt; endl;\n    &#125;;\n    p();\n\n    &#x2F;&#x2F; 直接用auto存储更方便\n    auto p1 &#x3D; []\n    &#123;\n        cout &lt;&lt; &quot;func() - p1&quot; &lt;&lt; endl;\n    &#125;;\n    p1();\n\n    &#x2F;&#x2F; 有返回值和参数\n    auto add1 &#x3D; [](int a, int b) -&gt; auto\n    &#123;\n        return a + b;\n    &#125;;\n    cout &lt;&lt; add1(1, 2) &lt;&lt; endl;\n\n    &#x2F;&#x2F; 返回值类型也可省略\n    auto add2 &#x3D; [](int a, int b)\n    &#123;\n        return a + b;\n    &#125;;\n    cout &lt;&lt; add2(2, 3) &lt;&lt; endl;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo4\nfunc() - 1\nfunc() - p\nfunc() - p1\n3\n5</code></pre>\n\n\n</li>\n<li><p>代码示例2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nvoid calculate(int a, int b, int (*func)(int, int))\n&#123;\n    cout &lt;&lt; func(a, b) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    calculate(1, 2, [](int a, int b)&#123;return a + b;&#125;);\n    calculate(4, 2, [](int a, int b)&#123;return a - b;&#125;);\n    calculate(8, 2, [](int a, int b)&#123;return a * b;&#125;);\n    calculate(8, 2, [](int a, int b)&#123;return a &#x2F; b;&#125;);\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo5\n3\n2\n16\n4</code></pre></li>\n</ul>\n<h5 id=\"25-3-2-lambda变量捕获\"><a href=\"#25-3-2-lambda变量捕获\" class=\"headerlink\" title=\"25.3.2 lambda变量捕获\"></a>25.3.2 lambda变量捕获</h5><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n\n    auto add1 &#x3D; [a, b](int c, int d)\n    &#123;\n        cout &lt;&lt; a + b &lt;&lt; &quot;\\n&quot; &lt;&lt; c + d &lt;&lt; endl;\n    &#125;;\n    add1(1, 98);\n\n    &#x2F;&#x2F; 隐式捕获:（全捕获）\n    &#x2F;&#x2F; [&#x3D;] 值类型\n    &#x2F;&#x2F; [&amp;] 引用类型 \n    auto add2 &#x3D; [&#x3D;]\n    &#123;\n        cout &lt;&lt; a + b &lt;&lt; &quot;\\n&quot;;\n    &#125;;\n    add2();\n    \n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"25-4-C-14特性\"><a href=\"#25-4-C-14特性\" class=\"headerlink\" title=\"25.4 C++14特性\"></a>25.4 C++14特性</h4><ul>\n<li><p>泛型lambda表达式：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto func &#x3D; [](auto a, auto b)&#123;return a + b;&#125;;</code></pre>\n\n\n</li>\n<li><p>捕获的变量进行初始化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int a &#x3D; 9;\nauto func &#x3D; [a &#x3D; 10]&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;;\nfunc(); &#x2F;&#x2F;打印结果：10\n\ncout &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; 打印结果：9</code></pre></li>\n</ul>\n<h4 id=\"25-5-C-17特性\"><a href=\"#25-5-C-17特性\" class=\"headerlink\" title=\"25.5 C++17特性\"></a>25.5 C++17特性</h4><ul>\n<li><p>可以进行初始化的<code>if</code>和<code>switch</code>语句</p>\n</li>\n<li><p>代码示例：<code>if</code>，<code>else if</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if (int a &#x3D; 10; a &gt; 0)\n&#123;\n    cout &lt;&lt; a &lt;&lt; endl;\n&#125;</code></pre>\n\n\n</li>\n<li><p>代码示例：<code>switch</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">switch(int a &#x3D; 1; a)\n&#123;\n    case 0:\n        break;\n    case 1:\n        break;\n    default:\n        break;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"26-异常\"><a href=\"#26-异常\" class=\"headerlink\" title=\"26. 异常\"></a>26. 异常</h3><h4 id=\"26-1-异常基本用法\"><a href=\"#26-1-异常基本用法\" class=\"headerlink\" title=\"26.1 异常基本用法\"></a>26.1 异常基本用法</h4><ul>\n<li><p>编程过程中常见的错误：</p>\n<ul>\n<li>语法错误</li>\n<li>逻辑错误</li>\n<li>异常</li>\n</ul>\n</li>\n<li><p>异常：一种程序运行过程中可能会发生的错误</p>\n<ul>\n<li>每次异常可能类型不同，不能确定</li>\n<li>异常没有处理，程序会直接中断或崩溃等等</li>\n</ul>\n</li>\n<li><p>异常处理过程：</p>\n<ul>\n<li><code>throw</code>异常后，会在当前函数中查找匹配的<code>catch</code></li>\n<li>找不到就会终止当前的函数代码，去上一层函数中查找</li>\n<li>如果都找不到，程序直接终止</li>\n</ul>\n</li>\n<li><p>代码示例1：简单的异常演示</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int i &#x3D; 0;\n    for (i ; i &lt; 99999; ++i)\n    &#123;\n        try\n        &#123;\n            int *p &#x3D; new int[999999];\n        &#125;\n        catch(...)\n        &#123;\n            cout &lt;&lt; &quot;for loop &quot; &lt;&lt; i &lt;&lt; &quot; error!&quot; &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：多次打印（每次的异常结果可能不同）</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1\nfor loop 6176 error!\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1\nfor loop 6180 error!\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1\nfor loop 6182 error!</code></pre>\n\n\n\n\n</li>\n<li><p>代码示例2：主动抛出异常</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nvoid divide(int a, int b)\n&#123;\n    if (b &#x3D;&#x3D; 0)\n    &#123;\n        throw 0;\n    &#125;\n    cout &lt;&lt; a &#x2F; b &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    try\n    &#123;\n        divide(10, 1);\n        divide(10, 0);\n        divide(10, 2);\n    &#125;\n    catch(const int exc)\n    &#123;\n        cout &lt;&lt; &quot;Divide Error &quot; &lt;&lt; exc &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo2\n10\nDivide Error 0</code></pre>\n</li>\n<li><p>总结：<code>throw</code>后面的类型，要和<code>catch</code>里面接受的类型<code>保持一致</code></p>\n</li>\n<li><p>代码示例3：异常处理过程</p>\n</li>\n<li><p>没有<code>catch</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nvoid func1()\n&#123;\n    cout &lt;&lt; &quot;func1()-begin&quot; &lt;&lt; endl;\n    throw 0; &#x2F;&#x2F; 抛出异常，func1()中没有catch，向上层函数func2()中找\n    cout &lt;&lt; &quot;func1()-end&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2()\n&#123;\n    cout &lt;&lt; &quot;func2()-begin&quot; &lt;&lt; endl;\n    func1(); &#x2F;&#x2F; throw 来到func2()，也没有发现catch，继续向上到main()\n    cout &lt;&lt; &quot;func2()-end&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;main()-begin&quot; &lt;&lt; endl;\n    func2(); &#x2F;&#x2F; throw来到main()中，依然没有发现catch，此时程序终止\n    cout &lt;&lt; &quot;main()-end&quot; &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo3\nmain()-begin\nfunc2()-begin\nfunc1()-begin</code></pre>\n\n\n</li>\n<li><p>有<code>catch</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nvoid func1()\n&#123;\n    cout &lt;&lt; &quot;func1()-begin&quot; &lt;&lt; endl;\n    try\n    &#123;\n        throw 0;\n    &#125;\n    catch(int exc)\n    &#123;\n        cout &lt;&lt; &quot;Error &quot; &lt;&lt; exc &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    \n    cout &lt;&lt; &quot;func1()-end&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2()\n&#123;\n    cout &lt;&lt; &quot;func2()-begin&quot; &lt;&lt; endl;\n    func1();\n    cout &lt;&lt; &quot;func2()-end&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;main()-begin&quot; &lt;&lt; endl;\n    func2();\n    cout &lt;&lt; &quot;main()-end&quot; &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo3\nmain()-begin\nfunc2()-begin\nfunc1()-begin\nError 0\nfunc1()-end\nfunc2()-end\nmain()-end</code></pre></li>\n</ul>\n<h4 id=\"26-2-异常抛出声明\"><a href=\"#26-2-异常抛出声明\" class=\"headerlink\" title=\"26.2 异常抛出声明\"></a>26.2 异常抛出声明</h4><ul>\n<li><p>为了增强可读性和方便团队协作，函数内部抛出异常，建议函数声明一下函数类型</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void func1() throw()&#123;&#125; &#x2F;&#x2F; 不抛出异常\nvoid func2() throw(int, double)&#123;&#125; &#x2F;&#x2F; 可能抛出 int，double 类型的异常</code></pre></li>\n</ul>\n<h4 id=\"26-3-自定义异常类型\"><a href=\"#26-3-自定义异常类型\" class=\"headerlink\" title=\"26.3 自定义异常类型\"></a>26.3 自定义异常类型</h4><ul>\n<li><p>代码示例1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Exception\n&#123;\npublic:    \n    virtual const char *what() &#x3D; 0;\n&#125;;\n\nclass DivideException : public Exception\n&#123;\npublic:    \n    const char *what()&#123;return &quot;Divide Error&quot;;&#125;\n&#125;;\n\nvoid divide(int a, int b)\n&#123;\n    if (b &#x3D;&#x3D; 0)&#123;throw DivideException();&#125;\n    cout &lt;&lt; a &#x2F; b &lt;&lt; &quot;\\n&quot;;\n&#125;\n\nint main()\n&#123;\n    try\n    &#123;\n        divide(10, 0);\n    &#125;\n    catch(DivideException e)\n    &#123;\n        cout &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo4\nDivide Error</code></pre>\n\n\n\n\n</li>\n<li><p>代码示例2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Exception\n&#123;\npublic:    \n    virtual const char *what() const &#x3D; 0;\n&#125;;\n\nclass DivideException : public Exception\n&#123;\npublic:    \n    const char *what() const&#123;return &quot;Divide Error&quot;;&#125;\n&#125;;\n\nvoid divide(int a, int b)\n&#123;\n    if (b &#x3D;&#x3D; 0)&#123;throw DivideException();&#125;\n    cout &lt;&lt; a &#x2F; b &lt;&lt; &quot;\\n&quot;;\n&#125;\n\nint main()\n&#123;\n    try\n    &#123;\n        divide(10, 0);\n    &#125;\n    catch(const Exception &amp;e)\n    &#123;\n        cout &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo4\nDivide Error</code></pre></li>\n</ul>\n<h3 id=\"27-智能指针\"><a href=\"#27-智能指针\" class=\"headerlink\" title=\"27. 智能指针\"></a>27. 智能指针</h3><ul>\n<li><p>目的：改善传统指针存在的问题</p>\n</li>\n<li><p>传统指针存在的问题：</p>\n<ul>\n<li>需要手动管理内存</li>\n<li>容易发生内存泄漏<ul>\n<li>忘记释放</li>\n<li>出现抛出异常</li>\n</ul>\n</li>\n<li>释放后会变成野指针</li>\n</ul>\n</li>\n<li><p>智能指针的作用：</p>\n<ul>\n<li><code>auto_ptr</code>：C++98，存在缺陷，不能用于数组</li>\n<li><code>shared_ptr</code>：C++11</li>\n<li><code>unique_ptr</code>：C++11</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"27-1-智能指针基本使用\"><a href=\"#27-1-智能指针基本使用\" class=\"headerlink\" title=\"27.1 智能指针基本使用\"></a>27.1 智能指针基本使用</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;        \n\n    void run()&#123;cout &lt;&lt; &quot;Person::run() &quot; &lt;&lt; m_age &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test1()\n&#123;\n    shared_ptr&lt;Person&gt; p(new Person(10));\n    p-&gt;run();\n&#125;\n\nint main()\n&#123;\n    test1();\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo1\nPerson::Person(int)\nPerson::run() 10\nPerson::~Person()</code></pre></li>\n</ul>\n<h4 id=\"27-2-自定义智能指针\"><a href=\"#27-2-自定义智能指针\" class=\"headerlink\" title=\"27.2 自定义智能指针\"></a>27.2 自定义智能指针</h4><ul>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;typename class_T&gt;\nclass fh_ptr\n&#123;\nprivate:\n    class_T *obj_ptr;\n\npublic:\n    fh_ptr(class_T *ptr) : obj_ptr(ptr)&#123;&#125;\n    ~fh_ptr()\n    &#123;\n        if (obj_ptr &#x3D;&#x3D; nullptr)&#123;return;&#125;\n        delete obj_ptr;\n        obj_ptr &#x3D; nullptr;\n    &#125;    \n\n    class_T *operator-&gt;()&#123;return obj_ptr;&#125;\n&#125;;\n\nclass Person\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;        \n\n    void run()&#123;cout &lt;&lt; &quot;Person::run() &quot; &lt;&lt; m_age &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test1()\n&#123;\n    fh_ptr&lt;Person&gt; p(new Person(10));\n    p-&gt;run();\n&#125;\n\nint main()\n&#123;\n    test1();\n    \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo2\nPerson::Person(int)\nPerson::run() 10\nPerson::~Person()</code></pre></li>\n</ul>\n<h4 id=\"27-3-shared-ptr\"><a href=\"#27-3-shared-ptr\" class=\"headerlink\" title=\"27.3 shared_ptr\"></a>27.3 shared_ptr</h4><h5 id=\"27-3-1-shared-ptr原理\"><a href=\"#27-3-1-shared-ptr原理\" class=\"headerlink\" title=\"27.3.1 shared_ptr原理\"></a>27.3.1 shared_ptr原理</h5><ul>\n<li>一个<code>shared_ptr</code>会对一个对象产生强引用</li>\n<li>每个对象都会有一个对应的强引用计数，记录着当前的对象被多少<code>shared_ptr</code>强引用<ul>\n<li>可以通过<code>shared_ptr</code>的<code>use_count</code>函数获得强引用计数</li>\n</ul>\n</li>\n<li>当有一个新的<code>shared_ptr</code>指向对象时，对象的强引用计数会<code>加1</code></li>\n<li>当一个<code>shared_ptr</code>销毁时，对象的强引用计数<code>减1</code></li>\n<li>当一个对象的强引用计数<code>为0</code>时，对象就会自动销毁</li>\n</ul>\n<h5 id=\"27-3-2-shared-ptr循环引用\"><a href=\"#27-3-2-shared-ptr循环引用\" class=\"headerlink\" title=\"27.3.2 shared_ptr循环引用\"></a>27.3.2 shared_ptr循环引用</h5><h6 id=\"27-3-2-1-演示循环引用问题\"><a href=\"#27-3-2-1-演示循环引用问题\" class=\"headerlink\" title=\"27.3.2.1 演示循环引用问题\"></a>27.3.2.1 演示循环引用问题</h6><ul>\n<li><p>循环引用的问题：</p>\n<ul>\n<li><p><code>shared_ptr</code>是<code>强引用</code>智能指针</p>\n</li>\n<li><p>发生两个类的对象相互引用，产生循环引用</p>\n</li>\n<li><p>循环引用会产生栈空间的智能指针对象销毁后，指向堆区的对象不会被销毁</p>\n</li>\n</ul>\n</li>\n<li><p>代码示例：<code>演示循环引用的问题</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nclass Person;\n\nclass Car\n&#123;\npublic:\n    shared_ptr&lt;Person&gt; m_person;\n    Car()&#123;cout &lt;&lt; &quot;Car::Car()\\n&quot;;&#125;\n    ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()\\n&quot;;&#125;\n&#125;;\n\nclass Person\n&#123;\npublic:\n    shared_ptr&lt;Car&gt; m_car;\n    Person()&#123;cout &lt;&lt; &quot;Person::Person()\\n&quot;;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()\\n&quot;;&#125;\n&#125;;\n\nvoid test()\n&#123;\n    shared_ptr&lt;Person&gt; person(new Person);\n    shared_ptr&lt;Car&gt; car(new Car);\n\n    person-&gt;m_car &#x3D; car;\n    car-&gt;m_person &#x3D; person;\n&#125;\n\nint main()\n&#123;\n    test();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo3\nPerson::Person()\nCar::Car()</code></pre></li>\n</ul>\n<h6 id=\"27-3-2-2-解决循环引用问题\"><a href=\"#27-3-2-2-解决循环引用问题\" class=\"headerlink\" title=\"27.3.2.2 解决循环引用问题\"></a>27.3.2.2 解决循环引用问题</h6><ul>\n<li><p><code>weak_ptr</code></p>\n<ul>\n<li>会对对象产生<code>弱引用</code></li>\n<li>解决<code>shared_ptr</code>的循环引用问题</li>\n</ul>\n</li>\n<li><p>代码示例：<code>解决循环引用问题</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nclass Person;\n\nclass Car\n&#123;\npublic:\n    &#x2F;&#x2F; 只需要其中一个 是 弱引用 即可\n    weak_ptr&lt;Person&gt; m_person;\n    Car()&#123;cout &lt;&lt; &quot;Car::Car()\\n&quot;;&#125;\n    ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()\\n&quot;;&#125;\n&#125;;\n\nclass Person\n&#123;\npublic:\n    shared_ptr&lt;Car&gt; m_car;\n    Person()&#123;cout &lt;&lt; &quot;Person::Person()\\n&quot;;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()\\n&quot;;&#125;\n&#125;;\n\nvoid test()\n&#123;\n    shared_ptr&lt;Person&gt; person(new Person);\n    shared_ptr&lt;Car&gt; car(new Car);\n\n    person-&gt;m_car &#x3D; car;\n    car-&gt;m_person &#x3D; person;\n&#125;\n\nint main()\n&#123;\n    test();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>打印结果：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo3\nPerson::Person()\nCar::Car()\nPerson::~Person()\nCar::~Car()</code></pre></li>\n</ul>\n<h4 id=\"27-4-unique-ptr\"><a href=\"#27-4-unique-ptr\" class=\"headerlink\" title=\"27.4 unique_ptr\"></a>27.4 unique_ptr</h4><ul>\n<li><p>同样是<code>强引用</code>，但可以确保同一时间只有<code>一个指针</code>指向对象</p>\n</li>\n<li><p>当<code>unique</code>销毁时，指向的对象也就自动销毁</p>\n</li>\n<li><p>使用<code>std::move</code>函数转移<code>unqiue_ptr</code>的所有权</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">unique_ptr&lt;A&gt; a1;\nunique_ptr&lt;A&gt; a2(new A);\na1 &#x3D; std::move(a2)</code></pre></li>\n</ul>\n","feature":true,"text":"C++_面向对象反汇编补充1. 类1.1 类的定义 C++中可以使用 struct，class来定义类 1.2 struct和class区别 struct默认成员权限是public class默认成员权限是private 1.2.1 定义和访问 代码示例： struct Pers...","link":"","photos":[],"count_time":{"symbolsCount":"85k","symbolsTime":"1:17"},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"Assemly","slug":"Assemly","count":2,"path":"api/tags/Assemly.json"},{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%8D%E6%B1%87%E7%BC%96%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">C++_面向对象反汇编补充</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%B1%BB\"><span class=\"toc-text\">1. 类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1.1 类的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-struct%E5%92%8Cclass%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.2 struct和class区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">1.2.1 定义和访问</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-2-%E5%8F%8D%E6%B1%87%E7%BC%96%E6%9F%A5%E7%9C%8B%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.2.2 反汇编查看区别</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">1.3 对象的内存布局</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-this\"><span class=\"toc-text\">2. this</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">3. 内存空间的布局</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E4%BB%A3%E7%A0%81%E5%8C%BA\"><span class=\"toc-text\">3.1 代码区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%85%A8%E5%B1%80%E5%8C%BA\"><span class=\"toc-text\">3.2 全局区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-%E5%A0%86%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">3.3 堆空间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-1-%E5%A0%86%E7%A9%BA%E9%97%B4%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">3.3.1 堆空间申请和释放</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-2-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">3.3.2 堆空间初始化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-3-2-1-memset\"><span class=\"toc-text\">3.3.2.1 memset</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98\"><span class=\"toc-text\">3.4 对象的内存</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">4. 构造函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.1 构造函数的错误概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">4.2 构造函数的调用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">4.3 构造函数的成员变量初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%9B%86%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">4.4 构造函数的集体初始化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5. 析构函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-malloc%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5.1 malloc与析构函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E5%AF%B9%E8%B1%A1%E5%86%85%E7%94%B3%E8%AF%B7%E7%9A%84%E5%A0%86%E5%8C%BA%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">5.2 对象内申请的堆区对象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">6. 声明和实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-%E5%85%B7%E4%BD%93%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">6.1 具体演示</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">7. 命名空间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">7.1 命名空间的基本用法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-2-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%B5%8C%E5%A5%97\"><span class=\"toc-text\">7.2 命名空间的嵌套</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-3-%E5%AD%98%E5%9C%A8%E6%9C%80%E5%A4%A7%E9%BB%98%E8%AE%A4%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">7.3 存在最大默认命名空间</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">8. 继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">8.1 继承的内存布局</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-2-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90\"><span class=\"toc-text\">8.2 成员访问权限</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">9. 初始化列表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BA%92%E8%B0%83\"><span class=\"toc-text\">10. 构造函数互调</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-1-%E4%BA%92%E8%B0%83%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">10.1 互调语法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90\"><span class=\"toc-text\">10.2 语法分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-3-%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">10.3 父类的构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-4-%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">10.4 构造和析构的顺序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">11. 多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-1-%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB%E6%8C%87%E9%92%88\"><span class=\"toc-text\">11.1 父类和子类指针</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-2-%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">11.2 虚函数实现多态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-3-%E8%99%9A%E8%A1%A8\"><span class=\"toc-text\">11.3 虚表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-3-1-%E8%99%9A%E8%A1%A8%E7%9A%84%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">11.3.1 虚表的大小</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-3-2-%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90%E8%99%9A%E8%A1%A8\"><span class=\"toc-text\">11.3.2 反汇编分析虚表</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-3-3-%E8%99%9A%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">11.3.3 虚表的设计思想</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-3-4-%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%9C%80%E6%B1%82\"><span class=\"toc-text\">11.3.4 多态实现的需求</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-4-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">11.4 虚析构函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-5-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">11.5 纯虚函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-6-%E5%A4%9A%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">11.6 多继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-6-1-%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">11.6.1 多继承概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-6-2-%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-x2F-%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">11.6.2 同名成员函数&#x2F;变量</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-6-3-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">11.6.3 菱形继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#11-6-3-1-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">11.6.3.1 菱形继承结构</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#11-6-3-2-%E8%99%9A%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">11.6.3.2 虚继承</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98\"><span class=\"toc-text\">12. 静态成员</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">12.1 静态成员基本定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-2-%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90%E9%9D%99%E6%80%81%E6%88%90%E5%91%98\"><span class=\"toc-text\">12.2 反汇编分析静态成员</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-3-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">12.3 静态成员应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#12-3-1-%E7%BB%9F%E8%AE%A1%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">12.3.1 统计对象个数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#12-3-2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">12.3.2 单例模式</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-const%E6%88%90%E5%91%98\"><span class=\"toc-text\">13. const成员</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98\"><span class=\"toc-text\">14. 引用类型成员</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">15. 拷贝构造函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#15-1-%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">15.1 默认拷贝构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#15-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">15.2 自定义拷贝构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#15-3-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">15.3 调用父类拷贝构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#15-4-%E6%B5%85%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">15.4 浅复制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#15-5-%E6%B5%85-x2F-%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">15.5 浅&#x2F;深拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#15-5-1-%E8%A7%A3%E5%86%B3%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">15.5.1 解决浅拷贝问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#15-5-2-%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">15.5.2 深拷贝</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">16. 对象类型参数和返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">17. 匿名对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E9%9A%90%E5%BC%8F%E6%9E%84%E9%80%A0\"><span class=\"toc-text\">18. 隐式构造</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">19. 编译器自动生成的构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">20. 友元</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">21. 内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#21-1-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">21.1 内部类的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#21-2-%E5%86%85%E9%83%A8%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">21.2 内部类声明与实现分离</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#22-%E5%B1%80%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">22. 局部类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#23-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">23. 运算符重载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#23-1-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">23.1 基本运算符重载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#23-2-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">23.2 调用父类的运算符重载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#23-3-%E4%BB%BF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">23.3 仿函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#24-%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">24. 模板</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#24-1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">24.1 函数模板定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#24-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">24.2 函数模板分离</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#24-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">24.3 类模板的定义</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#25-%E5%85%B6%E5%AE%83%E8%AF%AD%E6%B3%95-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">25. 其它语法-特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#25-1-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">25.1 类型转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#25-1-1-const-cast\"><span class=\"toc-text\">25.1.1 const_cast</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#25-1-2-dynamic-cast\"><span class=\"toc-text\">25.1.2 dynamic_cast</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#25-1-3-static-cast\"><span class=\"toc-text\">25.1.3 static_cast</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#25-1-4-reinterpret-cast\"><span class=\"toc-text\">25.1.4 reinterpret_cast</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#25-2-C-11%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">25.2 C++11特性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#25-3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">25.3 Lambda表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#25-3-1-lambda%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">25.3.1 lambda基本用法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#25-3-2-lambda%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7\"><span class=\"toc-text\">25.3.2 lambda变量捕获</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#25-4-C-14%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">25.4 C++14特性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#25-5-C-17%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">25.5 C++17特性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#26-%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">26. 异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#26-1-%E5%BC%82%E5%B8%B8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">26.1 异常基本用法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#26-2-%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">26.2 异常抛出声明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#26-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">26.3 自定义异常类型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#27-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\"><span class=\"toc-text\">27. 智能指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#27-1-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">27.1 智能指针基本使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#27-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\"><span class=\"toc-text\">27.2 自定义智能指针</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#27-3-shared-ptr\"><span class=\"toc-text\">27.3 shared_ptr</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#27-3-1-shared-ptr%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">27.3.1 shared_ptr原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#27-3-2-shared-ptr%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">27.3.2 shared_ptr循环引用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#27-3-2-1-%E6%BC%94%E7%A4%BA%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">27.3.2.1 演示循环引用问题</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#27-3-2-2-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">27.3.2.2 解决循环引用问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#27-4-unique-ptr\"><span class=\"toc-text\">27.4 unique_ptr</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"UE4 RPC","uid":"01b2c0831f95e39e5fd56ec4f69b86cb","slug":"7_UE4_RPC_04","date":"2022-10-06T07:28:25.953Z","updated":"2022-10-07T13:00:17.289Z","comments":true,"path":"api/articles/7_UE4_RPC_04.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (20).webp","text":"UE4 RPC1. RPC 架构1.1 架构简介 一个服务器， 一个或多个客户端 不能信任客户端，所有重要信息都需要通过服务器验证 Listen Server监听服务器和Dedicated Server专有服务器 1.2 基本GamePlay结构 Server GameMode ...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UnrealEngine","slug":"UnrealEngine","count":9,"path":"api/tags/UnrealEngine.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"汇编_辅助C++","uid":"a6ccd9fe4a40d3d3e4e5ed99b6f169f1","slug":"11_汇编_辅助C++_01","date":"2022-10-06T07:28:25.978Z","updated":"2022-10-07T13:00:53.279Z","comments":true,"path":"api/articles/11_汇编_辅助C++_01.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (29).webp","text":"汇编_辅助C++ 汇编语言种类：x64汇编（64bit） 书写格式：intel 汇编不区分大小写 1. 汇编格式了解 项目 intel 说明 寄存器命名 eax intel不带% 操作数顺序 mov edx, eax 将eax的值赋值给edx 常数\\立即数 mov eax, 3m...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"Assemly","slug":"Assemly","count":2,"path":"api/tags/Assemly.json"},{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}