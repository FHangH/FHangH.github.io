{"title":"C++_核心编程","uid":"e94a77a3753f22f554c8c36e4173e356","slug":"1_C++_核心编程_03","date":"2022-10-06T07:28:25.912Z","updated":"2022-11-10T01:30:17.082Z","comments":true,"path":"api/articles/1_C++_核心编程_03.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (3).webp","content":"<h1 id=\"C-核心编程\"><a href=\"#C-核心编程\" class=\"headerlink\" title=\"C++_核心编程\"></a>C++_核心编程</h1><p>[toc]</p>\n<h3 id=\"1-内存分区模型\"><a href=\"#1-内存分区模型\" class=\"headerlink\" title=\"1. 内存分区模型\"></a>1. 内存分区模型</h3><p>C++程序在执行时，内存大方向划分为4个区域</p>\n<ul>\n<li>代码区：存放函数的二进制代码，由操作系统进行管理的</li>\n<li>全局区：存放全局变量和静态变量以及常量</li>\n<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>\n<li>堆区：由程序员分配和释放，若不释放，程序执行结束后会系统回收</li>\n</ul>\n<p>内存分区的意义：</p>\n<ul>\n<li>不同区域存放的数据，赋予不同的生命周期</li>\n</ul>\n<h4 id=\"1-1-程序运行前\"><a href=\"#1-1-程序运行前\" class=\"headerlink\" title=\"1.1 程序运行前\"></a>1.1 程序运行前</h4><p>程序编译后，生成可执行的 .exe 文件 未执行前，分成两个区域</p>\n<p>代码区：</p>\n<ul>\n<li>存放CPU执行的机器指令</li>\n<li>代码区是共享的，目的是对于频繁的执行程序，只需在内存中存放一份即可</li>\n<li>代码区是只读的，目的是防止程序意外的修改了它的指令</li>\n</ul>\n<p>全局区：</p>\n<ul>\n<li>全局变量和静态变量存放其中</li>\n<li>全局区还包括了常量区，字符串常量和其他常量也存放其中</li>\n<li>该区域的数据在程序结束后由操作系统释放</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li>全局区：全局变量，静态变量，常量</li>\n<li>常量区：const修饰的全局变量，字符串常量</li>\n<li>局部区：局部变量，const修饰的局部变量和常量</li>\n</ul>\n<p>代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;Global variable outside Function\nint g_a &#x3D; 10;\nint g_b &#x3D; 20;\n\n&#x2F;&#x2F;Global constant variable outside Function\nconst int g_c_a &#x3D; 10;\nconst int g_c_b &#x3D; 20;\n\nint main()\n&#123;\n    &#x2F;&#x2F;Local variable inside Function\n    int l_a &#x3D; 10;\n    int l_b &#x3D; 20;\n\n    &#x2F;&#x2F;Static variable\n    static int s_a &#x3D; 10;\n    static int s_b &#x3D; 20;\n\n    &#x2F;&#x2F;Constant Local variable inside Function\n    const int l_c_a &#x3D; 10;\n    const int l_c_b &#x3D; 20;\n\n    &#x2F;&#x2F;Debug local variable\n    cout &lt;&lt; &quot;Local Area_Local variable l_a: &quot; &lt;&lt; (int) &amp;l_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Local Area_Local variable l_b: &quot; &lt;&lt; (int) &amp;l_b &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug constant local variable\n    cout &lt;&lt; &quot;Local Area_Constant local variable l_c_a:&quot; &lt;&lt; (int) &amp;l_c_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Local Area_Constant local variable l_c_b:&quot; &lt;&lt; (int) &amp;l_c_b &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug global variable\n    cout &lt;&lt; &quot;Global Area_Global variable g_a: &quot; &lt;&lt; (int) &amp;g_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Global Area_Global variable g_b: &quot; &lt;&lt; (int) &amp;g_b &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug static variable\n    cout &lt;&lt; &quot;Global Area_Static variable s_a: &quot; &lt;&lt; (int) &amp;s_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Global Area_Static variable s_b: &quot; &lt;&lt; (int) &amp;s_b &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug string constant\n    cout &lt;&lt; &quot;Global Area_String constant str_c_a:&quot; &lt;&lt; (int) &amp;&quot;Hello World&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug global constant variable\n    cout &lt;&lt; &quot;Global Area_global constant variable g_c_a:&quot; &lt;&lt; (int) &amp;g_c_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Global Area_global constant variable g_c_b:&quot; &lt;&lt; (int) &amp;g_c_b &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n\n\n\n\n\n<h4 id=\"1-2-程序运行后\"><a href=\"#1-2-程序运行后\" class=\"headerlink\" title=\"1.2 程序运行后\"></a>1.2 程序运行后</h4><ul>\n<li><p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</p>\n</li>\n<li><p>注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;定义一个返回值int类型的函数\nint *demoFunc()\n&#123;\n    &#x2F;&#x2F;定义一个局部变量，存在栈区中\n    int a &#x3D; 10;\n    &#x2F;&#x2F;返回一个局部变量的地址\n    return &amp;a;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F;接受局部变量传来的地址\n    int *p_a &#x3D; demoFunc();\n\n    cout &lt;&lt; *p_a &lt;&lt; endl; &#x2F;&#x2F;第一次能正常的解析地址对应的值，函数执行结束，系统回收了数据\n    cout &lt;&lt; *p_a &lt;&lt; endl; &#x2F;&#x2F;第二次，无法正常解析到对应的值，因为函数执行一次结束后，没有返回值了\n&#125;</code></pre>\n</li>\n<li><p>堆区：由程序员释放，若不释放，程序结束时由操作系统回收</p>\n</li>\n<li><p>方式：C++通过 new 在堆区中开辟内存</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nint *demoFunc()\n&#123;\n    &#x2F;&#x2F;通过指针地址存放 new 关键字对int类型的值在堆中开辟的内存所在的地址\n    &#x2F;&#x2F;这个 int的值存放在堆中，改函数执行结束后，依然存在\n    int *p_a &#x3D; new int(10);\n    return p_a;\n&#125;\n\nint main()\n&#123;\n    int *p_a &#x3D; demoFunc();\n    cout &lt;&lt; *p_a &lt;&lt; endl;\n    cout &lt;&lt; *p_a &lt;&lt; endl; &#x2F;&#x2F;函数执行结束后，指针指向的指针内存空间依然存在，所以可以正常得到内存中的值\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<p>1.3 new操作符</p>\n<ul>\n<li>C++ 通过 new 在堆区开辟数据</li>\n<li>堆区的数据，由程序员手动开辟，手动释放，利用 delet 操作符</li>\n<li>语法：<code>new 数据类型（）；</code></li>\n<li>利用new创建的数据，会返回该数据对应的类型的指针地址</li>\n</ul>\n<p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;创建一个返回int类型的地址函数\nint *newKeyDemo()\n&#123;\n    &#x2F;&#x2F;new操作符开辟的数据会返回一个指针\n    int *p_a &#x3D; new int(10);\n    &#x2F;&#x2F;返回指针\n    return p_a;\n&#125;\n\nvoid printDemo1Info()\n&#123;\n    &#x2F;&#x2F;创建一个指针接受返回值\n    int *Info1 &#x3D; newKeyDemo();\n    cout &lt;&lt; *Info1 &lt;&lt; endl;\n    &#x2F;&#x2F;delete 操作符会释放 new在堆中的数据\n    delete Info1;\n    cout &lt;&lt; *Info1 &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;利用new操作符创建数组\nvoid printDemo2Info()\n&#123;\n    int *p_arr &#x3D; new int[10];\n\n    for (int i &#x3D; 0; i &lt; 10; i++)\n    &#123;\n        p_arr[i] &#x3D; i + 1;\n    &#125;\n\n    for (int j &#x3D; 0; j &lt; 10; j++)\n    &#123;\n        cout &lt;&lt; p_arr[j] &lt;&lt; &quot; &quot;;\n    &#125;\n\n    delete[] p_arr;\n&#125;\n\nint main()\n&#123;\n    printDemo1Info();\n    printDemo2Info();\n    return 0;\n&#125;</code></pre>\n\n\n\n\n\n<h3 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2. 引用\"></a>2. 引用</h3><h4 id=\"2-1-引用的基本使用\"><a href=\"#2-1-引用的基本使用\" class=\"headerlink\" title=\"2.1 引用的基本使用\"></a>2.1 引用的基本使用</h4><ul>\n<li><p>作用：给变量起别名</p>\n</li>\n<li><p>语法：<code>数据类型 &amp;别名 = 原名；</code></p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int &amp;b &#x3D; a;\n\n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n    b &#x3D; 20;\n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"2-2-引用注意事项\"><a href=\"#2-2-引用注意事项\" class=\"headerlink\" title=\"2.2 引用注意事项\"></a>2.2 引用注意事项</h4><ul>\n<li><p>引用必须初始化</p>\n</li>\n<li><p>引用在初始化后不可以改变</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int c &#x3D; 10;\n    &#x2F;&#x2F;int &amp;b; 引用必须初始化\n    int &amp;b &#x3D; a;\n    &#x2F;&#x2F;int &amp;b &#x3D; c; 引用初始化后不可更改\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"2-3-引用做函数参数\"><a href=\"#2-3-引用做函数参数\" class=\"headerlink\" title=\"2.3 引用做函数参数\"></a>2.3 引用做函数参数</h4><ul>\n<li><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>\n</li>\n<li><p>优点：可以简化指针修改实参</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap01(int a, int b)\n&#123;\n    int temp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; temp;\n&#125;\n\nvoid swap02(int *p_a, int *p_b)\n&#123;\n    int temp &#x3D; *p_a;\n    *p_a &#x3D; *p_b;\n    *p_b &#x3D; temp;\n&#125;\n\nvoid swap03(int &amp;a, int &amp;b)\n&#123;\n    int temp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; temp;\n&#125;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n\n&#x2F;&#x2F;    swap01(a, b); 值传递，形参不修饰实参\n&#x2F;&#x2F;    swap02(&amp;a, &amp;b); 地址传递，形参修饰实参\n    swap03(a, b); &#x2F;&#x2F; 引用传递，形参修饰实参\n\n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"2-4-引用做函数的返回值\"><a href=\"#2-4-引用做函数的返回值\" class=\"headerlink\" title=\"2.4 引用做函数的返回值\"></a>2.4 引用做函数的返回值</h4><ul>\n<li><p>作用：引用可以作为函数的返回值</p>\n</li>\n<li><p>注意：不要返回局部变量引用</p>\n</li>\n<li><p>用法：函数调用作为左值</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nint &amp;demo1()\n&#123;\n    int a &#x3D; 10; &#x2F;&#x2F;函数体内定义的局部变量，函数执行完后，系统自动回收\n    return a;\n&#125;\n\nint &amp;demo2()\n&#123;\n    static int b &#x3D; 20; &#x2F;&#x2F;static 修饰的静态变量，存储在全局区，整个程序执行完后，系统自动回收\n    return b;\n&#125;\n\nint main()\n&#123;\n    int &amp;ref_a &#x3D; demo1();\n    int &amp;ref_b &#x3D; demo2();\n    cout &lt;&lt; &quot;ref_a &#x3D; &quot; &lt;&lt; ref_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;ref_a &#x3D; &quot; &lt;&lt; ref_a &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n\n    demo2() &#x3D; 1000; &#x2F;&#x2F;函数的调用是引用，可以作为左值\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"2-5-引用的本质\"><a href=\"#2-5-引用的本质\" class=\"headerlink\" title=\"2.5 引用的本质\"></a>2.5 引用的本质</h4><ul>\n<li><p>本质：在C++内部实现一个指针常量</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F; 转换为 int *const ref_b &#x3D; &amp;a\nvoid demo1(int &amp;ref_b)\n&#123;\n    ref_b &#x3D; 100;\n&#125;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    &#x2F;&#x2F; 自动转换为 int *const ref_a &#x3D; &amp;a; &lt;&lt; &#x3D; &gt;&gt; 指针常量；因为指针的指向（地址）不可改变，所以引用的初始化后不可更改\n    int &amp;ref_a &#x3D; a;\n    &#x2F;&#x2F; ref是引用，自动转换成 *ref &#x3D; 20；\n    ref_a &#x3D; 20;\n  \n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;ref_a &#x3D; &quot; &lt;&lt; ref_a &lt;&lt; endl;\n  \n    demo1(ref_a);\n  \n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>结论：引用本质是指针，使用方便</p>\n</li>\n</ul>\n<h4 id=\"2-6-常量引用\"><a href=\"#2-6-常量引用\" class=\"headerlink\" title=\"2.6 常量引用\"></a>2.6 常量引用</h4><ul>\n<li><p>作用：常量引用一般用来修饰形参，防止误操作</p>\n</li>\n<li><p>使用：在函数形参列表中，可以加 const 修饰形参，防止形参被实参修改</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nvoid printInfo(const int &amp;ref_b)\n&#123;\n    &#x2F;&#x2F;常量引用的值不可以修改\n    &#x2F;&#x2F;ref_b &#x3D; 1000;\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 编辑器 转换为 int temp &#x3D; 10;   const int &amp;a &#x3D; temp;\n    &#x2F;&#x2F;const int &amp;ref_a &#x3D; 10;\n    &#x2F;&#x2F; ref_a 用 const 修饰后值不能被修改\n    &#x2F;&#x2F;ref_a &#x3D; 20;\n\tint a &#x3D; 100;\n\tprintInfo(a);\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\treturn 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"2-7-引用补充\"><a href=\"#2-7-引用补充\" class=\"headerlink\" title=\"2.7 引用补充\"></a>2.7 引用补充</h4><ul>\n<li><p>一个引用占用一个指针的大小</p>\n</li>\n<li><p>证明引用本质是指针</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; 指针转汇编\n&#x2F;&#x2F; int *p &#x3D; &amp;age;\nlea eax, [age]\nmov dword ptr [p], eax\n\n&#x2F;&#x2F; *p &#x3D; 30;\nmov eax, dword ptr [p]\nmov dword ptr [eax], 1Eh\n\n&#x2F;&#x2F; 引用转汇编\n&#x2F;&#x2F; int &amp;ref &#x3D; age;\nlea eax, [age]\nmov dword ptr [p], eax\n\n&#x2F;&#x2F; ref &#x3D; 30;\nmov eax, dword ptr [p]\nmov dword ptr [eax], 1Eh</code></pre>\n\n\n</li>\n<li><p>数组引用</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int array[] &#x3D; &#123;1, 2, 3&#125;;\n\n&#x2F;&#x2F; 数组名 array 是数组的首元素地址，&#x3D;&gt; (i)\n&#x2F;&#x2F; 两种写法\nint (&amp;ref1)[3] &#x3D; array;\nint *const &amp;ref2 &#x3D; array;</code></pre>\n\n\n\n</li>\n<li><p>不存在的引用</p>\n<ul>\n<li>引用的引用</li>\n<li>指向引用的指针</li>\n<li>引用数组</li>\n</ul>\n</li>\n<li><p>常引用</p>\n<ul>\n<li><code>const</code> 必须写在 <code>&amp;</code> 左边，才算是<code>常引用</code></li>\n</ul>\n</li>\n<li><p>常引用的特点</p>\n<ul>\n<li><p>可以指向临时数据：<code>常量</code>、<code>表达</code>、<code>函数返回值</code>等</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 默认情况下，&amp;ref 只能将变量赋值给它\nint a &#x3D; 10;\nint &amp;ref &#x3D; a;\n\n&#x2F;&#x2F; 常量\nconst int &amp;ref &#x3D; 10;\n\n&#x2F;&#x2F; 表达式\nint a &#x3D; 10;\nint b &#x3D; 20;\n\nconst int &amp;ref &#x3D; a + b;\n\n&#x2F;&#x2F; 函数返回值\nint func()&#123;return 10;&#125;\n\nconst int &amp;ref &#x3D; func();</code></pre>\n\n\n</li>\n<li><p>可以指向不同类型的数据</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int a &#x3D; 10;\nconst double &amp;ref &#x3D; a;</code></pre>\n\n\n</li>\n<li><p>作为函数参数时(规则适用于 <code>const指针</code>)</p>\n<ul>\n<li><p>可以接受 <code>const</code> 和 <code>非const</code> 实参(<code>非const</code> 引用，只能接受 <code>非const</code> 实参)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int sum(const int &amp;a, const int &amp;b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; const实参\n    const int a &#x3D; 10;\n    const int b &#x3D; 20;\n    sum(a, b);\n    sum(10, 20);\n    \n    &#x2F;&#x2F; 非const实参\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n    sum(a, b);\n    \n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>可以跟 <code>非const</code> 引用<code>构成重载</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; sum_1\nint sum(const int &amp;a, const int &amp;b)\n&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; sum_2\nint sum(int &amp;a, int &amp;b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; const实参\n    const int a &#x3D; 10;\n    const int b &#x3D; 20;\n    \n    &#x2F;&#x2F; 调用 sum_1\n    sum(a, b);\n    sum(10, 20);\n    \n    &#x2F;&#x2F; 非const实参\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n    \n    &#x2F;&#x2F; 调用 sum_2\n    sum(a, b);\n    \n    return 0;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>当<code>常量引用</code>指向<code>不同类型</code>的数据时，会<code>产生临时变量</code>，即引用指向的并不是初始化时的那个变量</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int age &#x3D; 10;\nconst long &amp;rAge &#x3D; age;\nage &#x3D; 30;\n\ncout &lt;&lt; &quot;rAge: &quot; &lt;&lt; rAge &lt;&lt; endl;\ncout &lt;&lt; &quot;age: &quot; &lt;&lt; age &lt;&lt; endl;\n\n&#x2F;&#x2F; 运行结果&gt;&gt;\nrAge: 10\nage: 30</code></pre>\n</li>\n<li><p>利用反汇编分析：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; 查看反汇编\nmov dword ptr[age], 0Ah\n\n&#x2F;&#x2F; 常量引用指向不同类型数据，会产生如下两句；指向同类型不会\nmov eax, dword ptr[age]\nmov dword ptr[temp], eax\n\nlea ecx, [temp]\nmov dword ptr[rAge], ecx\nmov dword prt[age], 1Eh</code></pre>\n</li>\n<li><p>实际代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 源代码\nint age &#x3D; 10;\nconst long &amp;rAge &#x3D; age;\nage &#x3D; 30;\n\n&#x2F;&#x2F; 实际代码\nint age &#x3D; 10;\nint temp &#x3D; age;\nconst long &amp;rAge &#x3D; temp;\nage &#x3D; 30;</code></pre></li>\n</ul>\n<h3 id=\"3-函数进阶\"><a href=\"#3-函数进阶\" class=\"headerlink\" title=\"3. 函数进阶\"></a>3. 函数进阶</h3><h4 id=\"3-1-函数默认参数\"><a href=\"#3-1-函数默认参数\" class=\"headerlink\" title=\"3.1 函数默认参数\"></a>3.1 函数默认参数</h4><ul>\n<li><p>在C++中，函数的形参列表中的形参可以有默认值</p>\n</li>\n<li><p>语法：<code>返回值类型 函数名 （参数 = 默认值）&#123;&#125;</code></p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 无默认值参数，通过调用函数传入参数值\nint func01(int a, int b, int c)\n&#123;\n    return a + b + c;\n&#125;\n\n&#x2F;&#x2F; 有默认值参数，可以通过调用函数传入参数值，也可以不传参数值\nint func02(int a &#x3D; 10, int b &#x3D; 20, int c &#x3D; 30)\n&#123;\n    return a + b + c;\n&#125;\n\n&#x2F;&#x2F; 当函数定义中，有默认参数值的一项形参，其之后的其他形参也要有形参\n&#x2F;&#x2F;int func03(int a &#x3D; 10, int b, int c)\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    return a + b + c;\n&#x2F;&#x2F;&#125;\n\n&#x2F;&#x2F; 函数在声明时，形参有默认值，定义时，形参不得定义默认值\nint func04(int a &#x3D; 10, int b &#x3D; 20);\n\n&#x2F;&#x2F;int func04(int a &#x3D; 20, int b &#x3D; 10)\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    return a + b;\n&#x2F;&#x2F;&#125;\n\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Func01: &quot; &lt;&lt; func01(10, 20, 30) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Func02: &quot; &lt;&lt; func02() &lt;&lt; endl;\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-1-1-函数默认参数补充\"><a href=\"#3-1-1-函数默认参数补充\" class=\"headerlink\" title=\"3.1.1 函数默认参数补充\"></a>3.1.1 函数默认参数补充</h5><ul>\n<li><p>默认参数可以是全局变量</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int b &#x3D; 20;\n\nint sum(int a &#x3D; 20, b &#x3D; a)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; sum() &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>默认参数可以是函数名(函数所在内存的地址：指针变量)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void test(int a)\n&#123;\n    cout &lt;&lt; &quot;test(int) - &quot; &lt;&lt; a &lt;&lt; endl;\n&#125;\n\nvoid func(int v1, void(*ptr_Test)(int) &#x3D; test)\n&#123;\n    ptr_Test(v1);\n&#125;\n\nint main()\n&#123;\n    func(20, test);\n    return 0;\n&#125;</code></pre>\n\n<p><code>void(*ptr_Test)(int) = test;</code></p>\n<p><code>ptr_Test(10);</code></p>\n</li>\n<li><p>默认参数，需要<code>保证从右到左</code>依次赋予默认参数，<code>不能出现右边形参没有默认值</code>的情况</p>\n</li>\n<li><p>原理：<code>C++编译转汇编</code>时，调用有默认参数的函数时，先进行<code>push参数</code>，再<code>调用函数</code>，其中<code>优先push最右边的参数值</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void sum(int a, int b &#x3D; 2)\n&#123;\n    cout &lt;&lt; a + b;\n&#125;\n\nint main()\n&#123;\n    sum(1);\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-basic\" data-language=\"basic\"><code class=\"language-basic\">push 2\npush 1\ncall sum()\nadd esp, 8</code></pre></li>\n</ul>\n<h4 id=\"3-2-函数占位参数\"><a href=\"#3-2-函数占位参数\" class=\"headerlink\" title=\"3.2 函数占位参数\"></a>3.2 函数占位参数</h4><ul>\n<li><p>C++函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n</li>\n<li><p>占位参数可以有默认值</p>\n</li>\n<li><p>语法：<code>返回值类型 函数名 （数据类型）&#123;&#125;；</code></p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 占位参数可以有默认值\nvoid func1(int a, int &#x3D; 10)\n&#123;\n    cout &lt;&lt; &quot;Func1 Test&quot; &lt;&lt; endl; \n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 有默认值可以不传实参，否则占位参数也要传实参\n    func1(10, 10);\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-3-函数重载\"><a href=\"#3-3-函数重载\" class=\"headerlink\" title=\"3.3 函数重载\"></a>3.3 函数重载</h4><h5 id=\"3-3-1-函数重载概述\"><a href=\"#3-3-1-函数重载概述\" class=\"headerlink\" title=\"3.3.1 函数重载概述\"></a>3.3.1 函数重载概述</h5><ul>\n<li><p>作用：函数名可以重复，提高复用性</p>\n</li>\n<li><p>条件：</p>\n<ol>\n<li>同一作用域下</li>\n<li>函数名相同</li>\n<li>函数参数类型不同 或 个数不同 或 顺序不同</li>\n</ol>\n</li>\n<li><p>注意：函数的返回值不可以作为函数重载的条件</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid func()\n&#123;\n    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a)\n&#123;\n    cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a, int b)\n&#123;\n    cout &lt;&lt; &quot;func(int a, int b)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a, double b)\n&#123;\n    cout &lt;&lt; &quot;func(int a, double b)&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 返回值不可以作为函数重载的条件\n&#x2F;&#x2F;int func()\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;\n&#x2F;&#x2F;&#125;\n\nint main()\n&#123;\n    func();\n    func(10);\n    func(10, 20);\n    func(10, 20.20);\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"3-3-2-函数重载注意事项\"><a href=\"#3-3-2-函数重载注意事项\" class=\"headerlink\" title=\"3.3.2 函数重载注意事项\"></a>3.3.2 函数重载注意事项</h5><ul>\n<li><p>引用作为重载条件</p>\n</li>\n<li><p>函数重载碰到函数默认参数</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid func()\n&#123;\n    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int &amp;a)\n&#123;\n    cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(const int &amp;a)\n&#123;\n    cout &lt;&lt; &quot;func(const int &amp;a)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int &amp;a, int &amp;b)\n&#123;\n    cout &lt;&lt; &quot;func(int &amp;a, int &amp;b)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2(int a)\n&#123;\n    cout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2(int a, int b &#x3D; 10)\n&#123;\n    cout &lt;&lt; &quot;func(int a, int b &#x3D; 10)&quot; &lt;&lt; endl;\n&#125;\n\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n\n    func();\n    func(a);\n    func(10);\n    func(a, b);\n\n    &#x2F;&#x2F; func2 函数有重载，且其中一个参数有默认值\n    &#x2F;&#x2F;func2(a);\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h6 id=\"3-3-2-1-函数重载补充内容\"><a href=\"#3-3-2-1-函数重载补充内容\" class=\"headerlink\" title=\"3.3.2.1 函数重载补充内容\"></a>3.3.2.1 函数重载补充内容</h6><ul>\n<li><p>函数重载后，<code>并非</code>是所有的重载函数，共同有一个<code>相同的函数名</code>，仅参数不同</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void func();\n\nvoid func(int a);\n\nvoid func(int a, int b);</code></pre>\n\n<p>以上三个函数<code>func</code>是重载函数，在<code>编辑器</code>和我们<code>人类的视角</code>中是有着<code>相同</code>的函数<code>名称func</code>；</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">call func_1()\n\ncall func_2()\n\ncall func_3()</code></pre>\n\n<p>以上是当<code>编译时</code>，<code>C++转汇编</code>时，汇编中的情况，同时这些重载函数的<code>内存地址</code>自然也是<code>不一样</code>的；</p>\n<p>但在<code>编译器</code>中，<code>不同版本</code>或<code>类型的</code>编译器，在编译时会这些重载函数进行<code>重新进行命名</code>；</p>\n</li>\n</ul>\n<h4 id=\"3-4-内联函数\"><a href=\"#3-4-内联函数\" class=\"headerlink\" title=\"3.4 内联函数\"></a>3.4 内联函数</h4><ul>\n<li><p>功能描述：编译器会将内联函数的调用，直接展开成函数体</p>\n</li>\n<li><p>使用<code>inline</code>修饰函数的声明或实现，可以使其变成内联函数(建议声明和实现都使用<code>inline</code>修饰)</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">inline int sum(int a, int b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    int c &#x3D; sum(1, 2);\n    return 0;\n&#125;\n\n&#x2F;&#x2F; sum(1, 2)  &#x3D;&gt; a + b;</code></pre>\n\n\n</li>\n<li><p>内联函数</p>\n<ul>\n<li>缺点：会增加代码的体积</li>\n<li>优点：函数调用，需要开辟栈空间，内联函数不需要，节省资源</li>\n</ul>\n</li>\n<li><p>使用场景：</p>\n<ul>\n<li>函数的体积不大(不超过10行)</li>\n<li>不会被频繁调用</li>\n</ul>\n</li>\n<li><p>补充知识：</p>\n<ul>\n<li>不是所有函数被<code>inline</code>修饰后，编译器都会将其变成内联函数：递归函数</li>\n</ul>\n</li>\n<li><p>通过反汇编查看内联函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">inline int sum(int a, int b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    int c &#x3D; sum(1, 2);\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">&#x2F;&#x2F; int c &#x3D; sum(1, 2);\n\n&#x2F;&#x2F; 普通函数--反汇编\npush 0A\npush 0B\ncall sum()\nadd esp, 8\nmov dword ptr[c], eax\n\n&#x2F;&#x2F; 内联函数--反汇编\nmov eax, 0A\nadd eax, 0B\nmov dword ptr[c],</code></pre></li>\n</ul>\n<h3 id=\"4-类和对象\"><a href=\"#4-类和对象\" class=\"headerlink\" title=\"4. 类和对象\"></a>4. 类和对象</h3><ul>\n<li>C++面向对象的三大特性：封装，继承，多态</li>\n</ul>\n<h4 id=\"4-1-封装\"><a href=\"#4-1-封装\" class=\"headerlink\" title=\"4.1 封装\"></a>4.1 封装</h4><h5 id=\"4-1-1-封装的意义\"><a href=\"#4-1-1-封装的意义\" class=\"headerlink\" title=\"4.1.1 封装的意义\"></a>4.1.1 封装的意义</h5><ul>\n<li><p>意义一：</p>\n<ol>\n<li>将属性和行为作为一个整体，表现生活中的事物</li>\n<li>将属性和行为加以权限控制</li>\n<li>在设计类时，属性和行为写在一起，表现事物</li>\n</ol>\n</li>\n<li><p>语法：<code>class 类名 &#123; 访问权限：属性 / 行为 &#125;；</code></p>\n</li>\n<li><p>示例1：设计一个圆，求圆的周长</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 类名 （圆）\nclass Circle\n&#123;\n    &#x2F;&#x2F; 权限（公开）\npublic:\n    &#x2F;&#x2F; 属性\n    const double Pi &#x3D; 3.14;\n    double cir_R;\n\n    &#x2F;&#x2F; 计算圆周长的函数\n    double calculatePerimeter()\n    &#123;\n        return  2 * Pi * cir_R;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 通过Circle类创建一个实例（对象） c1\n    Circle c1;\n    &#x2F;&#x2F; 通过对象，对类中的属性 cir_R 进行赋值 \n    c1.cir_R &#x3D; 10.0;\n    double value &#x3D; c1.calculatePerimeter();\n    cout &lt;&lt; &quot;Circle perimeter : &quot; &lt;&lt; value &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>示例2：设计一个学生类，属性有姓名和学号，对属性进行赋值，并显示属性信息（两种写法）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Student\n&#123;\npublic:\n    string stu_Name;\n    int stu_ID;\n\n    void printStudentInfo()\n    &#123;\n        cout &lt;&lt; &quot;Student Info : &quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; stu_Name &lt;&lt; &quot;  ID: &quot; &lt;&lt; stu_ID &lt;&lt; endl;\n    &#125;\n&#125;;\n\n\nint main()\n&#123;\n    Student s1;\n    s1.stu_ID &#x3D; 123456;\n    s1.stu_Name &#x3D; &quot;FH&quot;;\n    s1.printStudentInfo();\n\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Student\n&#123;\npublic:\n    string stu_Name;\n    int stu_ID;\n\n    void setName(string name)\n    &#123;\n        stu_Name &#x3D; name;\n    &#125;\n\n    void setID(int id)\n    &#123;\n        stu_ID &#x3D; id;\n    &#125;\n\n    void printStudentInfo()\n    &#123;\n        cout &lt;&lt; &quot;Student Info : &quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; stu_Name &lt;&lt; &quot;  ID: &quot; &lt;&lt; stu_ID &lt;&lt; endl;\n    &#125;\n&#125;;\n\n\nint main()\n&#123;\n    Student s1;\n    s1.setName(&quot;FH&quot;);\n    s1.setID(123456);\n    s1.printStudentInfo();\n\n    Student s2;\n    s2.setName(&quot;CYL&quot;);\n    s2.setID(666666);\n    s2.printStudentInfo();\n\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>意义二：不属性和行为放在不同的权限下，加以控制</p>\n</li>\n<li><p>访问权限三种：</p>\n<table>\n<thead>\n<tr>\n<th>public 公开</th>\n<th>成员类内可访问，类外可访问</th>\n<th>子类可访问</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>protected 保护</td>\n<td>成员类内可访问，类外不可访问</td>\n<td>子类可访问保护内容</td>\n</tr>\n<tr>\n<td>private 私有</td>\n<td>成员类内可访问，类外不可访问</td>\n<td>子类不可访问私有内容</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n\nprotected:\n    string car;\n\nprivate:\n    int password;\n\nprivate:\n    void func()\n    &#123;\n        name &#x3D; &quot;FH&quot;;\n        car &#x3D; &quot;XXX&quot;;\n        password &#x3D; 123456;\n    &#125;\n&#125;;\n\n\nint main()\n&#123;\n    Person p1;\n    p1.name &#x3D; &quot;CYL&quot;;\n\n    &#x2F;&#x2F;p1.car &#x3D; &quot;YYY&quot;; &#x2F;&#x2F; 保护权限内容，类外不可访问和修改\n    &#x2F;&#x2F;p1.password &#x3D; 999999; &#x2F;&#x2F; 私有权限内容，类外不可访问和修改\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-1-2-struct和class区别\"><a href=\"#4-1-2-struct和class区别\" class=\"headerlink\" title=\"4.1.2 struct和class区别\"></a>4.1.2 struct和class区别</h5><ul>\n<li><p>区别：struct 默认权限为公开；class默认权限为私有</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass C1\n&#123;\n    int a;\n&#125;;\n\nstruct C2\n&#123;\n    int a;\n&#125;;\n\nint main()\n&#123;\n    C1 c1;\n    C2 c2;\n    \n    &#x2F;&#x2F;c1.a &#x3D; 10; &#x2F;&#x2F; class默认私有，无法访问\n    c2.a &#x3D; 10; &#x2F;&#x2F; struct默认公开，可以访问\n    \n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-1-3-成员属性私有化\"><a href=\"#4-1-3-成员属性私有化\" class=\"headerlink\" title=\"4.1.3 成员属性私有化\"></a>4.1.3 成员属性私有化</h5><ul>\n<li><p>优点：</p>\n<ol>\n<li>将所有成员属性设置为私有，可以自己控制读写权限</li>\n<li>对于写权限，可以检测数据的有效性</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    void setName(string name)\n    &#123;\n        p_Name &#x3D; name;\n    &#125;\n    string getName()\n    &#123;\n        return p_Name;\n    &#125;\n\n    int getAge()\n    &#123;\n        p_Age &#x3D; 24;\n        return p_Age;\n    &#125;\n\n    void setID(int id)\n    &#123;\n        p_ID &#x3D; id;\n    &#125;\n\nprivate:\n    string p_Name; &#x2F;&#x2F; 可读可写\n    int p_Age; &#x2F;&#x2F; 可读\n    int p_ID; &#x2F;&#x2F; 可写\n&#125;;\n\nint main()\n&#123;\n    Person p;\n    p.setName(&quot;FH&quot;);\n    p.setID(123455);\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n    cout &lt;&lt; &quot;Age: &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-1-4-案例：设计立方体\"><a href=\"#4-1-4-案例：设计立方体\" class=\"headerlink\" title=\"4.1.4 案例：设计立方体\"></a>4.1.4 案例：设计立方体</h5><ul>\n<li><p>要求：设计立法体类（cube），求面积和体积，分别用全局函数和成员函数判断两个立方体是否相等</p>\n</li>\n<li><p>代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Cube\n&#123;\nprivate:\n    float c_Length &#x3D; 1.0;\n    float c_Width &#x3D; 1.0;\n    float c_Height &#x3D; 1.0;\n\npublic:\n    void setLength(float length)\n    &#123;\n        c_Length &#x3D; length;\n    &#125;\n\n    float getLength() const\n    &#123;\n        return c_Length;\n    &#125;\n\n    void setWidth(float width)\n    &#123;\n        c_Width &#x3D; width;\n    &#125;\n\n    float getWidth() const\n    &#123;\n        return c_Width;\n    &#125;\n\n    void setHeight(float height)\n    &#123;\n        c_Height &#x3D; height;\n    &#125;\n\n    float getHeight() const\n    &#123;\n        return c_Height;\n    &#125;\n\n    float calculateArea() const\n    &#123;\n        return 2 * c_Length * c_Width + 2 * c_Length * c_Height + 2 * c_Width * c_Height;\n    &#125;\n\n    float calculateVolume() const\n    &#123;\n        return c_Height * c_Width * c_Length;\n    &#125;\n\n    &#x2F;&#x2F; 成员函数判断两个立方体是否相等\n    string calculateSameFromClass(Cube &amp;c) const\n    &#123;\n        if (c.getLength() &#x3D;&#x3D; c_Length &amp;&amp; c.getWidth() &#x3D;&#x3D; c_Width &amp;&amp; c.getHeight() &#x3D;&#x3D; c_Height)\n        &#123;\n            return &quot;Class_Same!!!&quot;;\n        &#125;\n        return &quot;Class_No Same!!!&quot;;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 全局函数判断两个立方体是否相等\nstring calculateSameFromGlobal(Cube &amp;c1, Cube &amp;c2)\n&#123;\n    if (c1.getHeight() &#x3D;&#x3D; c2.getHeight() &amp;&amp; c1.getWidth() &#x3D;&#x3D; c2.getWidth() &amp;&amp; c1.getLength() &#x3D;&#x3D; c2.getLength())\n    &#123;\n        return &quot;Global_Same!!!&quot;;\n    &#125;\n    return &quot;Global_No Same!!!&quot;;\n&#125;\n\nint main()\n&#123;\n    Cube c1;\n    Cube c2;\n    Cube c3;\n\n    c1.setHeight(10.0);\n    c1.setLength(10.0);\n    c1.setWidth(10.0);\n\n    c2.setHeight(10.0);\n    c2.setLength(10.0);\n    c2.setWidth(10.0);\n\n    c3.setHeight(20.0);\n    c3.setLength(20.0);\n    c3.setWidth(20.0);\n\n    &#x2F;&#x2F; 存储立方体的面积以及体积返回的值\n    float cube_Area &#x3D; c1.calculateArea();\n    float cube_Volume &#x3D; c1.calculateVolume();\n\n    &#x2F;&#x2F; 存储两种函数等到的判断返回结果\n    string global_Same &#x3D; calculateSameFromGlobal(c1, c2);\n    string class_Same &#x3D; c1.calculateSameFromClass(c3);\n\n    cout &lt;&lt; &quot;Cube Area: &quot; &lt;&lt; cube_Area &lt;&lt; endl;\n    cout &lt;&lt; &quot;Cube Volume: &quot; &lt;&lt; cube_Volume &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;Global_Same: &quot; &lt;&lt; global_Same &lt;&lt; endl;\n    cout &lt;&lt; &quot;Class_Same: &quot; &lt;&lt; class_Same &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-1-5-案例：点圆的关系\"><a href=\"#4-1-5-案例：点圆的关系\" class=\"headerlink\" title=\"4.1.5 案例：点圆的关系\"></a>4.1.5 案例：点圆的关系</h5><ul>\n<li><p>要求：设计圆类（Circle）设计点类（Point），计算点和圆的包含关系（圆外）（圆上）（圆内）（圆心）</p>\n</li>\n<li><p>代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 点类\nclass Point\n&#123;\nprivate:\n    &#x2F;&#x2F; 点X坐标\n    double p_X;\n    &#x2F;&#x2F; 点Y坐标\n    double p_Y;\n\npublic:\n    void set_X(double x)\n    &#123;\n        p_X &#x3D; x;\n    &#125;\n    double get_X() const\n    &#123;\n        return p_X;\n    &#125;\n\n    void set_Y(double y)\n    &#123;\n        p_Y &#x3D; y;\n    &#125;\n    double get_Y() const\n    &#123;\n        return p_Y;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 圆类\nclass Circle\n&#123;\nprivate:\n    &#x2F;&#x2F; 圆的半径\n    double c_Radius;\n    &#x2F;&#x2F; 圆心的坐标\n    Point c_Center;\n\npublic:\n    void setRadius(double radius)\n    &#123;\n        c_Radius &#x3D; radius;\n    &#125;\n    double getRadius() const\n    &#123;\n        return c_Radius;\n    &#125;\n\n    void setCenter(Point &amp;center)\n    &#123;\n        c_Center &#x3D; center;\n    &#125;\n    Point getCenter()\n    &#123;\n        return c_Center;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 计算圆与点之间的关系\nvoid calculateCircleAndPoint(Circle &amp;c, Point &amp;p)\n&#123;\n    &#x2F;&#x2F; 圆心点X - 点X\n    double ppDistanceX &#x3D; c.getCenter().get_X() - p.get_X();\n    &#x2F;&#x2F; 圆心点Y - 点Y\n    double ppDistanceY &#x3D; c.getCenter().get_Y() - p.get_X();\n    &#x2F;&#x2F; 圆的半径\n    double rDistanceR &#x3D; c.getRadius();\n\n    &#x2F;&#x2F; 分别计算：圆心X到点X的平方值，圆心Y到点Y的平方值，圆半径的平方值\n    double powX &#x3D; pow(ppDistanceX, 2);\n    double powY &#x3D; pow(ppDistanceY, 2);\n    double powR &#x3D; pow(rDistanceR, 2);\n\n    &#x2F;&#x2F; 等到判断关系值 （x - x1）^2 + (y - y1)^2 &#x3D; r^2\n    double ppDistance &#x3D; powX + powY;\n    double rDistance &#x3D; powR;\n\n\n    if (ppDistance &#x3D;&#x3D; rDistance)\n    &#123;\n        cout &lt;&lt; &quot;Point On The Circle&quot; &lt;&lt; endl;\n    &#125;\n    else if (ppDistance &lt; rDistance)\n    &#123;\n        cout &lt;&lt; &quot;Point Within The Circle&quot; &lt;&lt; endl;\n    &#125;\n    else if (ppDistance &gt; rDistance)\n    &#123;\n        cout &lt;&lt; &quot;Point Outside The Circle&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 实例化一个圆\n    Circle c&#123;&#125;;\n    &#x2F;&#x2F; 实例化一个圆心的坐标 和 点的坐标\n    Point p_center&#123;&#125;;\n    Point p&#123;&#125;;\n\n    p_center.set_X(10.0);\n    p_center.set_Y(0);\n    p.set_X(10.0);\n    p.set_Y(10.0);\n    c.setRadius(10.0);\n    c.setCenter(p_center);\n\n    calculateCircleAndPoint(c, p);\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"4-2-对象初始化和清理\"><a href=\"#4-2-对象初始化和清理\" class=\"headerlink\" title=\"4.2 对象初始化和清理\"></a>4.2 对象初始化和清理</h4><ul>\n<li>C++中每个对象都有初始设置以及对象销毁前的清理数据的设置</li>\n</ul>\n<h5 id=\"4-2-1-构造函数和析构函数\"><a href=\"#4-2-1-构造函数和析构函数\" class=\"headerlink\" title=\"4.2.1 构造函数和析构函数\"></a>4.2.1 构造函数和析构函数</h5><p>问题：</p>\n<ul>\n<li>对象的初始化和清理是两个很重要的安全问题</li>\n<li>一个对象或者变量没有初始化状态，使用的后果是未知的</li>\n<li>使用完一个对象或变量，没有及时清理，也会造成安全问题</li>\n</ul>\n<p>解决：</p>\n<ul>\n<li>C++利用构造函数和析构函数解决问题，这两个函数被编译器自动调用，完成对象的初始化和清理工作</li>\n<li>对象的初始化和清理工作是编译器强制要求的，如果不提供构造函数和析构函数，编译器会提供编译器提供的构造函数和析构函数是空实现</li>\n</ul>\n<p>含义：</p>\n<ul>\n<li>构造函数：主要为创建对象时为对象的成员属性赋值，构造函数由编译器自动调用</li>\n<li>析构函数：主要为对象销毁前系统自动调用，执行清理工作</li>\n</ul>\n<p>构造函数语法：<code>类名（）&#123;&#125;;</code></p>\n<ol>\n<li>构造函数，没有返回值和void</li>\n<li>函数名称和类名相同</li>\n<li>构造函数可以有参数，所以可以重载</li>\n<li>程序在调用对象时，会自动调用构造函数，且只调用一次</li>\n</ol>\n<p>析构函数语法：<code>~ 类名（）&#123;&#125;;</code></p>\n<ol>\n<li>析构函数，没有返回值和void</li>\n<li>函数名称和类名不相同，在前面加 ~</li>\n<li>构造函数部可以有参数，所以不可以重载</li>\n<li>程序在调用对象时，会自动调用析构函数，且只调用一次</li>\n</ol>\n<p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Test\n&#123;\npublic:\n    Test()\n    &#123;\n        cout &lt;&lt; &quot;Test构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Test()\n    &#123;\n        cout &lt;&lt; &quot;Test析构函数&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Test t1;\n&#125;\n\nint main()\n&#123;\n    demo(); &#x2F;&#x2F; 函数执行时调用构造函数，结束时调用析构函数\n    Test t2; &#x2F;&#x2F; 函数执行时调用构造函数\n    system(&quot;pause&quot;); &#x2F;&#x2F; 程序在此处暂停，析构函数为被调用，按任意键后执行析构函数\n    return 0;\n&#125;</code></pre>\n\n\n\n\n\n<h5 id=\"4-2-2-构造函数分类及调用\"><a href=\"#4-2-2-构造函数分类及调用\" class=\"headerlink\" title=\"4.2.2 构造函数分类及调用\"></a>4.2.2 构造函数分类及调用</h5><ul>\n<li><p>分类：</p>\n<ol>\n<li>按参数分为：有参构造，无参构造</li>\n<li>按类型分为：普通构造，拷贝构造</li>\n</ol>\n</li>\n<li><p>调用：</p>\n<ol>\n<li>括号法</li>\n<li>显示法</li>\n<li>隐式转换法</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\n\npublic:\n    &#x2F;&#x2F; 创建构造函数\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int a)\n    &#123;\n        age &#x3D; a;\n        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(const Person &amp;p) &#x2F;&#x2F; 将对象的属性拷贝进来\n    &#123;\n        age &#x3D; p.age;\n        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;\n    &#125;\n\n    int age;\n&#125;;\n\n&#x2F;&#x2F; 调用构造函数\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 括号法调用\n    &#x2F;&#x2F; 注意：无参构造函数不用括号：Person p1(); 编译器会作为 void func(); 声明来处理，调用空实现的构造函数\n    Person p1; &#x2F;&#x2F; 无参构造函数\n    Person p2(10); &#x2F;&#x2F; 有参构造函数\n    Person p3(p2); &#x2F;&#x2F; 拷贝构造函数\n\n    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.age &lt;&lt; endl;\n    cout &lt;&lt; &quot;p3 age: &quot; &lt;&lt; p3.age &lt;&lt; endl;\n\n    &#x2F;&#x2F; 显示法调用\n    Person p4;\n    Person p5 &#x3D; Person(20);\n    Person p6 &#x3D; Person(p5);\n    &#x2F;&#x2F; 注意 Person(20) 单独写出来为匿名对象，程序中无法使用，执行完会被系统立即回收\n    &#x2F;&#x2F; 注意 不用拷贝函数初始化匿名对象，Person(p6) 编译器等价于 Person p6 , 而 Person p6 已经作为对象被实例化了\n\n    &#x2F;&#x2F; 隐式转换法调用\n    Person p7 &#x3D; 10; &#x2F;&#x2F; 等价于 Person p7 &#x3D; Person(10);\n    Person p8 &#x3D; p7;\n\n    system(&quot;pause&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-2-3-拷贝构造函数调用时机\"><a href=\"#4-2-3-拷贝构造函数调用时机\" class=\"headerlink\" title=\"4.2.3 拷贝构造函数调用时机\"></a>4.2.3 拷贝构造函数调用时机</h5><ul>\n<li><p>C++中拷贝构造函数调用时机三种情况\t</p>\n<ol>\n<li>使用一个已经创建的对象来初始化一个新对象</li>\n<li>值传递的方式给函数参数传值</li>\n<li>以值方式返回局部对象</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int p_age;\n\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int a)\n    &#123;\n        p_age &#x3D; a;\n        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(const Person &amp;person)\n    &#123;\n        p_age &#x3D; person.p_age;\n        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;1. 使用一个已经创建的对象来初始化一个新对象\nvoid demo1()\n&#123;\n    Person p1(10); &#x2F;&#x2F; 有参构造\n    Person p2(p1); &#x2F;&#x2F; 拷贝构造\n    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.p_age &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;2. 值传递的方式给函数参数传值\nvoid test2(Person person)\n&#123;\n\n&#125;\n\nvoid demo2()\n&#123;\n    Person p3; &#x2F;&#x2F; 默认构造\n    test2(p3); &#x2F;&#x2F; 拷贝构造 - 此处 p3 为p3对象的副本（拷贝）\n&#125;\n\n&#x2F;&#x2F;3. 以值方式返回局部对象\nPerson test3()\n&#123;\n    Person p4; &#x2F;&#x2F; 默认构造\n    cout &lt;&lt; &quot;p4 address: &quot; &lt;&lt; (int *) &amp;p4 &lt;&lt; endl;\n    return p4; &#x2F;&#x2F; 此处 p4 为p4对象的副本（拷贝）\n&#125;\n\nvoid demo3()\n&#123;\n    Person p5 &#x3D; test3(); &#x2F;&#x2F; 拷贝构造 - 得到 p4 的对象副本\n    cout &lt;&lt; &quot;p5 address: &quot; &lt;&lt; (int *) &amp;p5 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F;demo1();\n    &#x2F;&#x2F;demo2();\n    demo3();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-2-4-构造函数调用规则\"><a href=\"#4-2-4-构造函数调用规则\" class=\"headerlink\" title=\"4.2.4 构造函数调用规则\"></a>4.2.4 构造函数调用规则</h5><ul>\n<li><p>默认情况下，C++编译器至少给一个类添三个函数</p>\n<ol>\n<li>默认构造函数（无参，函数体为空）</li>\n<li>默认析构函数（无参，函数体为空）</li>\n<li>默认拷贝构造函数 对类实例化的对象的属性值拷贝</li>\n</ol>\n</li>\n<li><p>调用规则：</p>\n<ol>\n<li>如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数</li>\n<li>如果自定义拷贝构造函数，编译器不提供其他构造函数</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int p_age;\n\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int a)\n    &#123;\n        p_age &#x3D; a;\n        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(const Person &amp;person)\n    &#123;\n        p_age &#x3D; person.p_age;\n        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;1. 如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数\nvoid demo1() &#x2F;&#x2F; 默认构造函数不会被调用\n&#123;\n    Person p1(10);\n    Person p2(p1);\n&#125;\n\n&#x2F;&#x2F;2. 如果自定义拷贝构造函数，编译器不提供其他构造函数\nvoid demo2() &#x2F;&#x2F; 自定义拷贝构造函数后，其他构造函数需自己添加\n&#123;\n Person p3;\n Person p4(p3);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-2-5-深拷贝和浅拷贝\"><a href=\"#4-2-5-深拷贝和浅拷贝\" class=\"headerlink\" title=\"4.2.5 深拷贝和浅拷贝\"></a>4.2.5 深拷贝和浅拷贝</h5><ul>\n<li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n</li>\n<li><p>浅拷贝：简单的赋值拷贝（编译器默认提供的拷贝构造函数就是浅拷贝）</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int p_age;\n    int *p_height;\n\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int a, int height)\n    &#123;\n        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;\n        p_age &#x3D; a;\n        p_height &#x3D; new int(height);\n    &#125;\n\n    &#x2F;&#x2F; 通过深拷贝的方法解决浅拷贝带来的问题 深拷贝定义后，编译器默认执行该构造函数\n    Person(const Person &amp;person)\n    &#123;\n        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;\n        p_age &#x3D; person.p_age;\n        p_height &#x3D; new int(*person.p_height); &#x2F;&#x2F; 自定义的赋值方式，堆中开辟空间\n        &#x2F;&#x2F;p_height &#x3D; person.p_height; &#x2F;&#x2F; 编译器默认的赋值方式\n    &#125;\n\n&#x2F;&#x2F; 浅拷贝时，p2 内的 p_height 被释放，p1 无可释放，程序执行非法操作（报错）\n&#x2F;&#x2F; 深拷贝时，p2 内的 p_height 是单独的堆区空间被释放，不影响 p1 的 p_height 内存释放（正确）\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person析构函数&quot; &lt;&lt; endl;\n        if (p_height !&#x3D; NULL)\n        &#123;\n            delete p_height;\n            p_height &#x3D; NULL;\n        &#125;\n    &#125;\n&#125;;\n\nvoid demoTest() &#x2F;&#x2F; 栈区内存释放的顺序是先进后出，所以析构函数 释放内存是从 p2 开始\n&#123;\n    Person p1(10, 170);\n    cout &lt;&lt; &quot;p1 age: &quot; &lt;&lt; p1.p_age &lt;&lt; &quot; p1 height: &quot; &lt;&lt; *p1.p_height &lt;&lt; endl;\n    Person p2(p1); &#x2F;&#x2F; 编译器提供的浅构造函数，解析的是p1指针指向的内存空间\n    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.p_age &lt;&lt; &quot; p2 height: &quot; &lt;&lt; *p2.p_height &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demoTest();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-2-6-初始化列表\"><a href=\"#4-2-6-初始化列表\" class=\"headerlink\" title=\"4.2.6 初始化列表\"></a>4.2.6 初始化列表</h5><ul>\n<li><p>作用：C++提供初始化列表，用来初始化属性</p>\n</li>\n<li><p>语法：<code>构造函数（）：属性1（值1），属性2（值2）... &#123;&#125;</code></p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int p_a;\n    int p_b;\n\n    &#x2F;&#x2F; 通过有参构造函数初始化属性值\n&#x2F;&#x2F;    Person(int a, int b)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        p_a &#x3D; a;\n&#x2F;&#x2F;        p_b &#x3D; b;\n&#x2F;&#x2F;    &#125;\n\n&#x2F;&#x2F; 通过初始化列表来初始化属性值\n    Person(int a, int b) : p_a(a), p_b(b)\n    &#123;\n\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Person p1(10, 20);\n    cout &lt;&lt; &quot;p1 a: &quot; &lt;&lt; p1.p_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;p1 b: &quot; &lt;&lt; p1.p_b &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-2-7-类对象作为类成员\"><a href=\"#4-2-7-类对象作为类成员\" class=\"headerlink\" title=\"4.2.7 类对象作为类成员\"></a>4.2.7 类对象作为类成员</h5><ul>\n<li><p>C++类中的成员可以说另一个类的对象，称为：对象成员</p>\n</li>\n<li><p>例如：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class A &#123;&#125;\nclass B\n&#123;\n    A a;\n&#125;</code></pre>\n</li>\n<li><p>B类中有对象作为成员，A为对象成员</p>\n</li>\n<li><p>程序执行时，先构造A，再构造B</p>\n</li>\n<li><p>程序结束时，先析构B，再析构A</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Phone\n&#123;\npublic:\n    string p_Name;\n\n    Phone(string name)\n    &#123;\n        cout &lt;&lt; &quot;Phone 构造函数调用 (先构造)&quot; &lt;&lt; endl;\n        p_Name &#x3D; name;\n    &#125;\n\n    ~Phone()\n    &#123;\n        cout &lt;&lt; &quot;Phone 析构函数调用&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Human\n&#123;\npublic:\n    string h_Name;\n    Phone h_Phone;\n\n    Human(string name, string phone) : h_Name(name), h_Phone(phone)\n    &#123;\n        cout &lt;&lt; &quot;Human 构造函数调用&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Human()\n    &#123;\n        cout &lt;&lt; &quot;Human 析构函数调用 (先析构)&quot; &lt;&lt; endl;\n    &#125;\n\n&#125;;\n\nvoid demo()\n&#123;\n    Human h(&quot;FH&quot;, &quot;Apple&quot;);\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; h.h_Name &lt;&lt; &quot; Phone: &quot; &lt;&lt; h.h_Phone.p_Name &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-2-8-静态成员\"><a href=\"#4-2-8-静态成员\" class=\"headerlink\" title=\"4.2.8 静态成员\"></a>4.2.8 静态成员</h5><ul>\n<li><p>定义：在成员变量和成员函数前加关键字static，称为静态成员</p>\n</li>\n<li><p>分类：</p>\n<ol>\n<li>静态成员变量<ul>\n<li>所有对象共享一份数据</li>\n<li>在编译阶段分配内存</li>\n<li>类内声明，类外初始化</li>\n</ul>\n</li>\n<li>静态成员函数<ul>\n<li>所有对象共享一个函数</li>\n<li>静态成员函数只能访问静态成员变量</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    static int p_num; &#x2F;&#x2F; 静态成员变量 类内声明\n\n    static void func() &#x2F;&#x2F; 静态成员函数\n    &#123;\n        p_num &#x3D; 100;\n        cout &lt;&lt; &quot;num: &quot; &lt;&lt; p_num &lt;&lt; endl;\n    &#125;\n\nprivate: &#x2F;&#x2F; 静态成员变量的访问权限可以为私密 类外无法访问\n    static void func2()\n    &#123;\n        cout &lt;&lt; &quot;private func2&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint Person::p_num &#x3D; 0; &#x2F;&#x2F; 静态成员变量 类外初始化\n\nint main()\n&#123;\n    &#x2F;&#x2F; 通过对象访问\n    Person p;\n    p.func();\n\n    &#x2F;&#x2F; 通过类名访问 （静态成员函数可以直接通过类的作用域直接调用）\n    Person::func();\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"4-3-对象模型和this指针\"><a href=\"#4-3-对象模型和this指针\" class=\"headerlink\" title=\"4.3 对象模型和this指针\"></a>4.3 对象模型和this指针</h4><h5 id=\"4-3-1-成员变量和成员函数分开存储\"><a href=\"#4-3-1-成员变量和成员函数分开存储\" class=\"headerlink\" title=\"4.3.1 成员变量和成员函数分开存储\"></a>4.3.1 成员变量和成员函数分开存储</h5><ul>\n<li><p>C++中，类内的成员变量和成员函数分开存储</p>\n</li>\n<li><p>只有非静态成员变量才属于类的对象上</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass demo1\n&#123;\n    &#x2F;&#x2F; 空对象 默认 占内存空间 1\n&#125;;\n\nclass demo2\n&#123;\n    int num &#x3D; 0; &#x2F;&#x2F; 非空对象 占内存空间 依据成员变量\n&#125;;\n\nclass demo3\n&#123;\n    int num3 &#x3D; 0;\n    static int s_num; &#x2F;&#x2F; 静态成员变量 不在类的对象上\n\n    void func()\n    &#123;\n        &#x2F;&#x2F; 成员函数 不在类的对象上 (无论是否静态)\n    &#125;\n&#125;;\n\nint demo3::s_num &#x3D; 0;\n\nvoid Test1()\n&#123;\n    cout &lt;&lt; &quot;Size of demo1: &quot; &lt;&lt; sizeof(demo1) &lt;&lt; endl;\n&#125;\n\nvoid Test2()\n&#123;\n    cout &lt;&lt; &quot;Size of demo2: &quot; &lt;&lt; sizeof(demo2) &lt;&lt; endl;\n&#125;\n\nvoid Test3()\n&#123;\n    cout &lt;&lt; &quot;Size of demo3: &quot; &lt;&lt; sizeof(demo3) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    Test1();\n    Test2();\n    Test3();\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-3-2-this指针概念\"><a href=\"#4-3-2-this指针概念\" class=\"headerlink\" title=\"4.3.2 this指针概念\"></a>4.3.2 this指针概念</h5><ul>\n<li><p>作用：this指针指向被调用的成员函数所属对象</p>\n</li>\n<li><p>this指针是隐含每个非静态成员函数的一种指针</p>\n</li>\n<li><p>this指针不需定义，直接使用</p>\n</li>\n<li><p>用途：</p>\n<ol>\n<li>当形参和成员变量同名时，可用this指针来区分</li>\n<li>在类的非静态成员函数返回对象本身，可使用 return *this；</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int age;\n\n    Person(int age)\n    &#123;\n        &#x2F;&#x2F; this可以区分相同名称的变量\n        this-&gt;age &#x3D; age;\n    &#125;\n\n    &#x2F;&#x2F;返回的是Person对象的引用\n    Person &amp;addPersonAge(Person &amp;p)\n    &#123;\n        this-&gt;age +&#x3D; p.age;\n        return *this; &#x2F;&#x2F; 返回对象为 *this\n    &#125;\n&#125;;\n\nvoid func1()\n&#123;\n    Person p1(10);\n    cout &lt;&lt; &quot;p1 Age: &quot; &lt;&lt; p1.age &lt;&lt; endl;\n&#125;\n\nvoid func2()\n&#123;\n    Person p2(20);\n    Person p3(20);\n    &#x2F;&#x2F; 链式编程思想\n    &#x2F;&#x2F; p3.addPersonAge(p2) 的执行结果是返回 对象的本身，所以可以链式调用成员函数\n    p3.addPersonAge(p2).addPersonAge(p2).addPersonAge(p2);\n    cout &lt;&lt; &quot;p3 Age: &quot; &lt;&lt; p3.age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    func1();\n    func2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-3-3-空指针访问成员函数\"><a href=\"#4-3-3-空指针访问成员函数\" class=\"headerlink\" title=\"4.3.3 空指针访问成员函数\"></a>4.3.3 空指针访问成员函数</h5><ul>\n<li><p>C++中空指针可以调用成员函数，但要注意是否用到this</p>\n</li>\n<li><p>如果用到this，需要加上判断，保证代码的安全</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Demo\n&#123;\npublic:\n    int age &#x3D; 10;\n\n    void func1()\n    &#123;\n        cout &lt;&lt; &quot;func1&quot; &lt;&lt; endl;\n    &#125;\n\n    void func2()\n    &#123;\n        &#x2F;&#x2F; 为保证安全性，防止传入的空指针调用成员变量导致崩溃\n        if (this &#x3D;&#x3D; NULL)\n        &#123;\n            return;\n        &#125;\n        &#x2F;&#x2F; 此处的this 《&#x3D;&#x3D;》 this.age this是空的，无实际对象，无法调用\n        cout &lt;&lt; &quot;func2 &quot; &lt;&lt; age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid test()\n&#123;\n    &#x2F;&#x2F; 创建一个对象的地址为空\n    Demo *d &#x3D; NULL;\n    d-&gt;func1();\n    d-&gt;func2();\n&#125;\n\nint main()\n&#123;\n    test();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-3-4-const修饰成员函数\"><a href=\"#4-3-4-const修饰成员函数\" class=\"headerlink\" title=\"4.3.4 const修饰成员函数\"></a>4.3.4 const修饰成员函数</h5><ul>\n<li><p>常函数：</p>\n<ol>\n<li>成员函数后加const，该函数称为常函数</li>\n<li>常函数内不可以修改成员属性</li>\n<li>成员属性声明时加关键字mutable，在常函数中依然可以修改</li>\n</ol>\n</li>\n<li><p>常对象</p>\n<ol>\n<li>声明对象前加const，则称为常对象</li>\n<li>常对象只能调用常函数</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int age;\n    &#x2F;&#x2F; mutable 修饰的成员变量\n    mutable int id;\n\n    &#x2F;&#x2F; this指针是指针常量，指针的指向不可修改\n    &#x2F;&#x2F; const Person *const this；\n    &#x2F;&#x2F; 常量函数的const 修饰的this指针 让this指针指向的值也不可修改\n    void printAge() const\n    &#123;\n        &#x2F;&#x2F; this-&gt;age &#x3D; 10;\n\n        &#x2F;&#x2F; 常函数可以修改 mutable的值\n        this-&gt;id &#x3D; 10;\n    &#125;\n\n    void printID()\n    &#123;\n\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 常对象\n    const Person p&#123;&#125;;\n\n    p.printAge();\n    &#x2F;&#x2F;p.printID(); &#x2F;&#x2F; 常对象只能调用 常函数\n\n    &#x2F;&#x2F;p.age &#x3D; 100; &#x2F;&#x2F; 常对象内的成员变量属性值不能修改\n    p.id &#x3D; 100; &#x2F;&#x2F; 常对象内的mutable成员变量属性值能修改\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"4-4-友元\"><a href=\"#4-4-友元\" class=\"headerlink\" title=\"4.4 友元\"></a>4.4 友元</h4><ul>\n<li>作用：目的是让一个函数或者类访问另一个类中的私有成员</li>\n<li>关键字：friend</li>\n<li>实现：<ol>\n<li>全局函数做友元</li>\n<li>类做友元</li>\n<li>成员函数做友元</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"4-4-1-全局函数做友元\"><a href=\"#4-4-1-全局函数做友元\" class=\"headerlink\" title=\"4.4.1 全局函数做友元\"></a>4.4.1 全局函数做友元</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Room\n&#123;\n    &#x2F;&#x2F; 将一个全局函数 在类中 通过friend关键在修饰 声明后，该全局函数可以访问 类中私有的成员变量属性\n    friend void Func_Friend(Room *room);\nprivate:\n    string privateRoom;\n\npublic:\n    string publicRoom;\n\n    Room()\n    &#123;\n        privateRoom &#x3D; &quot;privateRoom Access Succeeded&quot;;\n        publicRoom &#x3D; &quot;publicRoom Access Succeeded&quot;;\n    &#125;\n&#125;;\n\nvoid Func_Friend(Room *room)\n&#123;\n    cout &lt;&lt; &quot;Friend Function Access: &quot; &lt;&lt; room-&gt;publicRoom &lt;&lt; endl;\n    &#x2F;&#x2F; 声明友元后，可以正常访问类中的私有成员变量\n    cout &lt;&lt; &quot;Friend Function Access: &quot; &lt;&lt; room-&gt;privateRoom &lt;&lt; endl;\n&#125;\n\nvoid Test()\n&#123;\n    Room room;\n    Func_Friend(&amp;room);\n&#125;\n\nint main()\n&#123;\n    Test();\n    return 0;\n&#125;</code></pre>\n\n\n\n\n\n<h5 id=\"4-4-2-类做友元\"><a href=\"#4-4-2-类做友元\" class=\"headerlink\" title=\"4.4.2 类做友元\"></a>4.4.2 类做友元</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 先声明一个 Service类\nclass Service;\n\nclass User\n&#123;\nprivate:\n    &#x2F;&#x2F; 定义一个 私有 Service类对象的指针\n    Service *service;\n\npublic:\n    &#x2F;&#x2F; 构造函数和成员函数写在类外\n    User();\n    void access();\n&#125;;\n\nclass Service\n&#123;\n    &#x2F;&#x2F; 将 User类 声明为 Service类的友元类 使得User类的对象是 Service类得到友元对象，可以访问私有成员变量的属性\n    friend class User;\nprivate:\n    string priContent;\n\npublic:\n    string pubContent;\n\n    &#x2F;&#x2F; 构造函数声明在外\n    Service();\n&#125;;\n\n&#x2F;&#x2F; 通过User类的作用域创建一个User类的构造函数，初始化User类中的成员变量的属性值\nUser::User()\n&#123;\n    &#x2F;&#x2F; 创建一个Service类的对象指针\n    service &#x3D; new Service;\n&#125;\n\n&#x2F;&#x2F; 通过User类的作用域创建一个User类的成员函数\nvoid User::access()\n&#123;\n    cout &lt;&lt; &quot;User Access Service: &quot; &lt;&lt; service-&gt;pubContent &lt;&lt; endl;\n    &#x2F;&#x2F; 当User类成为Service类的友元后，可以在User的函数内访问 Service类中的私有成员变量属性\n    cout &lt;&lt; &quot;User Access Service: &quot; &lt;&lt; service-&gt;priContent &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 通过Service类的作用域创建一个Service类的构造函数\nService::Service()\n&#123;\n    this-&gt;priContent &#x3D; &quot;priContent&quot;;\n    this-&gt;pubContent &#x3D; &quot;pubContent&quot;;\n&#125;\n\nvoid demo()\n&#123;\n    User user;\n    user.access();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n\n\n\n\n<h5 id=\"4-4-3-成员函数做友元\"><a href=\"#4-4-3-成员函数做友元\" class=\"headerlink\" title=\"4.4.3 成员函数做友元\"></a>4.4.3 成员函数做友元</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Service;\n\nclass User\n&#123;\npublic:\n    Service *service;\n\n    User();\n\n    void access1();\n    void access2();\n&#125;;\n\nclass Service\n&#123;\n    &#x2F;&#x2F; 通过friend关键字 声明User类中的成员函数access2() 是Service类的友元函数\n    friend void User::access2();\nprivate:\n    string priContent;\n\npublic:\n    string pubContent;\n\n    Service();\n&#125;;\n\n&#x2F;&#x2F; User类和Service类的构造函数和成员函数在类外创建，类内声明\nUser::User()\n&#123;\n    service &#x3D; new Service;\n&#125;\n\nvoid User::access1()\n&#123;\n    cout &lt;&lt; &quot;Access pubContent: &quot; &lt;&lt; service-&gt;pubContent &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 访问Service类中的私有成员变量的属性\nvoid User::access2()\n&#123;\n    cout &lt;&lt; &quot;Access priContent: &quot; &lt;&lt; service-&gt;priContent &lt;&lt; endl;\n&#125;\n\nService::Service()\n&#123;\n    priContent &#x3D; &quot;priContent&quot;;\n    pubContent &#x3D; &quot;pubContent&quot;;\n&#125;\n\nvoid demo()\n&#123;\n    User user;\n    user.access1();\n    user.access2();\n&#125;\n\nint main()\n&#123;\n    demo();\n\n    return 0;\n&#125;</code></pre>\n\n\n\n\n\n<h4 id=\"4-5-运算符重载\"><a href=\"#4-5-运算符重载\" class=\"headerlink\" title=\"4.5 运算符重载\"></a>4.5 运算符重载</h4><ul>\n<li>概念：对已有的运算符进行重新的定义，赋予另一种功能，以适应不同的数据类型</li>\n</ul>\n<h5 id=\"4-5-1-加号运算符重载\"><a href=\"#4-5-1-加号运算符重载\" class=\"headerlink\" title=\"4.5.1 加号运算符重载\"></a>4.5.1 加号运算符重载</h5><ul>\n<li><p>作用：实现两个自定义数据类型相加的运算</p>\n</li>\n<li><p>编辑器提供了通用名称：operator+</p>\n</li>\n<li><p>内置的不能使用运算符重载，只有自定义类型的可以使用</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2020&#x2F;8&#x2F;11.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Num\n&#123;\npublic:\n    int num1;\n    int num2;\n\n    &#x2F;&#x2F; 类中 成员函数 实现的 重载运算‘+’\n    Num operator+(Num &amp;n) const\n    &#123;\n        Num my_n&#123;&#125;;\n        my_n.num1 &#x3D; this-&gt;num1 + n.num1;\n        my_n.num2 &#x3D; this-&gt;num2 + n.num2;\n        return my_n;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 全局函数 运算符重载的默认写法\nNum operator+(Num &amp;n1, Num &amp;n2)\n&#123;\n    Num my_n&#123;&#125;;\n    my_n.num1 &#x3D; n1.num1 + n2.num1;\n    my_n.num2 &#x3D; n1.num2 + n2.num2;\n    return my_n;\n&#125;\n\n&#x2F;&#x2F; 运算符函数 重载\nNum operator+(Num &amp;n, int num)\n&#123;\n    Num my_n&#123;&#125;;\n    my_n.num1 &#x3D; n.num1 + num;\n    my_n.num2 &#x3D; n.num2 + num;\n    return my_n;\n&#125;\n\nvoid demo1()\n&#123;\n    Num n1&#123;&#125;;\n    n1.num1 &#x3D; 10;\n    n1.num2 &#x3D; 10;\n\n    Num n2&#123;&#125;;\n    n2.num1 &#x3D; 5;\n    n2.num2 &#x3D; 5;\n\n    Num n3&#123;&#125;;\n    &#x2F;&#x2F; 重载后的简化写法\n    n3 &#x3D; n1 + n2;\n\n    &#x2F;&#x2F; 成员函数 重载的默认写法\n    &#x2F;&#x2F; n3 &#x3D; n1.operator+(n2);\n\n    &#x2F;&#x2F; 全局函数 重载的默认写法\n    &#x2F;&#x2F; n3 &#x3D; operator+(n1, n2);\n\n    cout &lt;&lt; &quot;Operator: n3 &#x3D; n1 + n2 &#x3D; &quot; &lt;&lt; n3.num1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;Operator: n3 &#x3D; n1 + n2 &#x3D; &quot; &lt;&lt; n3.num2 &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    Num n4&#123;&#125;;\n    n4.num1 &#x3D; 20;\n\n    int num2 &#x3D; 10;\n\n    &#x2F;&#x2F; 重载运算符函数的 重载写法 （Num类型 + int类型）\n    Num n5 &#x3D; n4 + num2;\n\n    cout &lt;&lt; &quot;Operator: n5 &#x3D; n4 + num2 &#x3D; &quot; &lt;&lt; n5.num1 &lt;&lt;endl;\n    cout &lt;&lt; &quot;Operator: n5 &#x3D; n4 + num2 &#x3D; &quot; &lt;&lt; n5.num2 &lt;&lt;endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-5-2-左移运算符重载\"><a href=\"#4-5-2-左移运算符重载\" class=\"headerlink\" title=\"4.5.2 左移运算符重载\"></a>4.5.2 左移运算符重载</h5><ul>\n<li><p>作用：输出自定义的数据类型</p>\n</li>\n<li><p>左移运算符重载 最好在声明为全局函数</p>\n</li>\n<li><p>配合友元使用</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;4&#x2F;29.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, Person &amp;p);\nprivate:\n    string name;\n    int age&#123;&#125;;\n\npublic:\n    Person(string name, int age);\n&#125;;\n\nPerson::Person(string newName, int newAge)\n&#123;\n    name &#x3D; newName;\n    age &#x3D; newAge;\n&#125;\n\nostream &amp;operator&lt;&lt;(ostream &amp;c, Person &amp;p)\n&#123;\n    cout &lt;&lt; &quot;Person Name: &quot; &lt;&lt; p.name &lt;&lt; endl;\n    cout &lt;&lt; &quot;Person Age: &quot; &lt;&lt; p.age &lt;&lt; endl;\n    return c;\n&#125;\n\nvoid demo()\n&#123;\n    Person p(&quot;FHang&quot;, 24);\n    cout &lt;&lt; p &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-5-3-递增运算符重载\"><a href=\"#4-5-3-递增运算符重载\" class=\"headerlink\" title=\"4.5.3 递增运算符重载\"></a>4.5.3 递增运算符重载</h5><ul>\n<li><p>需要配合 全局左移运算符 重载</p>\n</li>\n<li><p>配合使用 友元</p>\n</li>\n<li><p>前置重载 返回引用</p>\n</li>\n<li><p>后置重载 返回类内值</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass MyInt\n&#123;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt);\nprivate:\n    int my_num;\n\npublic:\n    MyInt()\n    &#123;\n        my_num &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 重载 前置 ++ 运算符\n    &#x2F;&#x2F; 返回引用的目的是 仅对当前的对象进行计算，若是返回对象，则一次计算后，生成另一个新对象\n    MyInt &amp;operator++()\n    &#123;\n        my_num++;\n        return *this;\n    &#125;\n\n    &#x2F;&#x2F; 重载 后置 ++ 运算符\n    &#x2F;&#x2F; MyInt &amp;operator++(int) &#x3D;&gt; int 是 占位参数，告诉编译器，用于区分，前后置重载\n    &#x2F;&#x2F; 此处 返回值 不返回自身引用，该函数内 自身的引用指向的值 是临时变量，一次操作后，被回收，若是连续多次使用 后置 ++，便是访问NULL，非法操作\n    MyInt operator++(int)\n    &#123;\n        MyInt tempInt &#x3D; *this;\n        my_num++;\n        return tempInt;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 全局重载 左移运算符\nostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt)\n&#123;\n    cout &lt;&lt; myInt.my_num;\n    return c;\n&#125;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;&lt;---------demo1-----------&gt;&quot; &lt;&lt; endl;\n    MyInt myInt;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;&lt;---------demo2-----------&gt;&quot; &lt;&lt; endl;\n    MyInt myInt;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n    cout &lt;&lt; ++myInt &lt;&lt; endl;\n    cout &lt;&lt; ++(++myInt) &lt;&lt; endl;\n    cout &lt;&lt; myInt++ &lt;&lt; endl;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-5-4-递减运算符重载\"><a href=\"#4-5-4-递减运算符重载\" class=\"headerlink\" title=\"4.5.4 递减运算符重载\"></a>4.5.4 递减运算符重载</h5><ul>\n<li><p>基本情况 同 递增运算符重载</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass MyInt\n&#123;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt);\nprivate:\n    int my_num;\n\npublic:\n    MyInt()\n    &#123;\n        my_num &#x3D; 10;\n    &#125;\n\n    &#x2F;&#x2F; 重置 前置 -- 返回引用\n    MyInt &amp;operator--()\n    &#123;\n        my_num--;\n        return *this;\n    &#125;\n\n    &#x2F;&#x2F; 重置 后置 -- 返回值\n    MyInt operator--(int)\n    &#123;\n        MyInt tempInt &#x3D; *this;\n        my_num--;\n        return tempInt;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 全局重载 左移运算符\nostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt)\n&#123;\n    cout &lt;&lt; myInt.my_num;\n    return c;\n&#125;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;&lt;---------demo1-----------&gt;&quot; &lt;&lt; endl;\n    MyInt myInt;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;&lt;---------demo2-----------&gt;&quot; &lt;&lt; endl;\n    MyInt myInt;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n    cout &lt;&lt; --myInt &lt;&lt; endl;\n    cout &lt;&lt; --(--myInt) &lt;&lt; endl;\n    cout &lt;&lt; myInt-- &lt;&lt; endl;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-5-5-赋值运算符重载\"><a href=\"#4-5-5-赋值运算符重载\" class=\"headerlink\" title=\"4.5.5 赋值运算符重载\"></a>4.5.5 赋值运算符重载</h5><ul>\n<li><p>C++ 编译器至少给一个类添加4个函数</p>\n<ol>\n<li>默认构造函数（无参，函数体为空）</li>\n<li>默认析构函数（无参，函数体为空）</li>\n<li>默认拷贝构造函数，对属性值进行值拷贝</li>\n<li>赋值运算符 operator&#x3D;，对属性值进行值拷贝</li>\n</ol>\n</li>\n<li><p>如果类中有属性指向堆区，做赋值操作也会出现深浅拷贝问题</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int *my_Age;\n\n    explicit Person(int age)\n    &#123;\n        my_Age &#x3D; new int(age);\n    &#125;\n\n    ~Person()\n    &#123;\n        if (my_Age !&#x3D; nullptr)\n        &#123;\n            delete my_Age;\n            my_Age &#x3D; nullptr;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 重载 赋值运算符 让每一个对象 都各自对应一块堆区，避免浅拷贝带来的多个对象指向同一堆区，在析构函数的作用下，重复释放堆区\n    Person &amp;operator&#x3D;(Person &amp;person)\n    &#123;\n        &#x2F;&#x2F; 编译器 默认 浅拷贝\n        &#x2F;&#x2F; my_Age &#x3D; person.my_Age;\n\n        &#x2F;&#x2F; 1. 在 p2 &#x3D; p1 中，p2在堆区中已有属性值，所以在进行深拷贝之前，先释放 p2 堆区\n        if (my_Age !&#x3D; nullptr)\n        &#123;\n            delete my_Age;\n            my_Age &#x3D; nullptr;\n        &#125;\n\n        &#x2F;&#x2F; 2. 进行 深拷贝\n        my_Age &#x3D; new int(*person.my_Age);\n\n        return *this;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    Person p1(18);\n    Person p2(24);\n\n    &#x2F;&#x2F; 该 赋值操作 为 浅拷贝\n    p2 &#x3D; p1;\n\n    &#x2F;&#x2F; 浅拷贝时 堆区 my_Age 占有 的内存 被析构函数 重复释放\n    cout &lt;&lt; *p1.my_Age &lt;&lt; endl;\n    cout &lt;&lt; *p2.my_Age &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    Person p1(18);\n    Person p2(24);\n    Person p3(36);\n\n    p3 &#x3D; p2 &#x3D; p1;\n\n    cout &lt;&lt; *p1.my_Age &lt;&lt; endl;\n    cout &lt;&lt; *p2.my_Age &lt;&lt; endl;\n    cout &lt;&lt; *p3.my_Age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-5-6-关系运算符重载\"><a href=\"#4-5-6-关系运算符重载\" class=\"headerlink\" title=\"4.5.6 关系运算符重载\"></a>4.5.6 关系运算符重载</h5><ul>\n<li><p>让自定义的两个对象类型进行比较操作</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string my_Name;\n    int my_Age;\n\n    Person(string name, int age)\n    &#123;\n        my_Name &#x3D; std::move(name);\n        my_Age &#x3D; age;\n    &#125;\n\n    &#x2F;&#x2F; 重载 关系运算符 返回值类型可以为：int类型 0&#x2F;1；或者 bool类型\n    &#x2F;&#x2F; 此次 重载的关系运算符为 &#x3D;&#x3D;，其他例如：!&#x3D;, &lt;, &gt; ...同理\n    int operator&#x3D;&#x3D;(Person &amp;person) const\n    &#123;\n        if (this-&gt;my_Name &#x3D;&#x3D; person.my_Name &amp;&amp; this-&gt;my_Age &#x3D;&#x3D; person.my_Age)\n        &#123;\n            return 1;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    Person p1(&quot;FH&quot;, 24);\n    Person p2(&quot;HF&quot;, 24);\n\n    &#x2F;&#x2F; 此处 的 p1 &#x3D;&#x3D; p2 是 p1.operator&#x3D;&#x3D;(p2), 返回一个 bool类型 或者 0&#x2F;1的int类型，进行if语句判断\n    if (p1 &#x3D;&#x3D; p2)\n    &#123;\n        cout &lt;&lt; &quot;P1 &#x3D; P2&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;P1 !&#x3D; P2&quot; &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; 此次 得到的返回值为 int类型的 0&#x2F;1，所以亦可采用 switch语句来xie\n    switch (p1 &#x3D;&#x3D; p2)\n    &#123;\n        case 0:\n            cout &lt;&lt; &quot;P1 !&#x3D; P2&quot; &lt;&lt; endl;\n            break;\n\n        case 1:\n            cout &lt;&lt; &quot;P1 &#x3D; P2&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-5-7-函数调用运算符重载\"><a href=\"#4-5-7-函数调用运算符重载\" class=\"headerlink\" title=\"4.5.7 函数调用运算符重载\"></a>4.5.7 函数调用运算符重载</h5><ul>\n<li><p>函数调用运算符（）也可重载</p>\n</li>\n<li><p>重载后使用的方式，类似函数的调用，被称为 “仿函数”</p>\n</li>\n<li><p>仿函数 的写法灵活，没有固定写法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass FPrint\n&#123;\npublic:\n    void operator()(const string &amp;text)\n    &#123;\n        cout &lt;&lt; text &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass FAdd\n&#123;\npublic:\n    void operator()(int num1, int num2)\n    &#123;\n        cout &lt;&lt; num1 + num2 &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    FPrint fPrint;\n    fPrint(&quot;Hello World !&quot;);\n&#125;\n\nvoid demo2()\n&#123;\n    FAdd fAdd;\n    fAdd(10, 20);\n\n    &#x2F;&#x2F; 匿名函数对象\n    FAdd()(20, 40);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"4-6-继承\"><a href=\"#4-6-继承\" class=\"headerlink\" title=\"4.6 继承\"></a>4.6 继承</h4><h5 id=\"4-6-1-继承的基本使用\"><a href=\"#4-6-1-继承的基本使用\" class=\"headerlink\" title=\"4.6.1 继承的基本使用\"></a>4.6.1 继承的基本使用</h5><ul>\n<li><p>继承的作用：减少编写重复的代码</p>\n</li>\n<li><p>继承的语法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class 子类 : 继承方式 父类 \n1. 子类 也叫 派生类 （derived class）\n2. 父类 也叫 基类 (base class)\n3. 继承方式：public</code></pre>\n</li>\n<li><p>继承的演示：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;22.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 公共页面 是 其子类页面 公用拥有的属性\nclass BasePage\n&#123;\npublic:\n    void pageHeader()\n    &#123;\n        cout &lt;&lt; &quot; -首页 公开课 登陆 注册 (公共)&quot; &lt;&lt; endl;\n    &#125;\n\n    void pageLeft()\n    &#123;\n        cout &lt;&lt; &quot; -Java C# C&#x2F;C++ Php Golang (公共)&quot; &lt;&lt; endl;\n    &#125;\n\n    void pageFoot()\n    &#123;\n        cout &lt;&lt; &quot; -帮助中心 交流合作 友链 (公共)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容\nclass JavaPage : public BasePage\n&#123;\npublic:\n    JavaPage()\n    &#123;\n        cout &lt;&lt; &quot;&lt;&lt;-- Java Web Page --&gt;&gt;&quot; &lt;&lt; endl;\n    &#125;\n    \n    ~JavaPage()\n    &#123;\n        cout &lt;&lt; endl;\n    &#125;\n\n    void pageBody()\n    &#123;\n        cout &lt;&lt; &quot; -Java_demo1 Java_demo2 Java_demo3 (Java)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容\nclass CPP : public BasePage\n&#123;\npublic:\n    CPP()\n    &#123;\n        cout &lt;&lt; &quot;&lt;&lt;-- C&#x2F;C++ Web Page --&gt;&gt;&quot; &lt;&lt; endl;\n    &#125;\n    \n    ~CPP()\n    &#123;\n        cout &lt;&lt; endl;\n    &#125;\n\n    void pageBody()\n    &#123;\n        cout &lt;&lt; &quot; -C&#x2F;C++_demo1 C&#x2F;C++_demo2 C&#x2F;C++_demo3 (C&#x2F;C++)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid java_demo()\n&#123;\n    JavaPage javaPage;\n    javaPage.pageHeader();\n    javaPage.pageLeft();\n    javaPage.pageBody();\n    javaPage.pageFoot();\n&#125;\n\nvoid cpp_demo()\n&#123;\n    CPP cpp;\n    cpp.pageHeader();\n    cpp.pageLeft();\n    cpp.pageBody();\n    cpp.pageFoot();\n&#125;\n\nint main()\n&#123;\n    java_demo();\n    cpp_demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-6-2-继承的方式\"><a href=\"#4-6-2-继承的方式\" class=\"headerlink\" title=\"4.6.2 继承的方式\"></a>4.6.2 继承的方式</h5><ul>\n<li><p>继承语法: <code>class 子类 : 继承方式 父类</code></p>\n</li>\n<li><p>继承方式：</p>\n<ol>\n<li>公共继承：public</li>\n<li>保护继承：protected</li>\n<li>私有继承：private</li>\n</ol>\n</li>\n<li><p>继承方式演示：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 父类中的 private 可以被 子类  任何继承方式 继承；但 ！ 子类 无法 访问 和 使用\nclass Father\n&#123;\npublic:\n    int a;\nprotected:\n    int b;\nprivate:\n    int c;\n&#125;;\n\nclass Son : public Father\n&#123;\n&#x2F;&#x2F; public继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 无改动；\npublic:\n    int a;\nprotected:\n    int b;\n&#125;;\n\nclass Son : protected Father\n&#123;\n&#x2F;&#x2F; protected继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 protected\nprotected:\n    int a;\n    int b;\n&#125;;\n\nclass Son : private Father\n&#123;\n&#x2F;&#x2F; private继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 private\nprivate:\n    int a;\n    int b;\n&#125;;\n\n&#x2F;&#x2F; 总结：\n&#x2F;&#x2F; 父类的 private 可以被 任何 继承方式 继承；但 ！ 子类 无法 访问 和 使用\n&#x2F;&#x2F; 子类通过某个 继承方式 继承 父类 后，父类中的 public，protected 中的成员变量 在子类中 以某种继承方式出现；</code></pre></li>\n</ul>\n<h5 id=\"4-6-3-继承中的对象模型\"><a href=\"#4-6-3-继承中的对象模型\" class=\"headerlink\" title=\"4.6.3 继承中的对象模型\"></a>4.6.3 继承中的对象模型</h5><h6 id=\"4-6-3-1-验证子类模型\"><a href=\"#4-6-3-1-验证子类模型\" class=\"headerlink\" title=\"4.6.3.1 验证子类模型\"></a>4.6.3.1 验证子类模型</h6><ul>\n<li><p>父类中的所有成员变量(非静态)，无论是什么权限保护的成员，都会被子类继承，但子类无法访问和使用</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;22.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base\n&#123;\npublic:\n    int base_A;\nprotected:\n    int base_B;\nprivate:\n    int base_C;\n&#125;;\n\nclass Derived_1 : public Base\n&#123;\npublic:\n    int derived_A;\n&#125;;\n\nvoid demo1()\n&#123;\n    Derived_1 derived1&#123;&#125;;\n    cout &lt;&lt; sizeof(derived1) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h6 id=\"4-6-3-2-Developer-Powershell-VS\"><a href=\"#4-6-3-2-Developer-Powershell-VS\" class=\"headerlink\" title=\"4.6.3.2 Developer Powershell - VS\"></a>4.6.3.2 Developer Powershell - VS</h6><ul>\n<li><p>Visual Studio 提供的工具</p>\n</li>\n<li><p>使用方式：</p>\n<ol>\n<li>首先找到上面的案例代码的所在文件位置</li>\n<li>打开 Visual Studio 提供的 Developer Powershell</li>\n<li>将工作路径切换到案例代码的所在文件路径</li>\n<li>通过开发命令，查看案例代码中，子类对象的结构</li>\n</ol>\n</li>\n<li><p>使用步骤：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 切换路径 和 查看路径下 是否存在 案例代码 cpp 文件\n\n**********************************************************************\n** Visual Studio 2019 Developer PowerShell v16.9.4\n** Copyright (c) 2021 Microsoft Corporation\n**********************************************************************\nPS C:\\Users\\Admin\\source\\repos&gt; D:\nPS D:\\DevelopmentTool\\VisualStudio\\IDE&gt; cd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; ls\n\n\n    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a----         2021&#x2F;6&#x2F;22     15:09           1515 Inherit_Base.cpp\n-a----         2021&#x2F;6&#x2F;22     15:42            397 Inherit_ObjectModel.cpp</code></pre>\n\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 通过开发命令，查看案例代码中，子类对象的结构\n\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl &#x2F;d1 reportSingleClassLayoutDerived_1 &quot;.\\Inherit_ObjectModel.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nInherit_ObjectModel.cpp\n\nclass Derived_1 size(16): # 此处可以看到 子类Derived_1对象的大小 和 之前的案例代码的打印结果一致\n        +---\n 0      | +--- (base class Base) # 子类Derived_1完全继承父类中所有成员 中的 base_A base_B  base_C\n 0      | | base_A\n 4      | | base_B\n 8      | | base_C\n        | +---\n12      | derived_A # 同时 子类Derived_1 自身的成员也在 derived_A\n        +---\n\n# 总结：子类 Derived_1中 四个int类型的成员变量，占内存大小为16字节</code></pre>\n\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 用到的指令\n\n# 切换盘符 到 案例代码 所在 的 盘\nD:\n\n# 切换到具体的路径地址\ncd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9\n\n# 查看路径下 的 案例代码文件 Inherit_ObjectModel.cpp\nls\n\n# 指定 报告单个类的布局 ：子类Deriverd_1\n# cl &#x2F;d1 reportSingleClassLayout需要查看的类 &quot;类所在的具体文件&quot;\ncl &#x2F;d1 reportSingleClassLayoutDerived_1 &quot;.\\Inherit_ObjectModel.cpp&quot;</code></pre></li>\n</ul>\n<h5 id=\"4-6-4-继承中构造和析构顺序\"><a href=\"#4-6-4-继承中构造和析构顺序\" class=\"headerlink\" title=\"4.6.4 继承中构造和析构顺序\"></a>4.6.4 继承中构造和析构顺序</h5><ul>\n<li><p>子类继承父类之后，当创建子类对象时，也会调用父类的构造和析构函数</p>\n</li>\n<li><p>案例验证，子类和父类的构造和析构函数的调用先后顺序</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;22.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base\n&#123;\npublic:\n    Base()\n    &#123;\n        cout &lt;&lt; &quot;Base Constructor Transfer&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Base()\n    &#123;\n        cout &lt;&lt; &quot;Base Destructor Transfer&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Derived : public Base\n&#123;\npublic:\n    Derived()\n    &#123;\n        cout &lt;&lt; &quot;Derived Constructor Transfer&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Derived()\n    &#123;\n        cout &lt;&lt; &quot;Derived Destructor Transfer&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Derived derived;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 案例结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_3.exe\nBase Constructor Transfer\nDerived Constructor Transfer\nDerived Destructor Transfer\nBase Destructor Transfer</code></pre>\n</li>\n<li><p>由 案例结果 可以 看出</p>\n</li>\n<li><p>当创建子类时，子类和父类 的 构造和析构函数的调用 顺序</p>\n<ol>\n<li>子类构造</li>\n<li>父类构造</li>\n<li>父类析构</li>\n<li>子类析构</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"4-6-5-继承同名成员处理方式\"><a href=\"#4-6-5-继承同名成员处理方式\" class=\"headerlink\" title=\"4.6.5 继承同名成员处理方式\"></a>4.6.5 继承同名成员处理方式</h5><ul>\n<li><p>继承时的问题：当子类和父类出现同名成员，如何通过子类对象，访问子类或父类的同名数据</p>\n<ol>\n<li>访问子类同名成员，直接访问</li>\n<li>访问父类同名成员，添加作用域</li>\n</ol>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;22.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base\n&#123;\npublic:\n    int num;\n\n    Base()\n    &#123;\n        num &#x3D; 100;\n    &#125;\n\n    void FPrint()\n    &#123;\n        cout &lt;&lt; &quot;Base Print&quot; &lt;&lt; endl;\n    &#125;\n\n    void FPrint(int n)\n    &#123;\n        cout &lt;&lt; &quot;Base Print (int n) : Overload Function&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Derived : public Base\n&#123;\npublic:\n    int num;\n\n    Derived()\n    &#123;\n        num &#x3D; 200;\n    &#125;\n\n    void FPrint()\n    &#123;\n        cout &lt;&lt; &quot;Derived Print&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Derived derived;\n    cout &lt;&lt; &quot;Derived num &#x3D; &quot; &lt;&lt; derived.num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base num &#x3D; &quot; &lt;&lt; derived.Base::num &lt;&lt; endl;\n    derived.FPrint();\n    derived.Base::FPrint();\n\n    &#x2F;&#x2F; 当父类和子类中，存在同名成员时，会默认隐藏父类的成员，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用\n    &#x2F;&#x2F; derived.FPrint(10);  &#x2F;&#x2F; 父类被隐藏，所以直接传参也无法找到 重载的函数，因为子类没有 FPrint的重载函数\n    derived.Base::FPrint(10); &#x2F;&#x2F; 加上 父类作用域后 可调用\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>解决方法：</p>\n<ol>\n<li>子类对象可以直接访问到子类同名成员</li>\n<li>子类对象加上作用域可以访问到父类同名成员</li>\n<li>当子类和父类拥有同名的成员函数，子类会隐藏父类同名成员函数，子类加作用域可以访问到父类中同名函数</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"4-6-6-继承同名静态成员处理方式\"><a href=\"#4-6-6-继承同名静态成员处理方式\" class=\"headerlink\" title=\"4.6.6 继承同名静态成员处理方式\"></a>4.6.6 继承同名静态成员处理方式</h5><ul>\n<li><p>问题：继承中，同名的静态成员在子类对象上如何访问</p>\n</li>\n<li><p>静态成员和非静态成员出现同名，处理方式一致</p>\n<ol>\n<li>访问子类同名成员，直接访问</li>\n<li>访问父类同名成员，添加作用域</li>\n</ol>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 10:23\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 基类\nclass Base\n&#123;\npublic:\n    static int num;\n\n    static void func()\n    &#123;\n        cout &lt;&lt; &quot;Base-Static Func&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Base()\n    &#123;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint Base::num &#x3D; 100;\n\n&#x2F;&#x2F; 子类\nclass Derived : public Base\n&#123;\npublic:\n    static int num;\n\n    static void func()\n    &#123;\n        cout &lt;&lt; &quot;Derived-Static Func&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint Derived::num &#x3D; 200;\n\n&#x2F;&#x2F; 同名静态成员属性\nvoid demo1()\n&#123;\n    Derived derived;\n    &#x2F;&#x2F; 通过对象访问\n    cout &lt;&lt; &quot;通过对象访问&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;Derived Num &#x3D; &quot; &lt;&lt; derived.num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base Num &#x3D; &quot; &lt;&lt; derived.Base::num &lt;&lt; endl;\n\n    &#x2F;&#x2F; 通过类目访问\n    cout &lt;&lt; &quot;通过类目访问&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;Derived Num &#x3D; &quot; &lt;&lt; Derived::num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base Num &#x3D; &quot; &lt;&lt; Base::num &lt;&lt; endl;\n\n    &#x2F;&#x2F; 第一个 :: 表示使用类名访问；第二个 :: 表示父类作用域下\n    cout &lt;&lt; &quot;Base Num &#x3D; &quot; &lt;&lt; Derived::Base::num &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 同名静态成员变量\nvoid demo2()\n&#123;\n    Derived derived;\n    &#x2F;&#x2F; 通过对象访问\n    cout &lt;&lt; &quot;通过对象访问&quot; &lt;&lt; endl;\n    derived.func();\n    derived.Base::func();\n\n    &#x2F;&#x2F; 通过类目访问\n    cout &lt;&lt; &quot;通过类目访问&quot; &lt;&lt; endl;\n    Derived::func();\n    Derived::Base::func();\n&#125;\n\n&#x2F;&#x2F; 当父类和子类中，存在同名成员变量时，会默认隐藏父类的成员变量，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：同名静态成员处理方式和非同名静态的处理方式一样</p>\n</li>\n<li><p>区别：同名静态成员处理：</p>\n<ol>\n<li>通过对象调用</li>\n<li>通过类目调用</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"4-6-7-多继承语法\"><a href=\"#4-6-7-多继承语法\" class=\"headerlink\" title=\"4.6.7 多继承语法\"></a>4.6.7 多继承语法</h5><ul>\n<li><p>C++ 允许一个类继承多个类</p>\n</li>\n<li><p>语法：class 子类 : 继承方式 父类1, 继承方式 父类2…</p>\n</li>\n<li><p>多继承可能会引发父类中同名成员出现，需要加作用域区分使用</p>\n</li>\n<li><p>实际开发中，建议不用，不易于维护</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 11:03\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base1\n&#123;\npublic:\n    int num;\n\n    Base1()\n    &#123;\n        num &#x3D; 100;\n    &#125;\n&#125;;\n\nclass Base2\n&#123;\npublic:\n    int num;\n\n    Base2()\n    &#123;\n        num &#x3D; 200;\n    &#125;\n&#125;;\n\nclass Derived : public Base1, public Base2\n&#123;\npublic:\n    int num;\n\n    Derived()\n    &#123;\n        num &#x3D; 300;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Derived derived;\n    cout &lt;&lt; &quot;Sizeof derived &#x3D; &quot; &lt;&lt; sizeof(derived) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Derived Num &#x3D; &quot; &lt;&lt; derived.num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base1 Num &#x3D; &quot; &lt;&lt; derived.Base1::num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base2 Num &#x3D; &quot; &lt;&lt; derived.Base2::num &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>此处也使用了 Developer PowerShell 查看了 Derived 类的结构</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">**********************************************************************\n** Visual Studio 2019 Developer PowerShell v16.9.4\n** Copyright (c) 2021 Microsoft Corporation\n**********************************************************************\nPS C:\\Users\\Admin\\source\\repos&gt; D:\nPS D:\\DevelopmentTool\\VisualStudio\\IDE&gt; cd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo&gt; ls\n\n\n    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\nd-----          2021&#x2F;5&#x2F;4      9:34                .idea\nd-----         2021&#x2F;6&#x2F;24     11:12                cmake-build-debug\nd-----          2021&#x2F;5&#x2F;4      9:34                Code1\nd-----          2021&#x2F;5&#x2F;4      9:34                Code2\nd-----          2021&#x2F;5&#x2F;4      9:34                Code3\nd-----          2021&#x2F;5&#x2F;4      9:34                Code4\nd-----          2021&#x2F;5&#x2F;4      9:34                Code4_CirclePoint\nd-----          2021&#x2F;5&#x2F;4      9:34                Code5\nd-----          2021&#x2F;5&#x2F;4      9:34                Code6\nd-----          2021&#x2F;5&#x2F;4      9:34                Code7\nd-----         2021&#x2F;6&#x2F;20     21:27                Code8\nd-----         2021&#x2F;6&#x2F;24     11:11                Code9\n-a----         2021&#x2F;2&#x2F;21     19:24            174 .gitignore\n-a----         2021&#x2F;6&#x2F;24     11:12           2930 CMakeLists.txt\n\n\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo&gt; cd Code9\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; ls\n\n\n    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a----         2021&#x2F;6&#x2F;22     15:09           1515 Inherit_Base.cpp\n-a----         2021&#x2F;6&#x2F;22     16:36            590 Inherit_ConstructorDestructorTransferOrder.cpp\n-a----         2021&#x2F;6&#x2F;22     17:32           1216 Inherit_DealWithSameName.cpp\n-a----         2021&#x2F;6&#x2F;24     10:49           1431 Inherit_DealWithSameNameObject.cpp\n-a----         2021&#x2F;6&#x2F;24     11:11            126 Inherit_DiamondInheritance.cpp\n-a----         2021&#x2F;6&#x2F;24     11:10            730 Inherit_MoreInherit.cpp\n-a----         2021&#x2F;6&#x2F;22     16:01            395 Inherit_ObjectModel.cpp\n\n\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl &#x2F;d1 reportSingleClassLayoutDerived &quot;.\\Inherit_MoreInherit.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nInherit_MoreInherit.cpp\n\nclass Derived   size(12):\n        +---\n 0      | +--- (base class Base1)\n 0      | | num\n        | +---\n 4      | +--- (base class Base2)\n 4      | | num\n        | +---\n 8      | num\n        +---</code></pre></li>\n</ul>\n<h5 id=\"4-6-8-菱形继承\"><a href=\"#4-6-8-菱形继承\" class=\"headerlink\" title=\"4.6.8 菱形继承\"></a>4.6.8 菱形继承</h5><ul>\n<li><p>概念：</p>\n<ol>\n<li>两个派生类继承同一个基类</li>\n<li>又有某一个类同时继承了两个派生类</li>\n</ol>\n</li>\n<li><p>问题解决：</p>\n<ol>\n<li><p>默认情况下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 11:11\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    int age;\n\n    Animal()\n    &#123;\n        age &#x3D; 10;\n    &#125;\n&#125;;\n\nclass Tiger : public Animal&#123;&#125;;\n\nclass Lion : public Animal&#123;&#125;;\n\nclass LionTiger : public Tiger, public Lion&#123;&#125;;\n\nvoid demo1()\n&#123;\n    LionTiger lionTiger;\n\n    &#x2F;&#x2F; 菱形继承，两个父类拥有相同的数据，通过作用域区分，同时造成资源浪费，通过 虚继承 解决问题\n    lionTiger.Tiger::age &#x3D; 20;\n    lionTiger.Lion::age &#x3D; 30;\n\n    cout &lt;&lt; &quot;Tiger Age &#x3D; &quot; &lt;&lt; lionTiger.Tiger::age &lt;&lt; endl;\n    cout &lt;&lt; &quot;Lion Age &#x3D; &quot; &lt;&lt; lionTiger.Lion::age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 打印结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_7.exe\n&#x2F;&#x2F; 此时，可看出，LionTiger同时继承了两个成员变量，在作用域下可单独赋值\nTiger Age &#x3D; 20\nLion Age &#x3D; 30</code></pre>\n\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 利用 Developer Powershell 工具， 查看 LionTriger 类 的结构\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl &#x2F;d1 reportSingleClassLayoutLionTiger &quot;.\\Inherit_DiamondInheritance.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nInherit_DiamondInheritance.cpp\n.\\Inherit_DiamondInheritance.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以 防止数据丢失\n\nclass LionTiger size(8): # 可以看到，LionTiger 继承了两个 重复的成员\n        +---\n 0      | +--- (base class Tiger)\n 0      | | +--- (base class Animal)\n 0      | | | age\n        | | +---\n        | +---\n 4      | +--- (base class Lion)\n 4      | | +--- (base class Animal)\n 4      | | | age\n        | | +---\n        | +---\n        +---</code></pre>\n</li>\n<li><p>使用虚继承解决问题，关键字：virtual</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 11:11\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    int age;\n\n    Animal()\n    &#123;\n        age &#x3D; 10;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 利用 虚继承 解决菱形继承的问题\n&#x2F;&#x2F; 使用 关键字 virtual ，两个派生类继承同一个父类时，两个派生类 可虚拟共享同一个 父类中继承来的成员，（继承了虚基类 Animal的age 的地址）\n&#x2F;&#x2F; Animal 类，称为 虚基类\nclass Tiger : virtual public Animal&#123;&#125;;\n\nclass Lion : virtual public Animal&#123;&#125;;\n\nclass LionTiger : public Tiger, public Lion&#123;&#125;;\n\nvoid demo1()\n&#123;\n    LionTiger lionTiger;\n\n    &#x2F;&#x2F; 菱形继承，两个父类拥有相同的数据，通过作用域区分，同时造成资源浪费，通过 虚继承 解决问题\n    lionTiger.Tiger::age &#x3D; 20;\n    lionTiger.Lion::age &#x3D; 30;\n\n    cout &lt;&lt; &quot;Tiger Age &#x3D; &quot; &lt;&lt; lionTiger.Tiger::age &lt;&lt; endl;\n    cout &lt;&lt; &quot;Lion Age &#x3D; &quot; &lt;&lt; lionTiger.Lion::age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 打印结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_7.exe\n&#x2F;&#x2F; 使用 虚继承 后，LionTiger 只继承了一个 成员变量\nTiger Age &#x3D; 30\nLion Age &#x3D; 30</code></pre>\n\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 利用 Developer Powershell 工具， 查看 LionTriger 类 的结构 (使用了 虚继承)\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl &#x2F;d1 reportSingleClassLayoutLionTiger &quot;.\\Inherit_DiamondInheritance.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nInherit_DiamondInheritance.cpp\n.\\Inherit_DiamondInheritance.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以 防止数据丢失\n\nclass LionTiger size(12):\n        +---\n 0      | +--- (base class Tiger)\n 0      | | &#123;vbptr&#125; # 指向 LionTiger::$vbtable@Tiger@: \n        | +---\n 4      | +--- (base class Lion)\n 4      | | &#123;vbptr&#125; # 指向 LionTiger::$vbtable@Lion@:\n        | +---\n        +---\n        +--- (virtual base Animal)\n 8      | age\n        +---\n\nLionTiger::$vbtable@Tiger@: # 偏移量 8，从类结构布局的开始 +8，刚好指向 virtual base Animal 的 成员变量 age\n 0      | 0\n 1      | 8 (LionTigerd(Tiger+0)Animal)\n \nLionTiger::$vbtable@Lion@: # 偏移量 4，从类结构布局的开始 +4，刚好指向 virtual base Animal 的 成员变量 age\n 0      | 0\n 1      | 4 (LionTigerd(Lion+0)Animal)\nvbi:       class  offset o.vbptr  o.vbte fVtorDisp\n          Animal       8       0       4 0\n\n#  一些解释，上面的结构\nvbptr -&gt; v&#x3D;virtual, b&#x3D;base, ptr&#x3D;pointer; vbptr 指向 vbtable\nvbtable -&gt; v&#x3D;virtual, b&#x3D;base, table</code></pre></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"4-7-多态\"><a href=\"#4-7-多态\" class=\"headerlink\" title=\"4.7 多态\"></a>4.7 多态</h4><h5 id=\"4-7-1-多态的基本概念\"><a href=\"#4-7-1-多态的基本概念\" class=\"headerlink\" title=\"4.7.1 多态的基本概念\"></a>4.7.1 多态的基本概念</h5><p>多态是C++面向对象的三大特性之一</p>\n<ul>\n<li><p>多态分为两类</p>\n<ol>\n<li>静态多态：函数重载 和 运算符重载 属于静态多态，复用函数名</li>\n<li>动态多态：派生类 和 虚函数 实现运行时，为多态</li>\n</ol>\n</li>\n<li><p>静态多态和动态多态的区别</p>\n<ol>\n<li>静态多态的函数地址早绑定 — 编译阶段确定函数地址</li>\n<li>动态多态的函数地址晚绑定 — 运行阶段确定函数地址</li>\n</ol>\n</li>\n<li><p>案例说明</p>\n<ol>\n<li><p>静态多态</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 14:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 该函数的地址是早绑定，编译阶段确定引用的 Animal类的对象地址，后面调用时，传入Cat对象，不改变结果（静态多态）\n&#x2F;&#x2F; 将基类Animal中的 函数 speak() 设为虚函数，运行时才确定地址，后面调用时，传入Cat对象，引用的便是Cat的对象地址（动态多态）\nvoid doSpeak(Animal &amp;animal)\n&#123;\n    animal.speak();\n&#125;\n\nvoid demo()\n&#123;\n    Cat cat;\n    doSpeak(cat);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 运行结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code10_1.exe\nAnimal Speaking</code></pre>\n</li>\n<li><p>动态多态</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 14:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    &#x2F;&#x2F; 使用关键字 virtual，使得变成虚函数\n    virtual void speak()\n    &#123;\n        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Dog Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 该函数内传入引用对象调用的speak()函数的地址是早绑定，编译阶段确定引用的 Animal类的对象地址，后面调用时，传入Cat对象，不改变结果（静态多态）\n&#x2F;&#x2F; 将基类Animal中的 函数 speak() 设为虚函数，运行时才确定地址，后面调用时，传入Cat对象，引用的便是Cat的对象地址（动态多态）\nvoid doSpeak(Animal &amp;animal)\n&#123;\n    &#x2F;&#x2F; speak()早绑定时，默认是传入基类Animal的引用对象地址\n    &#x2F;&#x2F; speak()使用virtual后是晚绑定时，传入指定引用对象地址\n    animal.speak();\n&#125;\n\nvoid demo()\n&#123;\n    Cat cat;\n    Dog dog;\n    doSpeak(cat);\n    doSpeak(dog);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 运行结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code10_1.exe\nCat Speaking\nDog Speaking</code></pre></li>\n</ol>\n</li>\n<li><p>动态多态的满足条件</p>\n<ol>\n<li>有继承关系</li>\n<li>子类重写父类的虚函数</li>\n<li>重写：函数返回值类型，函数名，参数列表，完全一致</li>\n</ol>\n</li>\n<li><p>动态多态的使用：父类的指针或引用，执行子类对象</p>\n</li>\n</ul>\n<h5 id=\"4-7-2-多态深入原理\"><a href=\"#4-7-2-多态深入原理\" class=\"headerlink\" title=\"4.7.2 多态深入原理\"></a>4.7.2 多态深入原理</h5><p>案例代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 14:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    virtual void speak()\n    &#123;\n        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Dog Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid doSpeak(Animal &amp;animal) &#x2F;&#x2F; 此处 &#x3D;&gt; Animal &amp;animal &#x3D; cat\n&#123;\n    animal.speak();\n&#125;\n\nvoid demo()\n&#123;\n    Cat cat;\n    Dog dog;\n    doSpeak(cat); \n    doSpeak(dog);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n<ul>\n<li><p>静态多态</p>\n<ul>\n<li>基类 Animal 中的 speak() 没有 virtual 前是早绑定，函数地址在类外，此时Animal类是空类，大小为1；</li>\n</ul>\n</li>\n<li><p>动态多态</p>\n<ul>\n<li><p>基类 Animal 中的 speak() 有 virtual 是晚绑定，函数地址在类内，此时Animal类不是空类，大小为4；</p>\n</li>\n<li><p>此时 虚函数speak()，在类内中是 vfptr &#x3D; virtualFunctionPointer ( 虚函数(表)指针 )，指向vftable (虚函数表)，函数地址入口是 &amp;Animal::speak;</p>\n</li>\n<li><p>子类Cat继承Animal后，默认情况下，Cat类完全继承了Animal类的属性；</p>\n</li>\n<li><p>但案例代码中，Cat类内实现了speak()的重写，此时函数地址入口是 &amp;Cat::speak;</p>\n</li>\n<li><p>子类中的虚函数表内部会替换成子类的虚函数地址；</p>\n</li>\n<li><p>此时，当父类的指针或引用指向子类对象时，发生多态；</p>\n</li>\n</ul>\n</li>\n<li><p>验证：Developer PowerShell</p>\n<ul>\n<li><p>静态多态</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 基类Animal 的函数表\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutAnimal &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass Animal    size(1):\n        +---\n        +---</code></pre>\n\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass _s__CatchableType size(28):\n        +---\n 0      | properties\n 4      | pType\n 8      | _PMD thisDisplacement\n20      | sizeOrOffset\n24      | copyFunction\n        +---\n\nclass _s__CatchableTypeArray    size(4):\n        +---\n 0      | nCatchableTypes\n 4      | arrayOfCatchableTypes\n        +---\n\nclass Cat       size(1):\n        +---\n 0      | +--- (base class Animal) #基类没有实现虚函数，为静态多态时，子类完全继承基类，即使子类重写了speak，也依然是默认的基类对象引用\n        | +---\n        +---</code></pre>\n\n\n</li>\n<li><p>动态多态</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 基类Animal 的函数表\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutAnimal &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass Animal    size(4):\n        +---\n 0      | &#123;vfptr&#125;\n        +---\n\nAnimal::$vftable@:\n        | &amp;Animal_meta\n        |  0\n 0      | &amp;Animal::speak\n\nAnimal::speak this adjustor: 0</code></pre>\n\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 子类Cat 没有发生重写时的 函数表\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass _s__CatchableType size(28):\n        +---\n 0      | properties\n 4      | pType\n 8      | _PMD thisDisplacement\n20      | sizeOrOffset\n24      | copyFunction\n        +---\n\nclass _s__CatchableTypeArray    size(4):\n        +---\n 0      | nCatchableTypes\n 4      | arrayOfCatchableTypes\n        +---\n\nclass Cat       size(4):\n        +---\n 0      | +--- (base class Animal)\n 0      | | &#123;vfptr&#125;\n        | +---\n        +---\n\nCat::$vftable@:\n        | &amp;Cat_meta\n        |  0\n 0      | &amp;Animal::speak # Cat内没有重写 speak 时，Cat类的函数指针指向的函数表是 Animal 的</code></pre>\n\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># 子类Cat 发生重写时的 函数表\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass _s__CatchableType size(28):\n        +---\n 0      | properties\n 4      | pType\n 8      | _PMD thisDisplacement\n20      | sizeOrOffset\n24      | copyFunction\n        +---\n\nclass _s__CatchableTypeArray    size(4):\n        +---\n 0      | nCatchableTypes\n 4      | arrayOfCatchableTypes\n        +---\n\nclass Cat       size(4):\n        +---\n 0      | +--- (base class Animal)\n 0      | | &#123;vfptr&#125;\n        | +---\n        +---\n\nCat::$vftable@:\n        | &amp;Cat_meta\n        |  0\n 0      | &amp;Cat::speak  # Cat内重写 speak 后，Cat类的函数指针指向的函数表是 Cat 的\n\nCat::speak this adjustor: 0</code></pre></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"4-7-3-多态案例-计算器\"><a href=\"#4-7-3-多态案例-计算器\" class=\"headerlink\" title=\"4.7.3 多态案例-计算器\"></a>4.7.3 多态案例-计算器</h5><ul>\n<li><p>案例描述：分别使用普通的方法和多态，设计实现两个操作数进行运算的计算器类</p>\n</li>\n<li><p>多态的优点：</p>\n<ul>\n<li>代码组织结构清晰</li>\n<li>可读性强</li>\n<li>利于前期和后期的扩展和维护</li>\n</ul>\n</li>\n<li><p>示例：普通实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 16:39\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Calculator\n&#123;\npublic:\n    int num1;\n    int num2;\n\n    float getResult(string f_operator)\n    &#123;\n        if (f_operator &#x3D;&#x3D; &quot;+&quot;)\n        &#123;\n            return num1 + num2;\n        &#125;\n        if (f_operator &#x3D;&#x3D; &quot;-&quot;)\n        &#123;\n            return num1 - num2;\n        &#125;\n        if (f_operator &#x3D;&#x3D; &quot;*&quot;)\n        &#123;\n            return num1 * num2;\n        &#125;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Calculator calculator&#123;&#125;;\n    calculator.num1 &#x3D; 10;\n    calculator.num2 &#x3D; 15;\n\n    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; + &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; calculator.getResult(&quot;+&quot;) &lt;&lt; endl;\n    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; - &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; calculator.getResult(&quot;-&quot;) &lt;&lt; endl;\n    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; * &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; calculator.getResult(&quot;*&quot;) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>多态实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 18:46\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass AbstractCalculator\n&#123;\npublic:\n    int num1;\n    int num2;\n\n    virtual float getResult()\n    &#123;\n        return 0.0;\n    &#125;\n&#125;;\n\nclass SumCalculator : public AbstractCalculator\n&#123;\npublic:\n    virtual float getResult()\n    &#123;\n        return float (num1 + num2);\n    &#125;\n&#125;;\n\nclass SubCalculator : public AbstractCalculator\n&#123;\npublic:\n    virtual float getResult()\n    &#123;\n        return float (num1 - num2);\n    &#125;\n&#125;;\n\nclass MulCalculator : public AbstractCalculator\n&#123;\npublic:\n    virtual float getResult()\n    &#123;\n        return float (num1 * num2);\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 父类指针或引用指向子类执行\n    AbstractCalculator *abs;\n    &#x2F;&#x2F; Sum\n    abs &#x3D; new SumCalculator;\n    abs-&gt;num1 &#x3D; 10;\n    abs-&gt;num2 &#x3D; 15;\n    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; + &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;\n    delete abs;\n\n    &#x2F;&#x2F; Sub\n    abs &#x3D; new SubCalculator;\n    abs-&gt;num1 &#x3D; 10;\n    abs-&gt;num2 &#x3D; 15;\n    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; - &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;\n    delete abs;\n\n    &#x2F;&#x2F; Mul\n    abs &#x3D; new MulCalculator;\n    abs-&gt;num1 &#x3D; 10;\n    abs-&gt;num2 &#x3D; 15;\n    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; * &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;\n    delete abs;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-7-4-纯虚函数和抽象类\"><a href=\"#4-7-4-纯虚函数和抽象类\" class=\"headerlink\" title=\"4.7.4 纯虚函数和抽象类\"></a>4.7.4 纯虚函数和抽象类</h5><ul>\n<li><p>纯函数和抽象类的定义和语法：</p>\n<ul>\n<li>在多态中，通常父类中虚函数的实现是无意义的，主要是调用子类中重写的内容，因此可将该虚函数称为 纯虚函数</li>\n<li>纯虚函数语法：<code>virtual 返回值类型 函数名 (参数列表) = 0；</code></li>\n<li>当类中存在纯虚函数时，该类亦可称为抽象类；（例如：4.7.3中的AbstractCalculator类）</li>\n</ul>\n</li>\n<li><p>抽象类的特点：</p>\n<ul>\n<li>无法实例化对象</li>\n<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>\n</ul>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 19:15\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 抽象类\nclass Base\n&#123;\npublic:\n    &#x2F;&#x2F; 纯虚函数\n    virtual void func() &#x3D; 0;\n&#125;;\n\nclass Derived : public Base\n&#123;\npublic:\n    virtual void func()\n    &#123;\n        cout &lt;&lt; &quot;Derived Function&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Base *base &#x3D; new Derived;\n    base-&gt;func();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-7-5-多态案例-制作饮品\"><a href=\"#4-7-5-多态案例-制作饮品\" class=\"headerlink\" title=\"4.7.5 多态案例-制作饮品\"></a>4.7.5 多态案例-制作饮品</h5><ul>\n<li><p>案例描述：煮水 -&gt; 冲泡 -&gt; 倒入杯中 -&gt; 加入辅料</p>\n</li>\n<li><p>实现要求：利用多态，提供抽象制作的饮品基类，提供子类制作咖啡和茶叶</p>\n</li>\n<li><p>案例代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 19:29\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass AbstractMakeDrinks\n&#123;\npublic:\n    virtual void boilWater() &#x3D; 0;\n    virtual void brew() &#x3D; 0;\n    virtual void pourIntoCup() &#x3D; 0;\n    virtual void addAccessories() &#x3D; 0;\n\n    void makeDrinks()\n    &#123;\n        boilWater();\n        brew();\n        pourIntoCup();\n        addAccessories();\n    &#125;\n\n    ~AbstractMakeDrinks()\n    &#123;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass MakeCoffee : public AbstractMakeDrinks\n&#123;\npublic:\n    MakeCoffee()\n    &#123;\n        cout &lt;&lt; &quot;&lt; -- Make Coffee --&gt;&quot; &lt;&lt; endl;\n    &#125;\n    virtual void boilWater()\n    &#123;\n        cout &lt;&lt; &quot;BoilWater&quot; &lt;&lt; endl;\n    &#125;\n    virtual void brew()\n    &#123;\n        cout &lt;&lt; &quot;Brew Coffee&quot; &lt;&lt; endl;\n    &#125;\n    virtual void pourIntoCup()\n    &#123;\n        cout &lt;&lt; &quot;Pour Coffee Into The Cup&quot; &lt;&lt; endl;\n    &#125;\n    virtual void addAccessories()\n    &#123;\n        cout &lt;&lt; &quot;Add Accessories Like Milk&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass MakeTea : public AbstractMakeDrinks\n&#123;\npublic:\n    MakeTea()\n    &#123;\n        cout &lt;&lt; &quot;&lt; -- Make Tea --&gt;&quot; &lt;&lt; endl;\n    &#125;\n    virtual void boilWater()\n    &#123;\n        cout &lt;&lt; &quot;BoilWater&quot; &lt;&lt; endl;\n    &#125;\n    virtual void brew()\n    &#123;\n        cout &lt;&lt; &quot;Brew Tea&quot; &lt;&lt; endl;\n    &#125;\n    virtual void pourIntoCup()\n    &#123;\n        cout &lt;&lt; &quot;Pour Tea Into The Cup&quot; &lt;&lt; endl;\n    &#125;\n    virtual void addAccessories()\n    &#123;\n        cout &lt;&lt; &quot;Add Accessories Like Sugar&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 参数是 指针地址 的写法\nvoid makeDrinks(AbstractMakeDrinks *abstractMakeDrinks)\n&#123;\n    abstractMakeDrinks-&gt;makeDrinks();\n    delete abstractMakeDrinks;\n&#125;\n\nvoid makeDrinks_Coffee()\n&#123;\n    makeDrinks(new MakeCoffee);\n&#125;\n\nvoid makeDrinks_Tea()\n&#123;\n    makeDrinks(new MakeTea);\n&#125;\n\n&#x2F;&#x2F; 参数是 对象引用 的写法\n&#x2F;&#x2F;void makeDrinks(AbstractMakeDrinks &amp;abstractMakeDrinks)\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    abstractMakeDrinks.makeDrinks();\n&#x2F;&#x2F;    delete &amp;abstractMakeDrinks;\n&#x2F;&#x2F;&#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;void makeDrinks_Coffee()\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    makeDrinks(*new MakeCoffee);\n&#x2F;&#x2F;&#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;void makeDrinks_Tea()\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    makeDrinks(*new MakeTea);\n&#x2F;&#x2F;&#125;\n\nint main()\n&#123;\n    makeDrinks_Coffee();\n    makeDrinks_Tea();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"4-7-6-虚析构和纯虚析构\"><a href=\"#4-7-6-虚析构和纯虚析构\" class=\"headerlink\" title=\"4.7.6 虚析构和纯虚析构\"></a>4.7.6 虚析构和纯虚析构</h5><ul>\n<li><p>多态使用时，如果子类中有属性开辟到堆区，父类指针在释放时无法调用到子类的析构代码</p>\n</li>\n<li><p>解决方式：将父类中的析构函数改为虚析构或纯虚析构</p>\n</li>\n<li><p>虚析构和纯虚析构的共性：</p>\n<ul>\n<li>可以解决父类指针释放子类对象</li>\n<li>都需要具体的函数实现</li>\n</ul>\n</li>\n<li><p>虚析构和纯虚析构的区别：</p>\n<ul>\n<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>\n</ul>\n</li>\n<li><p>虚析构语法：<code>virtual ~类名 () &#123;&#125;</code></p>\n</li>\n<li><p>纯虚析构语法：</p>\n<ul>\n<li>类内：<code>virtual ~类名 () = 0;</code></li>\n<li>类外：<code>类名::~类名() &#123;&#125;</code></li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 20:24\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    Animal()\n    &#123;\n        cout &lt;&lt; &quot;Animal Construct Transfer&quot; &lt;&lt; endl;\n    &#125;\n    &#x2F;&#x2F; 虚析构，此时释放父类时，会调用子类的析构函数\n    virtual ~Animal()\n    &#123;\n        cout &lt;&lt; &quot;Animal Destruct Transfer&quot; &lt;&lt; endl;\n    &#125;\n    &#x2F;&#x2F; 纯虚析构，在类外实现具体\n    &#x2F;&#x2F; virtual ~Animal() &#x3D; 0;\n\n    &#x2F;&#x2F; 纯虚函数\n    virtual void speak() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; 类外实现的 纯虚析构\n&#x2F;&#x2F;Animal::~Animal()\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    cout &lt;&lt; &quot;Animal Destruct Transfer&quot; &lt;&lt; endl;\n&#x2F;&#x2F;&#125;\n\nclass Cat : public Animal\n&#123;\npublic:\n    string *cat_Name;\n\n    Cat(string name)\n    &#123;\n        cout &lt;&lt; &quot;Cat Construct Transfer&quot; &lt;&lt; endl;\n        cat_Name &#x3D; new string(name);\n    &#125;\n    ~Cat()\n    &#123;\n        if (cat_Name !&#x3D; nullptr)\n        &#123;\n            cout &lt;&lt; &quot;Cat Destruct Transfer&quot; &lt;&lt; endl;\n            delete cat_Name;\n            cat_Name &#x3D; nullptr;\n        &#125;\n    &#125;\n\n    virtual void speak()\n    &#123;\n        cout &lt;&lt; *cat_Name &lt;&lt; &quot;Cat is Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 父类指针指向子类调用\n    Animal *animal &#x3D; new Cat(&quot;Tom&quot;);\n    animal-&gt;speak();\n    &#x2F;&#x2F; 释放父类对象析构时，不会调用子类的析构函数，出现内存泄露\n    &#x2F;&#x2F; 在基类的析构函数前 加入关键字 virtual，即可解决问题\n    delete animal;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n</li>\n<li><p>总结：</p>\n<ol>\n<li>虚析构和纯虚析构，用来解决父类指针释放子类对象</li>\n<li>如果子类在堆区中，没有开辟空间，可以不写虚析构或纯虚析构</li>\n<li>拥有纯虚析构的类，属于抽象类</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"4-7-7-多态案例-电脑组装\"><a href=\"#4-7-7-多态案例-电脑组装\" class=\"headerlink\" title=\"4.7.7 多态案例-电脑组装\"></a>4.7.7 多态案例-电脑组装</h5><ul>\n<li><p>案例描述：</p>\n<ul>\n<li>电脑主要组成部分：CPU，显卡，内存条；</li>\n<li>将每个零件封装成抽象基类，并且提供不同的厂商生产不同的零件，例如：Inter和AMD；</li>\n<li>创建电脑类提供电脑工作的函数，并且调用每个零件工作的接口；</li>\n<li>测试时，组装三台电脑进行测试</li>\n</ul>\n</li>\n<li><p>案例代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 14:06\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 抽象 CPU类\nclass CPU\n&#123;\npublic:\n    virtual void calculation() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; 抽象 显卡类\nclass GraphicsCard\n&#123;\npublic:\n    virtual void display() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; 抽象 内存类\nclass RAM\n&#123;\npublic:\n    virtual void storage() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; 电脑类\nclass Computer\n&#123;\nprivate:\n    string *name;\n    CPU *cpu;\n    GraphicsCard *graphicsCard;\n    RAM *ram;\n\npublic:\n    &#x2F;&#x2F; 电脑零件组装\n    Computer(string *name, CPU *cpu, GraphicsCard *graphicsCard, RAM *ram)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;cpu &#x3D; cpu;\n        this-&gt;graphicsCard &#x3D; graphicsCard;\n        this-&gt;ram &#x3D; ram;\n        cout &lt;&lt; &quot;&lt; --&quot; &lt;&lt; *this-&gt;name &lt;&lt; &quot; Computer Is Start Run&quot; &lt;&lt; &quot;-- &gt;&quot; &lt;&lt; endl;\n    &#125;\n    ~Computer()\n    &#123;\n        if (cpu !&#x3D; nullptr)\n        &#123;\n            delete cpu;\n            cpu &#x3D; nullptr;\n        &#125;\n        if (graphicsCard !&#x3D; nullptr)\n        &#123;\n            delete graphicsCard;\n            graphicsCard &#x3D; nullptr;\n        &#125;\n        if (ram !&#x3D; nullptr)\n        &#123;\n            delete ram;\n            ram &#x3D; nullptr;\n        &#125;\n        cout &lt;&lt; &quot;&lt; --&quot; &lt;&lt; *this-&gt;name &lt;&lt; &quot; Computer Is Running Normal&quot; &lt;&lt; &quot;-- &gt;&quot; &lt;&lt; endl;\n        cout &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; 电脑运行函数\n    void computerRun()\n    &#123;\n        &#x2F;&#x2F; 电脑零件 接口调用\n        cpu-&gt;calculation();\n        graphicsCard-&gt;display();\n        ram-&gt;storage();\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 具体厂商的类\n&#x2F;&#x2F; Inter Class\nclass Inter_CPU : public CPU\n&#123;\npublic:\n    void calculation() override\n    &#123;\n        cout &lt;&lt; &quot;Inter CPU Is Calculation&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Inter_GraphicsCard : public GraphicsCard\n&#123;\npublic:\n    void display() override\n    &#123;\n        cout &lt;&lt; &quot;Inter Graphics Card Is Displaying&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Inter_RAM : public RAM\n&#123;\npublic:\n    void storage() override\n    &#123;\n        cout &lt;&lt; &quot;Inter RAM Is In Storage&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; AMD Class\nclass AMD_CPU : public CPU\n&#123;\npublic:\n    void calculation() override\n    &#123;\n        cout &lt;&lt; &quot;AMD CPU Is Calculation&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass AMD_GraphicsCard : public GraphicsCard\n&#123;\npublic:\n    void display() override\n    &#123;\n        cout &lt;&lt; &quot;AMD Graphics Card Is Displaying&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass AMD_RAM : public RAM\n&#123;\npublic:\n    void storage() override\n    &#123;\n        cout &lt;&lt; &quot;AMD RAM Is In Storage&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 组装不同厂商组件的电脑\n&#x2F;&#x2F; Assembling Inter Computer\nvoid assemblingComputer_Inter()\n&#123;\n    &#x2F;&#x2F; 准备 Inter Computer 的 Component\n    string name &#x3D; &quot;Inter&quot;;\n    CPU *interCPU &#x3D; new Inter_CPU;\n    GraphicsCard *interGraphicsCard &#x3D; new Inter_GraphicsCard;\n    RAM *interRAM &#x3D; new Inter_RAM;\n\n    &#x2F;&#x2F; Assembling Inter Computer\n    Computer *computer &#x3D; new Computer(&amp;name, interCPU, interGraphicsCard, interRAM);\n\n    &#x2F;&#x2F; Running Inter Computer\n    computer-&gt;computerRun();\n    delete computer;\n&#125;\n\n&#x2F;&#x2F; Assembling AMD Computer\nvoid assemblingComputer_AMD()\n&#123;\n    &#x2F;&#x2F; 准备 AMD Computer 的 Component\n    string name &#x3D; &quot;AMD&quot;;\n    CPU *amdCPU &#x3D; new AMD_CPU;\n    GraphicsCard *amdGraphicsCard &#x3D; new AMD_GraphicsCard;\n    RAM *amdRAM &#x3D; new AMD_RAM;\n\n    &#x2F;&#x2F; Assembling AMD Computer\n    Computer *computer &#x3D; new Computer(&amp;name, amdCPU, amdGraphicsCard, amdRAM);\n\n    &#x2F;&#x2F; Running AMD Computer\n    computer-&gt;computerRun();\n    delete computer;\n&#125;\n\nint main()\n&#123;\n    assemblingComputer_Inter();\n    assemblingComputer_AMD();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"5-文件操作\"><a href=\"#5-文件操作\" class=\"headerlink\" title=\"5. 文件操作\"></a>5. 文件操作</h3><ul>\n<li>文件作用：<ul>\n<li>程序运行时产生的数据都是临时数据，程序结束后，都会被释放</li>\n<li>通过文件，可以将数据持久化</li>\n<li>C++中对文件操作，需要包含头文件 <code>&lt;fstream&gt;</code></li>\n</ul>\n</li>\n<li>文件类型：<ol>\n<li>文本文件：文件以文本的ASCII码形式存储在计算机中</li>\n<li>二进制文件：文件以文本的二进制形式存储在计算机中，无法直接读懂</li>\n</ol>\n</li>\n<li>操作文件的三大类：<ol>\n<li><code>ofstream</code>：写操作\t</li>\n<li><code>ifstream</code>：读操作</li>\n<li><code>fstream</code>：读写操作</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-1-文本文件\"><a href=\"#5-1-文本文件\" class=\"headerlink\" title=\"5.1 文本文件\"></a>5.1 文本文件</h4><h5 id=\"5-1-1-写文本文件\"><a href=\"#5-1-1-写文本文件\" class=\"headerlink\" title=\"5.1.1 写文本文件\"></a>5.1.1 写文本文件</h5><ul>\n<li><p>写文件步骤：</p>\n<ol>\n<li>包含头文件：<code>#include &lt;fstream&gt;</code></li>\n<li>创建流对象：<code>ofstream ofs</code></li>\n<li>打开文件：<code>ofs.open(&quot;文件路径&quot;, 打开方式)</code></li>\n<li>写数据：<code>ofs &lt;&lt; &quot;写入数据&quot;;</code></li>\n<li>关闭文件：<code>ofs.close()</code></li>\n</ol>\n</li>\n<li><p>文件的打开方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">打开方式</th>\n<th align=\"left\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ios::in</td>\n<td align=\"left\">为读文件而打开文件</td>\n</tr>\n<tr>\n<td align=\"left\">ios::out</td>\n<td align=\"left\">为写文件而打开文件</td>\n</tr>\n<tr>\n<td align=\"left\">ios::ate</td>\n<td align=\"left\">初始位置：文件尾</td>\n</tr>\n<tr>\n<td align=\"left\">ios::app</td>\n<td align=\"left\">追加方式写文件</td>\n</tr>\n<tr>\n<td align=\"left\">ios::trunc</td>\n<td align=\"left\">如果文件存在，先删除，再创建</td>\n</tr>\n<tr>\n<td align=\"left\">ios::binary</td>\n<td align=\"left\">二进制方式</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>注意：文件打开方式，可以配合使用，利用 <code>|</code>操作符</p>\n</li>\n<li><p>例如：用二进制方式写文件：<code>ios::binary | ios::out</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 15:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    ofstream ofs;\n    ofs.open(R&quot;(C:\\Users\\Admin\\Desktop\\demo.txt)&quot;, ios::out);\n\n    ofs &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;\n    ofs &lt;&lt; &quot;Hello FHang&quot; &lt;&lt; endl;\n\n    ofs.close();\n\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"5-1-2-读文本文件\"><a href=\"#5-1-2-读文本文件\" class=\"headerlink\" title=\"5.1.2 读文本文件\"></a>5.1.2 读文本文件</h5><ul>\n<li><p>写文件步骤：</p>\n<ol>\n<li>包含头文件：<code>#include &lt;fstream&gt;</code></li>\n<li>创建流对象：<code>ifstream ifs</code></li>\n<li>先判断打开文件是否成功，打开文件：<code>ifs.open(&quot;文件路径&quot;, 打开方式)</code></li>\n<li>读数据：四种读取方式</li>\n<li>关闭文件：<code>ifs.close()</code></li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 16:06\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    ifstream ifs;\n    ifs.open(R&quot;(C:\\Users\\Admin\\Desktop\\demo.txt)&quot;, ios::in);\n\n    if (!ifs.is_open())\n    &#123;\n        cout &lt;&lt; &quot;Open File Failed&quot; &lt;&lt; endl;\n\treturn;\n    &#125;\n\n    &#x2F;&#x2F; 读数据，四种\n    &#x2F;&#x2F; 1. 一行行读，不喜欢这个\n&#x2F;&#x2F;    char buf[1024] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;    while (ifs &gt;&gt; buf)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; buf &lt;&lt; endl;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F; 2. 一行行读，感觉一般\n&#x2F;&#x2F;    char buf[1024] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;    while (ifs.getline(buf, sizeof(buf)))\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; buf &lt;&lt; endl;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F; 3. 一行行读，个人一般常用\n    string buf;\n    while (getline(ifs, buf))\n    &#123;\n        cout &lt;&lt; buf &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; 4. 一个个读，慢\n&#x2F;&#x2F;    char buf;\n&#x2F;&#x2F;    while ((buf &#x3D; ifs.get()) !&#x3D; EOF)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; buf;\n&#x2F;&#x2F;    &#125;\n\n    ifs.close();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"5-2-二进制文件\"><a href=\"#5-2-二进制文件\" class=\"headerlink\" title=\"5.2 二进制文件\"></a>5.2 二进制文件</h4><ul>\n<li>以二进制的方式对文件进行读写操作</li>\n<li>打开方式需要指定：<code>ios:binary</code></li>\n</ul>\n<h5 id=\"5-2-1-写二进制文件\"><a href=\"#5-2-1-写二进制文件\" class=\"headerlink\" title=\"5.2.1 写二进制文件\"></a>5.2.1 写二进制文件</h5><ul>\n<li><p>二进制写文件主要利用 流对象 调用成员函数 <code>write()</code></p>\n</li>\n<li><p>函数原型：<code>ostream &amp;write(const char *buffer, int len);</code></p>\n</li>\n<li><p>参数解释：字符指针 <code>buffer</code>指向内存中一段内存空间，<code>len</code>是读写的字节数</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 16:34\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string f_Name;\n    int f_Age;\n&#125;;\n\nvoid demo()\n&#123;\n    Person person &#x3D; &#123;&quot;FHang&quot;, 24&#125;;\n    ofstream ofs;\n    ofs.open(R&quot;(C:\\Users\\Admin\\Desktop\\Person.txt)&quot;, ios::out | ios::binary);\n    ofs.write((const char *) &amp;person, sizeof(Person));\n    ofs.close();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"5-2-2-读二进制文件\"><a href=\"#5-2-2-读二进制文件\" class=\"headerlink\" title=\"5.2.2 读二进制文件\"></a>5.2.2 读二进制文件</h5><ul>\n<li><p>二进制方式读文件，主要利用 流对象 调用成员函数 <code>read</code></p>\n</li>\n<li><p>函数原型：<code>ostream &amp;read(char *buffer, int len);</code></p>\n</li>\n<li><p>参数解释：字符指针 <code>buffer</code>指向内存中一段内存空间，<code>len</code>是读写的字节数</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 17:00\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string f_Name;\n    int f_Age;\n&#125;;\n\nvoid demo()\n&#123;\n    Person person;\n    ifstream ifs;\n    ifs.open(R&quot;(C:\\Users\\Admin\\Desktop\\Person.txt)&quot;, ios::in | ios::binary);\n\n    if (!ifs.is_open())\n    &#123;\n        cout &lt;&lt; &quot;Open File Failed&quot; &lt;&lt; endl;\n        return;\n    &#125;\n\n    ifs.read((char *) &amp;person, sizeof(Person));\n    cout &lt;&lt; &quot;Name &#x3D; &quot; &lt;&lt; person.f_Name &lt;&lt; endl;\n    cout &lt;&lt; &quot;Age &#x3D; &quot; &lt;&lt; person.f_Age &lt;&lt; endl;\n\n    ifs.close();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"6-extern-C\"><a href=\"#6-extern-C\" class=\"headerlink\" title=\"6. extern C\"></a>6. extern C</h3><ul>\n<li><p>功能描述：将<code>C++</code>代码，以<code>C语</code>言的<code>形式</code>进行<code>编译</code></p>\n</li>\n<li><p>作用：用于<code>C/C++混合开发</code>时，<code>C++</code>中<code>使用C</code>写的<code>第三方库</code>时使用</p>\n</li>\n<li><p>注意：<code>C</code>不支持<code>函数重载</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">extern &quot;C&quot;\n&#123;\n    int func();\n    int func(int a);\n&#125;\n\nint main()\n&#123;\n    func();\n    func(1);\n    return o;\n&#125;\n\nint func()&#123;return 0;&#125;\n\nint func(int a)&#123;return a;&#125;</code></pre>\n\n<p>以上是 <code>extern C</code> 的使用方式，但这个程序<code>编译会报错</code>；</p>\n<p>在 <code>C/C++</code> 中，编译时转汇编，依据<code>编译器</code>的<code>区别</code>，函数名会变<code>改名</code>：</p>\n<pre class=\"line-numbers language-basic\" data-language=\"basic\"><code class=\"language-basic\">&#x2F;&#x2F; C \ncall _func()\n\n&#x2F;&#x2F; C++\ncall func_i()</code></pre>\n\n<p>所以，当<code>C++</code>文件中，使用<code>extern C</code>修饰重载函数后，编译会<code>出错</code></p>\n</li>\n</ul>\n<h4 id=\"6-1-实例演示1\"><a href=\"#6-1-实例演示1\" class=\"headerlink\" title=\"6.1 实例演示1\"></a>6.1 实例演示1</h4><ul>\n<li><p><code>math.h</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">extern &quot;C&quot;\n&#123;\n    int sum(int a, int b);\n&#125;</code></pre>\n</li>\n<li><p><code>math.c</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int sum(int a, int b)\n&#123;\n    return a + b;\n&#125;</code></pre>\n</li>\n<li><p><code>demo.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &quot;math.h&quot;\n\nint main()\n&#123;\n    std::cout &lt;&lt; sum(1, 2) &lt;&lt; std::endl;\n    return 0;\n&#125;</code></pre>\n\n<p>在<code>C++</code>文件中，不能直接使用<code>C</code>文件中的函数，因为<code>编译器</code>的<code>区别</code>，<code>相同</code>的<code>函数名</code>，在编译时，函数的名称会<code>变得不同</code>，所以<code>C++</code>文件中就找不到<code>C</code>中的<code>函数声明和实现</code>，只能<code>指向</code>自己文件中的声明；</p>\n<p>所以需要 <code>extern C</code>修饰，这样编译器就会在编译时修改函数名，<code>修改成C的规范</code>，这样<code>C++</code>文件中就可以找到<code>C</code>文件中的函数声明和实现;</p>\n</li>\n<li><p>补充：如果别的 <code>C</code> 文件中要使用 <code>math.h</code> ，直接包含 <code>math.h</code> 会<code>报错</code>，因为 <code>C </code>的<code>编译器</code> 无法<code>识别 extern C</code></p>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><code>extern C</code> 直接修饰 <code>C的头文件</code>内的<code>声明</code>即可，<code>同时</code>修饰<code>实现</code>也可以，但<code>没必要</code>；唯独<code>不能</code>只修饰<code>实现</code>；</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-2-实例演示2\"><a href=\"#6-2-实例演示2\" class=\"headerlink\" title=\"6.2 实例演示2\"></a>6.2 实例演示2</h4><ul>\n<li><p>补充知识：</p>\n<ol>\n<li>Cpp 文件开头默认会有<code>#define __cpluscplus</code>，用于编译时标识自己是 Cpp 文件</li>\n<li>Cpp 头文件中一般可以使用： <ul>\n<li><code>#ifdef 项目文件名</code></li>\n<li><code>#endif</code></li>\n<li>包含头文件内容</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<p><code>math.h</code> </p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#ifdef __cpluscplus\nextern &quot;C&quot;\n&#123;\n#endif &#x2F;&#x2F; __cpluscplus\n    \n    int sum(int a, int b);\n    \n#ifdef __cpluscplus    \n&#125;\n#endif &#x2F;&#x2F; __cpluscplus</code></pre>\n\n\n\n<p><code>demo.cpp</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define __cpluscplus &#x2F;&#x2F; 编译时 默认存在的\n\n#include &lt;iostream&gt;\n#include &quot;math.h&quot;\n\nint main()\n&#123;\n    std::cout &lt;&lt; sum(1, 2) &lt;&lt; std::endl;\n    return 0;\n&#125;</code></pre>\n\n<p>当 <code>Cpp</code> 文件包含这个头文件时，编译时会识别到 <code>#ifdef</code>和<code>#endif</code>，这样 <code>extern C</code>就可以生效；</p>\n<p>当 <code>C</code> 文件包含这个头文件时，编译时就会忽略 <code>extern C</code>；</p>\n<p>这样的写法格式的好处：<code>C</code> 文件 和 <code>Cpp</code> 文件 都可以直接包含 <code>math.h</code>文件，进行使用</p>\n</li>\n<li><p>补充知识：实际开发中，避免重复引用头文件，浪费资源，需要使用 <code>#ifndef __文件名_H</code> 、<code>#define __文件名_H</code> 、<code>#endif</code></p>\n<p><code>math.h</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#ifndef __MATH_H &#x2F;&#x2F; 规范写法\n#define __MATH_H\n\n#ifdef __cpluscplus\nextern &quot;C&quot;\n&#123;\n#endif &#x2F;&#x2F; __cpluscplus\n    \n    int sum(int a, int b);\n    \n#ifdef __cpluscplus    \n&#125;\n#endif &#x2F;&#x2F; __cpluscplus\n\n#endif &#x2F;&#x2F; MATH</code></pre>\n</li>\n<li><p><code>#ifdef</code>：如果定义了，参与编译</p>\n</li>\n<li><p><code>#ifndef</code>：如果没有被其它文件引用或定义</p>\n</li>\n<li><p><code>#define</code>：定义这个文件的内容</p>\n</li>\n<li><p><code>#endif</code>：结束定义</p>\n</li>\n<li><p>简单写法：<code>#pragma once</code></p>\n<p><code>math.h</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#pragma once\n\n#ifdef __cpluscplus\nextern &quot;C&quot;\n&#123;\n#endif &#x2F;&#x2F; __cpluscplus\n    \n    int sum(int a, int b);\n    \n#ifdef __cpluscplus    \n&#125;\n#endif &#x2F;&#x2F; __cpluscplus</code></pre>\n</li>\n<li><p>效果和 <code>#ifndef __文件名_H</code> 、<code>#define __文件名_H</code> 、<code>#endif</code> 是一样的</p>\n</li>\n<li><p><code>#ifndef __文件名_H</code> 、<code>#define __文件名_H</code> 、<code>#endif</code>受到C&#x2F;C++标准支持，不受编译器限制</p>\n</li>\n<li><p><code>#pragma once</code> 老版编译器不兼容(GCC 3.4之前的版本)</p>\n</li>\n</ul>\n","text":"C++_核心编程[toc] 1. 内存分区模型C++程序在执行时，内存大方向划分为4个区域 代码区：存放函数的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等 堆区：由程序员分配和释放，若不释放，程...","link":"","photos":[],"count_time":{"symbolsCount":"96k","symbolsTime":"1:27"},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">C++_核心编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">1. 内存分区模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D\"><span class=\"toc-text\">1.1 程序运行前</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E\"><span class=\"toc-text\">1.2 程序运行后</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">2. 引用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.1 引用的基本使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E5%BC%95%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">2.2 引用注意事项</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2.3 引用做函数参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">2.4 引用做函数的返回值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">2.5 引用的本质</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">2.6 常量引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-7-%E5%BC%95%E7%94%A8%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">2.7 引用补充</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">3. 函数进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">3.1 函数默认参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-1-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">3.1.1 函数默认参数补充</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">3.2 函数占位参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">3.3 函数重载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">3.3.1 函数重载概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-2-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">3.3.2 函数重载注意事项</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-3-2-1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">3.3.2.1 函数重载补充内容</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.4 内联函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">4. 类和对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">4.1 封装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-1-%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">4.1.1 封装的意义</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-2-struct%E5%92%8Cclass%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.1.2 struct和class区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-3-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E7%A7%81%E6%9C%89%E5%8C%96\"><span class=\"toc-text\">4.1.3 成员属性私有化</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-4-%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%AE%BE%E8%AE%A1%E7%AB%8B%E6%96%B9%E4%BD%93\"><span class=\"toc-text\">4.1.4 案例：设计立方体</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-5-%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%82%B9%E5%9C%86%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">4.1.5 案例：点圆的关系</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86\"><span class=\"toc-text\">4.2 对象初始化和清理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">4.2.1 构造函数和析构函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">4.2.2 构造函数分类及调用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-3-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">4.2.3 拷贝构造函数调用时机</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">4.2.4 构造函数调用规则</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">4.2.5 深拷贝和浅拷贝</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-6-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">4.2.6 初始化列表</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-7-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98\"><span class=\"toc-text\">4.2.7 类对象作为类成员</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-8-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98\"><span class=\"toc-text\">4.2.8 静态成员</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88\"><span class=\"toc-text\">4.3 对象模型和this指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-3-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">4.3.1 成员变量和成员函数分开存储</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-3-2-this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.3.2 this指针概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-3-3-%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">4.3.3 空指针访问成员函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-3-4-const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">4.3.4 const修饰成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">4.4 友元</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-4-1-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">4.4.1 全局函数做友元</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-4-2-%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">4.4.2 类做友元</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-4-3-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">4.4.3 成员函数做友元</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-5-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">4.5 运算符重载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-5-1-%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">4.5.1 加号运算符重载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-5-2-%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">4.5.2 左移运算符重载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-5-3-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">4.5.3 递增运算符重载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-5-4-%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">4.5.4 递减运算符重载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-5-5-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">4.5.5 赋值运算符重载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-5-6-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">4.5.6 关系运算符重载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-5-7-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">4.5.7 函数调用运算符重载</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-6-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">4.6 继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">4.6.1 继承的基本使用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.6.2 继承的方式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-3-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">4.6.3 继承中的对象模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-6-3-1-%E9%AA%8C%E8%AF%81%E5%AD%90%E7%B1%BB%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">4.6.3.1 验证子类模型</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-6-3-2-Developer-Powershell-VS\"><span class=\"toc-text\">4.6.3.2 Developer Powershell - VS</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-4-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">4.6.4 继承中构造和析构顺序</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-5-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.6.5 继承同名成员处理方式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-6-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.6.6 继承同名静态成员处理方式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-7-%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">4.6.7 多继承语法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-8-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">4.6.8 菱形继承</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-7-%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">4.7 多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-7-1-%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.7.1 多态的基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-7-2-%E5%A4%9A%E6%80%81%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4.7.2 多态深入原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-7-3-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B-%E8%AE%A1%E7%AE%97%E5%99%A8\"><span class=\"toc-text\">4.7.3 多态案例-计算器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-7-4-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">4.7.4 纯虚函数和抽象类</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-7-5-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B-%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81\"><span class=\"toc-text\">4.7.5 多态案例-制作饮品</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-7-6-%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84\"><span class=\"toc-text\">4.7.6 虚析构和纯虚析构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-7-7-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B-%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85\"><span class=\"toc-text\">4.7.7 多态案例-电脑组装</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">5. 文件操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5.1 文本文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1-1-%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5.1.1 写文本文件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1-2-%E8%AF%BB%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5.1.2 读文本文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5.2 二进制文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2-1-%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5.2.1 写二进制文件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2-2-%E8%AF%BB%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5.2.2 读二进制文件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-extern-C\"><span class=\"toc-text\">6. extern C</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA1\"><span class=\"toc-text\">6.1 实例演示1</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA2\"><span class=\"toc-text\">6.2 实例演示2</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++_基础","uid":"c90c4a4848e304bff822a98a4aa17a84","slug":"1_C++_基础_01","date":"2022-10-06T07:28:25.915Z","updated":"2022-11-10T01:30:30.467Z","comments":true,"path":"api/articles/1_C++_基础_01.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (1).webp","text":"C++_基础[toc] 1. 第一阶段1. HelloWorld#include &lt;iostream&gt; using namespace std; void main() &#123; cout &lt;&lt; &quot;hello world&quot; &lt;...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"C++_STL算法","uid":"1314ed16965aff00f28615c8023e8a57","slug":"1_C++_STL算法_07","date":"2022-10-06T07:28:25.910Z","updated":"2022-11-10T01:30:05.985Z","comments":true,"path":"api/articles/1_C++_STL算法_07.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (7).webp","text":"C++_STL算法[toc] 概述： 算法主要是头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt; 组成 &lt;algorithm&gt; 是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}