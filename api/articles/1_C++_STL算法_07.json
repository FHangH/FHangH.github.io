{"title":"C++_STL算法","uid":"1314ed16965aff00f28615c8023e8a57","slug":"1_C++_STL算法_07","date":"2022-10-06T07:28:25.910Z","updated":"2023-01-10T01:10:19.450Z","comments":true,"path":"api/articles/1_C++_STL算法_07.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (7).webp","content":"<h1 id=\"C-STL算法\"><a href=\"#C-STL算法\" class=\"headerlink\" title=\"C++_STL算法\"></a>C++_STL算法</h1><p>[toc]</p>\n<p>概述：</p>\n<ul>\n<li>算法主要是头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code> 组成</li>\n<li><code>&lt;algorithm&gt;</code> 是所有<code>STL</code>头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等到</li>\n<li><code>&lt;numeric&gt;</code> 体积很小，包括几个序列上面进行简单数学运算和模板函数</li>\n<li><code>&lt;functional&gt;</code> 定义了一些类模板，用以声明函数对象</li>\n</ul>\n<h3 id=\"1-常用遍历算法\"><a href=\"#1-常用遍历算法\" class=\"headerlink\" title=\"1. 常用遍历算法\"></a>1. 常用遍历算法</h3><table>\n<thead>\n<tr>\n<th>算法简介</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>for_each</code></td>\n<td>遍历容器</td>\n</tr>\n<tr>\n<td><code>transform</code></td>\n<td>搬运容器到另一个容器</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-1-for-each\"><a href=\"#1-1-for-each\" class=\"headerlink\" title=\"1.1 for_each\"></a>1.1 for_each</h4><ul>\n<li><p>功能描述：实现遍历容器</p>\n</li>\n<li><p>函数原型：</p>\n<ul>\n<li><code>for_each(iterator begin, iterator end, _functional);</code></li>\n<li><code>_functional</code> 函数或函数对象</li>\n</ul>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 13:48\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass PrintVector_Class\n&#123;\npublic:\n    void operator()(int &amp;value)\n    &#123;\n        cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid printVector_func(int &amp;value)\n&#123;\n    cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n    v.reserve(5);\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    for_each(v.begin(), v.end(), printVector_func);\n    cout &lt;&lt; endl;\n\n    for_each(v.begin(), v.end(), PrintVector_Class());\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"1-2-transform\"><a href=\"#1-2-transform\" class=\"headerlink\" title=\"1.2 transform\"></a>1.2 transform</h4><ul>\n<li><p>功能描述：搬运容器到另一个容器中</p>\n</li>\n<li><p><code>transform(iterator begin_1, iterator end_1, iterator iterator_2, _functional);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 14:29\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass TransVector\n&#123;\npublic:\n    int operator()(int &amp;value)\n    &#123;\n        return value;\n    &#125;\n&#125;;\n\nint transVector_Func(int &amp;value)\n&#123;\n    return value;\n&#125;\n\nvoid printVector(const vector&lt;int&gt; &amp;v)\n&#123;\n    for (int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    v1.reserve(5);\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n\n    v2.resize(v1.size());\n\n    &#x2F;&#x2F; transform(v1.begin(), v1.end(), v2.begin(), TransVector());\n    transform(v1.begin(), v1.end(), v2.begin(), transVector_Func);\n    printVector(v2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"2-常用查找算法\"><a href=\"#2-常用查找算法\" class=\"headerlink\" title=\"2. 常用查找算法\"></a>2. 常用查找算法</h3><table>\n<thead>\n<tr>\n<th>算法简介</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>find</code></td>\n<td>查找元素</td>\n</tr>\n<tr>\n<td><code>find_if</code></td>\n<td>按条件查找元素</td>\n</tr>\n<tr>\n<td><code>adjacent_find</code></td>\n<td>查找相邻重复的元素</td>\n</tr>\n<tr>\n<td><code>binary_search</code></td>\n<td>二分查找法</td>\n</tr>\n<tr>\n<td><code>count</code></td>\n<td>统计元素个数</td>\n</tr>\n<tr>\n<td><code>count_if</code></td>\n<td>按条件统计元素个数</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-1-find\"><a href=\"#2-1-find\" class=\"headerlink\" title=\"2.1 find\"></a>2.1 find</h4><ul>\n<li><p>功能描述：查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器<code>end()</code></p>\n</li>\n<li><p>函数原型：<code>find(iterator begin, iterator end, value);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 14:52\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(const string &amp;name, const int &amp;age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n\n    &#x2F;&#x2F; find 底层无法比较 自定义数据类型，所以要 重载&#x3D;&#x3D;\n    &#x2F;&#x2F; find 底层是直接 解析元素迭代器去比较要 查找的元素值，所以 自定义类型的数据，无法直接比较\n    bool operator&#x3D;&#x3D;(const Person &amp;person)\n    &#123;\n        if (this-&gt;name &#x3D;&#x3D; person.name &amp;&amp; this-&gt;age &#x3D;&#x3D; person.age)\n        &#123;\n            return true;\n        &#125;\n        else\n        &#123;\n            return false;\n        &#125;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(&quot;QQ&quot;, 12);\n    Person p2(&quot;WW&quot;, 12);\n    Person p3(&quot;EE&quot;, 12);\n    Person p4(&quot;RR&quot;, 12);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    vector&lt;Person&gt;::iterator it &#x3D; find(v.begin(), v.end(), p2);\n    if (it &#x3D;&#x3D; v.cend())\n    &#123;\n        cout &lt;&lt; &quot;No Find&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; it-&gt;name &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>总结：</p>\n<ol>\n<li><code>find</code> 底层无法比较<code>自定义</code>数据类型，所以要<code>重载==</code></li>\n<li><code>find</code> 底层是直接<code>解析元素迭代器</code>去比较要查找的元素值，所以自定义类型的数据，无法直接比较</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-2-find-if\"><a href=\"#2-2-find-if\" class=\"headerlink\" title=\"2.2 find_if\"></a>2.2 find_if</h4><ul>\n<li><p>功能描述：按条件查找</p>\n</li>\n<li><p>函数原型：<code>find_if(iterator begin, iterator end, _Pred);</code></p>\n</li>\n<li><p><code>_Pred</code>：函数或谓词(返回<code>bool</code>类型)</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 15:42\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(const string &amp;name, const int &amp;age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nclass FindIF_MoreThan_3\n&#123;\npublic:\n    bool operator()(const int &amp;value)\n    &#123;\n        return value &gt; 3;\n    &#125;\n&#125;;\n\nclass FindIF_MoreThan_Age_8\n&#123;\npublic:\n    bool operator()(const Person &amp;person)\n    &#123;\n        return person.age &gt; 8;\n    &#125;\n&#125;;\n\nclass UpSort_Age\n&#123;\npublic:\n    bool operator()(Person &amp;person1, Person &amp;person2)\n    &#123;\n        return person1.age &lt; person2.age;\n    &#125;\n&#125;;\n\nvoid printVector(const vector&lt;Person&gt; &amp;v)\n&#123;\n    for (vector&lt;Person&gt;::const_iterator it &#x3D; v.cbegin(); it !&#x3D; v.cend(); ++it)\n    &#123;\n        cout &lt;&lt; it-&gt;name &lt;&lt; &quot; : &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 0; i &lt;&#x3D; 5; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    vector&lt;int&gt;::iterator it &#x3D; find_if(v.begin(), v.end(), FindIF_MoreThan_3());\n    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; *it &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    vector&lt;Person&gt; v;\n    Person p1(&quot;QQ&quot;, 13);\n    Person p2(&quot;WW&quot;, 8);\n    Person p3(&quot;EE&quot;, 10);\n    Person p4(&quot;RR&quot;, 12);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    sort(v.begin(), v.end(), UpSort_Age());\n    printVector(v);\n\n    vector&lt;Person&gt;::iterator it &#x3D; find_if(v.begin(),  v.end(), FindIF_MoreThan_Age_8());\n    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"2-3-adjacent-find\"><a href=\"#2-3-adjacent-find\" class=\"headerlink\" title=\"2.3 adjacent_find\"></a>2.3 adjacent_find</h4><ul>\n<li><p>功能描述：查找相邻重复元素</p>\n</li>\n<li><p>函数原型：<code>adjacent_find(iterator begin, iterator end);</code></p>\n</li>\n<li><p>返回相邻元素的第一个位置的迭代器</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 16:38\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    v.push_back(0);\n    v.push_back(1);\n    v.push_back(0);\n    v.push_back(2);\n    v.push_back(2);\n\n    vector&lt;int&gt;::iterator it &#x3D; adjacent_find(v.begin(),  v.end());\n    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; *it &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"2-4-binary-search\"><a href=\"#2-4-binary-search\" class=\"headerlink\" title=\"2.4 binary_search\"></a>2.4 binary_search</h4><ul>\n<li><p>功能描述：查找指定元素是否存在</p>\n</li>\n<li><p>函数原型：<code>bool binary_search(iterator begin, iterator end, value);</code></p>\n</li>\n<li><p>查找指定元素，找到返回 <code>ture</code> 否则返回 <code>false</code></p>\n</li>\n<li><p>不用于<code>无序序列</code>(就是容器内的元素不是有序排列的)</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 16:51\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 0; i &lt;&#x3D; 5; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    bool isSearch &#x3D; binary_search(v.begin(),  v.end(), 5);\n\n    string searchRet &#x3D; isSearch ? &quot;true&quot; : &quot;false&quot;;\n\n    if (isSearch)\n    &#123;\n        cout &lt;&lt; &quot;Search: &quot; &lt;&lt; searchRet &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Search: &quot; &lt;&lt; searchRet &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre>\n\n\n</li>\n<li><p>总结：<code>binary_search()</code>效率很高，只用于<code>有序序列</code></p>\n</li>\n</ul>\n<h4 id=\"2-5-count\"><a href=\"#2-5-count\" class=\"headerlink\" title=\"2.5 count\"></a>2.5 count</h4><ul>\n<li><p>功能描述：统计元素个数</p>\n</li>\n<li><p>函数原型：<code>count(iterator begin, iterator end, value);</code></p>\n</li>\n<li><p>返回<code>int</code>类型</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 13:02\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(const string &amp;name, const int &amp;age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n\n    bool operator&#x3D;&#x3D;(const Person &amp;p)\n    &#123;\n        if (this-&gt;age &#x3D;&#x3D; p.age)\n        &#123;\n            return true;\n        &#125;\n        else\n        &#123;\n            return false;\n        &#125;\n    &#125;\n&#125;;\n\nvoid printVector(const vector&lt;int&gt; &amp;v)\n&#123;\n    for (int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printVector(const vector&lt;Person&gt; &amp;p)\n&#123;\n    for (Person it : p)\n    &#123;\n        cout &lt;&lt; it.name &lt;&lt; &quot; : &quot; &lt;&lt; it.age &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(rand()%2);\n    &#125;\n\n    printVector(v);\n\n    int countNum &#x3D; count(v.begin(),  v.end(), 0);\n    cout &lt;&lt; &quot;Count 0 : &quot; &lt;&lt; countNum &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(&quot;QQ&quot;, 11);\n    Person p2(&quot;WW&quot;, 10);\n    Person p3(&quot;EE&quot;, 10);\n    Person p4(&quot;RR&quot;, 10);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    Person p(&quot;SS&quot;, 10);\n\n    printVector(v);\n\n    int countNum &#x3D; count(v.begin(),  v.end(), p);\n    cout &lt;&lt; &quot;Count P : &quot; &lt;&lt; countNum &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int) time(NULL));\n    demo1();\n    demo2();\n\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"2-6-count-if\"><a href=\"#2-6-count-if\" class=\"headerlink\" title=\"2.6 count_if\"></a>2.6 count_if</h4><ul>\n<li><p>功能描述：按条件统计元素个数</p>\n</li>\n<li><p>函数原型：<code>count_if(iterator begin, iterator end, _Pred);</code></p>\n</li>\n<li><p><code>_Pred</code>谓词(条件)</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 13:50\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int age;\n\n    Person(const int &amp;age)\n    &#123;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nbool great_4(const int &amp;value)\n&#123;\n    return value &gt; 4;\n&#125;\n\nbool equal_10(const Person &amp;p)\n&#123;\n    return p.age &#x3D;&#x3D; 10;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D;9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    const int countNum &#x3D; count_if(v.begin(),  v.end(), great_4);\n    cout &lt;&lt; countNum &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(11);\n    Person p2(10);\n    Person p3(10);\n    Person p4(10);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    int countNum &#x3D; count_if(v.begin(),  v.end(), equal_10);\n    cout &lt;&lt; countNum &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"3-常用排序算法\"><a href=\"#3-常用排序算法\" class=\"headerlink\" title=\"3. 常用排序算法\"></a>3. 常用排序算法</h3><table>\n<thead>\n<tr>\n<th>算法简介</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>sort</code></td>\n<td>对容器内元素进行排序</td>\n</tr>\n<tr>\n<td><code>random_shuffle</code></td>\n<td>洗牌–指定范围内元素随机调整次序</td>\n</tr>\n<tr>\n<td><code>merge</code></td>\n<td>容器元素合并，并存储到另一个容器中</td>\n</tr>\n<tr>\n<td><code>reverse</code></td>\n<td>反转指定范围的元素</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-1-sort\"><a href=\"#3-1-sort\" class=\"headerlink\" title=\"3.1 sort\"></a>3.1 sort</h4><ul>\n<li><p>功能描述：对容器内元素进行排序</p>\n</li>\n<li><p>函数原型：</p>\n<ol>\n<li><code>sort(iterator begin, iterator end, _Pred);</code></li>\n<li>按照谓词的条件查找元素，找到返回指定元素位置的迭代器，找不到返回结束迭代器位置</li>\n<li><code>sort(iterator begin, iterator end);</code></li>\n<li>默认从小到大排序</li>\n</ol>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 14:09\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nvoid printVector(const vector&lt;T&gt; &amp;v)\n&#123;\n    for (T it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\ntemplate&lt;class T&gt;\nbool downSort(const T &amp;value1, const T &amp;value2)\n&#123;\n    return value1 &gt; value2;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D;9; ++i)\n    &#123;\n        v.push_back(rand()%10);\n    &#125;\n    printVector(v);\n\n    sort(v.begin(), v.end());\n    printVector(v);\n\n    sort(v.begin(), v.end(), downSort&lt;int&gt;);\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int)time(NULL));\n    demo1();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-2-random-shuffle\"><a href=\"#3-2-random-shuffle\" class=\"headerlink\" title=\"3.2 random_shuffle\"></a>3.2 random_shuffle</h4><ul>\n<li><p>功能描述：洗牌–指定范围内的元素随机调整次序</p>\n</li>\n<li><p>函数原型：<code>random_shuffle(iterator begin, iterator end);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 14:27\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;ctime&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nvoid printVector(const vector&lt;T&gt; &amp;v)\n&#123;\n    for (T it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    printVector(v);\n\n    random_shuffle(v.begin(), v.end());\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int)time(NULL));\n    demo1();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-3-merge\"><a href=\"#3-3-merge\" class=\"headerlink\" title=\"3.3 merge\"></a>3.3 merge</h4><ul>\n<li><p>功能描述：两个容器元素合并，存储到同一个容器中</p>\n</li>\n<li><p>函数原型：<code>merge(iterator begin1, iterator end1, iterator begin2, iterator end2, iterator newBegin);</code></p>\n</li>\n<li><p>注意：两个容器内的元素，必须是<code>有序序列</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 15:41\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nvoid printVector(T value)\n&#123;\n    cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v3;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(9 - i);\n    &#125;\n\n    v3.resize(v1.size() + v2.size());\n\n    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());\n    for_each(v3.begin(), v3.end(), printVector&lt;int&gt;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"3-4-reverse\"><a href=\"#3-4-reverse\" class=\"headerlink\" title=\"3.4 reverse\"></a>3.4 reverse</h4><ul>\n<li><p>功能描述：将容器内元素进行反转</p>\n</li>\n<li><p>函数原型：<code>reverse(iterator begin, iterator end);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 15:51\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nclass PrintVector_T\n&#123;\npublic:\n    void operator()(const T &amp;value)\n    &#123;\n        cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\ntemplate&lt;class T&gt;\nvoid printVector_T(const T &amp;value)\n&#123;\n    cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    cout &lt;&lt; &quot;Meta: &quot;;\n    for_each(v.begin(), v.end(), PrintVector_T&lt;int&gt;());\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;Reverse: &quot;;\n    reverse(v.begin(), v.end());\n    for_each(v.begin(), v.end(), printVector_T&lt;int&gt;);\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"4-常用拷贝替换算法\"><a href=\"#4-常用拷贝替换算法\" class=\"headerlink\" title=\"4. 常用拷贝替换算法\"></a>4. 常用拷贝替换算法</h3><table>\n<thead>\n<tr>\n<th>算法简介</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>copy</code></td>\n<td>容器内指定范围的元素拷贝到另一个容器中</td>\n</tr>\n<tr>\n<td><code>replace</code></td>\n<td>容器内指定范围的<code>旧元素</code> 改为 <code>新元素</code></td>\n</tr>\n<tr>\n<td><code>replace_if</code></td>\n<td>容器内指定范围的<code>满足条件的旧元素</code> 改为 <code>新元素</code></td>\n</tr>\n<tr>\n<td><code>swap</code></td>\n<td>互换两个容器的元素</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-1-copy\"><a href=\"#4-1-copy\" class=\"headerlink\" title=\"4.1 copy\"></a>4.1 copy</h4><ul>\n<li><p>功能描述：容器内指定范围的元素拷贝到另一个容器中</p>\n</li>\n<li><p>函数原型：<code>copy(iterator begin, iterator end, iterator newBegin);</code></p>\n</li>\n<li><p>按值查找元素，返回找到的指定位置迭代器，找不到返回结束迭代器</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 16:10\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass PrintVector\n&#123;\npublic:\n    void operator()(int value)\n    &#123;\n        cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n\n    v2.resize(v1.size());\n\n    copy(v1.begin(), v1.end(), v2.begin());\n\n    for_each(v2.begin(), v2.end(), PrintVector());\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"4-2-replace\"><a href=\"#4-2-replace\" class=\"headerlink\" title=\"4.2 replace\"></a>4.2 replace</h4><ul>\n<li><p>功能描述：容器内指定范围的<code>旧元素</code> 改为 <code>新元素</code></p>\n</li>\n<li><p>函数原型：<code>replace(iterator begin, iterator end, old_Value, new_Value);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 16:18\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)\n&#123;\n    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;\n    for (const int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    printVector(v, &quot;Meta&quot;);\n\n    replace(v.begin(), v.end(), 0, 9);\n    printVector(v, &quot;New&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"4-3-replace-if\"><a href=\"#4-3-replace-if\" class=\"headerlink\" title=\"4.3 replace_if\"></a>4.3 replace_if</h4><ul>\n<li><p>功能描述：容器内指定范围的<code>满足条件的旧元素</code> 改为 <code>新元素</code></p>\n</li>\n<li><p>函数原型：<code>replace_if(iterator beign, iterator end, _Pred, new_Value);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 16:25\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)\n&#123;\n    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;\n    for (const int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nbool greater_5(int value)\n&#123;\n    return value &gt; 5;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    printVector(v, &quot;Meta&quot;);\n\n    replace_if(v.begin(), v.end(), greater_5, 0);\n    printVector(v, &quot;New&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"4-4-swap\"><a href=\"#4-4-swap\" class=\"headerlink\" title=\"4.4 swap\"></a>4.4 swap</h4><ul>\n<li><p>功能描述：互换两个容器的元素</p>\n</li>\n<li><p>函数原型：<code>swap(contatiner c1, contatiner c2);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 16:30\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)\n&#123;\n    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;\n    for (const int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(9 - i);\n    &#125;\n\n    printVector(v1, &quot;meta&quot;);\n    printVector(v2, &quot;meta&quot;);\n\n    swap(v1, v2);\n    printVector(v1, &quot;new&quot;);\n    printVector(v2, &quot;new&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"5-常用算术生成算法\"><a href=\"#5-常用算术生成算法\" class=\"headerlink\" title=\"5. 常用算术生成算法\"></a>5. 常用算术生成算法</h3><ul>\n<li><p>注意：算术生成算法属于小型算法，使用时需要包含头文件<code>#include &lt;numeric&gt;</code></p>\n<table>\n<thead>\n<tr>\n<th>算法简介</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>accumulate</code></td>\n<td>计算容器区间内元素累计总和</td>\n</tr>\n<tr>\n<td><code>fill</code></td>\n<td>向容器中<code>填充</code>元素</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"5-1-accumulate\"><a href=\"#5-1-accumulate\" class=\"headerlink\" title=\"5.1 accumulate\"></a>5.1 accumulate</h4><ul>\n<li><p>功能描述：计算容器区间内元素累计总和</p>\n</li>\n<li><p>函数原型：<code>accumulate(iterator begin, iterator end, value);</code></p>\n</li>\n<li><p><code>value</code>起始值</p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 17:02\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    const int sum &#x3D; accumulate(v.cbegin(), v.cend(), 0);\n    cout &lt;&lt; sum &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"5-2-fill\"><a href=\"#5-2-fill\" class=\"headerlink\" title=\"5.2 fill\"></a>5.2 fill</h4><ul>\n<li><p>功能描述：向容器中<code>填充</code>元素</p>\n</li>\n<li><p>函数原型：<code>fill(iterator begin, iterator end, value);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 17:12\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v)\n&#123;\n    for (const int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 8; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    fill(v.begin(), v.end(), 9);\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"6-常用集合算法\"><a href=\"#6-常用集合算法\" class=\"headerlink\" title=\"6. 常用集合算法\"></a>6. 常用集合算法</h3><table>\n<thead>\n<tr>\n<th>算法简介</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>set_intersection</code></td>\n<td>求两个容器的<code>交集</code></td>\n</tr>\n<tr>\n<td><code>set_union</code></td>\n<td>求两个容器的<code>并集</code></td>\n</tr>\n<tr>\n<td><code>set_difference</code></td>\n<td>求两个容器的<code>差集</code></td>\n</tr>\n</tbody></table>\n<ul>\n<li>注意：<ol>\n<li>使用前，确保 <code>新容器</code> 的预设一个 <code>合适大小</code></li>\n<li>算法<code>返回</code>的是 <code>最后一个元素</code> 所在位置的 <code>迭代器</code></li>\n<li>遍历 <code>新容器</code> 要用 <code>算法返回的迭代器</code>，而不是使用 <code>新容器自身的结束迭代器</code></li>\n<li><code>交集算法</code>中，<code>新容器自身的结束迭代器</code> 可能超出 <code>最后一个元素</code> 所在位置的 <code>迭代器</code></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"6-1-set-intersection\"><a href=\"#6-1-set-intersection\" class=\"headerlink\" title=\"6.1 set_intersection\"></a>6.1 set_intersection</h4><ul>\n<li><p>功能描述：求两个容器的<code>交集</code></p>\n</li>\n<li><p>函数原型：<code>set_intersection(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 17:27\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (const int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (vector&lt;int&gt;::const_iterator itBegin &#x3D; v.begin(); itBegin !&#x3D; it; ++itBegin)\n    &#123;\n        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v_tag;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i + 5);\n    &#125;\n    printVector(v1, &quot;V1&quot;);\n    printVector(v2, &quot;V2&quot;);\n\n    v_tag.resize(min(v1.size(), v2.size()));\n\n    vector&lt;int&gt;::const_iterator itLast &#x3D; set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());\n\n    &#x2F;&#x2F; 使用 新容器自身迭代器\n    printVector(v_tag, &quot;Target&quot;);\n\n    &#x2F;&#x2F; 使用 set_intersection 返回的 最后一个元素的迭代器\n    printVector(v_tag, itLast, &quot;Target&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"6-2-set-union\"><a href=\"#6-2-set-union\" class=\"headerlink\" title=\"6.2 set_union\"></a>6.2 set_union</h4><ul>\n<li><p>功能描述：求两个容器的<code>并集</code></p>\n</li>\n<li><p>函数原型：<code>set_union(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 17:50\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (const int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (vector&lt;int&gt;::const_iterator itBegin &#x3D; v.begin(); itBegin !&#x3D; it; ++itBegin)\n    &#123;\n        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v_tag;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 4; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i + 4);\n    &#125;\n    printVector(v1, &quot;V1&quot;);\n    printVector(v2, &quot;V2&quot;);\n\n    v_tag.resize(v1.size() + v2.size());\n\n    vector&lt;int&gt;::const_iterator itLast &#x3D; set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());\n\n    &#x2F;&#x2F; 使用 set_union 返回的 最后一个元素的迭代器\n    printVector(v_tag, itLast, &quot;Target&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"6-3-set-difference\"><a href=\"#6-3-set-difference\" class=\"headerlink\" title=\"6.3 set_difference\"></a>6.3 set_difference</h4><ul>\n<li><p>功能描述：求两个容器的<code>差集</code></p>\n</li>\n<li><p>差集：</p>\n<ol>\n<li><p>求出 c1 和 c2 的交集</p>\n</li>\n<li><p>c1 与 c2 的差集：c1 的 减去 交集部分</p>\n</li>\n<li><p>c2 与 c1 的差集：c2 的 减去 交集部分</p>\n</li>\n</ol>\n</li>\n<li><p>函数原型：<code>set_difference(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);</code></p>\n</li>\n<li><p>代码示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 18:13\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (const int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (vector&lt;int&gt;::const_iterator itBegin &#x3D; v.begin(); itBegin !&#x3D; it; ++itBegin)\n    &#123;\n        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v_tag;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i + 5);\n    &#125;\n    printVector(v1, &quot;V1&quot;);\n    printVector(v2, &quot;V2&quot;);\n\n    v_tag.resize(max(v1.size(), v2.size()));\n\n    &#x2F;&#x2F; V1 对于 V2 的 差集\n    vector&lt;int&gt;::const_iterator itLast_V1 &#x3D; set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());\n    printVector(v_tag, itLast_V1, &quot;V1 Difference&quot;);\n\n    &#x2F;&#x2F; V2 对于 V1 的 差集\n    vector&lt;int&gt;::const_iterator itLast_V2 &#x3D; set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), v_tag.begin());\n    printVector(v_tag, itLast_V2, &quot;V2 Difference&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;</code></pre></li>\n</ul>\n","text":"C++_STL算法[toc] 概述： 算法主要是头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt; 组成 &lt;algorithm&gt; 是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-STL%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">C++_STL算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">1. 常用遍历算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-for-each\"><span class=\"toc-text\">1.1 for_each</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-transform\"><span class=\"toc-text\">1.2 transform</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2. 常用查找算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-find\"><span class=\"toc-text\">2.1 find</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-find-if\"><span class=\"toc-text\">2.2 find_if</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-adjacent-find\"><span class=\"toc-text\">2.3 adjacent_find</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-binary-search\"><span class=\"toc-text\">2.4 binary_search</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-count\"><span class=\"toc-text\">2.5 count</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-count-if\"><span class=\"toc-text\">2.6 count_if</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3. 常用排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-sort\"><span class=\"toc-text\">3.1 sort</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-random-shuffle\"><span class=\"toc-text\">3.2 random_shuffle</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-merge\"><span class=\"toc-text\">3.3 merge</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-reverse\"><span class=\"toc-text\">3.4 reverse</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">4. 常用拷贝替换算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-copy\"><span class=\"toc-text\">4.1 copy</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-replace\"><span class=\"toc-text\">4.2 replace</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-replace-if\"><span class=\"toc-text\">4.3 replace_if</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-swap\"><span class=\"toc-text\">4.4 swap</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">5. 常用算术生成算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-accumulate\"><span class=\"toc-text\">5.1 accumulate</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-fill\"><span class=\"toc-text\">5.2 fill</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">6. 常用集合算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-set-intersection\"><span class=\"toc-text\">6.1 set_intersection</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-set-union\"><span class=\"toc-text\">6.2 set_union</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-3-set-difference\"><span class=\"toc-text\">6.3 set_difference</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++_核心编程","uid":"e94a77a3753f22f554c8c36e4173e356","slug":"1_C++_核心编程_03","date":"2022-10-06T07:28:25.912Z","updated":"2023-01-10T01:10:19.450Z","comments":true,"path":"api/articles/1_C++_核心编程_03.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (3).webp","text":"C++_核心编程[toc] 1. 内存分区模型C++程序在执行时，内存大方向划分为4个区域 代码区：存放函数的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等 堆区：由程序员分配和释放，若不释放，程...","link":"","photos":[],"count_time":{"symbolsCount":"96k","symbolsTime":"1:27"},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{}}