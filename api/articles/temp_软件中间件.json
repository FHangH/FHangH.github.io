{"title":"软件中间件","uid":"969a273c20a676d026ced13f1dc7c160","slug":"temp_软件中间件","date":"2023-02-10T02:56:22.992Z","updated":"2023-02-10T03:08:14.693Z","comments":true,"path":"api/articles/temp_软件中间件.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (104).webp","content":"<h1 id=\"软件中间件\"><a href=\"#软件中间件\" class=\"headerlink\" title=\"软件中间件\"></a>软件中间件</h1><h3 id=\"选择题（均是多选）\"><a href=\"#选择题（均是多选）\" class=\"headerlink\" title=\"选择题（均是多选）\"></a>选择题（均是多选）</h3><p>1、完整实现 EJB 规范的产品有（ BC ）。<br>A、Spring<br><strong>B、GlassFish</strong><br><strong>C、Tomee</strong><br>D、MyBatis</p>\n<p>2、Spring中用于处理 HTTP 方法的资源注解是（ ACD ）。<br><strong>A、@PostMapping</strong><br>B、@ID<br><strong>C、@RequestBody</strong><br><strong>D、@PatchMapping</strong></p>\n<p>3、Java NIO 中，下列哪个可供选择器监控的通道 IO 事件类型：（ A ）。<br><strong>A、SelectionKey.OP_READ</strong><br>B、SelectionKey.DENY<br>C、SelectionKey.CONNECT<br>D、SelectionKey.WRITE</p>\n<p>4、Java 反射机制 API 的关键类是（C）<br>A、java.lang.Object<br>B、java.lang.reflect.Method<br><strong>C、java.lang.Class</strong><br>D、java.lang.reflect.Constructor</p>\n<p>5、下列那些字段可以使得 HTTP GET 请求就具体化为条件获取（ C ）。<br>A、If-Recive-Since<br>B、If-Unmodified-Content<br><strong>C、If-Match</strong><br>D、If-Match-Date</p>\n<p>6、Java Servlet 中用于声明一个类为 Servlet 的注解是（ A）。<br><strong>A、@WebServlet</strong><br>C、@Get<br>B、@Controller<br>D、@Post</p>\n<p>7、 HTML DOM 模型中，获取网页中元素的方法有（ ABCD）。<br><strong>A、getElementById()</strong><br><strong>B、getElementsByName()</strong><br><strong>C、getElementByclassName()</strong><br><strong>D、getElementByTagName()</strong></p>\n<p>8、下列属于 Java 通道类型的是（ BD）。<br>A、ServerBootstrap<br><strong>B、NioSocketChannel</strong><br>C、NioEventLoop<br><strong>D、AsynchronousSocketChannel</strong></p>\n<p>9、 在 HTTP 响应消息中，下列哪种状态码可以表示请求资源状态未改变（D ）。<br>A、302<br>B、204<br>C、102<br><strong>D、304</strong></p>\n<p>10、下列说法正确的是（ A ）。<br><strong>A、HTTP&#x2F;2.0 的消息的以二进制数据进行传输的，结构比复杂。</strong><br>B、SOAP 协议的依托协议是 HTTP&#x2F;2。<br>C、Netty 不能采用阻塞方式工作。<br>D、gRPC 协议是明文的，在消息传递过程中，结构比较简单。</p>\n<p>11、属于消息中间件产品的是（ AB）。<br><strong>A、ActiveMQ</strong><br><strong>B、RocketMQ</strong><br>C、Dubbo3<br>D、MyBatis</p>\n<p>12、下列那组件实现了 TCP&#x2F;IP协议规范（ ABC）。<br><strong>A、Socket</strong><br><strong>B、Java Socket</strong><br><strong>C、WinSock</strong><br>D、Jfinal</p>\n<p>13、Java 声明自定义注解的关键字是（ A ）。<br><strong>A、@interface</strong><br>B、class<br>C、interface<br>D、final</p>\n<p>14、下面哪个属于 HTTP&#x2F;1.1 协议的标准 METHOD（ AD ）。<br><strong>A、OPTIONS</strong><br>B、SELECT<br>C、UPDATE<br><strong>D、PUT</strong></p>\n<p>15、指明 HTTP 响应中包含托挂的关键字是（D）。<br>A、CheckNum<br>B、ExtraInfo<br>C、Content-Trail<br><strong>D、Trailer</strong></p>\n<p>16、JavaNIO 中，实现服务器的核心组件是（B）。<br>A、ServerSocket<br><strong>B、ServerSocketChanel</strong><br>C、Socket<br>D、SocketChanel</p>\n<p>17、HTTP&#x2F;1.1 协议 Request 的首行不包括哪类字段（B ）。<br>A、Method<br><strong>B、Status-Code</strong><br>C、Request-URI<br>D、HTTP-Version</p>\n<p>18、HTTP 协议的消息主体内容编码有（ AB）。<br><strong>A、gzip</strong><br><strong>B、compress</strong><br>C、utf-8<br>D、en</p>\n<p>19、实现跨域请求的方式有（ CD）。<br>A、隧道协议<br>B、PPTP<br><strong>C、JSONP</strong><br><strong>D、Web 代理</strong></p>\n<p>20、实现 Java Servlet 规范的产品有（ AB）。<br><strong>A、TOMEE</strong><br><strong>B、GlassFish</strong><br>C、Apache2<br>D、nginx</p>\n<p>21、属于数据库中间件产品的是（ BD）。<br>A、ActiveMQ<br><strong>B、SQLAlchemy</strong><br>C、MTS<br><strong>D、MyBatis</strong></p>\n<p>22、在三层结构的分布式系统中，包含了系统的核心业务逻辑的是（D ）。<br>A、数据层<br>B、表示层<br>C、客户层<br><strong>D、中间层</strong></p>\n<p>23、Java 接口文件的不应该出现内容是：（ C）。<br>A、interface<br>B、public<br><strong>C、函数的实现</strong><br>D、String</p>\n<p>24、下面哪一个不属于 HTTP&#x2F;1.1 协议的标准 METHOD（C ）。<br>A、OPTIONS<br>B、CONNECT<br><strong>C、UPDATE</strong><br>D、PUT</p>\n<p>25、下面属于 RPC 技术和框架有（ AC ）。<br><strong>A、Dubbo&#x2F;Dubbox</strong><br>B、SOAP<br><strong>C、Finagle</strong><br>D、MINA</p>\n<p>26、Java 8 版本的 Java SE 提供 11 种内置注解，请问下列哪些不再其中（D ）。<br>A、@Runtime<br>B、@FuntionInterface<br>C、@SuppressWarnings<br><strong>D、@Table</strong></p>\n<p>27、HTTP&#x2F;1.1 协议 Response 的状态行不包括哪类字段（ AC ）。<br><strong>A、Method</strong><br>B、Status-Code<br><strong>C、Request-URI</strong><br>D、HTTP-Version</p>\n<p>28、关于反射机制下列描述不正确的是（ D）。<br>A、在运行时判断任意一个对象所属的类<br>B、在运行时判断任意一个类所具有的成员变量和方法<br>C、生成动态代理<br><strong>D、Java 反射的主要实现包含在 javax.lang.reflect 包中</strong></p>\n<p>29、下列哪种不是 Java I&#x2F;O 的标准实现方式（ C）。<br>A、BIO<br>B、AIO<br><strong>C、Netty</strong><br>D、NIO</p>\n<p>30、下列说法正确的是（ CD ）。<br>A、RPC 不能采用 UDP 作为其底层通信协议<br>B、SOAP 协议的底层协议是 TCP&#x2F;IP<br><strong>C、RPC 是一种技术思想而非一种规范或协议</strong><br><strong>D、RPC 服务器启动时主动向注册中心登记自己的服务种类、服务方法、版本</strong></p>\n<p>31、实现 Java Servlet 规范的产品有（ BC ）。<br>A、Hibernate<br><strong>B、GlassFish</strong><br><strong>C、Tomee</strong><br>D、MyBatis</p>\n<p>32、Spring中可以处理指定 URL 中包含的一个或多个参数的注解是（ A ）。<br><strong>A、@PathVariable</strong><br>B、@ID<br>C、@RequestBody<br>D、@Data</p>\n<p>33、属于 Java AIO 中核心的类是：（ A）。<br><strong>A、CompletionHandler</strong><br>B、ServerSocket<br>C、HashMap<br>D、Socket</p>\n<p>34、下面哪一个不属于标准 HTTP&#x2F;1.1 协议头的参数的是（ D）。<br>A、Last-Modified<br>B、User-Agent<br>C、Connection<br><strong>D、Length</strong></p>\n<p>35、下面不属于 RPC 框架的是（D）。<br>A、Dubbo&#x2F;Dubbox<br>B、gRPC<br>C、Finagle<br><strong>D、MINA</strong></p>\n<p>36、Java 8 版本的 Java SE 提供 5 种内置注解，请问下列哪些是正确的（ BC ）。<br>A、@Runtime<br><strong>B、@Funtioninterface</strong><br><strong>C、@SuppressWarnings</strong><br>D、@Table</p>\n<p>38、下列属于 Netty 通道类型的是（B）。<br>A、ServerBootstrap<br><strong>B、NioSocketChannel</strong><br>C、NioEventLoop<br>D、AsynchronousSocketChannel</p>\n<p>39、在 HTTP 响应消息中，下列哪种状态码可以表示请求已经成功处理（ B）。<br>A、302<br><strong>B、204</strong><br>C、102<br>D、201</p>\n<p>40、下列说法正确的是（B ）。<br>A、HTTP&#x2F;1.1 的消息的以二进制数据进行传输的，结构比复杂。<br><strong>B、SOAP 协议的依托协议是 HTTP。</strong><br>C、Netty 不能采用阻塞方式工作。<br>D、HTTP&#x2F;2 协议是明文的，在消息传递过程中，结构比较简单。</p>\n<h3 id=\"填空题\"><a href=\"#填空题\" class=\"headerlink\" title=\"填空题\"></a>填空题</h3><p>1、 软件的三大类型：<code>单机</code>、<code>CS</code>、<code>BS</code>。</p>\n<p>2、 反射（Reflection）是程序的<code>自我分析能力</code>,通过反射可以确定类有哪些方法、有哪些构造方法以及有哪些成员变量。Java 语言提供了反射机制，通过反射机制能够<code>动态读取一个类的信息</code>；能够在运行时动态加载类，而不是在<code>编译期</code>。反射可以应用于框架开发，它能够从配置文件中读取配置信息动态加载类、<code>创建对象</code>，以及调用方法和成员变量。</p>\n<p>3、 HTTP&#x2F;1.1 协议的响应消息由<code>响应行</code>、<code>响应头</code>、<code>响应体</code>组成。</p>\n<p>4、 实现 ORM 中间件重点处理<code>从实体类生成数据库表</code>、<code>从数据库表生成实体类</code>、<code>实体类和数据库表中数据的自动转换</code>自动化。<br> <br>5、 Java NIO 的三个核心组件是：<code>Channel（通道）</code>, <code>Buffer（缓冲区</code>, <code>Selector（选择器）</code></p>\n<p>6、在 HTTP&#x2F;1.1 协议中，处理多事务的连接的方式有：<code>并行连接</code>、<code>Keep-Alive</code>、<code>持久连接</code>、<code>管道</code>。</p>\n<p>7、常见的五种基本 I&#x2F;O 模型，分别是：阻塞 I&#x2F;O 模型、非阻塞 I&#x2F;O 模型、<code>IO 复用模型</code>、<code>信号驱动的 IO 模型和异步 IO 模型</code></p>\n<p>8、Java 8 提供的元注解包括：@Documented、@Target、@Retention、<code>@Inherited</code>、<code>@Repeatable</code></p>\n<p>9、一个 HTTP 事务由一条<code>请求消息</code>和一条<code>响应消息</code>构成。</p>\n<p>10、Reactor 模式由<code>Reactor&gt;</code>和 <code>Handler</code>两大角色组成。</p>\n<p>11、 I&#x2F;O 通信模型有：<code>阻塞 I/O 模型</code>、<code>非阻塞 I/O 模型</code>、<code>IO 复用模型</code>、<code>信号驱动的 IO 模型</code>、<code>异步 IO 模型</code></p>\n<p>12、Java BIO 和 NIO 的本质区别是，Java BIO 是面向<code>流</code>，NIO 是面向<code>缓存区</code></p>\n<p>13、Java NIO 的核心组件分别是: <code>Selector</code>，<code>Channel</code>，<code>Buffer</code>组成。</p>\n<p>14、HTTP 响应的状态行由<code>HTTP 协议版本号</code>，<code>状态码</code>, <code>状态消息</code>构成。</p>\n<p>15、Netty 的 Handler 分为两大类：<code>Inbound</code> ，<code>Outbound</code>。</p>\n<p>16、在 HTTP&#x2F;1.1 协议中，处理多事务的连接的方式有：<code>并行连接</code>、<code>Keep-Alive</code>、<code>持久连接</code>、<code>管道</code></p>\n<p>19、浏览器将 CORS 请求分成两类：<code>简单请求</code>和 <code>非简单请求</code>。</p>\n<h3 id=\"简答\"><a href=\"#简答\" class=\"headerlink\" title=\"简答\"></a>简答</h3><p><strong>1、 在 Java 中，NIO 和 BIO 的区别主要体现在那三个方面？</strong></p>\n<ul>\n<li>BIO 是面向流的，NIO 是面向缓冲区的</li>\n<li>Java BIO 的各种流是阻塞的，Java NIO是非阻塞模式</li>\n<li>BIO 无选择器，NIO 有</li>\n</ul>\n<p><strong>2、 RESTful 架构风格背后的主要思想是什么？</strong></p>\n<ul>\n<li>统一接口：组件之间有统一的接口。</li>\n<li>RESTful web 服务是基于客户机&#x2F;服务器的，不存储状态。</li>\n<li>从客户机到服务器的请求的结果可以缓存在客户机中。</li>\n<li>它具有基于超媒体的统一接口，具有自描述消息。</li>\n<li>而且客户机和服务器并不知道它们之间的中间连接。</li>\n</ul>\n<p><strong>3、 AJAX 中包括哪些技术？</strong></p>\n<ul>\n<li>HTML、css、dom、XMLHttpRequest、javascript</li>\n<li>基于 Web 标准(XHTML + CSS)的展示</li>\n<li>使用 DOM 进行动态显示和交互</li>\n<li>使用 XMLHttpRequest 进行数据交换和相关操作</li>\n<li>用 JS 可以控制 XMLHttpRequest 对象向服务器提出请求并处理响应，而不影响用户对页面的正常访问</li>\n</ul>\n<p><strong>4、 请简述 HTTP&#x2F;1.1 协议 300 型响应码中几个重要的响应码，含义是什么？</strong></p>\n<ul>\n<li>300 同样的一个 URI，可以对应多个实际的资源</li>\n<li>301 请求的 URL 已移走</li>\n<li>302 请求的 URL 临时移走</li>\n<li>303 此状态码也是重定向</li>\n<li>307 此状态码也是重定向响应</li>\n</ul>\n<p><strong>5、 序列化和反序列化会涉及 POJO 的编码和格式化（Encoding &amp; Format），目前我们可选择的编码方式有几种？评价一个序列化框架的优缺点应该从那些方面着手？</strong></p>\n<ol>\n<li>4 种，使用 JSON、基于 XML、使用 Java 内置的编码和序列化机制、开源的二进制的序列化&#x2F;反序列化框架</li>\n<li>结果数据大小，原则上说，序列化后的数据尺寸越小，传输效率越高</li>\n<li>结构复杂度，这会影响序列化&#x2F;反序列化的效率，结构越复杂，越耗时</li>\n</ol>\n<p><strong>6、简述 HTTP 协议请求的八个方法的名称及其功能。</strong></p>\n<ul>\n<li>GET 表示我们要请求一个由 URI 指定的在服务器上的资源。</li>\n<li>PUT 方法 表示如果指定 URL 资源不存在就创建它，否则就修改它。</li>\n<li>POST 方法 表示要创建一个新的子资源，或者更新一个存在的资源。</li>\n<li>DELETE 表示我们要删除一个由 URI 指定的资源。</li>\n<li>HEAD 和 GET 一样，但是仅仅返回指定资源响应的头部分，而不必返回响应主体</li>\n<li>OPTIONS 查询目标资源支持 method 的清单。</li>\n<li>TRACE 查询到目标资源经过的中间节点。用于测试。</li>\n<li>CONNECT 建立一个到 URI 指定的服务器的隧道。</li>\n</ul>\n<p><strong>7、简述 java.lang.reflect 包中提供反射处理能力的几个类并说明其作用。</strong></p>\n<ul>\n<li>Constructor 类：提供类的构造方法信息。</li>\n<li>Field 类：提供类或接口中成员变量信息。</li>\n<li>Method 类：提供类或接口成员方法信息。</li>\n<li>Array 类：提供了动态创建和访问 Java 数组的方法。</li>\n<li>Modifier 类：提供类和成员访问修饰符信息。</li>\n</ul>\n<p><strong>8、简述目前 Java 中常见的几种实现 RESTful 技术方案。</strong></p>\n<ul>\n<li>使用 Spring 的 RestTemplate</li>\n<li>通过 Servlet 实现</li>\n<li>JAX-RS</li>\n<li>JAX-RS 即 Java API for RESTful Web Services</li>\n</ul>\n<p><strong>9、请简述 java.lang.Class 类和 java.lang.Object 的作用和区别。</strong></p>\n<ul>\n<li>Class 类也是类的一种，只是名字和 class 关键字高度相似，用于 java 反射机制。</li>\n<li>Class 类的对象不能像普通类一样，以 new 的方式创建，它的对象只能由 JVM 创建，因为这个类没有 public 构造函数</li>\n<li>Class 类的作用是运行时提供或获得某个对象的类型信息，这些信息也可用于反射。</li>\n<li>Object 类是一切 java 类的父类，对于普通的 java 类，即便不声明，也是默认继承了 Object类。</li>\n<li>Object 类位于 java.lang 包中，java.lang 包包含着 Java 最基础和核心的类，在编译时会自动导入</li>\n<li>Object 类定义了线程同步与交互的一系列方法</li>\n</ul>\n<p><strong>11 简述 Java NIO 中使用 Buffer 类的基本步骤？</strong></p>\n<ul>\n<li>（1）使用创建子类实例对象的 allocate()方法，创建一个 Buffer 类的实例对象。</li>\n<li>（2）调用 put 方法，将数据写入到缓冲区中。</li>\n<li>（3）写入完成后，在开始读取数据前，调用 Buffer.flip()方法，将缓冲区转换为读模式。</li>\n<li>（4）调用 get 方法，从缓冲区中读取数据。</li>\n<li>（5）读取完成后，调用 Buffer.clear()方法，将缓冲区转换为写入模式。</li>\n</ul>\n<p><strong>13、 请简述 HTTP&#x2F;1.1 协议 200 型响应码中几个重要的响应码，含义是什么？</strong></p>\n<ul>\n<li>200 请求已经成功完成</li>\n<li>201 指明请求成功且创建了一个资源</li>\n<li>202 已接受请求，但尚未处理。</li>\n<li>203 已成功处理了请求，但返回的信息可能来自另一来源。</li>\n<li>204 成功处理了请求，但没有返回任何内容。</li>\n<li>205 成功处理了请求，但没有返回任何内容。</li>\n<li>206 为了支持大文件的分段下载</li>\n</ul>\n<p><strong>14、 简述 Reactor 模式的优点和缺点</strong></p>\n<ul>\n<li>优点:解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制</li>\n<li>缺点：模型复杂</li>\n</ul>\n<p><strong>16、简述 Java 反射机制中获取 Java 类构造方法的函数，并说明其作用。</strong></p>\n<ul>\n<li>在 java 反射机制中，可以使用 Class 类的 getConstructors()函数来获取 java 类构造方法。</li>\n<li>这个函数可以返回一个 Constructor 对象数组，可以用来查找、访问和调用 java 类的构造函数，从而实现对 java 类的动态构造和实例化。</li>\n</ul>\n<p><strong>18、列出 Java NIO 通道类中我们常用的文件处理和网络通信常用的通道类，并说明起作用。</strong></p>\n<ul>\n<li>FileChannel：文件通道，用于文件的数据读写。</li>\n<li>SocketChannel：套接字通道，用于套接字 TCP 连接的数据读写。</li>\n<li>ServerSocketChannel：服务器套接字通道（或服务器监听通道），允许我们监听TCP 连接请求，为每个监听到的请求创建一个 SocketChannel 通道。</li>\n<li>DatagramChannel：数据报通道，用于 UDP 的数据读写。</li>\n</ul>\n<p><strong>19、简述哪些 HTTP 请求会产使用到 CORS 机制。</strong></p>\n<ul>\n<li>使用 XMLHttpRequest 或 Fetch API 进行跨站请求</li>\n<li>网页字体</li>\n<li>WebGL 纹理</li>\n<li>以 drawImage 绘制到 Canvas 画布上的图形</li>\n<li>CSS 样式表</li>\n<li>指令码</li>\n</ul>\n<h3 id=\"程序综合题\"><a href=\"#程序综合题\" class=\"headerlink\" title=\"程序综合题\"></a>程序综合题</h3><p>1、补齐 HTTP Response 类程序中的缺失的代码。 ！！！！[]为答案！！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">code</span> <span class=\"operator\">=</span> [<span class=\"number\">200</span>]; <span class=\"comment\">// 答案 200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">this</span>.len = html.getBytes().length;</span><br><span class=\"line\">[setHead()];<span class=\"comment\">// 答案 setHead()</span></span><br><span class=\"line\">bw.append(headInfo.toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (code)</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">200</span>:</span><br><span class=\"line\">headInfo.append(<span class=\"string\">&quot;[OK]&quot;</span>);<span class=\"comment\">// 答案 &quot;OK&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">404</span>:</span><br><span class=\"line\">headInfo.append(<span class=\"string\">&quot;[NOT FOUND]&quot;</span>);<span class=\"comment\">// 答案 &quot;NOT FOUND&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">505</span>:</span><br><span class=\"line\">headInfo.append(<span class=\"string\">&quot;[Server ERROR]&quot;</span>);<span class=\"comment\">// 答案 &quot;Server ERROR&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">headInfo.append([CRLF]);<span class=\"comment\">// 答案 CRLF</span></span><br><span class=\"line\">headInfo.append(<span class=\"string\">&quot;[Date:]&quot;</span>).append(LocalDateTime.now()).append(CRLF);<span class=\"comment\">// 答案 Date</span></span><br><span class=\"line\">headInfo.append(<span class=\"string\">&quot;[Content-Type]:text/html;charset=UTF-8&quot;</span>).append(CRLF);<span class=\"comment\">// 答案 Content-Type</span></span><br><span class=\"line\">headInfo.append(<span class=\"string\">&quot;[Content-Length:]&quot;</span>).append(space).append(<span class=\"built_in\">this</span>.len).append(CRLF).append(CRLF);<span class=\"comment\">// 答案 Content-Length</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setCode</span><span class=\"params\">(<span class=\"type\">int</span> code)</span></span><br><span class=\"line\">[<span class=\"built_in\">this</span>.code] = code;<span class=\"comment\">// 答案 this.code</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>2、  下面代码是 HTTP Request 解析类，请根据协议要求，补齐空格中必须填入的代码，注意合理利用已定义变量：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">CRLF</span> <span class=\"operator\">=</span> [<span class=\"string\">&quot;\\n&quot;</span>];<span class=\"comment\">// 答案 &quot;\\n&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">byte</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">20000</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> [<span class=\"built_in\">this</span>.is.read(arr)];<span class=\"comment\">// 答案 this.is.read(arr)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">requestInfo</span> <span class=\"operator\">=</span> [<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(arr, <span class=\"number\">0</span>, len)];<span class=\"comment\">// 答案 new String(arr, 0, len)</span></span><br><span class=\"line\"></span><br><span class=\"line\">String[] arr = url.split(<span class=\"string\">&quot;\\\\?&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">this</span>.url = [arr[<span class=\"number\">0</span>]];<span class=\"comment\">// 答案 arr[0]</span></span><br><span class=\"line\">param = [arr[<span class=\"number\">1</span>]];<span class=\"comment\">// 答案 arr[1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">StringTokenizer</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringTokenizer</span>(param,[<span class=\"string\">&quot;&amp;&quot;</span>]);<span class=\"comment\">// 答案 &quot;&amp;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">key_value</span> <span class=\"operator\">=</span> (String) token.nextElement();</span><br><span class=\"line\">String[] ks = key_value.split([<span class=\"string\">&quot;=&quot;</span>]);<span class=\"comment\">// 答案 &quot;=&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">ks = Arrays.copyOf(ks, <span class=\"number\">2</span>);</span><br><span class=\"line\">ks[<span class=\"number\">1</span>] = [<span class=\"literal\">null</span>];<span class=\"comment\">// 答案 null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (values == <span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">return</span>[values[<span class=\"number\">0</span>]];<span class=\"comment\">// 答案 values[0]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getUrl</span><span class=\"params\">()</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> [<span class=\"built_in\">this</span>.url];<span class=\"comment\">// 答案 this.url</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>3、补齐通用服务线程池 ServicePool 程序中的缺失的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServicePool</span>&lt;Job extends [Runnable]&gt;<span class=\"comment\">// 答案 Runnable</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">threadNum</span> <span class=\"operator\">=</span> [<span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>()];<span class=\"comment\">// 答案 new AtomicLong()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; workerNum; i++) &#123;</span><br><span class=\"line\"><span class=\"type\">MyWorker</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyWorker</span>();</span><br><span class=\"line\">[workerList.add(worker)];<span class=\"comment\">// 答案 workerList.add(worker)</span></span><br><span class=\"line\"></span><br><span class=\"line\">jobsList.addLast(job);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;剩余待处理请求个数：&quot;</span> + ServicePool.<span class=\"built_in\">this</span>.getJobsize());</span><br><span class=\"line\">[jobsList.notify()];<span class=\"comment\">// 答案 jobsList.notify()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getJobsize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> [jobsList.size()];<span class=\"comment\">// 答案 jobsList.size()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyWorker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> [<span class=\"keyword\">volatile</span>] <span class=\"type\">boolean</span> <span class=\"variable\">isRunning</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;<span class=\"comment\">// 答案 volatile</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ([isRunning]) &#123;<span class=\"comment\">// 答案 isRunning</span></span><br><span class=\"line\"><span class=\"type\">Job</span> <span class=\"variable\">job</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">[jobsList.wait()];<span class=\"comment\">// 答案 jobsList.wait()</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) </span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;正在处理请求&quot;</span>);</span><br><span class=\"line\">[job.run()];<span class=\"comment\">// 答案 job.run()</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"分析题\"><a href=\"#分析题\" class=\"headerlink\" title=\"分析题\"></a>分析题</h3><p><strong>详述说明 RPC 框架中每个部分的功能</strong></p>\n<ul>\n<li>RPC架构主要包括三部分：</li>\n</ul>\n<ol>\n<li>服务注册中心：负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。  服务提供者，提供服务接口定义与服务实现类。  </li>\n<li>服务消费者：通过远程代理对象调用远程服务。  </li>\n<li>服务提供者：启动后主动向服务注册中心Registry)注册机器 IP、端口以及提供的服务列表：  服务消费者启动时向服务注册中心(Registry)获取服务提供方地址列表。  </li>\n<li>服务注册中心(Registry)可实现负载均衡和故障切换。</li>\n</ol>\n","text":"软件中间件选择题（均是多选）1、完整实现 EJB 规范的产品有（ BC ）。A、SpringB、GlassFishC、TomeeD、MyBatis 2、Spri...","permalink":"/post/temp_软件中间件","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"考试","slug":"考试","count":5,"path":"api/categories/考试.json"}],"tags":[{"name":"考试","slug":"考试","count":5,"path":"api/tags/考试.json"},{"name":"软件中间件","slug":"软件中间件","count":1,"path":"api/tags/软件中间件.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">软件中间件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%88%E5%9D%87%E6%98%AF%E5%A4%9A%E9%80%89%EF%BC%89\"><span class=\"toc-text\">选择题（均是多选）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A1%AB%E7%A9%BA%E9%A2%98\"><span class=\"toc-text\">填空题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E7%AD%94\"><span class=\"toc-text\">简答</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%BB%BC%E5%90%88%E9%A2%98\"><span class=\"toc-text\">程序综合题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E9%A2%98\"><span class=\"toc-text\">分析题</span></a></li></ol></li></ol></li></ol>","author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++_面向对象反汇编补充","uid":"e614b361765c5cfea11849494ca08809","slug":"1_C++_面向对象反汇编补充_08","date":"2022-10-06T07:28:25.917Z","updated":"2023-01-10T01:10:19.448Z","comments":true,"path":"api/articles/1_C++_面向对象反汇编补充_08.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (8).webp","text":"C++_面向对象反汇编补充[toc] 1. 类1.1 类的定义 C++中可以使用 struct，class来定义类 1.2 struct和class区别 str...","permalink":"/post/1_C++_面向对象反汇编补充_08","photos":[],"count_time":{"symbolsCount":"82k","symbolsTime":"1:15"},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"Assemly","slug":"Assemly","count":2,"path":"api/tags/Assemly.json"},{"name":"C/C++","slug":"C-C","count":10,"path":"api/tags/C-C.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"UE4_UE5源码编译及发布LinuxServer","uid":"f9596c511588d1107b8c7f2d14ce64a6","slug":"7_UE4_UE5源码编译及发布LinuxServer_10","date":"2023-01-11T02:01:11.553Z","updated":"2023-01-11T02:00:37.308Z","comments":true,"path":"api/articles/7_UE4_UE5源码编译及发布LinuxServer_10.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/FHangH/FHangBlogCDN_03@master/Aurora_ (30).webp","text":"UE4&#x2F;UE5 发布LinuxServer12023-01-11 更新了UE5.1源码编译以及打包 LinuxServer的内容 [toc] 情景内容...","permalink":"/post/7_UE4_UE5源码编译及发布LinuxServer_10","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":12,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UnrealEngine","slug":"UnrealEngine","count":12,"path":"api/tags/UnrealEngine.json"}],"author":{"name":"FangH","slug":"blog-author","avatar":"/img/fh.png","link":"/","description":"我曾惊鸿一瞥未来","socials":{"github":"https://github.com/FHangH","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zi-heng-18-99-47","csdn":"https://blog.csdn.net/weixin_44519692?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}