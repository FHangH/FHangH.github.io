[{"id":"9627196902f31a421d62461264dcdecc","title":"C++总结","content":"C++面试1. 线程和进程的区别\n线程和进程是操作系统中的两个基本概念。\n\n线程是进程的一部分，它是操作系统调度的基本单位，而进程是一个具有一定独立功能的程序关于某个数据集合上的一次运行活动。\n\n线程比进程更小，它可以更快地响应，并且更容易被操作系统调度。\n\n线程可以共享进程的资源，如内存，文件句柄等，而进程之间不能共享资源。\n\n此外，线程的上下文切换比进程的上下文切换更快，因为线程的上下文切换只需要保存和恢复少量的寄存器内容，而进程的上下文切换需要保存和恢复大量的内存内容。\n\n\n2. 进程间通信方式\n管道( pipe )\n有名管道 (named pipe)\n信号量( semophore )\n消息队列( message queue )\n信号 ( signal )\n套接字( socket )\n\n3. 线程间通信方式\n事件(Event); \n信号量(semaphore); \n互斥量(mutex); \n临界区(Critical section)\n\n4. 什么时候用进程或线程\n在多任务系统中，进程和线程都可以用来实现并发执行。\n进程是一个独立的执行单元，它有自己的内存空间和资源，可以被操作系统调度执行。\n而线程是进程的一个执行单元，它可以共享进程的资源，但是比进程更小，更轻量，可以更快地被操作系统调度执行。\n一般来说，如果需要多任务处理，可以使用进程；如果需要多线程处理，可以使用线程。此外，进程和线程也可以用来实现并发IO，以提高系统的性能。\n\n5. 栈和堆的区别栈（stack）: \n\n它由编译器自动管理，无需我 们手工控制\n1M大小\n计算机会在底层对栈提供支持：分配专门的寄存器存放 栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。但程序员无法对其进行控制。\n\n堆（heap）: \n\n申请和释放由程序员控制\n32 位系统下，堆内存可以达到 4G 的空间\n由 new 或 malloc 分配的内存，一般速度比较慢，而且容易产生内 存碎片\n\n6. C++和 C 的区别C 是一个结构化语言，它的重点在于算法和数据结构。\nC++中引入了重 载、内联函数、异常处理等。C++更是拓展了面向对象设计的内容，如类、继承、虚函数、模板和包容器类 等。\n7. 产生死锁的必要条件\n互斥条件：一个进程对共享资源的排他性使用，即一个资源在一段时间内只能被一个进程使用\n请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有\n不剥夺条件：进程已经获得的资源在未使用完之前，不能被其他进程强行剥夺，只有在资源使用完之后才能被释放\n循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系\n\n8. 预防死锁\n避免死锁：可以通过研究系统资源分配图来避免死锁，即在分配资源之前先检查是否会发生死锁。\n预防死锁：可以通过设置资源分配次序来预防死锁，即按照一定的顺序分配资源，以避免出现死锁。\n检测死锁：可以通过定期检测系统中是否存在死锁来及时发现死锁，并采取相应的措施来解决。\n解除死锁：可以通过撤销进程或释放资源来解除死锁，以便让系统恢复正常运行。\n\n9. TCP 和 UDP 的区别TCP（传输控制协议）\n\n是一种面向连接的、可靠的、基于字节流的传输层通信协议。\n它主要用于在两台计算机之间传输数据，并且能够确保数据的正确传输。\n它可以提供可靠的、有序的、双向的数据流，以及可靠的数据传输服务。\n它是一种面向连接的协议，因此在传输数据之前，它需要建立一个连接。\n它使用三次握手确认连接，然后才能传输数据。它还提供了流量控制、拥塞控制和可靠性等功能。\n\nTCP三次握手：\n\n客户端发送一个SYN（synchronize）信号给服务器\n服务器收到后，回复一个SYN&#x2F;ACK（synchronize-acknowledge）信号\n客户端收到后，再回复一个ACK（acknowledge）信号，这样就完成了一次三次握手\n\nTCP四次挥手：\n\n客户端发送一个FIN（finish）信号给服务器\n服务器收到后，回复一个ACK（acknowledge）信号\n客户端收到后，再发送一个FIN\n服务器收到后，回复一个ACK，这样就完成了一次四次挥手\n\n UDP\n\n是一种无连接的传输层协议，它不需要建立连接就可以发送数据，可以提供非常快速的数据传输。\n它提供了不可靠的服务，因为它不能保证数据的完整性和可靠性，但是它可以提供高速的数据传输。\n\n10. static 关键字静态变量：\n\n是在程序的整个生命周期中只存在一份拷贝，它的值在程序的整个生命周期中保持不变。它可以被所有函数所访问，在程序结束时才被释放。\n\n静态变量和函数是指在程序的整个生命周期内都存在的变量和函数。\n\n静态变量和函数可以在程序的任何地方被调用，而不必担心它们被重新定义或重新声明。\n\n静态变量和函数可以用来存储和访问全局变量，这些变量可以在程序的任何地方被访问。\n\n此外，静态变量和函数可以用来提供程序的私有函数，这些函数只能在程序的特定位置被调用。\n\n\n11. const 关键字\nconst 关键字用于声明常量，即只读变量，它的值一旦被赋值，就不能再改变。\nconst 关键字还可以用于修饰指针，以保证指针所指向的内容不被修改。\n在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值\n对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的 成员变量\n对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”\n\n12. 指针和引用的区别指针和引用都可以用来指向变量或者对象\n\n指针是一个变量，可以在程序中被赋值和改变，而引用是一个别名，它的值不能被改变。\n指针可以指向不同的对象，而引用只能指向它初始化时指定的对象。\n指针可以为空，而引用不能为空。\n指针可以在函数间传递，而引用不能。\n\n13. 哈希表哈希表（Hash Table）是一种数据结构，它将键映射到值，使得查找和插入操作的时间复杂度都是O(1)。它的基本思想是：通过计算一个关键字的哈希值，可以直接定位到相关联的值，从而提高查找效率。\n14. 哈希表处理冲突链地址法：是指把所有的冲突关键字存储在一个线性链表中，这个链表由其散列地址唯一标识\n开放定址法：指可存放新表项的空闲地址，既向它的同义词表项开放，又向它的非同义词表项开放\n再散列法：利用另一个哈希函数再次计算一个地址。直到冲突不再发生\n建立一个公共溢出区：一旦由哈希函数得到的地址冲突，就都填入溢出表\n15. 面向对象的三大特性和五个原则C++面向对象的三大特性：\n\n封装、继承和多态。这三个特性共同构成了面向对象编程的基础。\n\nC++面向对象的五个原则是：\n\n单一职责原则：每个类只负责一项职责\n开放封闭原则：软件实体应该可以扩展，但不可修改\n里氏替换原则：子类可以替换父类\n依赖倒置原则：程序依赖抽象而不是具体实现\n接口隔离原则：接口应该尽量小，只包含客户端需要的方法\n\nC++多态基于虚函数和虚继承实现：\n\n用一个更通用的基类指针指向 不同的子类实例\n为了能调用正确的方法，我们需要用到虚函数和虚继承。\n在内存中，通过虚函数表来实 现子类方法的正确调用；\n通过虚基类指针，仅保留一份基类的内存结构，避免冲突。\n\n16. 深拷贝和浅拷贝\n浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间\n\n深拷贝不但对指针进行拷贝， 而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。\n\n\n17. vector 的实现原理\nvector的实现原理是基于动态数组的，它可以自动调整大小，以适应不断变化的数据量。\n它使用一个连续的内存空间来存储元素，并且可以在不重新分配内存的情况下添加或删除元素。\n它的实现原理是：\n当添加元素时，vector会检查它的容量，如果容量不足，它会自动重新分配内存，以容纳新元素；\n当删除元素时，vector会自动调整它的容量，以释放多余的内存空间。\n\n\n\n​\t\n18. C++ 源代码到可执行代码的详细过程编译：将高级语言指令转换为功能等效 的汇编代码，再由汇编程序转换为机器语言，并且按照操作系统对可执行文件格式的要求链接生成可执行 程序\n源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接–&gt;可执行文件\n\n预处理：将源代码中的宏定义和条件编译指令处理成可供编译器处理的形式，使用预处理器（如cpp）将源代码中的宏定义和条件编译指令处理成可供编译器处理的形式。\n编译：将预处理后的源代码编译成汇编代码，使用编译器（如GCC）将源代码编译为汇编代码，汇编代码是机器可以识别的代码。\n优化：对汇编代码进行优化，使用优化器（如GCC）对汇编代码进行优化，以提高程序的执行效率。\n汇编：将优化后的汇编代码翻译成机器代码，使用汇编器（如GAS）将汇编代码翻译成机器代码，机器代码是机器可以直接执行的代码。\n链接：将多个机器代码文件链接成可执行文件，使用链接器（如LD）将多个机器代码文件链接成可执行文件，可执行文件是机器可以直接运行的文件。\n\n19. 虚函数和纯虚函数的区别虚函数：\n\n虚函数为了重载和多态的需要，在基类中定义的，即便定义为空；纯虚函数是在基类中声明 的虚函数，它可以再基类中有定义，且派生类必须定义自己的实现方法\n\n一旦父类的成员函数声明 virtual，其子类的函数不管有没有声明为 virtual，都是虚函数\n\n基类定义虚函数（可以实现，也可以不实现）\n\n子类（可以重载和不重载）\n\n\n纯虚函数：\n\n是基类只定义了函数体，没有实现过程（类似接口）\n纯虚必须在子类去实现\n\n普通函数如果不被使用，可以只有声明没有定义，虚函数必须要有定义，即使是一个空实现,因为编译 器无法确定会使用哪个函数\n20. overload,override,overwrite 的区别Overload(重载)：在 C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载\n\n（1）相同的范围（在同一个类中）； \n（2）函数名字相同；\n（3）参数不同； \n（4）virtual 关键字可有可无。\n\nOverride(覆盖)：是指派生类函数覆盖基类函数，特征是： \n\n（1）不同的范围（分别位于派生类与基类）； \n（2）函数名字相同； \n（3）参数相同； \n（4）基类函数必须有 virtual 关键字\n\nOverwrite(重写)：是指派生类的函数屏蔽了与其同名的基类函数，规则如下： \n\n（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字， 基类的函数将被隐藏。 \n（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关 键字。此时，基类的函数被隐藏。\n\n21. 强制类型转换\nstatic_cast：用于基本类型之间的转换，可以安全地执行数据类型转换。\na、用于类层次结构中基类和派生类之间指针或引用的转换 上行转换（派生类—-&gt;基类）是安全的； 下行转换（基类—-&gt;派生类）由于没有动态类型检查，所以是不安全的。 \nb、用于基本数据类型之间的转换，如把 int 转换为 char，这种带来安全性问题由程序员来保证 \nc、把空指针转换成目标类型的空指针 \nd、把任何类型的表达式转为 void 类型\n\n\nconst_cast：用于去除常量属性，可以把常量转换成非常量。\nreinterpret_cast：用于指针和引用之间的转换，可以把指针和引用转换成其他指针和引用类型。\ndynamic_cast：用于多态类型之间的转换，可以把多态类型转换成其他多态类型。\n\n22. malloc&#x2F;free，new&#x2F;delete\nmalloc&#x2F;free是C语言中的内存分配函数，它们只能用于分配和释放内存，不能调用构造函数和析构函数，因此不能用于管理类对象\nnew&#x2F;delete是C++语言中的内存分配函数，它们不仅可以用于分配和释放内存，还可以调用构造函数和析构函数，因此可以用于管理类对象。\n\n对于非内部数据类型的对象而言，对象的消亡之前要自动执行析构函数。由于 malloc&#x2F;free 是库函数 而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于 malloc&#x2F;free，因 此只有使用 new&#x2F;delete 运算符\n23.  c++11 特性nullptr\n\n传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些 编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0\nC++ 不允许直接将 void * 隐式转换到其他类型，但如果 NULL 被定义为 ((void*)0)，那么当编译char *ch = NULL;时，NULL 只好被定义为 0，而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱\nvoid foo(char *)\nvoid foo(int)\n\n\nNULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)， 从而导致代码违反直观\nnullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等 或者不等的比较\n\nChatGPT:\n\nnullptr 和 NULL 是C++中的两个特殊值，它们都表示空指针，但是它们之间有一些重要的区别：\nnullptr 是一个特殊的指针类型，它可以被用来表示任何类型的指针，而 NULL 只能表示原始指针类型。\nnullptr 是一个新的C++11特性，而 NULL 是C++98中的一个宏定义，它可以被用来表示空指针。\nnullptr 可以被用来调用重载函数，而 NULL 不能。\nnullptr 可以被用来初始化指针，而 NULL 不能。\n\n\n\nauto\n\nauto 是C++11中的一个关键字，它可以被用来自动推断变量的类型，从而简化程序的书写。它的主要用途有：\n简化变量的声明：使用auto可以更简单地声明变量，而不必指定变量的类型，从而简化程序的书写。\n提高代码的可读性：使用auto可以更有效地表达变量的意图，从而提高代码的可读性。\n更有效地使用模板：使用auto可以更有效地使用模板，从而提高代码的可读性和可维护性。\n\n\n\nC++11 还引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：\n12345template&lt;typename T, typename U&gt;auto add(T x, U y) -&gt; decltype(x+y) &#123;\treturn x+y;&#125;\n\nC++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：\n12345template&lt;typename T, typename U&gt;auto add(T x, U y) &#123;    return x+y;&#125;\n\n\n\n区间迭代\n12345// &amp; 启用了引用for(auto &amp;i : arr) &#123;\tstd::cout &lt;&lt; i &lt;&lt; std::endl;&#125;\n\n\n使用&amp;i可以更有效地处理数组中的每一个元素，因为它可以直接引用数组中的元素，而不必创建新的变量来存储数组中的元素，从而提高程序的性能\n使用const auto &amp;i可以保证数组中的每一个元素在循环中不会被修改，从而提高程序的可读性和可维护性。但是，使用const auto &amp;i会使程序的性能略有下降，因为它会多消耗一些内存。\n因为它会多消耗一些内存，因为它会创建一个新的变量来存储数组中的元素，而不是直接引用数组中的元素，从而消耗更多的内存。\n\n模板增强\n**外部模板 **\n\n传统 C++ 中，模板只有在使用时才会被编译器实例化，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时 间的增加。没有办法通知编译器不要触发模板实例化\n\nC++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能 够显式的告诉编译器何时进行模板的实例化：\n\n\n12template class std::vector; // 强行实例化 extern template class std::vector; // 不在该编译文件中实例化模板\n\n\n\n类型别名模板\n\n在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。 因为，模板不是类型\n12template&lt; typename U&gt;typedef SuckType&lt;std::vector&lt;int&gt;, U, 1&gt; NewType; // 不合法\n\nC++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效： \n1template  using NewType = SuckType; // 合法\n\n默认模板参数\n\nC++11 中提供了一种便利，可以指定模板的默认参数：\n12345template&lt;typename T = int, typename U = int&gt;auto add(T x, U y) -&gt; decltype(x+y) // C++ 11中， C++14 直接写成：auto add(T x, U y)即可&#123;\treturn x+y;&#125;\n\n构造函数\n委托构造\n\nC++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数， 从而达到简化代码的目的：\n1234567891011121314class Base &#123;public:\tint value1;\tint value2;\tBase() \t&#123;\t\tvalue1 = 1;\t&#125;\tBase(int value) : Base() \t&#123; // 委托 Base() 构造函数\t\tvalue2 = 2;\t&#125;&#125;;\n\n继承构造\n\n派生类想要使用基类的构造函数，需要在构造函数中显式声明\n\nC++11中：如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类 各种构造函数更加节省目标代码空间\n1234567891011121314C++11 的继承构造：struct A&#123; \tA(int i) &#123;&#125; \tA(double d,int i)&#123;&#125; \tA(float f,int i,const char* c)&#123;&#125; \t//...等等系列的构造函数版本&#125;;struct B:A&#123; \tusing A::A; \t//关于基类各构造函数的继承一句话搞定 \t//......&#125;;\n\nLambda 表达式\n\n实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一 个函数，但是又不想费力去命名一个函数的情况下去使用的\n1234[ caputrue ] ( parameters ) options -&gt; returnType&#123;    body; &#125;;\n\ncapture 是可选的，用于捕获外部变量；\n\nparameters 是可选的，用于接收参数；\n\nreturnType 是可选的，用于指定返回值类型；\n\nbody 是必需的，用于定义 lambda 表达式的函数体。\n\noptions 是函数选项；可以填 mutable,exception,attribute（选填） :\n\nmutable 说明 lambda 表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的 non-const 方法。\nexception 说明 lambda 表达式是否抛出异常以及何种异常。\nattribute 用来声明属性。\n\n\n\n捕获列表\n\nlambda 表达式的捕获列表精细控制了 lambda 表达式能够访问的外部变量，以 及如何访问这些变量\n\n[]不捕获任何变量\n捕获外部变量：可以使用 &amp; 或 = 来捕获外部变量。(按值捕获)且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷 贝\n捕获 this 指针：可以使用 this 来捕获 this 指针。捕获 this 的目的是可以在 lamda 中使 用当前类的成员函数和成员变量\n捕获外部类成员：可以使用 &amp; 来捕获外部类成员。\n[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。\n[bar]按值捕获 bar 变量，同时不捕获其他变量。\n\n\n如果希望去修改按值捕获的外部变量，需 要显示指明 lambda 表达式为 mutable。被 mutable 修饰的 lambda 表达式就算没有参数也要写 明参数列表\n\n捕获列表捕获住 的任何外部变量，最终会变为闭包类型的成员变量，按照 C++标准，lambda 表达式的operator() 默认是 const 的，而 mutable 的作用，就在 于取消 operator()的 const\n123int a = 0;auto f1 = [=] &#123; return a++; &#125;; //errorauto f2 = [=] () mutable &#123; return a++; &#125;; //OK\n\nLambda原理：\n\n定义一个 lambda 表达式后，编译器会自动生成一个匿 名类（这个类重载了()运算符），我们称为闭包类型\n运行时，这个 lambda 表达式就会返回一个匿名的闭包实例，是一个右值\n对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成 员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包\n引用捕获方式，无论 是否标记 mutable，都可以在 lambda 表达式中修改捕获的值\n\n\nlambda 表达式是不能被赋值的:\n1234auto a = [] &#123; cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125;;auto b = [] &#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125;;a = b; // 非法，lambda 无法赋值zauto c = a; // 合法，生成一个副本\n\n闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以用一个 lambda 表达式去初 始化另外一个 lambda 表达式而产生副本\n\n悬挂引用：引用捕获不会 延长引用的变量的生命周期\n12345std::function&lt;int(int)&gt; add_x(int x)&#123; return [&amp;](int a) &#123; return x + a; &#125;;&#125;// 参数 x 仅是一个临时变量，函数 add_x 调用后就被销毁了，但是返回的 lambda 表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果\n\nLambda函数指针：\n\nSTL 定义在&lt; functional &gt;头文件提供了一个多态的函数对象封装 std::function，其类似于函数指针。它可以绑定任何 类函数对象，只要参数与返回类型相同\n1std::function&lt;bool(int, int)&gt; wrapper = [](int x, int y) &#123; return x &lt; y; &#125;;\n\n重要应用：作为参数传递，实现函数回调\n\n最常用的是在 STL 算法中：count_if()，generate()，for_each()\n\n\n\n\n新增容器\nstd::array\n\n保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从 而获得更高的性能\n\n在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array 只需指定其类型和大小即可\n123std::array&lt;int, 4&gt; arr= &#123;1,2,3,4&#125;;int len = 4;std::array&lt;int, len&gt; arr = &#123;1,2,3,4&#125;; // 非法, 数组大小参数必须是常量表达式\n\nstd::forward_list\n\nstd::list是双向链表\nstd::forward_list是单向链表\n提供了 O(1) 复杂度 的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法 的容器\n不需要双向迭代时，具有比 std::list 更高的空间利用率\n\n无序容器\n包括 unordered_set、unordered_map、unordered_multiset 和 unordered_multimap\n特点：\n\n它们使用哈希函数来存储元素，而不是使用比较函数。\n它们提供了更快的查找性能，因为它们可以在常数时间内查找元素。\n它们支持更快的插入和删除操作，因为它们不需要移动元素来维护有序性。\n\n元组 std::tuple\n三个核心的函数：\n\nstd::make_tuple: 构造元组 \nstd::get: 获得元组某个位置的值 \nstd::tie: 元组拆包\n\n合并两个元组，可以通过 std::tuple_cat:\n1auto new_tuple = std::tuple_cat(get_student(1), std::move(t));\n\n\n\n语言级线程支持\n代码编译需要使用 -pthread 选项\n\nstd::thread 类，用于创建和控制线程。\nstd::mutex 类，用于控制线程之间的互斥访问。\nstd::condition_variable 类，用于实现线程间的同步。\nstd::future 类，用于获取异步操作的结果。\nstd::atomic 类，用于实现原子操作。\n\n线程同步：\n12345678910111213141516171819202122#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::mutex m;std::condition_variable cv;void thread_func()&#123;    std::unique_lock&lt;std::mutex&gt; lock(m);    cv.wait(lock);    // Do something&#125;int main()&#123;    std::thread t(thread_func);    // Do something    cv.notify_one();    t.join();    return 0;&#125;\n\n\n\n右值引用和 move 语义\n右值引用\n通过重载直接使用右值参数。 我们所要做的就是写一个以右值引用为参数的构造函数：\n12345string(string&amp;&amp; that) // string&amp;&amp; is an rvalue reference to a string&#123;\tdata = that.data;\tthat.data = 0;&#125;\n\n没有深度拷贝堆内存的数据，而是复制了指针，并把源对象的指针置空\n由于源对象是一个右值，不会再被使用，因此 客户并不会觉察到源对象被改变了转移构造函数\n类别：\n\nvar&amp;：左值引用\nvar&amp;&amp;：右值引用\n\n示例：\n\nC++ 11 中，std::auto_ptr&lt; T &gt;已经被 std::unique_ptr&lt; T &gt;所取代，后者就是利用的右值引用\n\n其转移构造函数：\n123456789unique_ptr(unique_ptr&amp;&amp; source) // note the rvalue reference&#123; \tptr = source.ptr; \tsource.ptr = nullptr;&#125;unique_ptr&lt;Shape&gt; a(new Triangle);unique_ptr&lt;Shape&gt; b(a); // errorunique_ptr&lt;Shape&gt; c(make_triangle()); // okay\n\n第二行不能编译通过，因为 a 是左值，但是参数 unique_ptr&amp;&amp; source 只能接受右值，这正是我们所 需要的，杜绝危险的隐式转移\n\n\n转移左值\n123unique_ptr&lt;Shape&gt; a(new Triangle);unique_ptr&lt;Shape&gt; b(a); // still an errorunique_ptr&lt;Shape&gt; c(std::move(a)); // okay\n\n\nstd::move 仅仅是简单地将左值转换为 右值，它本身并没有转移任何东西。它仅仅是让对象可以转移\n注意：第三行之后，a 不再拥有 Triangle 对象。不过这没有关系，因为通过明确的写 出 std::move(a)，我们很清楚我们的意图\n\n24. STL resize与reserveresize() 和 reserve() 都是用于管理容器大小的函数，但它们的作用不同\n\nresize() \n用于更改容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器 内的对象了\nresize 函数可以有两个参数，第一个参数是容器新的大小，第二个参数是要加入容器 中的新元素，如果这个参数被省略，那么就调用元素对象的默认构造函数\n\n\nreserve() \n用于预留容器的存储空间间，但并不真正创建元素对象，在创建对象之前，不能引用容器内 的元素\nreserve 函数之后一个参数，即需要预留的容器的空间\n\n\n\n25. vector与dequevector\nvector是动态容器，随着内容的添加，容器大小会在内部自行扩容，相较于array，array是静态空间，扩容的需要自行扩容\nvector 的数据结构：\n\n线性线性空间。它以两个迭代器 start 和 finish 分别指向配置得 来的连续空间中目前已经被使用的范围，并以迭代器 end_of_storage 指向整块连续空间的尾端\n\nvector 的构造与内存管理：\n\n插入元素时，如果空间不够，会另开辟一块更大的空间，让容器迭代器指向新的空间\n\ndeque\ndeque 是一种双向开口的连续线性空间（双端队列）。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删 除操作\ndeque 的中控器：\n\ndeque是由一段一段的定量连续空间构成，一旦有必要在 deque 的前端或尾端增加新空间，便配置一段 定量连续空间，串接在整个 deque 的头端或尾端\ndeque便是在这些分段的定量连续空间上， 维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价则是复 杂的迭代器架构\ndeque 采用一块所谓的 map(注意,不是 STL 的 map 容器)作为主控。这里所谓 map 是一小块连续空间 ， 其中每个元素(此处称为一个节点, node)都是指针，指向另一段(较大的) 连续线性空间，称为缓冲区。缓 冲区才是 deque 的存储空间主体\n\ndeque 的构造与内存管理：\n\n果申请的 map 空间不够时，也需要重新配置更大的空间，将原来 map 里的指针拷贝过来，最后释放 原来的空间\n\nvector 和 deque 的区别：\n\nvector 是单向开口的连续线性空间， dequeu 是一种双向开口的连续线性定\ndeque 允许于常数时间内对起头端进行元素的插入或移除操作\ndeque 没有所谓容量(capacity)观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新 的空间并链接起来\n\n26. 大端小端示例：\n\n值：123456\n地址：从右往左（默认） 或 从下往上（地址由小增大）\n\n大端：654321\n小端：123456\n12345678910int checkCPU()&#123; \tunion w \t&#123; \t\tint a; \t\tchar b; \t&#125;c; \tc.a = 1; \treturn (c.b == 1);//小端返回 1，大端返回 0&#125;\n\n\n\n27. malloc 原理堆的介绍：\n\n堆块由一个字的头部、有效载荷、填充以及一个字的脚部组成，空闲块是通过头部中的大小 字段隐含地连接在一起形成一个隐式空闲链表，分配器可以通过遍历堆中所有的块，从而间接遍历整个空 闲块的集合\n\nmalloc()步骤：\n\n放置、分割、合并\n\n放置\n用请求一个 k 字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲 块，分配器执行这种搜索的方式是放置策略确定的\n常见的策略：\n\n首次适配：从头开始搜索空闲链表，选择第一个适合的空闲块。 \n下一次适配：从上一次查询结束的地方开始搜索空闲链表，选择第一个适合的空闲块。 \n最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。\n\n分割\n一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空块中多少空间。 一个选择是用整个空闲块，另一个选择是将这个空闲块分割成两部分\n果分配器不能为请求块找到合适的空闲块将发生什么：\n\n选择是通过合并那些在内存中物理上相邻 的空闲块来创建一些更大的空闲块\n还是不能生成一个足够大的块，或者如果空闲块已经 最大程度地合并了，那么分配器就会通过调用 sbrk 函数，向内核请求额外的堆内存，分配器将额外的内存 转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中\n\n合并\n边界标记：允许在常数时间内进行对前面的块合并\n\n每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本\n如果每个块包括这样一个脚部， 那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态\n这个脚部总是在当前块开始位 置一个字的距离\n\n28. 构造、析构函数的虚函数构造函数不能声明为虚函数：\n\n构造一个对象，必须知道对象的类型\n当对象还没有构造完成时，编译器无法确定对象是类本身，还是派生类\n虚函数的执行依赖于虚函数表，虚函数表在构造函数中完成，如果构造函数声明为虚函数，调用构造函数时，虚函数表没有初始化，构造将无法进行\n\n析构函数可以：\n\n调用析构函数时，对象已经确定，虚函数表也已经存在，可以正常使用\n在类的继承中，基类指针指向子类对象，基类delete，析构函数如果不是虚函数，子类对象不会执行析构函数\n析构时，先从最下面的子类开始逐层向父类析构\n\n29. STL unordered_map 和 mapunordered_map：\n\n键值对形式\nhashMap\n无序存储\n不存重复的键\n\nhash_map 与 unordered_map\n\nunordered_map 在 C++11 的时候被引入标准库\n\n查询平均时间是 O(1)，unordered，就是无序了，数据是按散列函数 插入到槽里面去的，数据之间无顺序可言\n\n有些时候我只要访问而不需要顺序，因此可以选择哈希表\n\n\nunordered_map 与 map\n\nmap 的内部结构是 R-B-tree 来实现的，所以保证了一个稳定的动态操作时间，查询、插入、删除都是 O（logn），最坏和平均都是\n是并不是 unordered_map 查询时间一定比 map 短，因为实际情况中还要考虑到数据量\nunordered_map 的 hash 函数的构造速度也没那么快\n\nunordered_map 与 unordered_set\n\nunordered_set：value 就是它自己的 key，而不是像之前的 unordered_map 那样 有键-值对\n\n题目：\n\nA,B 两组数， 由整数组成，然后把 B 中在 A 中出现的数字取出来，要求用线性时间完成，用 unordered_set 来存放 A 的数\n\n分析：\n\n可以使用 unordered_set 来存放 A 中的数字，然后遍历 B 中的每个数字，判断它是否在 A 中出现过。由于 unordered_set 的查找操作是平均 O(1) 时间复杂度的，所以整个算法的时间复杂度是线性的\n\n代码：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;std::vector&lt;int&gt; find_common_elements(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B) &#123;    std::unordered_set&lt;int&gt; setA(A.begin(), A.end());  // 将 A 中的数字存入 unordered_set    std::vector&lt;int&gt; result;  // 存放结果的 vector    for (auto num : B)     &#123;        if (setA.count(num) &gt; 0)         &#123;  // 如果 num 在 setA 中出现过，说明它在 A 中也出现过            result.push_back(num);  // 将 num 加入结果 vector        &#125;    &#125;    return result;&#125;int main() &#123;    std::vector&lt;int&gt; A = &#123;1, 2, 3, 4, 5&#125;;    std::vector&lt;int&gt; B = &#123;3, 4, 5, 6, 7&#125;;    std::vector&lt;int&gt; result = find_common_elements(A, B);    // 输出结果：[3, 4, 5]    for (auto num : result)     &#123;        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\n\n\n\n30. C&#x2F;C++中 externextern 用于在一个文件中引用在另一个文件中定义的全局变量或函数\nextern 声明的变量或函数只是一个声明，而不是定义。这意味着在当前文件或函数中使用\nextern 声明的变量或函数时，编译器不会为其分配内存空间或生成代码。相反，编译器会在链接时查找该变量或函数的定义，并将其与声明进行匹配。\nextern 修饰变量的声明\n\n如果文件 a.c 需要引用 b.c 中变量 int v，就可 以在 a.c 中声明 extern int v，然后就可以引用变量 v\n\nextern 修饰函数声明\n\n从本质上来讲，变量和函数没有区别。函数名是指向函数二进 制块开头处的指针\n文件 a.c 需要引用 b.c 中的函数，比如在 b.c 中原型是 int fun(int mu)，那么就可以在 a.c 中声明 extern int fun（int mu），然后就能使用 fun 来做任何事情\n\n使用 extern 和包含头文件来引用函数有什么区别\n\nextern 的引用方式比包含头文件要简洁得多\n加速程序的编译（确切的说是预处理）的过程，节省时间\n\nextern 修饰符可用于指示 C 或者 C++函数的调用规范\n\n在 C++中调用 C 库 函数，就需要在 C++程序中用 extern “C”声明要引用的函数\n\n这是给链接器用的，告诉链接 器在链接的时候用 C 函数规范来链接\n\n主要原因是 C++和 C 程序编译完成后在目标代码中命名 规则不同\n\n示例：\n\n我们要在C++中包含一个名为 example.h 的C头文件\n\nexample.h\n123456789#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* C语言代码 */#ifdef __cplusplus&#125;#endif\n\nindex.cpp\n1#include &quot;example.h&quot;\n\n\n\n31.  C++类的四个缺省函数\n默认构造函数\n拷贝构造函数\n析构函数\n赋值函数\n\n32. 重写拷贝构造函数当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝\n示例：\n123456789101112131415161718192021222324252627282930313233#include &lt;cstring&gt;class MyClass &#123;public:    // 构造函数    MyClass(int size)     &#123;        // 分配内存        m_size = size;        m_data = new int[m_size];    &#125;    // 拷贝构造函数    MyClass(const MyClass&amp; other)     &#123;        // 复制成员变量        m_size = other.m_size;        m_data = new int[m_size];        std::memcpy(m_data, other.m_data, m_size * sizeof(int));    &#125;    // 析构函数    ~MyClass()     &#123;        // 释放内存        delete[] m_data;    &#125;private:    int m_size;    int* m_data;&#125;;\n\n解释：\n\n拷贝构造函数的参数是一个 const MyClass&amp; 类型的引用，这意味着它接受一个常量引用。\n在拷贝构造函数中，我们创建一个新的对象，并将其成员变量设置为与另一个对象相同的值。\n对于指向动态内存分配的指针成员变量 m_data，我们使用 new 运算符为它分配新的内存，并使用 std::memcpy 函数将原始数据复制到新的内存中。\n这确保了新对象和原对象的指针成员变量都指向不同的内存地址，从而实现了深拷贝。最后，在析构函数中，我们释放了 m_data 指向的内存\n\n注意：\n\n如果类中有其他指针成员变量，也需要在拷贝构造函数中进行深拷贝，以确保新对象和原对象的指针成员变量都指向不同的内存地址\n\n33. 调用拷贝构造函数\n创建对象时\n当类的一个对象去初始化该类的另一个对象时\n如果函数的形参是类的对象，调用函数进行形参和实参结合时\n如果函数的返回值是类对象，函数调用完成返回时\n\n34. 构造函数的特征\n专门用来初始化对象成员变量的\n构造函数的名字必须与类名相同\n它不具有任何类型\n不返回任何值\n\n35. 类外访问类非公有成员\n友元\n继承\n公有成员函数\n父类 protected\n\n36. 不允许重载的运算符*（成员指针访问运算符号）\n::域运算符\nsizeof 长度运算符号\n?条件运算符号\n.（成员访问符）\n","slug":"temp_C++总结","date":"2023-03-21T11:39:12.197Z","categories_index":"C++","tags_index":"C++","author_index":"FangH"},{"id":"969a273c20a676d026ced13f1dc7c160","title":"软件中间件","content":"软件中间件选择题（均是多选）1、完整实现 EJB 规范的产品有（ BC ）。A、SpringB、GlassFishC、TomeeD、MyBatis\n2、Spring中用于处理 HTTP 方法的资源注解是（ ACD ）。A、@PostMappingB、@IDC、@RequestBodyD、@PatchMapping\n3、Java NIO 中，下列哪个可供选择器监控的通道 IO 事件类型：（ A ）。A、SelectionKey.OP_READB、SelectionKey.DENYC、SelectionKey.CONNECTD、SelectionKey.WRITE\n4、Java 反射机制 API 的关键类是（C）A、java.lang.ObjectB、java.lang.reflect.MethodC、java.lang.ClassD、java.lang.reflect.Constructor\n5、下列那些字段可以使得 HTTP GET 请求就具体化为条件获取（ C ）。A、If-Recive-SinceB、If-Unmodified-ContentC、If-MatchD、If-Match-Date\n6、Java Servlet 中用于声明一个类为 Servlet 的注解是（ A）。A、@WebServletC、@GetB、@ControllerD、@Post\n7、 HTML DOM 模型中，获取网页中元素的方法有（ ABCD）。A、getElementById()B、getElementsByName()C、getElementByclassName()D、getElementByTagName()\n8、下列属于 Java 通道类型的是（ BD）。A、ServerBootstrapB、NioSocketChannelC、NioEventLoopD、AsynchronousSocketChannel\n9、 在 HTTP 响应消息中，下列哪种状态码可以表示请求资源状态未改变（D ）。A、302B、204C、102D、304\n10、下列说法正确的是（ A ）。A、HTTP&#x2F;2.0 的消息的以二进制数据进行传输的，结构比复杂。B、SOAP 协议的依托协议是 HTTP&#x2F;2。C、Netty 不能采用阻塞方式工作。D、gRPC 协议是明文的，在消息传递过程中，结构比较简单。\n11、属于消息中间件产品的是（ AB）。A、ActiveMQB、RocketMQC、Dubbo3D、MyBatis\n12、下列那组件实现了 TCP&#x2F;IP协议规范（ ABC）。A、SocketB、Java SocketC、WinSockD、Jfinal\n13、Java 声明自定义注解的关键字是（ A ）。A、@interfaceB、classC、interfaceD、final\n14、下面哪个属于 HTTP&#x2F;1.1 协议的标准 METHOD（ AD ）。A、OPTIONSB、SELECTC、UPDATED、PUT\n15、指明 HTTP 响应中包含托挂的关键字是（D）。A、CheckNumB、ExtraInfoC、Content-TrailD、Trailer\n16、JavaNIO 中，实现服务器的核心组件是（B）。A、ServerSocketB、ServerSocketChanelC、SocketD、SocketChanel\n17、HTTP&#x2F;1.1 协议 Request 的首行不包括哪类字段（B ）。A、MethodB、Status-CodeC、Request-URID、HTTP-Version\n18、HTTP 协议的消息主体内容编码有（ AB）。A、gzipB、compressC、utf-8D、en\n19、实现跨域请求的方式有（ CD）。A、隧道协议B、PPTPC、JSONPD、Web 代理\n20、实现 Java Servlet 规范的产品有（ AB）。A、TOMEEB、GlassFishC、Apache2D、nginx\n21、属于数据库中间件产品的是（ BD）。A、ActiveMQB、SQLAlchemyC、MTSD、MyBatis\n22、在三层结构的分布式系统中，包含了系统的核心业务逻辑的是（D ）。A、数据层B、表示层C、客户层D、中间层\n23、Java 接口文件的不应该出现内容是：（ C）。A、interfaceB、publicC、函数的实现D、String\n24、下面哪一个不属于 HTTP&#x2F;1.1 协议的标准 METHOD（C ）。A、OPTIONSB、CONNECTC、UPDATED、PUT\n25、下面属于 RPC 技术和框架有（ AC ）。A、Dubbo&#x2F;DubboxB、SOAPC、FinagleD、MINA\n26、Java 8 版本的 Java SE 提供 11 种内置注解，请问下列哪些不再其中（D ）。A、@RuntimeB、@FuntionInterfaceC、@SuppressWarningsD、@Table\n27、HTTP&#x2F;1.1 协议 Response 的状态行不包括哪类字段（ AC ）。A、MethodB、Status-CodeC、Request-URID、HTTP-Version\n28、关于反射机制下列描述不正确的是（ D）。A、在运行时判断任意一个对象所属的类B、在运行时判断任意一个类所具有的成员变量和方法C、生成动态代理D、Java 反射的主要实现包含在 javax.lang.reflect 包中\n29、下列哪种不是 Java I&#x2F;O 的标准实现方式（ C）。A、BIOB、AIOC、NettyD、NIO\n30、下列说法正确的是（ CD ）。A、RPC 不能采用 UDP 作为其底层通信协议B、SOAP 协议的底层协议是 TCP&#x2F;IPC、RPC 是一种技术思想而非一种规范或协议D、RPC 服务器启动时主动向注册中心登记自己的服务种类、服务方法、版本\n31、实现 Java Servlet 规范的产品有（ BC ）。A、HibernateB、GlassFishC、TomeeD、MyBatis\n32、Spring中可以处理指定 URL 中包含的一个或多个参数的注解是（ A ）。A、@PathVariableB、@IDC、@RequestBodyD、@Data\n33、属于 Java AIO 中核心的类是：（ A）。A、CompletionHandlerB、ServerSocketC、HashMapD、Socket\n34、下面哪一个不属于标准 HTTP&#x2F;1.1 协议头的参数的是（ D）。A、Last-ModifiedB、User-AgentC、ConnectionD、Length\n35、下面不属于 RPC 框架的是（D）。A、Dubbo&#x2F;DubboxB、gRPCC、FinagleD、MINA\n36、Java 8 版本的 Java SE 提供 5 种内置注解，请问下列哪些是正确的（ BC ）。A、@RuntimeB、@FuntioninterfaceC、@SuppressWarningsD、@Table\n38、下列属于 Netty 通道类型的是（B）。A、ServerBootstrapB、NioSocketChannelC、NioEventLoopD、AsynchronousSocketChannel\n39、在 HTTP 响应消息中，下列哪种状态码可以表示请求已经成功处理（ B）。A、302B、204C、102D、201\n40、下列说法正确的是（B ）。A、HTTP&#x2F;1.1 的消息的以二进制数据进行传输的，结构比复杂。B、SOAP 协议的依托协议是 HTTP。C、Netty 不能采用阻塞方式工作。D、HTTP&#x2F;2 协议是明文的，在消息传递过程中，结构比较简单。\n填空题1、 软件的三大类型：单机、CS、BS。\n2、 反射（Reflection）是程序的自我分析能力,通过反射可以确定类有哪些方法、有哪些构造方法以及有哪些成员变量。Java 语言提供了反射机制，通过反射机制能够动态读取一个类的信息；能够在运行时动态加载类，而不是在编译期。反射可以应用于框架开发，它能够从配置文件中读取配置信息动态加载类、创建对象，以及调用方法和成员变量。\n3、 HTTP&#x2F;1.1 协议的响应消息由响应行、响应头、响应体组成。\n4、 实现 ORM 中间件重点处理从实体类生成数据库表、从数据库表生成实体类、实体类和数据库表中数据的自动转换自动化。 5、 Java NIO 的三个核心组件是：Channel（通道）, Buffer（缓冲区, Selector（选择器）\n6、在 HTTP&#x2F;1.1 协议中，处理多事务的连接的方式有：并行连接、Keep-Alive、持久连接、管道。\n7、常见的五种基本 I&#x2F;O 模型，分别是：阻塞 I&#x2F;O 模型、非阻塞 I&#x2F;O 模型、IO 复用模型、信号驱动的 IO 模型和异步 IO 模型\n8、Java 8 提供的元注解包括：@Documented、@Target、@Retention、@Inherited、@Repeatable\n9、一个 HTTP 事务由一条请求消息和一条响应消息构成。\n10、Reactor 模式由Reactor&gt;和 Handler两大角色组成。\n11、 I&#x2F;O 通信模型有：阻塞 I/O 模型、非阻塞 I/O 模型、IO 复用模型、信号驱动的 IO 模型、异步 IO 模型\n12、Java BIO 和 NIO 的本质区别是，Java BIO 是面向流，NIO 是面向缓存区\n13、Java NIO 的核心组件分别是: Selector，Channel，Buffer组成。\n14、HTTP 响应的状态行由HTTP 协议版本号，状态码, 状态消息构成。\n15、Netty 的 Handler 分为两大类：Inbound ，Outbound。\n16、在 HTTP&#x2F;1.1 协议中，处理多事务的连接的方式有：并行连接、Keep-Alive、持久连接、管道\n19、浏览器将 CORS 请求分成两类：简单请求和 非简单请求。\n简答1、 在 Java 中，NIO 和 BIO 的区别主要体现在那三个方面？\n\nBIO 是面向流的，NIO 是面向缓冲区的\nJava BIO 的各种流是阻塞的，Java NIO是非阻塞模式\nBIO 无选择器，NIO 有\n\n2、 RESTful 架构风格背后的主要思想是什么？\n\n统一接口：组件之间有统一的接口。\nRESTful web 服务是基于客户机&#x2F;服务器的，不存储状态。\n从客户机到服务器的请求的结果可以缓存在客户机中。\n它具有基于超媒体的统一接口，具有自描述消息。\n而且客户机和服务器并不知道它们之间的中间连接。\n\n3、 AJAX 中包括哪些技术？\n\nHTML、css、dom、XMLHttpRequest、javascript\n基于 Web 标准(XHTML + CSS)的展示\n使用 DOM 进行动态显示和交互\n使用 XMLHttpRequest 进行数据交换和相关操作\n用 JS 可以控制 XMLHttpRequest 对象向服务器提出请求并处理响应，而不影响用户对页面的正常访问\n\n4、 请简述 HTTP&#x2F;1.1 协议 300 型响应码中几个重要的响应码，含义是什么？\n\n300 同样的一个 URI，可以对应多个实际的资源\n301 请求的 URL 已移走\n302 请求的 URL 临时移走\n303 此状态码也是重定向\n307 此状态码也是重定向响应\n\n5、 序列化和反序列化会涉及 POJO 的编码和格式化（Encoding &amp; Format），目前我们可选择的编码方式有几种？评价一个序列化框架的优缺点应该从那些方面着手？\n\n4 种，使用 JSON、基于 XML、使用 Java 内置的编码和序列化机制、开源的二进制的序列化&#x2F;反序列化框架\n结果数据大小，原则上说，序列化后的数据尺寸越小，传输效率越高\n结构复杂度，这会影响序列化&#x2F;反序列化的效率，结构越复杂，越耗时\n\n6、简述 HTTP 协议请求的八个方法的名称及其功能。\n\nGET 表示我们要请求一个由 URI 指定的在服务器上的资源。\nPUT 方法 表示如果指定 URL 资源不存在就创建它，否则就修改它。\nPOST 方法 表示要创建一个新的子资源，或者更新一个存在的资源。\nDELETE 表示我们要删除一个由 URI 指定的资源。\nHEAD 和 GET 一样，但是仅仅返回指定资源响应的头部分，而不必返回响应主体\nOPTIONS 查询目标资源支持 method 的清单。\nTRACE 查询到目标资源经过的中间节点。用于测试。\nCONNECT 建立一个到 URI 指定的服务器的隧道。\n\n7、简述 java.lang.reflect 包中提供反射处理能力的几个类并说明其作用。\n\nConstructor 类：提供类的构造方法信息。\nField 类：提供类或接口中成员变量信息。\nMethod 类：提供类或接口成员方法信息。\nArray 类：提供了动态创建和访问 Java 数组的方法。\nModifier 类：提供类和成员访问修饰符信息。\n\n8、简述目前 Java 中常见的几种实现 RESTful 技术方案。\n\n使用 Spring 的 RestTemplate\n通过 Servlet 实现\nJAX-RS\nJAX-RS 即 Java API for RESTful Web Services\n\n9、请简述 java.lang.Class 类和 java.lang.Object 的作用和区别。\n\nClass 类也是类的一种，只是名字和 class 关键字高度相似，用于 java 反射机制。\nClass 类的对象不能像普通类一样，以 new 的方式创建，它的对象只能由 JVM 创建，因为这个类没有 public 构造函数\nClass 类的作用是运行时提供或获得某个对象的类型信息，这些信息也可用于反射。\nObject 类是一切 java 类的父类，对于普通的 java 类，即便不声明，也是默认继承了 Object类。\nObject 类位于 java.lang 包中，java.lang 包包含着 Java 最基础和核心的类，在编译时会自动导入\nObject 类定义了线程同步与交互的一系列方法\n\n11 简述 Java NIO 中使用 Buffer 类的基本步骤？\n\n（1）使用创建子类实例对象的 allocate()方法，创建一个 Buffer 类的实例对象。\n（2）调用 put 方法，将数据写入到缓冲区中。\n（3）写入完成后，在开始读取数据前，调用 Buffer.flip()方法，将缓冲区转换为读模式。\n（4）调用 get 方法，从缓冲区中读取数据。\n（5）读取完成后，调用 Buffer.clear()方法，将缓冲区转换为写入模式。\n\n13、 请简述 HTTP&#x2F;1.1 协议 200 型响应码中几个重要的响应码，含义是什么？\n\n200 请求已经成功完成\n201 指明请求成功且创建了一个资源\n202 已接受请求，但尚未处理。\n203 已成功处理了请求，但返回的信息可能来自另一来源。\n204 成功处理了请求，但没有返回任何内容。\n205 成功处理了请求，但没有返回任何内容。\n206 为了支持大文件的分段下载\n\n14、 简述 Reactor 模式的优点和缺点\n\n优点:解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制\n缺点：模型复杂\n\n16、简述 Java 反射机制中获取 Java 类构造方法的函数，并说明其作用。\n\n在 java 反射机制中，可以使用 Class 类的 getConstructors()函数来获取 java 类构造方法。\n这个函数可以返回一个 Constructor 对象数组，可以用来查找、访问和调用 java 类的构造函数，从而实现对 java 类的动态构造和实例化。\n\n18、列出 Java NIO 通道类中我们常用的文件处理和网络通信常用的通道类，并说明起作用。\n\nFileChannel：文件通道，用于文件的数据读写。\nSocketChannel：套接字通道，用于套接字 TCP 连接的数据读写。\nServerSocketChannel：服务器套接字通道（或服务器监听通道），允许我们监听TCP 连接请求，为每个监听到的请求创建一个 SocketChannel 通道。\nDatagramChannel：数据报通道，用于 UDP 的数据读写。\n\n19、简述哪些 HTTP 请求会产使用到 CORS 机制。\n\n使用 XMLHttpRequest 或 Fetch API 进行跨站请求\n网页字体\nWebGL 纹理\n以 drawImage 绘制到 Canvas 画布上的图形\nCSS 样式表\n指令码\n\n程序综合题1、补齐 HTTP Response 类程序中的缺失的代码。 ！！！！[]为答案！！！\n1234567891011121314151617181920212223public int code = [200]; // 答案 200this.len = html.getBytes().length;[setHead()];// 答案 setHead()bw.append(headInfo.toString());switch (code)case 200:headInfo.append(&quot;[OK]&quot;);// 答案 &quot;OK&quot;break;case 404:headInfo.append(&quot;[NOT FOUND]&quot;);// 答案 &quot;NOT FOUND&quot;break;case 505:headInfo.append(&quot;[Server ERROR]&quot;);// 答案 &quot;Server ERROR&quot;break;headInfo.append([CRLF]);// 答案 CRLFheadInfo.append(&quot;[Date:]&quot;).append(LocalDateTime.now()).append(CRLF);// 答案 DateheadInfo.append(&quot;[Content-Type]:text/html;charset=UTF-8&quot;).append(CRLF);// 答案 Content-TypeheadInfo.append(&quot;[Content-Length:]&quot;).append(space).append(this.len).append(CRLF).append(CRLF);// 答案 Content-Lengthpublic void setCode(int code)[this.code] = code;// 答案 this.code\n\n\n\n2、  下面代码是 HTTP Request 解析类，请根据协议要求，补齐空格中必须填入的代码，注意合理利用已定义变量：  \n1234567891011121314151617181920212223242526private final String CRLF = [&quot;\\n&quot;];// 答案 &quot;\\n&quot;byte[] arr = new byte[20000];int len = [this.is.read(arr)];// 答案 this.is.read(arr)String requestInfo = [new String(arr, 0, len)];// 答案 new String(arr, 0, len)String[] arr = url.split(&quot;\\\\?&quot;);this.url = [arr[0]];// 答案 arr[0]param = [arr[1]];// 答案 arr[1]StringTokenizer token = new StringTokenizer(param,[&quot;&amp;&quot;]);// 答案 &quot;&amp;&quot;String key_value = (String) token.nextElement();String[] ks = key_value.split([&quot;=&quot;]);// 答案 &quot;=&quot;ks = Arrays.copyOf(ks, 2);ks[1] = [null];// 答案 nullif (values == null)return null;elsereturn[values[0]];// 答案 values[0]public String getUrl()return [this.url];// 答案 this.url\n\n\n\n3、补齐通用服务线程池 ServicePool 程序中的缺失的代码\n12345678910111213141516171819202122232425262728public class ServicePool&lt;Job extends [Runnable]&gt;// 答案 Runnable    private AtomicLong threadNum = [new AtomicLong()];// 答案 new AtomicLong()for (int i = 0; i &lt; workerNum; i++) &#123;MyWorker worker = new MyWorker();[workerList.add(worker)];// 答案 workerList.add(worker)jobsList.addLast(job);System.out.println(&quot;剩余待处理请求个数：&quot; + ServicePool.this.getJobsize());[jobsList.notify()];// 答案 jobsList.notify()public int getJobsize() &#123;return [jobsList.size()];// 答案 jobsList.size()private class MyWorker implements Runnable &#123;private [volatile] boolean isRunning = true;// 答案 volatilepublic void run() &#123;while ([isRunning]) &#123;// 答案 isRunningJob job = null;try &#123;[jobsList.wait()];// 答案 jobsList.wait()&#125; catch (InterruptedException e) System.out.println(&quot;正在处理请求&quot;);[job.run()];// 答案 job.run()\n\n\n\n分析题详述说明 RPC 框架中每个部分的功能\n\nRPC架构主要包括三部分：\n\n\n服务注册中心：负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。  服务提供者，提供服务接口定义与服务实现类。  \n服务消费者：通过远程代理对象调用远程服务。  \n服务提供者：启动后主动向服务注册中心Registry)注册机器 IP、端口以及提供的服务列表：  服务消费者启动时向服务注册中心(Registry)获取服务提供方地址列表。  \n服务注册中心(Registry)可实现负载均衡和故障切换。\n\n","slug":"temp_软件中间件","date":"2023-02-10T02:56:22.992Z","categories_index":"考试","tags_index":"考试,软件中间件","author_index":"FangH"},{"id":"f9596c511588d1107b8c7f2d14ce64a6","title":"UE4_UE5源码编译及发布LinuxServer","content":"UE4&#x2F;UE5 发布LinuxServer12023-01-11 更新了UE5.1源码编译以及打包 LinuxServer的内容\n\n\n[toc]\n\n\n\n\n\n\n情景内容\n\n需要开发专用服务器\n需要将Server发到云端Linux系统主机\n需要关闭SSH，服务一直启用\n需要使用UE4\n\n\n\n\n\n\n\n\n\n\nUE5.1补充内容\n\n准备UE5.1 源码\n准备VS2022\n准备Linux交叉编译器-v20版本\n\n\n\n1. Visual Studio 20191.1 下载 Visual Studio\n\n\n\n\n\n\n注意\n\nUE4编译源码可以使用VS2022，但就此博客发布时间，需要修改配置文件才能正常编译，而2017版本太老了；\n后续的C++编写在选用Rider For Unreal和Epic商城的二进制版本UE4；\n项目写完后，用源码版UE4打包发布；\nUE5的试过了，很麻烦，问题很多，想想自己是写代码，何必执着于UE5，于是就释然了\n电脑安装源码引擎的硬盘空间至少要有200GB\n内存至少16GB，最好去网上查下扩展虚拟内存，自动托管到其他磁盘空间较大的磁盘，最好是固态硬盘\n编译源码引擎时，确保关闭无关电脑后台，除非报错，否则不操作电脑做其他事，防止虚拟内存不足\n\n\n\n\n微软只在Visual Stuido主页提供最新版本下载，需要单独去下载 Visual Studio 2019\n下载社区版的就可以了\n\n\n\n\n\n\n\n\nVS2022\nUE5.1版本及以后的新版本源码要以VS2022来编译，如果使用VS2019\n当你运行GenerateProjectFiles.bat时，虽然不会报错，但会提示VS2019不能生成 .NET 6的项目文件，后续在VS2019里面编译源码可能会有warning，也可能会影响到Window打包\n如果已经安装VS2019，只需要去Visual Studio Installer里安装一个VS2022即可，具体配置往下继续\n\n\n1.2 配置 Visual Studio\n安装完成后，会进入Visual Studio Installer\n在已安装内可以看见Visual Studio 2019的安装程序\n点击修改\n在工作负荷内找到游戏，勾选使用C++的游戏开发\n此时在右边的安装详细信息内的使用C++的游戏开发的可选项内确保勾选：\nC++分析工具\nC++ AddressSanitizer\n最新的Window 10 SDK\nIntelliCode\nUnreal Engine 安装程序\n\n\n单个组件内：\n默认勾选的C# 和 Visual Basic Roslyn 编译器\n搜索勾选MSBuild\n\n\n最后检查一下是否勾选了最新的Net Framework SDK，该博客勾选的是Net Framework 4.8 SDK\n下载安装，安装位置可自定义\n\n\n\n\n\n\n\n\n注意\n安装时出现共享组件、工具和SDK的路径不能修改，是因为此前可能已经安装过Visual Studio，需要修改注册表解决问题\n解决步骤：\n\nwin + r\nregedit\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStudio\\Setup删除SharedInstallationPath\n重启Visual Studio Installer\n\n\n\n\n\n\n\n\n\n\n特别注意\nUE5需要选的东西会更多，但默认先选择和UE4一样的使用C++的游戏开发\n这里注意一个细节：进入你的Windows设置 -&gt; 系统 -&gt; Window规格内查看你的操作系统版本\n我的是Win11系统，版本号是22621.963\n前面UE4里面的WindowsSDK的选项应该改选为Windows11 SDK 22621，找不到对应版本号的也没关系，VS2022会默认选好的Windows11 SDK 20000，这个也能用\n至于其他的选项，等正式编译源码的时候，VS2022会提示你还需要安装哪些\n\n\n1.3 修改解决方案样式\n\n\n\n\n\n可选步骤\n\n菜单栏内找到工具\n工具-&gt;自定义-&gt;命令-&gt;工具栏-&gt;标准-&gt;解决方案配置-&gt;修改所选内容\n更改宽度：例如200\n若要在生成项目时显示输出窗口，请在选项对话框-&gt;项目和解决方案&gt;常规页上，选择在生成开始时显示输出窗口\n\n\n\n\n\n\n\n\n\n\n特别注意\n以上VS2022里也适用\n\n\n1.4 管理员模式启动\n\n\n\n\n\n可能重要\n\n在VS安装目录内：\\Common7\\IDE\\devenv.exe\n右键-&gt;兼容性疑难解答-&gt;疑难解答程序-&gt;勾选改程序需要附加权限-&gt;测试后下一步-&gt;保存设置\n\n\n\n\n\n\n\n\n\n\n特别注意\n以上VS2022里也适用\n\n\n2. 交叉编译器\n\n\n\n\n\n\n特别注意\n下载交叉编译器，千万别去官方中文的虚幻文档，里面给的交叉编译工具链接版本是错的，应该默认进入官方英文的文档网站内下载\n博客使用的是UE4.27.2，下载文档内提供的链接，并确保是-v19的版本，如果不是就进错网站了，正确的网站：UE4.27.2 交叉编译\n\n\n\n\n\n\n\n\n\n特别注意\nUE5.1要用的是**-v20版本，注意先卸载前面的-V19**\n网址：UE5.1交叉编译\n\n\n2.1 安装交叉编译直接默认安装即可，也可以选择安装路径\ncmd验证：%LINUX_MULTIARCH_ROOT%x86_64-unknown-linux-gnu\\bin\\clang++ -v\n无效需手动配置环境变量\n2.2 配置环境变量\n进入系统环境变量\n添加：LINUX_MULTIARCH_ROOT\n路径：安装目录\\v19_clang-11.0.1-centos7\\x86_64-unknown-linux-gnu\\bin\n-v20：安装目录\\v20_clang-13.0.1-centos7\\x86_64-unknown-linux-gnu\\bin\n\n\n\n\n\n\n\n\n注意\n交叉编译器安装和配置完成后，需要重启电脑\n\n\n3. 源码UnrealEngine\n\n\n\n\n\n省略步骤\n github账号\n 加入Epic组织\n 选择UE4.27.2 Release下载\n\n\n3.1 配置Setup.batSetup.bat配置表：\n1234567891011121314151617181920212223242526Usage:   GitDependencies [options]Options:   --all                         Sync all folders   --include=&lt;X&gt;                 Include binaries in folders called &lt;X&gt;   --exclude=&lt;X&gt;                 Exclude binaries in folders called &lt;X&gt;   --prompt                      Prompt before overwriting modified files   --force                       Always overwrite modified files   --root=&lt;PATH&gt;                 Set the repository directory to be sync   --threads=&lt;N&gt;                 Use N threads when downloading new files   --dry-run                     Print a list of outdated files and exit   --max-retries                 Override maximum number of retries per file   --proxy=&lt;user:password@url&gt;   Sets the HTTP proxy address and credentials   --cache=&lt;PATH&gt;                Specifies a custom path for the download cache   --cache-size-multiplier=&lt;N&gt;   Cache size as multiplier of current download   --cache-days=&lt;N&gt;              Number of days to keep entries in the cache   --no-cache                    Disable caching of downloaded filesDetected settings:   Excluded folders: Mac, Android, Linux   Proxy server: none   Download cache: disabledDefault arguments can be set through the UE4_GITDEPS_ARGS environment variable.Installing prerequisites...\n\n\n\n该博客的配置：(截取的一段，只有**set PROMPT_ARGUMENT&#x3D;**需要修改)\n12345set PROMPT_ARGUMENT=for %%P in (%*) do if /I &quot;%%P&quot; == &quot;--prompt&quot; goto no_prompt_argumentfor %%P in (%*) do if /I &quot;%%P&quot; == &quot;--force&quot; goto no_prompt_argumentset PROMPT_ARGUMENT=--prompt --threads=20 --cache=E:\\UrealEngineSource\\UE4.27.2\\Cache:no_prompt_argument\n\n123--threads=20 # 加快下载速度，不宜过高--cache # 将下载的源码文件单独保存到指定位置，方便传给其他人和玩坏了，不用全删了重新下载了--exclude # 排除不想要的模块\n\n\n\n–exclude可选参数：\n123平台参数：Win32, Win64, osx32,osx64, Linux, Android, IOS, HTML5VS版本参数：VS2012,VS2013,VS2015尽量别排除VS版本的参数，平台参数可以排除不要的，该博客默认不加入 --exclude，全要了\n\n\n\n\n\n\n\n\n\n\n特别注意\n以上UE5.1也适用，但要注意 --cache=的路径\n尽量别用--exclude\n\n\n3.2 生成UE4.sln文件上面配置好Setup.bat文件后：\n\n双击运行Setup.bat\n双击运行GenerateProjectFiles.bat\n\n\n\n\n\n\n\n\n特别注意\n以上UE5.1也适用\n\n\n3.3 编译源码编辑器\n\n\n\n\n\n\n注意\n\n先编译源码 编辑器\n网上有的教程说的很乱，这里就编译Development Editor即可\n注意：\n如果是先完成过了源码引擎的编译，后下载交叉编译，需要按照博客[2. 交叉编译器](#2. 交叉编译器)的内容完成检查步骤\n再进行博客3.2 生成UE4.sln文件的步骤，再接着往下继续看，并完成下面的全部步骤\n\n\n\n\n\n双击UE4.sin文件，根据上面的VS2019配置，此时默认管理员模式\n在解决方案中依次选择：\n\nDevelopment Editor\nWin64\n选中侧边栏的UE4，右键-&gt;设为启动项\n右键UE4选择生成，注意：不希望看见Warning和Error，如果有请深入排查问题，然后右键UE4选择重新生成\n\n上面的步骤完成后，不关闭VS2019，建议进行下一步：\n\n依次再重新生成：AutomationTool、UnrealBuildTool、UnrealFrontend\n如果全部没Warning和Error，就算编译完成了\n\n\n\n\n\n\n\n\n特别注意\n这里补充一个细节：BuildConfiguration.xml\n源码引擎安装目录\\UE5.1\\Engine\\Saved\\UnrealBuildTool\nC:\\Users\\用户名\\AppData\\Roaming\\Unreal Engine\\UnrealBuildTool\n两处都有改：后续可以加快UE5的编译速度可能吧，应该，或许，大概，Maybe\n我这里提供我自己用的：\n12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;Configuration xmlns=&quot;https://www.unrealengine.com/BuildConfiguration&quot;&gt; &lt;ParallelExecutor&gt;    &lt;ProcessorCountMultiplier&gt;2&lt;/ProcessorCountMultiplier&gt;    &lt;MaxProcessorCount&gt;16&lt;/MaxProcessorCount&gt;    &lt;bStopCompilationAfterErrors&gt;true&lt;/bStopCompilationAfterErrors&gt;  &lt;/ParallelExecutor&gt;&lt;/Configuration&gt;\n\n具体用法可以去上网查BuildConfiguration.xml\n还可以安装一个UnrealVS插件，说是可以快速编译：可能吧，应该，或许，大概，Maybe\n插件所在的目录：E:\\UrealEngineSource\\UE5.1\\Engine\\Extras\\UnrealVS\n里面有两个选项：VS2019和VS2022，具体看你选择\n直接双击安装就可以，后面解决方案里找到UE5，右键就可以看到UnrealVS Quick Build\n\n\n3.4 创建快捷方式网上有的教程真的傻，非得打开UE4.sln在VS2019里面启动源码虚幻引擎\n其实可以进如源码引擎目录：\\Engine\\Binaries\\Win64找到UE4Editor.exe\n直接双击启动，或者创建快捷方式，放到方便使用的地方启动，和正常的Epic商城引擎没什么两样\n\n\n\n\n\n\n\n注意\n源码引擎编译完成后，先打开引擎看看打包功能是否出现:warning:标志\n如果有，大概率是VS2019和交叉编译器没有配置好，缺失SDK，需要重新生成\n如果没有，再往后继续看\n\n\n\n\n\n\n\n\n\n特别注意\n以上UE5.1也适用\n\n\n4. 打包测试项目\n\n\n\n\n\n\n特别注意\n以下UE4 &#x2F; UE5.1也适用，可能吧，应该，或许，大概，Maybe\n注意几个可能出现的细节：往往到了这一步，打包LinuxServer不会有什么问题了，但你会发现打包Windows或者WindowsClient并没有打包出来\n单独打包Windows或者WindowsClient，会看到类似一下的报错信息：\n1UATHelper: Packaging (Windows): ERROR: Game target not found. Game target is required with -cook or -cookonthefly\n\n这种错误一般发生在C++项目，解决方法是：StackOverflow\n\n复制项目名.Target.cs\n\n粘贴并重命名项目名Game.Target.cs\n\n修改内容参考如下：\n12345678910111213using UnrealBuildTool;using System.Collections.Generic;public class 项目名GameTarget : TargetRules // 类名改一下&#123;\tpublic 项目名GameTarget(TargetInfo Target) : base(Target) // 这里也改一下\t&#123;\t\tType = TargetType.Game; // 这里好像默认就是 Game，不用改了\t\tDefaultBuildSettings = BuildSettingsVersion.V2;\t\tExtraModuleNames.AddRange( new string[] &#123; &quot;项目名&quot; &#125; );\t&#125;&#125;\n\n删除项目内的Binaries，DerivedDataCache，Intermediate\n\n右键项目名.uproject，Generate Visual Studio Project Files\n\n打开项目名.sln，编译项目\n\n重新打开项目，再次尝试打包Window\n\n\n\n\n4.1 创建测试项目\n打开UE4，是不是源码引擎无所谓，真的\n新建一个C++、第三人称、无初学者内容包、无光追的项目Test\n\n4.2 修改测试项目\n进入ThirdPersonBP找到Map\n依次创建两个新Level：Map_Translation用来服务器过渡用，Map_Start这是游戏客户端默认打开的地图，已经存在的模板地图是客户端玩家进入的服务器地图\n同时创建一个User Widget，随便给个按钮，实现按钮点击事件，Open Level，Level Name参数是：你的云服务器公网IP:7777，后面会说云主机的配置，也可以直接跳到博客5. 云主机防火墙配置，先拿到公网IP\n打开Map_Start，打开关卡蓝图\n在Begin Play实现：Create Widget，Add To Viewport，GetPlayerController-&gt;SetShowMouse-&gt;ture\n\n4.3 设置测试项目\n打开项目设置：\n全局GameMode可以设为none，默认不设也许，完全不影响测试结果\n编辑器初始地图：无所谓\n游戏默认地图：Map_Start\n过渡地图：Map_Translation\n服务器地图：第三人称的模板默认地图\n\n\n在项目设置，打包中搜索list of maps to include in a packaged build:\n添加进上面的三个地图\n\n\n\n4.4 修改 build.cs\n\n\n\n\n\n\n注意\n注意：测试项目创建用的是不是源码引擎不重要，后面的[4.5 配置打包程序](#4.5 配置打包程序)要用源码引擎打开，具体后面会写\n接下来会编译至少两次项目C++源码，目的不是打包，而是测试打包环境是否正常，如果不需要测试，可以直接进入打包环节\n假设最终打包结果为：一个Linux Server，一个Windows Client\n需要先打开项目文件的**.sln**，解决方案依次是分别编译一下两种配置：\nLinux Server包：Development Server，Linux\nWindows Client包：Development，Win64，如果Windows Client想打包成发行版，就选择Shipping，Win64，该博客选择Development\n如果报错，例如：\n\n交叉编译比需求的版本老了，那就是交叉编译器装错了，顺便查查系统环境变量，再照着博客3.2 生成UE4.sln文件重来\n缺失对应平台的SDK，去博客的[1.2 配置 Visual Studio](#1.2 配置 Visual Studio)重来\n其他的自行上网查询\n\n\n\n上面的是警告，需要注意看需求，选择合适解决方案的配置，接下来是打包LinuxServer前的准备工作\n首先还算要打开项目目录下的**.sln**文件：\n\n找到项目目录中的项目名Editor.Target.cs文件\n\n直接复制这个文件，在同级目录下，再重命名为：项目名Server.Target.cs，打开\n\n修改内容为：(博客的配置)\n12345678910111213using UnrealBuildTool;using System.Collections.Generic;public class 项目名ServerTarget : TargetRules // 类名改一下&#123;\tpublic 项目名ServerTarget(TargetInfo Target) : base(Target) // 这里也改一下\t&#123;\t\tType = TargetType.Server; // 这里的Editor 改为 Server\t\tDefaultBuildSettings = BuildSettingsVersion.V2;\t\tExtraModuleNames.AddRange( new string[] &#123; &quot;项目名&quot; &#125; );\t&#125;&#125;\n\n分别是public class Test01ServerTarget ，public Test01ServerTarget(TargetInfo Target)，Type = TargetType.Server\n\n\n修改完成后：\n\n删除项目内的Binaries，DerivedDataCache，Intermediate\n右键项目名.uproject，Generate Visual Studio Project Files\n打开项目名.sln，编译项目\n尝试继续打包LinuxServer\n\n4.5 配置打包程序首先找到项目目录下的**.uproject文件，右键Select Unreal Engine Version，选择Soucre build开头的UE4**源码引擎\n生成一段时间后，双击**.uproject**文件打开源码引擎\n配置打包程序：(目的是一次性同时打包出 LinuxServer和windowsClient两个包)\n\n在引擎主界面的顶部菜单栏中找到窗口-&gt;项目启动程序\n添加自定义启动描述文件\n在烘培中选择常规，勾选LinuxServer，WindowsNoEditor(也可以是WindowsClient)\n烘培语言：随意，一般默认选en\n包：选择本地打包存储，修改自己的本地目录路径\n部署：选择不部署 (注意：很重要，不然后面打包会卡在Launching UAT)\n返回\n\n点击启动此描述文件，就可以打包了\n\n\n\n\n\n\n\n特别注意\nUE5这里好像没有WindowsNoEditor，选Windows或者WindowsClient\n如果有问题，可以看[4.1 创建测试项目](#4.1 创建测试项目)上面的danger提示\n\n\n5. 云主机&#x2F;ECS5.1 云服务配置\n\n\n\n\n\n云主机&#x2F;ECS&#x2F;轻量应用服务器\n随便哪家的云服务都行，系统最好安装Centos7，root密码随你，重要的是防火墙的配置：\n\n添加TCP，端口：7777\n添加UDP，端口：7777\n\n\n\n5.2 上传和运行Server\n\n\n\n\n\n\n注意\n博客省略了将文件上传到远端服务器的过程，反正把LinuxServer包压缩**.zip**格式比较简单操作，容易理解\n上传的路径最好是普通用户，好像不允许root用户执行，下面会介绍新建一个普通用户unreal，将压缩包上传到unreal家目录，也就是unreal@hostname ~\n\n\n\n先创建一个普通用户\n123useradd unrealpasswd unreal // 输入两次相同的秘密cd /home/unreal\n\n把压缩文件上传的当前目录\n\n安装解压程序\n1yum install unzip\n\n解压压缩包\n1unzip 压缩包\n\n通过root设置执行权限\n1chmod +x 项目名称Server.sh\n\n切换到普通用户unreal\n1su unreal\n\n执行\n1./项目名称Server.sh -log\n\n在本地端，打开WindowsNoEditor包的程序进行测试\n\n\n注意：在Windows本地段关闭远程连接云服务的SSH，正在运行的Server服务会停止\n解决方案：nohup，screen\n博客采用最简单的nohup：\n1nohup ./项目名称Server.sh -log &amp;\n\n如果想终止这个服务：\n1234su rootps aux// 找到 ./项目名称Server.sh -log 这个命令的进程，记住它的pidkill pid\n\n\n\n\n\n\n\n","slug":"7_UE4_UE5源码编译及发布LinuxServer_10","date":"2023-01-11T02:01:11.553Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"f95a59a33b004968630f7b42d7d7400d","title":"形式政策考试","content":"形式政策一. 单选题\n\\1. 我们乘势而上开启全面建设社会主义现代化国家新征程、向第二个百年奋斗目标进军,这标志着我国进入了一个(C )。\nA. 新发展时期\nB. 新发展方位\nC. 新发展阶段\nD. 新发展格局\n\\2. 习近平指出:“全面建设社会主义现代化国家、基本实现社会主义现代化,既是(  )我国发展的要求,也是我国社会主义从初级阶段向更高阶段迈进的要求。(A)\nA. 社会主义初级阶段\nB. 社会主义历史时期\nC. 社会主义新时代\nD. 社会主义实践探索\n\\3. (单选题, 5分)( A )是发展行动的先导。\nA. 发展理念\nB. 发展格局\nC. 发展方向\nD. 发展策略\n\\4. (单选题, 5分)(D )的发展理念,相互贯通、相互促进,是具有内在联系的集合体,要统一贯彻,不能顾此失彼,也不能相互替代。\nA. 改革、和谐、绿色、开放、共享\nB. 创新、协调、和谐、开放、共赢\nC. 创新、和谐、绿色、开放、发展\nD. 创新、协调、绿色、开放、共享\n\\5. (单选题, 5分)( B )是根据我国发展阶段、环境、条件变化提出来的,是重塑我国国际合作和竞争新优势的战略抉择,是把握未来发展主动权的战略性布局和先手棋。\nA. 新发展理念\nB. 新发展格局\nC. 新发展阶段\nD. 新发展时期\n\\6. (单选题, 5分)(  D  )是党治国理政的中心工作。\nA. 文化工作\nB. 政治工作\nC. 外交工作\nD. 经济工作\n\\7. (单选题, 5分)推进供给侧结构性改革,关键在于理解(  C  )。\nA. 供给性\nB. 倾向性\nC. 结构性\nD. 周期性\n\\8. (单选题, 5分)现代化经济体系必须坚持质量第一、( D )优先。\nA. 利益\nB. 速度\nC. 人才\nD. 效益\n\\9. (单选题, 5分)( A )是化解我国经济发展面临困难和矛盾的重大举措。\nA. 供给侧结构性改革\nB. 健全民主法制\nC. 社会公平正义\nD. 人民主体地位\n\\10. (单选题, 5分)建设充分发挥( A ),更好发挥政府作用的经济体制。\nA. 市场作用\nB. 服务业动能\nC. 社会作用\nD. 社会福利补给\n\\11. (单选题, 5分)经济改革的方向是要让(D)在资源配置中发挥决定性作用。\nA. 科技\nB. 创新\nC. 政府\nD. 市场\n\\12. (单选题, 5分)经济进入新常态后,伴随着经济增长速度的下降,推动(  A  )成为经济生活中的主旋律。\nA. 供给侧改革\nB. 产业结构升级\nC. 建设社会主义市场经济体制\nD. 建设现代化经济体系\n\\13. (单选题, 5分)我国经济已由高速增长阶段转向(),正处在转变发展方式、优化经济结构、转换增长动力的攻关期。(A)\nA. 高质量发展阶段\nB. 中高速阶段\nC. 低速阶段\nD. 高水平发展阶段\n14.国有企业是中国特色社会主义的重要物质基础和政治基础,关系(B )地位的巩固,关系我们党的执政地位和执政能力,关系我国社会主义制度。\nA. 人民主体\nB. 公有制主体\nC. 经济体制主体\nD. 社会发展主体\n\\15. (单选题, 4.6分)要破解发展中面临的难题,化解来自各方面的风险挑战,推动经济社会持续健康发展,必须依靠( B  )。\nA. 全面建成小康社会\nB. 全面深化改革\nC. 全面依法治国\nD. 全面从严治\n\\16. (单选题, 4.6分)党的十九大提出,到(A )“各方面制度更加完善,国家治理体系和治理能力现代化基本实现”。\nA. 2035年\nB. 2030年\nC. 2025年\nD. 2020年\n\\17. (单选题, 4.6分)中国特色社会主义制度和国家治理体系是以( )为指导、植根中国大地、具有深厚中华文化根基、深得人民拥护的制度和治理体系。(C)\nA. 社会主义\nB. 中国特色社会主义\nC. 马克思主义\nD. 毛泽东思想\n\\18. (单选题, 4.6分)坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化,不仅要建立完善的制度体系,还要在不断提高( D )上狠下功夫。\nA. 民主与法治\nB. 制度创新和社会和谐\nC. 社会发展和经济增速\nD. 制度执行力和治理能力\n\\19. (单选题, 4.6分)( B )作出了全面深化改革的决定。\nA. 党的十八大\nB. 党的十八届三中全会\nC. 党的十九大\nD. 党的十九届六中全会\n\\20. 全面深化改革必须始终站稳人民立场,坚持( A )的改革价值取向。\nA. 以人民为中心\nB. 社会主义本质要求\nC. 党的性质宗旨\nD. 社会主义发展\n\\21. (单选题, 4.6分)全面深化改革能否顺利推进,关键取决于党,取决于( B )。\nA. 全体人民的共同参与\nB. 党的集中统一领导\nC. 全方位对外开放\nD. 社会主义的发展方向\n\\22. (单选题, 4.6分)( A )是运用国家制度管理国家各方面事务的能力。\nA. 治理能力\nB. 治理体系\nC. 管理能力\nD. 协调能力\n\\23. (单选题, 4.6分)坚持以( C  )为原则推动“一带一路”建设。\nA. 中华民族伟大复兴\nB. 维护世界和平、促进共同发展\nC. 共商共建共享\nD. 维护党中央权威\n\\24. (单选题, 4.6分)( C  ),习近平先后提出共建“丝绸之路经济带”和“21世纪海上丝绸之路”的重大倡议。\nA. 2015 年9 月和10月\nB. 2014 年 9 月和10月\nC. 2013 年 9 月和10月\nD. 2012 年9 月和10月\n\\25. (单选题, 4.6分)(  B )是“一带一路”国际合作的重要内容,如同车之两轮、鸟之两翼。\nA. 陆海内外联动\nB. 引进来和走出去\nC. 东西双向互济\nD. 开放与合作\n\\26. (单选题, 4.6分)截至2022年7月,得到了全球( B  )个国家和国际组织的积极支持和参与。\nA. 151\nB. 181\nC. 162\nD. 172\n\\27. (单选题, 4.6分)中阿新闻交流中心、中阿电子图书馆门户网站正式落地;“汉语热”在阿拉伯国家持续升温,沙特、阿联酋、埃及宣布将中文教学纳入国民教育体系。上述现象主要说明( C )\nA. 各国之间经济互联互通\nB. 形成了“一带一路”产业化集群\nC. “一带一路”促进人文交流更加深入\nD. 中华文化成为人类文明的中心\n\\28. (单选题, 4.6分)党的十九届四中全会,对坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化作出总体擘画。以下表述不正确的是( D )\nA. 党成立100年时,在各方面制度更加成熟更加定型上取得明显成效\nB. 2035年,各方面制度更加完善,基本实现国家治理体系和治理能力现代化\nC. 新中国成立100年时,全面实现国家治理体系和治理能力现代化,中国特色社会主义制度更加巩固、优越性充分展现\nD. 本世纪中叶,全面建成符合社会主义现代化发展的国家治理体系\n\\29. (单选题, 5.6分)推进改革的目的是要不断推进我国社会主义制度( A ),赋予社会主义新的生机活力。\nA. 自我完善和发展\nB. 现实性和实效性\nC. 人民性和整体性\nD. 整体推进和全面发展\n二. 简答题\n\\1. (简答题, 10分)我国现代化经济体系的内容是什么?\n\n1.创新引领、协同发展的产业体系。\n2.统一开放、竞争有序的市场体系。\n3.体现效率、促进公平的收入分配体系。\n4.彰显优势、协调联动的城乡区域发展体系。\n5.资源节约、环境友好的绿色发展体系。\n6.多元平衡、安全高效的全面开放体系。\n\n\\2. (简答题, 10分)供给侧结构性改革的必要性是什么?\n\n1.适应把握引领经济发展新常态的重大创新。\n2.适应国际金融危机发生后综合国力竞争新形势的主动选择。\n3.推动我国经济实现高质量发展的必然要求。\n\n\\3.  (简答题, 10分)如何理解我国进入新发展阶段的基本依据?\n\n一、理论依据：马克思主义是远大理想和现实目标相结合、历史必然性和发展阶段性相统一的统一论 者，坚信人类社会必然走向共产主义，但实现这一崇高目标必然经历若干历史阶段。\n二、历史依据：新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段。\n三、现实依据：我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础。\n\n\\4. 全面深化改革主要围绕哪些领域进行改革?\n\n第一,紧紧围绕使市场在资源配置中起决定性作用深化经济体制改革。\n第二,紧紧围绕坚持党的领导、人民当家作主、依法治国有机统一深化政治体制改革。\n第三,紧紧围绕建设社会主义核心价值体系、社会主义文化强国深化文化体制改革。\n第四,紧紧围绕更好保障和改善民生、促进社会公平正义深化社会体制改革。\n第五,紧紧围绕建设美丽中国深化生态文明体制改革。\n第六,紧紧围绕提高科学执政、民主执政、依法执政水平深化党的建设制度改革。\n\n\n改革的系统集成主要体现在哪些方面？\n\n\n答:（1）加强顶层设计和总体规划，党中央集中统一领导，全国一盘棋。\n（2）注重系统性、整体性、协同性，善于打好改革的“组合拳”，做到前后呼应。\n（3）从“五位一体”总体布局和党的制度建设上整体推进，防止出现畸重畸轻、单兵突进、顾此失彼。\n\n第一讲 马克思主义中国化新的飞跃 知识点1、****习近平新时代中国特色社会主义思想是如何创立的？\n一是时代背景：“两个大局”同步交织、相互激荡。一个是中华民族伟大复兴的战略全局；一个是世界百年未有之大变局。习近平新时代中国特色社会主义思想，正是在中华民族伟大复兴进入关键时期创立并不断丰富发展的，正是在把握世界发展大势、应对全球共同挑战、维护人类共同利益的过程中创立并不断丰富发展的。\n二是历史方位：中国特色社会主义进入新时代。中国特色社会主义进入新时代，这是一个需要理论而且一定能够产生理论的时代，是一个需要思想而且一定能够产生思想的时代。习近平新时代中国特色社会主义思想正是在这样的伟大时代中应运而生、顺势而成的。\n新时代的内涵：是承前启后、继往开来、在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代；是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代；是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代；是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代；是我国不断为人类作出更大贡献的时代。\n中国特色社会主义进入新时代的意义：意味着中华民族迎来了从站起来、富起来到强起来的伟大飞跃；意味着科学社会主义在二十一世纪的中国焕发出强大生机活力；意味着拓展了发展中国家走向现代化的途径，为解决人类问题贡献了中国智慧和中国方案。\n三是实践基础：历史性成就、历史性变革。党的十八大以来，采取一系列战略性举措，推进一系列变革性实践，实现一系列突破性进展，取得一系列标志性成果。攻克了许多长期没有解决的难题，办成了许多事关长远的大事要事，经受住了来自政治、经济、意识形态、自然界等方面的风险挑战考验，党和国家事业取得历史性成就、发生历史性变革。\n四是基本方法：“两个结合”。坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，用马克思主义观察时代、把握时代、引领时代，继续发展当代中国马克思主义、21世纪马克思主义！\n2、****习近平新时代中国特色社会主义思想回答了什么重大时代课题 ？\n一是新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义。\n坚持和发展中国特色社会主义，是改革开放以来我们党全部理论和实践的鲜明主题。坚持和发展中国特色社会主义是一篇大文章，如何在新的时代条件下继续把这篇大文章写下去，是必须回答好的重大课题。\n二是建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国。\n在党的第一个百年目标全面建成小康社会实现之后，我们开启全面建设社会主义现代化国家新征程。党的十九大提出，将全面建设社会主义现代化国家的进程分为两个阶段。第一阶段，在2020年全面建成小康社会的基础上继续奋斗争取2035年基本实现社会主义现代化，第二个阶段，从2035年到本世纪中叶，在基本实现现代化的基础上，把我国建设成为富强民主文明和谐美丽的社会主义现代化强国。\n三是建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党。\n我们党作为百年大党，如何永葆先进性和纯洁性、永葆青春活力，如何永远得到人民拥护和支持，如何实现长期执政，是我们必须回答好、解决好的一个根本性问题。我们党历史这么长、规模这么大、执政这么久，如何跳出治乱兴衰的历史周期率？毛泽东同志在延安的窑洞里给出了第一个答案，这就是只有让人民来监督政府，政府才不敢松懈。经过百年奋斗特别是党的十八大以来新的实践，我们党又给出了第二个答案，这就是自我革命。\n3、****习近平新时代中国特色社会主义思想主要包含哪些内容？\n“十个明确”：如果把习近平新时代中国特色社会主义思想比作一座理论大厦，“十个明确”就是支撑整座大厦的主体部分。把握住了“十个明确”，就掌握了这一思想的核心要义和基本精神。\n明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，中国共产党是最高政治领导力量，全党必须增强“四个意识”、坚定“四个自信”、做到“两个维护”。\n明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国，以中国式现代化推进中华民族伟大复兴。\n明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，发展全过程人民民主，推动人的全面发展、全体人民共同富裕取得更为明显的实质性进展。\n明确中国特色社会主义事业总体布局是经济建设、政治建设、文化建设、社会建设、生态文明建设五位一体，战略布局是全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党四个全面。\n明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。\n明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家。\n明确必须坚持和完善社会主义基本经济制度，使市场在资源配置中起决定性作用，更好发挥政府作用，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展，统筹发展和安全。\n明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队。\n明确中国特色大国外交要服务民族复兴、促进人类进步，推动建设新型国际关系，推动构建人类命运共同体。\n明确全面从严治党的战略方针，提出新时代党的建设总要求，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，落实管党治党政治责任，以伟大自我革命引领伟大社会革命。\n“十四个坚持”：\n坚持党对一切工作的领导\n坚持以人民为中心\n坚持全面深化改革\n坚持新发展理念\n坚持人民当家作主\n坚持全面依法治国\n坚持社会主义核心价值体系\n坚持在发展中保障和改善民生\n坚持人与自然和谐共生\n坚持总体国家安全观\n坚持党对人民军队的绝对领导\n坚持“一国两制”和推进祖国统一\n坚持推动构建人类命运共同体\n坚持全面从严治党\n4、****如何理解习近平新时代中国特色社会主义思想的历史地位？\n一是，当代中国马克思主义、二十一世纪马克思主义。一以贯之坚持马克思主义，在当代中国、在二十一世纪的世界高高举起了马克思主义的光辉旗帜。与时俱进发展马克思主义，在当代中国、在二十一世纪的世界开辟了马克思主义的崭新境界，展现了强大的真理力量，增强了马克思主义的生命力、说服力。这一思想不断推进马克思主义中国化时代化，对马克思主义哲学、政治经济学、科学社会主义，对共产党执政规律、社会主义建设规律、人类社会发展规律，都提出了许多标志性引领性的新思想新观点新论断，为丰富发展马克思主义作出了原创性贡献，续写了马克思主义中国化时代化新篇章。\n二是，中华文化和中国精神的时代精华。这一思想汲取中华优秀传统文化所蕴含的丰富哲学思想、人文精神、道德理念和政治智慧，有效激活了中华优秀传统文化的生命力，成为中华优秀传统文化创造性转化、创新性发展的生动典范。这一思想大力弘扬以爱国主义为核心的民族精神和以改革创新为核心的时代精神，深刻阐发了以伟大建党精神为源头的中国共产党人的精神谱系，以及中国人民的伟大创造精神、伟大奋斗精神、伟大团结精神、伟大梦想精神，铸就了脱贫攻坚精神、伟大抗疫精神、新时代北斗精神、北京冬奥精神等，丰富了当代中国人的精神世界，为实现中华民族伟大复兴提供了精神力量。习近平新时代中国特色社会主义思想是中华文化和中国精神的时代精华，充盈着浓郁的中国味、深厚的中华情、浩然的民族魂，具有强大的历史穿透力、文化感染力、精神感召力。\n三是，马克思主义中国化新的飞跃。在习近平新时代中国特色社会主义思想的指导下，中国共产党团结带领中国人民，自信自强、守正创新，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，创造了新时代中国特色社会主义的伟大成就，为实现中华民族伟大复兴提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量。\n四是，深刻领悟“两个确立”的决定性意义。确立习近平同志党中央的核心、全党的核心地位、习近平新时代中国特色社会主义思想的指导地位。反映了全党全军全国各族人民共同心愿，对新时代党和国家事业发展、对推进中华民族伟大复兴历史进程具有决定性意义。标志着我们党思想上更加成熟，又一次实现了指导思想的与时俱进、我们党的团结统一达到了新的高度，凝聚起了实现中华民族伟大复兴的磅礴力量、我们党政治上更加成熟，形成了以习近平同志为核心的党中央领导集体。\n5、****如何学好用好习近平新时代中国特色社会主义思想？\n一是坚持读原著学原文悟原理。原著原文是最权威的，只有学深学透原著原文，才能全面把握习近平新时代中国特色社会主义思想的真谛真义、思想精华。要坚持原原本本地学、专心致志地读、细嚼慢咽地去感悟思考，深入学习领会这一思想的核心要义与基本精神，学习领会这一思想的理论特色和内在要求，学习领会这一思想蕴含的一系列新的重要观点、重大判断、重大举措。\n二是，带着问题学、联系实际学。习近平新时代中国特色社会主义思想扎根中国大地、立足中国国情、着眼中国客观实际，是在解决中国实际问题的过程中形成和发展起来的。学好这一思想，要把理论和实践有机结合起来，发扬理论联系实际的马克思主义学风，既向书本学，又向实践学。\n三是，把握贯穿其中的立场观点方法。我们要把握好习近平新时代中国特色社会主义思想的世界观和方法论，坚持好、运用好贯穿其中的立场观点方法，用以指导自己的学习和工作。\n四是，用党的创新理论认识世界、改造世界。为中国人民谋幸福、为中华民族谋复兴，为人类谋进步、为世界谋大同，是深刻理解和全面把握习近平新时代中国特色社会主义思想的金钥匙。学好用好这一思想，根本上是要用这一思想观察时代、把握时代、引领时代，用党的创新理论来认识世界、改造世界。\n第二讲 坚持和发展中国特色社会主义的总任务  \n1、****坚持和发展中国特色社会主义的总任务内容\n坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国，以中国式现代化推进中华民族伟大复兴。\n2、****中国共产党的初心、使命和百年奋斗的主题\n中国共产党一经诞生，就把为中国人民谋幸福、为中华民族谋复兴确立为自己的初心使命。一百年来，中国共产党团结带领中国人民进行的一切奋斗、一切牺牲、一切创造，归结起来就是一个主题：实现中华民族伟大复兴。\n3、****中国梦的科学内涵\n中国梦是中华民族伟大复兴的形象表达，“中国梦”的本质是国家富强、民族振兴、人民幸福。国家富强就是在全面建成小康社会的基础上，建设富强民主文明和谐美丽的社会主义现代化强国；民族振兴指中华民族更加坚强有力地自立于世界民族之林，为人类作出新的更大的贡献；人民幸福就是坚持以人民为中心，增进人民福祉，促进人的全面发展，实现全体人民共同富裕。\n实现中国梦必须走中国道路——中国特色社会主义道路；实现中国梦必须弘扬中国精神——以爱国主义为核心的民族精神和以改革创新为核心的时代精神；实现中国梦必须凝聚中国力量——中国各族人民大团结的力量。\n4****、如何理解中国特色社会主义是社会主义而不是别的什么主义\n五个方面，在领导力量上，中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，党是最高政治领导力量，是中国特色社会主义制度的最大优势； 在国体政体上，我国的国体是人民民主专政有社会主义国家，政体是人民代表大会制度；在经济制度上，坚持公有制为主体、多种所有制经济共同发展，坚持按劳分配为主体、多种分配方式并存，实行社会主义市场经济体制；在意识形态上，坚守马克思主义信仰、共产主义远大理想、中国特色社会主义共同理想，培育和践行社会主义核心价值观；在根本立场上，坚持以人民为中心，不断促进人的全面发展，实现全体人民共同富裕。这些都在新的历史条件下体现了科学社会主义基本原则，赓续民科学社会主义基因血脉，丰富和发展了科学社会主义并赋予其鲜明中国特色。\n5、 如何正确认识改革开放前后两历史时期的关系\n这是两个相互联系又有重大区别的时期，但本质上都是我们党领导人民进行社会主义建设的实践探索。中国特色社会主义是在改革开放历史时期开始的，但也是在新中国已经建立起社会主义基本制度、并进行了20多年建设的基础上开创的。如果没有1949年建立新中国并进行社会主义革命和建设，积累了重要的思想、物质、制度条件，积累了正反两方面经验，改革开放也很难顺利推进。虽然这两个历史时期在进行社会主义建设的思想指导、方针政策、实际工作上有很大差别，但两者决不是彼此割裂的，更不是根本对立的。不能用改革开放后的历史时期否定改革开放前的历史时期，也不能用改革开放前的历史时期否定改革开放后的历史时期。\n6、2035年远景目标**\n我国经济实力、科技实力、综合国力将大幅跃升，经济总量和城乡居民人均收入将再迈上新的大台阶，关键核心技术实现重大突破，进入创新型国家前列。基本实现新型工业化、信息化、城镇化、农业现代化，建成现代化经济体系；基本实现国家治理体系和治理能力现代化，人民平等参与、平等发展权利得到充分保障，基本建成法治国家、法治政府、法治社会。建成文化强国、教育强国、人才强国、体育强国、健康中国，国民素质和社会文明程度达到新高度，国家文化软实力显著增强；广泛形成绿色生产生活方式，碳排放达峰后稳中有降，生态环境根本好转，美丽中国建设目标基本实现形；成对外开放新格局，参与国际经济合作和竞争新优势明显增强；人均国内生产总值达到中等发达国家水平，中等收入群体显著扩大，基本公共服务实现均等化，城乡区域发展差距和居民生活水平差距显著缩小；平安中国建设达到更高水平，基本实现国防和军队现代化。人民生活更加美好，人的全面发展、全体人民共同富裕取得更为明显的实质性进展。\n7、中国式现代化的基本特征\n中国的现代化是人口规模巨大的现代化。我国要整体迈入现代化社会，其规模超过现有发达国家的总和，将彻底改写现代化的世界版图，在人类历史上是一件有深远影响的大事。\n中国的现代化是全体人民共同富裕的现代化。我国的现代化是社会主义的现代化，共同富裕是本质要求，必须坚持以人民为中心的发展思想，自觉主动解决地区差距、城乡差距、收入分配差距，防止出现两极分化，促进社会公平正义，逐步实现全体人民共同富裕。\n中国的现代化是物质文明和精神文明相协调的现代化。我国现代化包括物质文明建设和精神文明建设、国家物质力量和精神力量、全国各族人民物质生活和精神生活。必须坚持社会主义核心价值观，加强理想信念教育，弘扬中华优秀传统文化，增强人民精神力量，促进物的全面丰富的人的全面发展。\n中国的现代化是人与自然和谐共生的现代化。我国现代化注重同步推进物质文明和生态文明建设，走生产发展、生活富裕、生态良好的文明发展道路。既创造更多物质财富和精神财富以满足人民日益增长的美好生活需要，也提供更多优质生态产品经满足人民日益增长的优美生态需要。\n中国的现代化是走和平发展道路的现代化。我国现代化强调同世界各国互利共赢，推动构建人类命运共同体，努力为人类和平与发展作出贡献。\n","slug":"temp_形势政策","date":"2022-12-06T07:04:17.363Z","categories_index":"考试","tags_index":"考试,形式政策","author_index":"FangH"},{"id":"696f02b3075e4b4944dbfb1eaebb278e","title":"软件构件考试","content":"软件构件2016 A一、选择题\n\\1. 设计模式一般是用来解决什么问题的（ D  ）。\nA．需求获取中业务领域知识获取     \nB．测试用例的设计\nC．编码中如何组织代码         \nD．同一问题的不同表象\n\\2. 开闭原则的含义是一个软件实体（ A  ）。\nA．应该对扩展开发，对修改关闭     \nB．对修改开放，对扩展关闭\nC．在应用子类的地方可以使用父类代替 \n D．应该尽可能的使用大粒度的类实现\n\\3. 以下不属于创建型设计模式的是（ B  ）。\nA．工厂模式             \n B．Proxy模式\nC．抽象工厂              \nD．Builder模式\n\\4. 在应用程序开发中那种设计模式可以用于分离出算法（ A  ）。\nA.策略模式              \nB.中介模式\nC.组合模式             \n D.适配器模式\n\\5. 下列属于结构型设计模式的是（ C  ）。\nA．工厂模式            \n  B．中介模式\nC．组合模式             \n D．命令模式\n\\6. 不和陌生人说话（ B  ）是的通俗表示表述。\nA．接口隔离原则            \nB. 迪米特法则\nC. 开闭原则             \n D. 依赖倒置原则\n\\7. 下列属于面向对象基本原则的是（ C  ）\nA. 继承             \n B. 封装\nC. 里氏代换           \nD. 都不是\n\\8. 要依赖于抽象，不要依赖具体。即针对接口编程，不要针对实现编程,是（ D  ）的表述。  \nA. 开-闭原则           \n B. 接口隔离原则\nC. 里氏代换原则        \n  D. 依赖倒转原则\n\\9. 设计模式的两大主题是（ D  ）\nA. 系统的维护与开发       \nB. 对象组合与类的继承 C. 系统架构与系统开发     \n D. 系统复用与系统扩展\n\\10. 以下对”开-闭”原则的一些描述错误的是? （ A ）\nA. “开-闭”原则与”对可变性的封装原则”没有相似性.\nB. 找到一个系统的可变元素,将它封装起来,叫”开-闭”原则\nC. 对修改关闭: 是其原则之一\nD. 从抽象层导出一个或多个新的具体类可以改变系统的行为,是其原则之一\n\\11. 以下意图那个是用来描述SINGLETON（单例模式）? （ B  ）\nA. 将一个类的接口转换成客户希望的另外一个接口。该模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\nB. 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\nC. 定义一系列算法，并把他们分装起来， 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。\nD. 用一个中介对象来封装一系列的对象交互。\n\\12. 以下意图那个是用来描述COMPOSITE（组合模式）? （ C  ）\nA. 为其他对象提供一种代理以控制对这个对象的访问。\nB. 运用共享技术有效地支持大量细粒度的对象。\nC. 将对象组合成树形结构以表示 “部分-整体” 的层次结构。\nD. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\\13. 以下意图那个是用来描述 FACADE（外观模式）?( A )\nA. 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\nB. 定义一个用于创建对象的接口，让子类决定实例化哪一个类。\nC. 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\nD. 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\n\\14. 以下意图那个是用来描述 VISITOR（访问者模式）?( B )\nA. 定义对象间的一种一对多的依赖关系, 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\nB. 表示一个作用于某对象结构中的各元素的操作。\nC. 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\nD. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n\\15. 设计模式的原理? ( C )\nA. 面对实现编程           \nB. 面向对象编程\nC. 面向接口编程         \n D. 面向组合编程\n二、填空题\n \\1. 工厂模式分为 简单工厂、工厂模式、抽象工厂 三种类型。\n \\2. 创立型模式的根本意图是要把（对象的创建）和（使用分离）的责任进行分离，从而降低系统的（耦合度）。\n \\3. MVC模型的基本工作原理是基于（观察者）模式，实现是基于（命令）模式。\n \\4. 设计模式的基本要素有： 名字、意图 、问题 、方案、参与者与协作者 、实现、一般性结构\n \\5. 接口是可以在整个模型中反复使用的一组行为，是一个没有（属性）而只有（方法）的类。\n \\6. 软件体系结构是指一个系统的有目的的设计和规划，这个设计规划既不描述（活动），也不描述（系统怎么开发），它只描述系统的（组成元素）及其相互的交互协作。\n三、简答题\n \\1. 什么是设计模式？设计模式目标是什么？\n设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。\n使用设计模式是为了可重用代码、让代码更容易被他人理解，保证代码可靠性\n \\2. 设计模式中一般都遵循的原则有什么？\n开闭原则、根据场景进行设计原则、优先组合原则、包容变化原则\n \\3. 在MVC模型中M、V、C分别指什么？简述它们之间的关系？\nM: 模型(Model), V:视图(View) C:控制Controller)。\nModel层实现系统中的业务逻辑，通常可以用JavaBean或EJB来实现。 View层用于与用户的交互，通常用JSP来实现。 Controller层是Model与View之间沟通的桥梁，它可以分派用户的请求并选择恰当的视图以用于显示，同时它也可以解释用户的输入并将它们映射为模型层可执行的操作。\n \\4. 面向对象系统中功能复用的两种最常用技术是什么？\n类继承和对象组合\n \\5. 只根据抽象类中定义的接口来操纵对象有什么好处？\n   客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口\n   客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。\n四、应用题\n \\1. 画出工厂方法模式的结构图。什么情况下适合使用工厂方发模式？（8分）  \n\n\n\n\n\n\n\n\n\nInterface Product\n​    Interface ConcreteProduct 实现 Product\n​    Class Creator –&gt; product FactoryMethod()\n​                 \t\t –&gt;  void AnOperation()\n​    ConcreteCreator 继承 Creator à concreteproduct FactoryMethod() overide\n其中product：为工厂模式所要创建的对象类型定义一个接口。\nConcrete product:实现product接口。\nCreator：声明工厂方法（factory method）返回值为product的一个对象。\nConcrete creator：覆写factory Method()，返回值为concrete product 的一个具体实例。\n\n当客户程序不需要知道要使用对象的创建过程。 \n\n客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。\n\n\n\\2. 请用命令设计模式实现下图所示系统（12分）\n题目：发送者（开关）— 命令（电线）– 接收者（电灯）\n1234567891011public abstract class Command &#123;  protected Appliance appliance;  public Command(Appliance appliance)  &#123;      this.appliance=appliance;  &#125;  abstract public void excute();&#125; \n\n\n\n12345interface Appliance &#123;  public void on();  public void off();&#125;\n\n\n\n2016 B一、选择题\n\\1. 对于依赖倒转的表述错误的是（ D ）\nA. 依赖于抽象而不依赖于具体，也就是针对接口编程。 B. 依赖倒转的接口并非语法意义上的接口，而是，一个类对其他对象进行调用时，所知道的方法集合。 C. 从选项B的角度论述，一个对象可以有多个接口。 D. 此题没有正确答案。\n\\2. 以下意图那个是用来描述桥接模式? （ B  ）\nA. 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\nB. 将抽象部分与它的实现部分分离，使它们都可以独立地变化。\nC. 将一个复杂对象的构建与它的表示分离，使得同样构建过程可以创建不同的表示。\nD. 动态地给一个对象添加一些额外的职责。\n\\3. 以下属于属于创建型设计模式的是（ C  ）。\nA．外观模式               \nB．中介模式\nC．抽象工厂              \n D．命令模式\n\\4. 对象组合的有点表述不当的是（ D  ）\nA. 容器类仅能通过被包含对象的接口来对其进行访问。\nB. “黑盒” 复用，封装性好，因为被包含对象的内部细节对外是不可见。\nC. 通过获取指向其它的具有相同类型的对象引用，可以在运行期间动态地定义（对象的）组合\nD.造成极其严重的依赖关系。\n\\5. 在应用程序开发中那种设计模式可以用于分离出算法（ A  ）。\nA. 策略模式               \nB. 中介模式\nC. 组合模式             \n D. 适配器模式\n\\6. 下列不属于结构型设计模式的是（ A  ）。\nA．命令模式               \nB．适配器模式\nC．组合模式             \n D．外观模式\n\\7. 当我们想创建一个具体的对象而又不希望指定具体的类时，可以使用（ A  ）模式。\n A.创建型               \nB.结构型\n C行为型               \n D.以上都可以\n\\8. 在观察者模式中，表述错误的是（ C  ）\nA.观察者角色的更新是被动的。\nB.被观察者可以通知观察者进行更新\nC.观察者可以改变被观察者的状态，再由被观察者通知所有观察者依据被观察者的状态进行。\nD.以上表述全部错误。\n\\9. 开闭原则的含义是一个软件实体（ A ）。\nA．应该对扩展开发，对修改关闭      \nB．对修改开放，对扩展关闭\nC．在应用子类的地方可以使用父类代替 \n  D．应该尽可能的使用大粒度的类实现\n\\10. 关于继承表述错误的是：（ D  ）\nA.继承是一种通过扩展一个已有对象的实现，从而获得新功能的复用方法。\nB.泛化类（超类）可以显式地捕获那些公共的属性和方法。特殊类（子类）则通过附加属性和方法来进行实现的扩展。\nC.破坏了封装性，因为这会将父类的实现细节暴露给子类。\nD.继承本质上是“白盒复用”，对父类的修改，不会影响到子类。\n\\11. 设计模式一般是用来解决什么问题的（ A  ）。\nA．同一问题的不同表象        \n B．测试用例的设计\nC．编码中如何组织代码          \nD． 需求获取中业务领域知识获取的问题\n\\12. 以下意图那个是用来描述 ITERATOR(迭代器)? （ C  ）\nA.使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。\nB.用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\nC.提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。\nD.运用共享技术有效地支持大量细粒度的对象。\n\\13. 下图结构图描述的是那种 模式? （ A  ）\nA.  ABSTRACT FACTORY（抽象工厂）\nB. FACTORY METHOD（工厂方法） C. BUILDER（生成器）\nD. BRIDGE（桥接）\n\\14. 下图结构图描述的是那种模式? （ C  ）\nA.  STRATEGY(策略)\nB.  OBSERVER（观察者）\nC.  ADAPTER（适配器）\nD. BUILDER（生成器）\n\\15. 下列模式中,属于行为模式的是（ B  ）\n A. 工厂模式           \n B. 观察者\n C. 适配器            \n D. 以上都是\n二、填空题\n\\1. 工厂模式分为 简单工厂，工厂模式，抽象工厂 三种类型。\n\\2. 创立型模式的根本意图是要把 对象的创建 和 使用分离 的责任进行分离，从而降低系统的 耦合度。\n\\3. 面向对象的七条基本原则包括： 开闭原则，里式代换原则，合成聚合原则，依赖倒转，迪米特法则，单一原则，接口隔离\n\\4. 在存在继承关系的情况下，方法向 超类 方向集中，而数据向 子类 方向集中。\n\\5. 适配器模式，分为类的适配器和对象的适配器两种实现。其中类的适配器采用的是 继承 关系，而对象适配器采用的是 组合聚合 关系。\n6． 单例模式 模式确保某一个类仅有一个实例，并自行实例化并向整个系统提供这个实例。\n7．组合模式 模式将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。\n8．外观模式 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，为子系统中的一组接口提供一个一致的界面。\n三、简答题\n \\1. 设计模式具有哪三大特点？ \n  可重用性, 可传授性, 名称，每个设计模式都有名称。\n \\2. 为什么面向对象的分析和设计中优先使用组合，而非继承？\n  继承关系有很多缺点，如果合理使用组合则可以有效的避免这些缺点，使用组合关系将系统对变化的适应力从静态提升到动态，而且由于组合将已有对象组合到了新对象中，因此新对象可以调用已有对象的功能。\n 3．单例模式的两种实现方法，并说明优缺点？\n懒汉式，在类被加载时，唯一的实例已经被创建。这个模式在java中很容易实现，在其他语言中很难.\n  饿汉式，在类加载的时候不创建单例实体。只有在第一次请求实例的时候创建，并且只在第一次创建后不再创佳该类的实例\n \\4. 简述依赖例转原则的基本思想。请举出一个使用了软件依赖原则的软件设计模式，其中何处体现了依赖原则。\n  高层模块不应该依赖于低层模块，二者都应该依赖于抽象\n抽象不应该依赖于细节，细节应该不依赖于抽象\n \\5. 列举两个可以使我们在程序中不必使用if…else结构的软件设计模式。使用软件设计模式是如何做到这一点的？   策略模式（strategy）和状态模式（state）\n  策略模式是将不同算法（处理方法）封装到stategy类中，状态模式是将不同状态封装到state类中。二者都是通过，类中的子类，实现不同情况的调用，从而有效的替换充满在程序中的 if else 语句。\n四、综合题\n \\1. 我们经常碰到这种需求：通过公共场合传递文件，文件是用明文写的，凡是拿到这个文件都能看懂，传递过程中又不希望别人能看懂，于希望对文件内容进行加密。因为信息是不是军事机密，我们仅仅是想不被别人看明白，外传递过程中，传递人几乎不懂计算机的加密算法，那么很简单了，我们选择简单的字符移位的方法来实现加密。\n  请用外观模式实现这个文件传递过程，分别封装外观类，加密和解密类，文件存取类，客户端类。（Java语言或者类Java语言描述，语法可以不完全正确，但业务逻辑流程必须正确）\n123456789101112131415161718public class FileWriter &#123;  public void write(String encryptStr,String fileNameDes) throws IOException, FileNotFoundException  &#123;   System.out.println(&quot;处理后的文件&quot;);   File fs=new File(fileNameDes);         OutputStream outputStream=null;   if (!fs.exists())fs.createNewFile();         outputStream=new FileOutputStream(fs)   byte[] str=encryptStr.getBytes();         outputStream.write(str);   outputStream.flush();   outputStream.close();  &#125;\n\n\n\n12345678910111213141516171819public class FileReader &#123;  public String read(String fileNameSrc) throws FileNotFoundException, IOException  &#123;   System.out.println(&quot;以字节为单位读取文件内容，一次读一个字节：&quot;);   File fs=new File(fileNameSrc);   String result = null;   InputStream in=null;   in= new FileInputStream(fs);   byte[] bs=new byte[(int) fs.length()];   in.read(bs);   result=new String(bs);   in.close();   System.out.println(result);   return result;  &#125;&#125;\n\n1234567891011121314151617181920212223242526public class EncryptFacade&#123;  \tprivate FileReader reader;  \tprivate EncryptDencrypt enDencrypt;  \tprivate FileWriter writer;  \tpublic EncryptFacade() &#123;  \tsuper();   \tthis.reader = new FileReader();   \tthis.enDencrypt = new EncryptDencrypt();   \tthis.writer = new FileWriter();\tpublic void fileEncrypt(String fileNameSrc,String fileNameDes) throws IOException \t&#123;   \t\tString plainStr=reader.read(fileNameSrc);   \t\tString encryptStr=enDencrypt.encrypt(plainStr);   \t\twriter.write(encryptStr, fileNameDes);\t&#125;\tpublic void fileDencrypt(String fileNameEncode,String fileNameDecode) throws IOException \t&#123;   \t\tString encryptText=reader.read(fileNameEncode);   \t\tString plainStr=enDencrypt.deencrypyt(encryptText);   \t\twriter.write(plainStr, fileNameDecode);  \t&#125;&#125;\n\n\n\n123456789101112131415161718192021222324252627282930public class EncryptDencrypt &#123;  public String encrypt(String plainText)  &#123;      System.out.println(&quot;数据加密，将明文转换为密文:&quot;);      String esString=&quot;&quot;;      char[] chars=plainText.toCharArray();      for (char c : chars)      &#123;          char temp=(char)(Integer.valueOf(c)-5);          esString=esString+temp;      &#125;      System.out.println(esString);      return esString;  &#125;  public String deencrypyt(String encryptText)   &#123;      System.out.println(&quot;数据解密，将密文转换为明文:&quot;);\tString deString=&quot;&quot;;\tchar[] chars=encryptText.toCharArray();\tfor (char c : chars)     &#123;        char temp=(char)(Integer.valueOf(c)+5);        deString=deString+temp;    &#125;      System.out.println(deString);      return deString;  &#125;&#125;\n\n\n\n1234567891011public class Client &#123;   public static void main(String[] args) throws IOException &#123;   EncryptFacade f=new EncryptFacade();   System.out.println(&quot;加密文件：&quot;);   f.fileEncrypt(&quot;src.txt&quot;, &quot;des.txt&quot;);          System.out.println(&quot;解密文件：&quot;);   f.fileDencrypt(&quot;des.txt&quot;, &quot;dsrc.txt&quot;);  &#125;&#125;","slug":"temp_软件构件","date":"2022-12-06T07:04:17.361Z","categories_index":"考试","tags_index":"考试,软件构件","author_index":"FangH"},{"id":"2a4416dfe7e87d0be836e5eac76b7a8f","title":"Linux考试","content":"Linux1.0一、填空题1．GNU的含义是GNU’s Not Unix的递归缩写。\n2．Linux一般有3个主要部分：内核（kernel）、命令解释层（Shell或其他操作环境）、实用工具。\n3．**”&#x2F;etc&#x2F;sysconfig&#x2F;network”**文件主要用于设置基本的网络配置，包括主机名称、网关等。\n4．一块网卡对应一个配置文件，配置文件位于目录**”&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts”中，文件名以“ifcfg-“**开始。\n5．**”&#x2F;etc&#x2F;resolv.conf”**文件是DNS客户端用于指定系统所用的DNS服务器的IP地址。\n6．POSIX是便携式操作系统接口的缩写，重点在规范核心与应用程序之间的接口，这是由美国电气与电子工程师学会（IEEE）所发布的一项标准。\n7．当前的Linux常见的应用可分为企业应用与个人应用两个方面。\n8．Linux的版本分为内核版本和发行版本两种。\n9．安装Linux最少需要两个分区，分别是swap交换分区  ，**”&#x2F;（根）”**分区。\n10．Linux默认的系统管理员账号是root。\n二、选择题1．Linux最早是由计算机爱好者（  ）开发的。\n  A．Richard Petersen\n  B．Linus Torvalds \n  C．Rob Pick\n  D．Linux Sarwar\n2．下列中（  ）是自由软件。\nA．Windows XP\nB．UNIX\nC．Linux\nD．Windows 2008\n3．下列中（  ）不是Linux的特点。\n  A．多任务\n B．单用户 \n C．设备独立性  \n D．开放性\n4．Linux的内核版本2.3.20是（  ）的版本。\nA．不稳定   \nB．稳定的  \nC．第三次修订  \nD．第二次修订\n5．Linux安装过程中的硬盘分区工具是（  ）。\n  A．PQmagic       \nB．FDISK      \n C．FIPS             \nD．Disk Druid\n6．Linux的根分区系统类型可以设置成（  ）。\n  A．FATl6         \nB．FAT32        \nC．ext4              \nD．NTFS\n7．以下哪个命令能用来显示server当前正在监听的端口? （  ）\n  A．ifconfig          \nB．netlst         \nC．iptables       \nD．netstat\n8．以下哪个文件存放机器名到IP地址的映射? （  ）\n  A．**”&#x2F;etc&#x2F;hosts”**      B．&#x2F;etc&#x2F;host      C．&#x2F;etc&#x2F;host.equiv     D．&#x2F;etc&#x2F;hdinit\n9．Linux系统提供了一些网络测试命令，当与某远程网络连接不上时，就需要跟踪路由查看，以便了解在网络的什么位置出现了问题，请从下面的命令中选出满足该目的的命令。（  ）\n  A．ping           B．ifconfig       C．traceroute       D．netstat\n三、补充表格请将nmcli命令的含义列表补充完整。\n\n\n\nnmcli connection show\n显示所有连接\n\n\n\nnmcli connection show –active\n显示所有活动的连接状态\n\n\nnmcli connection show “ens33”\n显示网络连接配置\n\n\nnmcli device status\n显示设备状态\n\n\nnmcli device show ens33\n显示网络接口属性\n\n\nnmcli connection add help\n查看帮助\n\n\nnmcli connection reload\n重新加载配置\n\n\nnmcli connection down test2\n禁用test2的配置，注意一个网卡可以有多个配置。\n\n\nnmcli connection up test2\n启用test2的配置\n\n\nnmcli device disconnect ens33\n禁用ens33网卡，物理网卡\n\n\nnmcli device connect ens33\n启用ens33网卡\n\n\n四、简答题（部分）1．简述Linux的体系结构。\nLinux是由内核、bootloader、文件系统，Shell和应用程序构成\n2．使用虚拟机安装Linux系统时，为什么要先选择稍后安装操作系统，而不是去选择RHEL 7系统镜像光盘？\n在配置界面中若直接选择了RHEL 7系统镜像，则VMware Workstation虚拟机会使用内置的安装向导自动进行安装，最终安装出来的系统跟我们后续进行实验所需的系统环境会不一样。\n3．简述RPM与Yum软件仓库的作用。\nRPM是为了简化安装的复杂度，而Yum软件仓库是为了解决软件包之间的依赖关系。\n4．安装Red Hat Linux系统的基本磁盘分区有哪些?\n &#x2F;swap, &#x2F;, &#x2F;boot, &#x2F;var, &#x2F;tmp, &#x2F;home, &#x2F;usr\n5．Red Hat Linux系统支持的文件类型有哪些？\n纯文本文件, 二进制文件, 数据格式的文件, 目录文件, 连接文件\n6．RHEL 7系统采用了systemd作为初始化进程，那么如何查看某个服务的运行状态？\n执行命令“systemctl status 服务名.service”可查看服务的运行状态，其中服务名后的.service可以省略。\n2.7  练习题一、填空题1．在Linux系统中命令区分大小写。在命令行中，可以使用Tab键来自动补齐命令。\n2．如果要在一个命令行上输入和执行多条命令，可以使用分号来分隔命令。\n3．断开一个长命令行，可以使用  ” \\ “  ，以将一个较长的命令分成多行表达，增强命令的可读性。执行后，Shell自动显示提示符 “&gt;” ，表示正在输入一个长命令。\n4．要使程序以后台方式执行，只需在要执行的命令后跟上一个 “&amp;” 符号。\n二、选择题1．（  ）命令能用来查找在文件TESTFILE中包含4个字符的行。\n  A．grep ‘???? ‘ TESTFILE                \nB．grep ‘…. ‘ TESTFILE\n  C．grep ‘^????$’ TESTFILE           \nD．grep ‘^….$ ‘ TESTFILE\n2．（  ）命令用来显示&#x2F;home及其子目录下的文件名。\n  A．ls -a &#x2F;home     \nB．ls -R &#x2F;home    \nC．ls -l &#x2F;home \nD．ls -d &#x2F;home\n3．如果忘记了ls命令的用法，可以采用（  ）命令获得帮助。\n  A．？ls           \nB．help ls        \nC．man ls        \nD．get ls\n4．查看系统当中所有进程的命令是（  ）。\n  A．ps all          \nB．ps aix             \nC．ps auf            \nD．ps aux \n5．Linux中有多个查看文件的命令，如果希望在查看文件内容过程中用光标可以上下移动来查看文件内容，则符合要求的那一个命令是（  ）。\n  A．cat            \nB．more         \nC．less          \nD. head\n6．（  ）命令可以了解您在当前目录下还有多大空间。\n  A．df                \n B．du  &#x2F;        \nC．du  .         \nD．df .\n7．假如需要找出 &#x2F;etc&#x2F;my.conf 文件属于哪个包（package），可以执行（  ）命令。\n  A．rpm -q &#x2F;etc&#x2F;my.conf               \nB．rpm -requires &#x2F;etc&#x2F;my.conf \n  C．rpm -qf &#x2F;etc&#x2F;my.conf              \nD．rpm -q | grep &#x2F;etc&#x2F;my.conf \n8．在应用程序启动时，（  ）命令设置进程的优先级。\n  A．priority           \n B．nice          \nC．top           \nD．setpri\n9．（  ）命令可以把f1.txt复制为f2.txt。\n  A．cp f1.txt | f2.txt                   \nB．cat f1.txt | f2.txt \n  C．cat f1.txt &gt; f2.txt                 \nD．copy f1.txt | f2.txt\n10．使用（  ）命令可以查看Linux的启动信息。\n   A．mesg –d      \nB．dmesg        \nC．cat &#x2F;etc&#x2F;mesg   \nD．cat &#x2F;var&#x2F;mesg\n3.3 练 习 题一、填空题\n1．由于核心在内存中是受保护的区块，因此我们必须通过shell将我们输入的命令与Kernel沟通，以便让Kernel可以控制硬件正确无误地工作。\n2．系统合法的shell均写在**”&#x2F;etc&#x2F;shells”**文件中。 \n3．用户默认登录取得的shell记录于**”&#x2F;etc&#x2F;passwd”**的最后一个字段。 \n4．bash的功能主要有命令编辑功能；命令与文件补全功能；命令别名设置功能；作业控制、前台与后台控制；程序化脚本；通配符等。 \n5．shell变量有其规定的作用范围，可以分为全局变量与局部变量。\n6．set可以观察目前bash环境下的所有变量。\n7．通配符主要有**”*、?、[]”**等。\n8．正则表示法就是处理字符串的方法，是以行为单位来进行字符串的处理的。\n9．正则表示法通过一些特殊符号的辅助，可以让使用者轻易地查找、删除、替换某个或某些特定的字符串。\n10．正则表示法与通配符是完全不一样的。通配符（wild card）代表的是bash操作接口的一个功能，但正则表示法则是一种字符串处理的表示方式。 \n二、简述题\n1．vim的3种运行模式是什么？如何切换？\n命令模式、插入模式、底行模式\n2．什么是重定向？什么是管道？什么是命令替换？\n把命令执行的结果重新输入到一个文件中;\n将一个命令的输出，传给另外一个命令，作为另外一个命令的输入;\n通知所有人\n3．Shell变量有哪两种？分别如何定义？\n私有变量: A1&#x3D;”1234” delcare A2&#x3D;”2345”\n环境变量：A1&#x3D;”1234” export A1 \n4．如何设置用户自己的工作环境？\n~&#x2F;.profile\n4.8 练习题一、填空题\n1．Linux操作系统是多用户多任务的操作系统，它允许多个用户同时登录到系统，使用系统资源。\n2．Linux系统下的用户账户分为两种：普通用户和超级用户（root）。\n3．root用户的UID为　0　，普通用户的UID可以在创建时由管理员指定，如果不指定，用户的UID默认从500开始顺序编号。\n4．在Linux系统中，创建用户账户的同时也会创建一个与用户同名的组群，该组群是用户的主组群。普通组群的GID默认也从500开始编号。\n5．一个用户账户可以同时是多个组群的成员，其中某个组群是该用户的主组群（私有组群），其他组群为该用户的附属组群（标准组群）。\n6．在Linux系统中，所创建的用户账户及其相关信息（密码除外）均放在**”&#x2F;etc&#x2F;passwd”**配置文件中。\n7．由于所有用户对&#x2F;etc&#x2F;passwd文件均有读取权限，为了增强系统的安全性，用户经过加密之后的口令都存放在**”&#x2F;etc&#x2F;shadow”**文件中。\n8．组群账户的信息存放在**”&#x2F;etc&#x2F;group”文件中，而关于组群管理的信息（组群口令、组群管理员等）则存放在“&#x2F;etc&#x2F;gshadow”**文件中。\n二、选择题\t\n1．哪个目录存放用户密码信息？（  ）\n  A．&#x2F;etc            \nB．&#x2F;var          \nC．&#x2F;dev          \nD．&#x2F;boot\n2．请选出创建用户ID 是200、组ID是1000、用户主目录为&#x2F;home&#x2F;user01的正确命令。（  ）\n  A．useradd -u:200 -g:1000 -h:&#x2F;home&#x2F;user01 user01\n  B．useradd -u&#x3D;200 -g&#x3D;1000 -d&#x3D;&#x2F;home&#x2F;user01 user01\n  C．useradd -u 200 -g 1000 -d &#x2F;home&#x2F;user01 user01\n  D．useradd -u 200 -g 1000 -h &#x2F;home&#x2F;user01 user01\n3．用户登录系统后首先进入下列哪个目录?（  ）\n  A．&#x2F;home                          \nB．&#x2F;root的主目录 \n  C．&#x2F;usr                            \nD．用户自己的家目录\n4．在使用了shadow口令的系统中，&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow两个文件的权限正确的是（  ）。\n  A．-rw-r—– , -r——–       \nB．-rw-r–r– , -r–r–r—\n  C．-rw-r–r– , -r——–       \nD．-rw-r–rw- , -r—–r—\n5．下面哪个参数可以删除一个用户并同时删除用户的主目录？（  ）\n  A．rmuser –r       \nB．deluser –r     \nC．userdel –r     \nD．usermgr -r\n6．系统管理员应该采用哪些安全措施?（  ）\n  A．把root密码告诉每一位用户         \n  B．设置telnet服务来提供远程系统维护\n  C．经常检测账户数量、内存信息和磁盘信息  \n  D．当员工辞职后，立即删除该用户账户\n7．在&#x2F;etc&#x2F;group中有一行students::600:z3,14,w5，表示有多少用户在student组里？（  ）\n  A．3              \nB．4            \nC．5            \nD．不知道\n8．下列的哪些命令可以用来检测用户lisa的信息？（  ）\n  A．finger lisa                             \n B．grep lisa &#x2F;etc&#x2F;passwd   \n  C．find lisa &#x2F;etc&#x2F;passwd                   \n D．who lisa\n5.4 练习题一、选择题\\1. 假定kernel支持vfat分区，下面哪一个操作是将&#x2F;dev&#x2F;hda1，一个Windows分区加载到&#x2F;win目录？（ D）\nA. mount  -t windows  &#x2F;win  &#x2F;dev&#x2F;hda1 \nB. mount  -fs&#x3D;msdos &#x2F;dev&#x2F;hda1  &#x2F;win\nC. mount  -s  win   &#x2F;dev&#x2F;hda1 &#x2F;win  \nD. mount –t  vfat  &#x2F;dev&#x2F;hda1  &#x2F;win\n\\2. 请选择关于&#x2F;etc&#x2F;fstab的正确描述。（ B ）\nA. 启动系统后，由系统自动产生。\nB. 用于管理文件系统信息。\nC. 用于设置命名规则，是否使用可以用TAB来命名一个文件。\nD. 保存硬件信息。  \n\\3. 存放Linux基本命令的目录是什么（ A）\nA. &#x2F;bin   \nB. &#x2F;tmp   \nC. &#x2F;lib  \nD. &#x2F;root\n\\4. 对于普通用户创建的新目录，哪个是缺省的访问权限？（ A ）\nA. rwxr-xr-x  \nB. rw-rwxrw-   \nC. rwxrw-rw-  \nD. rwxrwxrw-\n\\5. 如果当前目录是&#x2F;home&#x2F;sea&#x2F;china，那么“china”的父目录是哪个目录？（ A）\nA. &#x2F;home&#x2F;sea   \nB. &#x2F;home&#x2F;   \nC. &#x2F;   \nD. &#x2F;sea\n\\6. 系统中有用户user1和user2，同属于users组。在user1用户目录下有一文件file1，它拥有644的权限，如果user2想修改user1用户目录下的file1文件，应拥有（ B）权限？ \nA. 744   \nB. 664   \nC. 646   \nD. 746\n\\7. 在一个新分区上建立文件系统应该使用命令（ C ）\nA. fdisk   \nB. makefs   \nC. mkfs   \nD. format\n\\8. 用ls –al 命令列出下面的文件列表，问哪一个文件是符号连接文件？（ D）\nA. -rw——- 2 hel-s users  56 Sep 09 11:05 hello\nB. -rw——- 2 hel-s users  56 Sep 09 11:05 goodbey\nC. drwx—– 1 hel  users 1024 Sep 10 08:10 zhang\nD. lrwx—– 1 hel users 2024  Sep 12 08:12  cheng\n\\9. Linux文件系统的目录结构是一棵倒挂的树，文件都按其作用分门别类地放在相关的目录中。现有一个外部设备文件，我们应该将其放在（C ）目录中。\nA. &#x2F;bin   \nB. &#x2F;etc   \nC. &#x2F;dev   \nD. lib \n\\10. 如果umask设置为022，缺省的创建的文件的权限为：（ D ）\nA. —-w–w- \nB.  –rwxr-xr-x \nC. r-xr-x— \nD. rw-r–r–\n二、填空题\\1. 文件系统（File System）是磁盘上有特定格式的一片区域，操作系统利用文件系统保存和管理文件。\n\\2. ext文件系统在1992年4月完成。称为扩展文件系统，是第一个专门针对Linux操作系统的文件系统。Linux系统使用ext2&#x2F;ext3&#x2F;ext4文件系统。\n\\3. ISO 9660是光盘所使用的标准文件系统。\n\\4. Linux的文件系统是采用阶层式的树状目录结构，在该结构中的最上层是根目录“&#x2F;”。\n\\5. 默认的权限可用umask命令修改，用法非常简单，只需执行“umask 777”命令，便代表屏蔽所有的权限，因而之后建立的文件或目录，其权限都变成000。\n\\6. 在Linux系统安装时，可以采用Disk Druid、RAID和LVM等方式进行分区。除此之外，在Linux系统中还有fdisk、cfdisk、parted等分区工具。\n\\7. RAID（Redundant Array of Inexpensive Disks），中文全称是独立磁盘冗余阵列，用于将多个廉价的小型磁盘驱动器合并成一个磁盘阵列，以提高存储性能和容错功能。RAID可分为软RAID和硬RAID，软RAID通过软件实现多块硬盘冗余。\n\\8. LVM（Logical Volume Manager）的中文全称是逻辑卷管理器，最早应用在IBM AIX系统上。它的主要作用是动态分配磁盘分区及调整磁盘分区大小，并且可以让多个分区或者物理硬盘作为一个逻辑卷（相当于一个逻辑硬盘）来使用。\n\\9. 可以通过索引节点数和磁盘块区数来限制用户和组群对磁盘空间的使用。\n三、简答题1． RAID技术主要是为了解决什么问题呢？\n答：RAID技术可以解决存储设备的读写速度问题及数据的冗余备份问题。\n2． RAID 0和RAID 5哪个更安全？\n答：RAID 0没有数据冗余功能，因此RAID 5更安全。\n3．位于LVM最底层的是物理卷还是卷组？\n答：最底层的是物理卷，然后在通过物理卷组成卷组。\n4． LVM对逻辑卷的扩容和缩容操作有何异同点呢？\n答：扩容和缩容操作都需要先取消逻辑卷与目录的挂载关联；扩容操作是先扩容后检查文件系统完整性，而缩容操作为了保证数据的安全，需要先检查文件系统完整性再缩容。\n5． LVM的快照卷能使用几次？\n答：只可使用一次，而且使用后即自动删除。\n6． LVM的删除顺序是怎么样的？\n答：依次移除逻辑卷、卷组和物理卷。\n6.4 练习题一、选择题\n\\1. TCP&#x2F;IP中，哪个协议是用来进行IP地址自动分配的？（ C ）\nA. ARP \nB.  NFS \nC.  DHCP \nD. DDNS\n\\2. DHCP租约文件默认保存在（ D ）目录中。\nA. &#x2F;etc&#x2F;dhcpd  \nB. &#x2F;var&#x2F;log&#x2F;dhcpd \nC. &#x2F;var&#x2F;log&#x2F;dhcp  \nD. &#x2F;var&#x2F;lib&#x2F;dhcp\n\\3. 配置完DHCP服务器，运行（ AB ）命令可以启动DHCP服务。\nA. service dhcpd start  \nB. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;dhcpd start \nC. start dhcpd      \nD. dhcpd on\n二、填空题\n1．DHCP工作过程包括DHCP Discover  DHCP offer  DHCP Request  DHCP Acknowledge 4种报文。\n2．如果DHCP客户端无法获得IP地址，将自动从169.254.0.0&#x2F;16地址段中选择一个作为自己的地址。\n3．在Windows环境下，使用ipconfig命令可以查看IP地址配置，使用ipconfig&#x2F;release命令可以释放IP地址，使用ipconfig&#x2F;renew命令可以续租IP地址。\n4．DHCP是一个简化主机IP地址分配管理的TCP&#x2F;IP标准协议，英文全称是Dynamic Host Configuration Protocol，中文名称为动态主机配置协议。\n5．当客户端注意到它的租用期到了50％以上时，就要更新该租用期。这时它发送一个    DHCP Request信息包给它所获得原始信息的服务器。\n6．当租用期达到期满时间的近 87.5％ 时，客户端如果在前一次请求中没能更新租用期的话，它会再次试图更新租用期。\n7．配置Linux客户端需要修改网卡配置文件，将BOOTPROTO项设置为dhcp。\n三、实践题\n架设一台DHCP服务器，并按照下面的要求进行配置：\n1．为192.168.203.0&#x2F;24建立一个IP作用域，并将192.168.203.60~192.168.203.200范围内的IP地址动态分配给客户机。\n2．假设子网的DNS服务器的IP地址为192.168.0.9，网关为192.168.203.254，所在的域为jnrp.edu.cn，将这些参数指定给客户机使用。\n7.7  练 习 题一、填空题\n1．在Internet中计算机之间直接利用IP地址进行寻址，因而需要将用户提供的主机名转换成IP地址，我们把这个过程称为域名解析\n2．DNS提供了一个分级的命名方案。\n3．DNS顶级域名中表示商业组织的是com。\n4．A表示主机的资源记录，CNAME表示别名的资源记录。\n5．写出可以用来检测DNS资源创建的是否正确的两个工具ping  nslookup。\n6．DNS服务器的查询模式有递归查询  转寄查询。\n7．DNS服务器分为四类：主DNS服务器（Master或Primary） 辅助DNS服务器（Slave或Secondary） 转发DNS服务器 惟高速缓存DNS服务器（Caching-only DNS server）。\n8．一般在DNS服务器之间的查询请求属于转寄查询。\n二、选择题\n1．在Linux环境下，能实现域名解析的功能软件模块是（  ）。\n  A．apache         \nB．dhcpd            \nC．BIND        \nD．SQUID \n2．www.163.com是Internet中主机的（  ）。\n  A．用户名             \nB．密码         \nC．别名         \nD．IP地址    \nE. FQDN\n3．在 DNS服务器配置文件中A类资源记录是什么意思? （  ）\n  A．官方信息                       \nB．IP地址到名字的映射  \n  C．名字到IP地址的映射            \nD．一个name server的规范\n4．在Linux DNS系统中，根服务器提示文件是（   ）。\t\n  A．&#x2F;etc&#x2F;named.ca                    \nB．&#x2F;var&#x2F;named&#x2F;named.ca \n  C．&#x2F;var&#x2F;named&#x2F;named.local          \n D．&#x2F;etc&#x2F;named.local\n5．DNS指针记录的标志是（  ）。\n  A．A       \n B．PTR     \nC．CNAME\nD．NS\n6．DNS服务使用的端口是（  ）。\n  A．TCP 53        \nB．UDP 54       \nC．TCP 54       \nD．UDP 53\n7．以下哪个命令可以测试DNS服务器的工作情况？（  ）。\n  A．dig            \nB．host          \nC．nslookup     \nD．named-checkzone\n8．下列哪个命令可以启动DNS服务？（  ）\n  A．systemctl start named             \nB．systemctl restart named\n  C．service dns start                  \nD．&#x2F;etc&#x2F;init.d&#x2F;dns start\n9．指定域名服务器位置的文件是（  ）。\n  A．&#x2F;etc&#x2F;hosts                        \nB．&#x2F;etc&#x2F;networks  \n  C．&#x2F;etc&#x2F;resolv.conf                   \nD．&#x2F;.profile\n","slug":"temp_Linux","date":"2022-12-04T05:07:37.200Z","categories_index":"考试","tags_index":"Linux,考试","author_index":"FangH"},{"id":"5aa55648d7b2f24c13a30d9efcc0b1bf","title":"Hadoop考试","content":"Hadoop集群2022.11.11\n一、知识点回顾\n\n二、启动集群并测试\n\n2022.11.15\n\n一、安装hadoop出现的问题\n\n二、Hadoop的生态系统\n\n三、分布式文件系统HDFS\n\n二、HDFS简介\n\n三.HDFS相关概念\n\n四.HDFS体系结构\n\n五.HDFS存储原理\n\n六.HDFS数据读写过程\n\n七.HFS编程\n\n\n\n\n一、知识点回顾二、启动集群并测试先删除集群rm -rf &#x2F;usr&#x2F;local&#x2F;hadoop-2.7.7&#x2F;tmp\n1、启动集群 start-all.shjps：查看HDFS相关的节点进程2720 DataNode2897 SecondaryNameNode25783491 Jps3352 NodeManager3066 ResourceManager\nHDES相关的节点进程：主从结构，一主多从NameNode：名称节点，HDFs的主节点，Master,负责HDFs分布式文件系统元数据的存储与处理DataNode：数据节点，HDFS的从节点，通常有1到多个，负责存储数据SecondaryNameNode：第二名称节点，辅助NameNode完成HDFS元数据的管理\nYARN相关的节点进程：主从结构，一主多从ResourceManager：资源管理节点，YARN的主节点，负责整个集群资源的调度与管理NodeManager：YARN的从节点，通常有1到多个，负责管理它所在节点的资源\n2、测试HDS查看：用命令 ：haddop fs：查看完整用法（HDFS：分布式文件系统）Web UI:URI地址，主机名或IP:端口号，默认端口50070上传一个大数据文件进行测试[bg@bgserver ~]$ hadoop fs -mkdir &#x2F;zhan[bg@bgserver ~]$ hadoop fs -put VMware-workstation-full-16.0.0-16894299.exe &#x2F;zhan[bg@bgserver ~]$ hadoop fs -ls &#x2F;zhan3、测式YARN和MR查看：web UI：URI地址，主机名或IP:端口号，默认端口8088跑应用程序\n2022.11.15一、安装hadoop出现的问题1、命令未找到：HADOOP HOME环境变量设置文件不存在：关注JDR的设置与路径2、少节点：查看节点日志文件userlogs：日志文件cat &#x2F;usr&#x2F;local&#x2F;hadoop3、INFO:信息WARN：警告ERROR：错误FATAL：致命错误4、排查：配置文件中结构问题、属性名称、属性值、路径对不对、相关资源权限\n二、Hadoop的生态系统一、Hadoop生态系统相关组件1、hdfs是Hadoop的分布式文件系统，存储，整个生态系统的基础2、YARN，通用的资源管理器3、MapReduce,并行计算框架，适用于批处理计算4、HBase,基于Hadoop分布式数据库，列式数据库5、Hive,基于Hadoop构建的数据仓库，数据存储在HDFS上，可将数据分析的任务写成的SQL查询转换成MapReduce程序进行执行6、Spark，大数据内存计算框架，计算速度快7、Zookeeper,分布式协调器，为集群运算提供分布式锁等机制8、Sqoop，ETL工具，可以实现关系数据库与HDFS之间的数据迁移9、Flume，日志收集工具10、Storm，流计算框架\n备注：数据仓库和数据库的区别：1、数据库存储的是原始数据，没经过任何加工；而数据仓库是为了满足数据分析需要设计的，对源数据进行了ETL（提取转换加载）过程，数据抽取工作分抽取、清洗、转换、装载；2、数据仓库的数据量要比数据库大很多。\nOLTP 和OLAP区别OLTP(Online transaction processing):在线&#x2F;联机事务处理。典型的OLTP类操作都比较简单，主要是对数据库中的数据进行增删改查，操作主体一般是产品的用户。OLAP(Online analytical processing):指联机分析处理。通过分析数据库中的数据来得出一些结论性的东西\n三、分布式文件系统HDFS一、分布式文件系统1·分布式文件系统部署由多个节点构成的计算机集群上。2.分布式文件系统中的节点通常分类两类：一类称主节点，也称Namenode(名称节点)，用于存储和管理文件系统的元数据；另一类是从节点，也称Datanode(数据节点)，负责存储数据，响应客户瑞的数据读写请求，在主节点的调度下实现数据复制与备份。客户端：shell，java API连接拒绝二、HDFS实现的目标优点：不足：（3）不支持多用户写入，随机写文件的修改； 不适合多次写入，一次读取（少量读取）4、不支持多用户的并行写。\n2022.11.18实训1.启动hadoop， 通过jps命令查看启动进程，通过web方式查看namenode和jobtracker，localhost:50070（将查看结果截图放入下方）答：启动hadoop：start-all.sh查看进程:jpsnamenode是HDES Web UIjobtracker是YARN Web UIHDES Web UI:主机名或IP:50070YARN Web UI:主机名或IP:18088小贴士：hadoop fs -ls &#x2F;hdfs dfs -ls &#x2F;考试必考1.[-cat[-ignoreCrc]】查看cp [-f][-p I-p[topax]]…]复杂[-get [-p][-ignoreCrc][-crc]…]【-help[cmd …]帮助[-mkdir[-p]】创建[-mv.】移动[-put[[p][】.】上传错误原因：磁盘错误安全模式：一般是off查看安全模式查看日志：\n\n在hdfs根目录下创建tmp目录，通过ls命令查看hadoop下tmp目录中的文件答：3.进入hadoop目录，执行命令：hadoop fs -ls &#x2F; 列出HDFS上的文件答：cd $HADOOP_HOME\n\n4. 在HDFS上 &#x2F;user下创建一个你自己拼音名字的目录5. 退出hadoop目录，回到用户主目录，创建一个test目录，进入test目录，执行echo “hello world” &gt;test1.txt 命令创建test1.txt文件，并输入hello world内容。&gt;:重定向符\n\n6.继续回到hadoop目录下，将刚才在本地创建的test1.txt上传（put）到HDFS下你名字的目录下。7. 查看HDFS下刚才上传的文件的内容8.退出hadoop目录，回到用户主目录，彻底删除test目录。cdrm -rf testll9.回到hadoop目录下，将HDFS上的test1.txt文件下载到用户主目录并查看hadoop fs -get &#x2F;user&#x2F;zhangsan&#x2F;test1.txt 这个是回到当前目录hadoop fs -get &#x2F;user&#x2F;hanyang&#x2F;test1.txt &#x2F;home&#x2F;bg 回到主目录10.在HDFS上删除test1.txt文件。\n二、HDFS简介1.HDFS是谷歌GFS分布式文件系统的开源实现，Hadoop:生态系统分布式文件系统。2.HDFS的实现目标：（优点）a、兼容廉价的计算机硬件b、流数据读写c、简单的数据访问模型（一次写入，多次读取）d、处理大数据集，文件数据量级在GB到TB级3.HDFS的局限性（不足）a、不适合低延迟数据访问b、无法高效存储大量小文件c、不支特多用户写和随机写\n三.HDFS相关概念1.块（1）HDFS采用文件分块冗余存储的机制，来解决大数据的数据存储与可用性（2）HDFS块通常要普通文件系统的块大很多（3）问答题 分块存储策略带来的好处：支持大规模文件存储、简化系统设计、适合数据备份（4）HDFS与其他分布式文件显著的区别在于：启用机架感知机制2.名称节点（1）名称节点是HDFS的主节点，存诸HDFS文件系统的元数据（2）两个重要数据结构：FsImage和EditlogFsImage存放某个时间点上，HDFS文件系统元数据快照Editlog存储是对HDFS 文件系统的更新操作3.第二名称节点SecondaryNameNode，辅助节点\n随着时间推移，Editlog会不断变大。HDFS会定期检查Editlog，让SecondaryNameNode启动复制合并机制：SecondaryNameNode会将FsImage和Editlog从NameNode所在节点拉取到自己所在的节点（之后的HDFS更新操作会写入一个新的Editlog文件)，对FsImage和Editlog文件进行合并，得到新的FsImage,再将新FsImage送回Namenode所在节点。\n如果Namenode挂掉，存在的元数据丢失，如何恢复集群，SecondaryNameNode有一个FsImage备份（冷备份）SecondaryNameNode能起到冷备份作用。\n4.数据节点（1）数据节点，是HDFS的从节点，通常有多个（2）数据节点负责存放数据，负责响应客户端数据的读写请求（3）数据节点会定期向名称节点报告自己的信息（心跳信息），说明自己是否可用、数据块列表等datanode通过心跳信息告诉namenode自己还在后，namenode才调度读写任务给datanode\n四.HDFS体系结构1、概述（1）HDFS采用了主从(Master&#x2F;Slave)结构模型，一个HDFS集群包括一个名称节点(NameNode)和若干个数据节点(DataNode)。默认块大小 dfs.blocksize 默认 128MB默认块副本数 dfs.replication 默认为3\n（2）名称节点作为中心服务器，负责管理文件系统的命名空间及客户端对文件的访问。（3）集群中的数据节点一般是一个节点运行一个数据节点进程，负责处理文件系统客户端的读&#x2F;写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作。（4）每个数据节点的数据实际上是保存在本地Linux文件系统中的。\n\n2、HDFS命名空间（1）HDFS命名空间：独立、唯一（2）HDFS命名空间面向所有应用、项目，相互没有隔离3、通信协议（1）HDFS采用 TCP&#x2F;IP协议（2）客户端与集群之间、集群内部各节点之间，都是通过RPC （远程过程调用）进行通信4、客户端（1）HDFS shell 命令： -ls -mkdir -cat -put -get -rm -mv（2）HDFS Java API\n5、HDFS不足（1）命名空间限制（2）性能的瓶颈：单点（NameNode）（3）隔离问题（4）集群可用性，单点故障（SPOF），生产环境可采用Hadoop HA（高可用）、Hadoop联邦机制\n五.HDFS存储原理1、数据的冗余存储（1）HDFS采用多副本冗余存储策略，默认存储3份，（2）多副本存储带来的好处：加快数据传输速度、容易检查数据错误、保证数据的可用性2、数据存取策略1.数据存放策略（1）第1副本：如果是集群内提交，则直接存在本地节点；如果集群外提交，则选择磁盘不太满、CPU不太忙的节点进行存储第2个副本：选择与第1个副本不同机架上的节点进行存储，目的是安全（防止交换机出问题）第3个副本：选择与第1个副本相同机架上的节点进行存储，目的是数据的高效和可用如果有更多副本，则随机选择节点进行存储\n2.数据读取策略HDFS提供API可用确定数据所在机架 ID，客户端可以调用API来确定自己的机架ID，采用就近原则来读取数据。如果没有，则随机选择一块。\n3、数据错误与恢复（1）名称节点出错：可采用SecondaryNamenode中的冷备份进行恢复（2）数据节点出错：名称节点若没有收到数据节点心跳信息，可将该数据节点标记不可用。若因为数据节点不可用造成文件数据块副本数低于副本数要求，则启动复制机制复制文件块，使副本数达到要求。（3）数据出错：HDFS在存储数据时，会计算校验码，存放在数据块文件相同的路径下，读取时会通过校验码对数据进行校验。\n六.HDFS数据读写过程1.写数据的过程（1）建立FileSystem对象（2）创建文件：FileSystem对象create方法，返回FSDataOutputStream对象（3）使用FSDataOutputStream对象的write方法写入用户数据（4）关闭对象将数据存放HDFS文件系统2.读数据的过程（1）建立FileSystem对象（2）打开文件：FileSystem对象open方法，返回FSDataInputStream对象（3）FSDataInputStream对象read方法（借助BufferedReader的readline）来实现数据读取（4）关闭对象\n七.HFS编程1.HDFS shellhadoop fshdfs dfs\n2.HDFS-Java API:(导包方式、Maven）（1)准备开发环境：JDK+IDEA（2)准备Hadoop程序包：$HADOOP HOME&#x2F;share&#x2F;hadoop目录common、hdfs、mapreduce、yarn四个子目录下所有.jar文件3、启动IDEA，建立Java空项目4)在项目引入Hadoop程序包：File–&gt;Project Structure–&gt;Libraries–&gt;±-&gt;Java–&gt;找到jar所在目录5)新建Java类，编写程序Configuration : core-default.xml core-site.xmlfs.defaultFS RPC6)定义包：File-&gt;Project Structure-&gt;Artifacts-&gt;±&gt;JAR-&gt;选择带依赖打包-&gt;定义main class\n7)生成JAR包：Build–&gt;Build Artifacts–&gt;build2022.11.25\n请编写程序，实现如下逻辑：（程序与运行结果均以截图形式提交）\n1）从命令行参数读入文件名file1\n\n访问HDFS，判断file1是否存在，若存在则输出“文件已存在”，程序结束\n\n3）若file1不存在，则在HDFS上创建该文件，并写入如下两行信息，其中班级、学号、姓名使用自己的个人信息\n123软件工程xxx班学生名单123456789,张三\n\n4）成功写入后，程序输出如下提示信息：\nHDFS数据写入成功！写入内容如下：\n123软件工程xxx班学生名单123456789,张三\n\n5）在程序中读从HDFS中读取file1文件内容，并对文件内容进行解析，并参考如下格式输出信息:\n大家好！我是张三，我的学号:123456789，我来自软件工程xxx班。\n程序整体输出参考下图：作业逻辑1、读命令行参数2、访问HDFS,判断file1是否存在3、在HDFS上创建该文件，写入数据（写入如下两行信息，其中班级、学号、姓名使用自己的个人信息）4、读HDFS文件内容\n调用hadoop，fs -ls &#x2F; 命令行参数\n123456789101112131415161718192021222324252627282930313233343536373839404142434445/*1、读命令行参数2、访问HDFS,判断file1是否存在3、在HDFS上创建该文件，写入数据（写入如下两行信息，其中班级、学号、姓名使用自己的个人信息）4、读HDFS文件内容 */package cn.edu.ahdy.bg;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import java.io.IOException;public class ex01 &#123;    public static void main(String[] args) throws IOException &#123;                           //hadoop fs -ls /                                  //fs对应args[0] ls对应args[1] /对应args[2]        //访问HDFS        //1.创建Configuration对象        Configuration conf = new Configuration();        Path file1 = new Path(args[0]);        //2.获取FileSystem对象        FileSystem fs= FileSystem.get(conf);        //3.创建文件        FSDataOutputStream out = fs.create(file1);        //4.写数据       String str=&quot;软件工程212,1234546789，张三&quot;;       out.write(str.getBytes());       //5.写完数据关闭对象，释放资源        out.close();        fs.close();    &#125;&#125;\n\n找到jar并导入jar查看jps，并启动集群\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*1、读命令行参数2、访问HDFS,判断file1是否存在3、在HDFS上创建该文件，写入数据（写入如下两行信息，其中班级、学号、姓名使用自己的个人信息）4、读HDFS文件内容 */package cn.edu.ahdy.bg;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataInputStream;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import java.io.BufferedReader;import java.io.FilterInputStream;import java.io.IOException;import java.io.InputStreamReader;public class ex01 &#123;    public static void main(String[] args) throws IOException &#123;                           //hadoop fs -ls /                                  //fs对应args[0] ls对应args[1] /对应args[2]        //访问HDFS        //1.创建Configuration对象        Configuration conf = new Configuration();        Path file1 = new Path(args[0]);        //2.获取FileSystem对象        FileSystem fs= FileSystem.get(conf);        //3.创建文件        FSDataOutputStream out = fs.create(file1);        //4.写数据       String str=&quot;软件工程212,1234546789，张三&quot;;       out.write(str.getBytes());       //5.写完数据关闭对象，释放资源        out.close();        //读数据        //1.打开文件        FSDataInputStream in = fs.open(file1);        //2.        BufferedReader reader= new BufferedReader(new InputStreamReader(in));        String temp =reader.readLine();        String[] infos = temp.split(&quot;,&quot;);        System.out.printf(&quot;大家好！我是%s，我的学号:%s，我来自%s班&quot;,infos[2],infos[1],infos[0]);        reader.close();        in.close();        fs.close();    &#125;&#125;\n\n不指定类类不存在解决方法1.\n2.\n","slug":"temp_Hadoop","date":"2022-12-04T05:07:37.197Z","categories_index":"考试","tags_index":"考试,Hadoop","author_index":"FangH"},{"id":"29a6d737f8291ebb946b1c03a0d2e8fa","title":"MultiPlayer-RPG-OpenLevel","content":"MultiPlayer-RPG-OpenLevel\n\n\n\n\n\n\n游戏介绍\n\n游戏名：代号-OP\n开发人：Fangh\n项目启动时间：2022-11-12 | 09:30\n项目完成时间：****\n\n\n\n\n\n\n\n\n\n项目日志\n2022-11-12 | 09:30：项目开始\n2022-11-17 | 9:00：开始设计部分数据库表\n2022-11-18 | 10：30：大概完善部分数据库表\n\n\n[toc]\n1. 需求分析\n\n\n\n\n\n游戏大致功能分析\n\n数据库\n用户登录注册\n弱联机类型\n开放世界\n动物\n联机副本\n大世界联机\n加入玩家大世界\n加入玩家副本\n聊天功能\n成就系统\n多装备(职业切换)\n玩家等级\n武器(职业)等级\n合成系统\n大世界AI – 普通AI – 精英AI – BossAI\n副本AI – 普通AI – 精英AI – BossAI\n部署专用服务器\n\n\n\n1.1 数据库数据库：MultiPlayerRPG\n数据表：\n\nPlayerInfo\nPlayerChat\nPropsInfo\nDelegateInfo\nBoxInfo\nMaterialInfo\n\n1.2 用户登录注册\n\n\n\n\n\n\n注意\n\n在云服务器完成\n在数据库录入和读取\n通过数据库插件和服务端交互\n\n\n\n\n本地用户注册-&gt;RPC服务端-&gt;服务端将数据记入服务器数据库\n本地用户登录-&gt;RPC服务端-&gt;验证是否登录-&gt;读取服务器数据库-&gt;验证信息-&gt;RPC本地用户进入世界\n\n2. 项目准备2.1 开发工具云服务器：\n\n部署专用服务器\nMySQL\n\nUE4.27.2 二进制版：\n\n开发游戏项目\n\nUE4.27.2 源码版：\n\n打包发布游戏项目\n\nRiderForUnreal：\n\nUE4 C++编写&#x2F;编译\n\n2.2 项目资源模型：\n\n角色模型\n角色武器模型\n动物模型\n场景模型\n动物模型\nAI模型\n\n动画：\n\n角色基本动画\n角色武器(职业)动画\n动物动画\nAI动画\n\n音效：\n\n角色音效\n武器(职业)音效\n世界音效\n副本音效\n动物音效\nAI音效\n\n特效：\n\n场景特效\n武器(职业)特效\nAI特效\n副本特效\n\n2.3 开发标准2.3.1 命名标准\n类名\nGameMode_\nPlayerController_\n\n\n变量名：fh_\n对象名：Fh_\n虚幻类对象名：Fh_XXX虚幻类型，Fh_XXXComponent\n\n\n函数名：FH_\n单播委托：\n委托名：FHDelegateXXX\n委托变量：FHDG_XXX\n动态委托名：FHDynamicDelegateXXX\n动态委托变量：FHDDG_XXX\n\n\n多播委托：\n委托名：FHDelegateMulXXX\n委托变量：FHDGM_XXX\n动态委托名：FHDynamicDelegateMulXXX\n动态委托变量：FHDDGM_XXX\n\n\n\n3. 数据表设计\n\n\n\n\n\n\n\n\n\nUserInfo\nPlayerInfo\nWeaponInfo\nPlayerChat\nPropsInfo\nDelegateInfo\nBoxInfo\nMaterialInfo\n\n3.1 UserInfoUserInfo结构\n\n\n\n字段名\n类型\n自增\n不为空\nPK &#x2F; FK\n\n\n\nUserID\nint\nY\nY\nPK\n\n\nUserName\nvarchar(30)\n\nY\n\n\n\nUserEmail\nvarchar(50)\n\nY\n\n\n\nUserPassword\nvarchar(20)\n\nY\n\n\n\nUserInfo表\n\n\n\nUserID\nUserName\nUserEmail\nUserPassword\n\n\n\n1000\nfang\n&#x37;&#x35;&#50;&#57;&#x37;&#x32;&#x31;&#x38;&#50;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#109;\n752972182\n\n\n1001\nqq\n&#49;&#x32;&#51;&#x34;&#53;&#54;&#x37;&#56;&#57;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#x6d;\n123456789\n\n\nUserInfo.sql\n123456create table UserInfo(\tUserID int not null auto_increment primary key,    UserName varchar(30) not null,    UserEmail varchar(50) not null,    UserPassWord varchar(20) not null);\n\n\n\n\n\n3.2 PlayerInfoPlayerInfo\n\n\n\n字段名\n类型\n自增\n不为空\nPK &#x2F; FK\n\n\n\nPlayerMaxHealth\nvarchar(20)\n\nY\n\n\n\nPlayerCurHealth\nvarchar(20)\n\nY\n\n\n\nPlayerGrade\nvarchar(10)\n\nY\n\n\n\nPlayerDamage\nvarchar(20)\n\nY\n\n\n\nPlayerCritRate\nvarchar(10)\n\nY\n\n\n\nPlayerCritMultiplier\nvarchar(10)\n\nY\n\n\n\nPlayerDefense\nvarchar(20)\n\nY\n\n\n\nUserID\nint\n\n\nFK\n\n\nPlayerInfo表\n\n\n\nPlayerMaxHealth\nPlayerCurHealth\nPlayerGrade\nPlayerDamage\nPlayerCritRate\nPlayerCritMultiplier\nPlayerDefense\nUserID\n\n\n\nPlayerGrade*100\n100\n1\nPlayerGrade\n9+PlayerGrade\n1.0+(PlayerGrade&#x2F;10)\n9+PlayerGrade\n1000\n\n\nPlayerGrade*100\n200\n2\nPlayerGrade\n9+PlayerGrade\n1.0+(PlayerGrade&#x2F;10)\n9+PlayerGrade\n1001\n\n\nPlayerInfo.sql\n1234567891011create table PlayerInfo(\tPlayerMaxHealth varchar(20) not null,    PlayerCurHealth varchar(20) not null,    PlayerGrade varchar(10) not null,    PlayerDamage varchar(20) not null,    PlayerCritRate varchar(10) not null,    PlayerCritMultiplier varchar(10) not null,    PlayerDefense varchar(20) not null,    UserID int,    foreign key(UserID) references UserInfo(UserID));\n\n\n\n3.3 WeaponInfoWeaponInfo\n\n\n\n字段名\n类型\n自增\n不为空\nPK &#x2F; FK\n\n\n\nWeaponName\nvarchar(10)\n\nY\n\n\n\nWeaponQuality\nenum\n\nY\n\n\n\nWeaponDescribe\nvarchar(100)\n\nY\n\n\n\nWeaponDamage\nvarchar(20)\n\nY\n\n\n\nWeaponCritRate\nvarchar(10)\n\nY\n\n\n\nWeaponCritMultiplier\nvarchar(10)\n\nY\n\n\n\nWeaponType\nenum\n\nY\n\n\n\nUserID\nint\n\n\nFK\n\n\nWeaponInfo表\n\n\n\nWeaponName\nWeaponQuality\nWeaponDescribe\nWeaponDamage\nWeaponCritRate\nWeaponCritMultiplier\nWeaponType\nUserID\n\n\n\nsword\nA\na sword\n30\n10\n0.5\nSword\n1000\n\n\ngun\nB\na gun\n10\n3.5\n0.2\nGun\n1001\n\n\nWeaponInfo.sql\n1234567891011create table WeaponInfo(\tWeaponName varchar(10) not null,    WeaponQuality enum(&#x27;S&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;) not null,    WeaponDescribe varchar(100) not null,    WeaponDamage varchar(20) not null,    WeaponCritRate varchar(10) not null,    WeaponCritMultiplier varchar(10) not null,    WeaponType enum(&#x27;Sword&#x27;,&#x27;Spear&#x27;,&#x27;Gun&#x27;,&#x27;Bow&#x27;,&#x27;Epee&#x27;,&#x27;Gloves&#x27;,&#x27;Sickle&#x27;) not null,    UserID int,    foreign key(UserID) references UserInfo(UserID));\n\n\n\n\n\n4. 功能分析4.1 用户登录注册","slug":"998_代号-OP_01","date":"2022-11-12T02:47:09.905Z","categories_index":"UnrealEngine,Demo","tags_index":"UnrealEngine,Demo","author_index":"FangH"},{"id":"c15d1216398d62840196d3f8cb97f0ec","title":"UE4 NetWorking","content":"UE4 NetWorking[toc]\n1. Introduction\n网络拓扑和NAT\nC++ Replication\nLow Level NetWorking\n诊断工具\n\n2. Network Address Translation\nNetwork Address Translation (NAT)\n\n三种类型：\n\nOpen：接受未经请求的链接\n**Moderate (中等)**：有时可以接受未经请求的链接\n**Strict (严格)**：只能接受知道地址的链\n\n3. NAT Implications\nClinet &#x2F; Server\n服务器应该开放\n客户端可以是任何类型的NAT\n\n\nPeer &#x2F; Peer\n所有客户端都必须开放NAT\n约有20%的玩家无法加入游戏\n\n\n\n4. Server Authoritative\n客户端只能与服务器对话\n服务器复制到客户端\n数据流是服务器-&gt;客户端\nRPC是双向的\n\n5. C++ Replication5.1 Basic Gameplay Classes\n\n\nServer\nClient\n\n\n\nGameModeGameStatePlayerController:每个玩家一个PlayerState:每个玩家一个\nGameStatePlayerController:每个玩家一个PlayerState:每个玩家一个\n\n\n5.2 Gameplay Classes\nGameMode：制定游戏规则\nGameState：关于GameMode的复制信息\nPlayerController：和GameMode的主要交互\nPlayerState：玩家的复制信息\n\n5.3 Data Replication\nbReplicates：设置为Actor构造函数的一部分\nUPROPERTY Macro：\nReplicated\nReplicatedUsing\n\n\nGetLifetimeReplicatedProps Function：确定复制的属性集\n\n5.4 Conditional Replication\n仅在条件满足时复制属性\n可以减少带宽消耗\n通过类似的宏完成\n\nCommon Replication Conditions：\n\nCOND_InitialOnly：此属性将仅尝试在初始复制时发送\nCOND_OwnerOnly：这个属性只会发送给所有者\nCOND_SkipOwner：此属性发送到除所有者之外的每个连接\nCOND_SimulatedOnly：此属性只会发送给模拟演员\nCOND_AutonomousOnly：该属性只会发送给自治参与者\n\n5.5 Function ReplicationUFUNCTION Macro\n\nReliable\nUnreliable\nClient\nServer\nNetMulticast\nWithValidation\nBlueprintAuthorityOnly:(仅蓝图授权)\nBlueprintCosmetic\n\n5.5.1 Reliable\n函数被保证调用\n网络出现错误时重新发送\n带宽饱和时会延迟\n\n1234567891011121314151617/** notify player about started match */UFUNCTION(Reliable, Client)void ClientGameStarted();void AShooterPlayerController::ClientGameStarted_Implementation()&#123;\tbAllowGameActions = true;\t// Enable controls and disable cinematic mode now the game has started\tSetCinematicMode(false, false, true, true, true);\tAShooterHUD* ShooterHUD = GetShooterHUD();\tif (ShooterHUD)\t&#123;\t\tShooterHUD-&gt;SetMatchState(EShooterMatchState::Playing);\t\tShooterHUD-&gt;ShowScoreboard(false);\t&#125;\t…&#125;\n\n\n\n5.5.2 Unreliable• 试图发送函数• 出现错误时不再发送• 带宽饱和时跳过\n123456789/** Replicated function sent by client to server - containsclient movement and view info. */UFUNCTION(Unreliable, Server, WithValidation)virtual void ServerMove(float TimeStamp, …);void UCharacterMovementComponent::ServerMove_Implementation(float TimeStamp, …)&#123;\t…&#125;\n\n\n\n5.5.3 NetMulticast\n发送给所有的客户端：Reliable和Unreliable也同样适用\n\n12345678910111213141516/** broadcast death to local clients */UFUNCTION(Reliable, NetMulticast)void BroadcastDeath(…);void AShooterPlayerState::BroadcastDeath_Implementation(…)&#123;\tfor (auto It = GetWorld()-&gt;GetPlayerControllerIterator(); It; ++It)\t&#123;\t\t// all local players get death messages so they can update their huds.\t\tAShooterPlayerController* TestPC = Cast&lt;AShooterPlayerController&gt;(*It);\t\tif (TestPC &amp;&amp; TestPC-&gt;IsLocalController())\t\t&#123;\t\t\tTestPC-&gt;OnDeathMessage(KillerPlayerState, this, KillerDamageType);\t\t&#125;\t&#125;&#125;\n\n\n\n5.5.4 WithValidation\n在目标函数之前调用\n用于验证函数的参数：旨在检测作弊&#x2F;黑客行为\n返回值影响函数是否被调用：false跳过呼叫并终止连接\n\n123456bool UCharacterMovementComponent::ServerMove_Validate(float TimeStamp, …)&#123;\tbool bIsValidMove = false;\t// Perform move validation here\treturn bIsValidMove;&#125;\n\n\n\n6. Actor Relevancy\n以 CPU 时间换取网络带宽\n基于距离\n这些演员是否足够接近\n现在的默认实现\n\n\n视线\n这些演员可以互相看到吗\nUE3 默认实现\n\n\n始终相关是一个选项\n以带宽换取 CPU 时间\n\n\n\n7. Low Level Details\nUNetDriver\nUNetConnection\nUChannel\nUControlChannel\nUVoiceChannel\nUActorChannel\n\n\n\n7.1 UNetDriver• 包含与 Tick 的连接列表• 在客户端，一个连接• 在服务器上，N 个连接\n7.2 UNetConnection\n包含需要复制的通道列表\nUChildConnection：用作分屏游戏的优化\n\n7.3 UChannel Objects\n逻辑结构：将数据路由到正确的对象\n由 ChannelID 访问：某些频道具有预定义的 ID\n\n7.4 UControlChannel• 处理连接握手• 处理对象加载请求• 处理杂项：非游戏性交流\n7.5 UVoiceChannel• 发送和接收语音数据：语音通道将数据路由到平台处理程序• 语音数据取决于平台• 语音数据作为扬声器 ID 和有效负载发送\n7.6 UActorChannel• 处理参与者复制：包括任何复制的组件• 每个复制的参与者一个参与者通道• 参与者按频道 ID 复制：根据阵列位置动态分配\n8. Voice Considerations• 游戏可以选择支持或不支持• 平台可以让其他玩家静音：玩家在游戏外静音另一个• 玩家可以静音其他玩家• 游戏玩法可以让玩家静音：基于团队，基于距离，一键通\n9. Diagnostic Tools9.1 Network Logging\nLogNet：有关通道和连接状态的详细信息\nLogNetPlayerMovement：有关来自客户端的移动和来自服务器的更正的详细信息\nLogNetTraffic：有关在连接上发送的数据的详细信息\n\n9.2 Network Statistics\nStat Net：列出 ping、通道计数、输入&#x2F;输出字节等\nStat Game：网络处理信息列表\n\n9.3 Network Simulation Options\nPktLag：将数据包的发送延迟 N ms\nPktLagVariance：为 PktLag 选项提供一些随机性\nPktLoss：不发送数据包的百分比\nPktDup：发送重复数据包的百分比\nPktOrder：启用时乱序发送数据包\n\n9.4 Setting the Simulation Options• Console\n1Net PktLag=100\n\n• INI File\n123456[PacketSimulationSettings]PktLag=50PktLagVariance=10PktLoss=3PktOrder=0PktDup=10\n\n","slug":"7_UE4_NetWorking_11","date":"2022-11-10T01:24:59.447Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"a6ccd9fe4a40d3d3e4e5ed99b6f169f1","title":"汇编_辅助C++","content":"汇编_辅助C++[toc]\n\n汇编语言种类：x64汇编（64bit）\n书写格式：intel\n汇编不区分大小写\n\n1. 汇编格式了解\n\n\n项目\nintel\n说明\n\n\n\n寄存器命名\neax\nintel不带%\n\n\n操作数顺序\nmov edx, eax\n将eax的值赋值给edx\n\n\n常数\\立即数\nmov eax, 3mov eax, 0x10\n将3赋值给eax将0x10赋值给eax\n\n\njmp指令\njmp edxjmp 0x4001002jmp [eax]\n在AT&amp;T的jmp地址前面加*\n\n\n操作数长度\nmov edx, eaxmov al, 0x10lea ax, [dx + 0x10]\n\n\n\n2. x64汇编-寄存器\n通用寄存器：(8字节, 1字节&#x3D;8位二进制)\n16bit: AX&#x2F;BX&#x2F;CX&#x2F;DX\n32bit: EAX&#x2F;EBX&#x2F;ECX&#x2F;EDX\n64bit: RAX&#x2F;RBX&#x2F;RCX&#x2F;RDX\n64bit: RBP&#x2F;RSI&#x2F;RDI&#x2F;RSP&#x2F;R8&#x2F;R9&#x2F;R10&#x2F;R11&#x2F;R12&#x2F;R13&#x2F;R14&#x2F;R15\n64bit 可以向下兼容 32bit，64bit 寄存就分一半就是 32bit\n\n\n兼容方式：\nRAX：\nEAX(低32bit -&gt; 4byte)\n\n\nEAX：\nAX(低16bit -&gt; 2byte)\n\n\nAX：\nAH(高8bit -&gt; 1byte)\nAL(低8bit)\n\n\n\n\n一般规律：\nR，64bit，8字节\nE，32bit，4字节\nA，16bit，2字节\nAH&#x2F;AL，8bit， 1字节\n\n\n\n3. 内联汇编\n在 cpp 文件中直接写 汇编代码，仅支持 x86\n\n格式：\n1234__asm&#123;    // 汇编代码&#125;\n\n\n\n代码示例1：\n12345678910int main()&#123;    int a = 10;    __asm    &#123;        mov eax, a    &#125;        return 0;&#125;\n\n12345678910// mov eax, a =&gt; // mov eax, dword ptr[a]// 汇编中不存在 a， 只有 a 所在的地址__asm&#123;    mov eax, 10&#125;// mov eax, 10 =&gt;// mov eax, 0Ah\n\n\n\n代码示例2：10是10进制，16进制是0AH，占用1个字节，需放入AX，低位AL中；11223344H是8位16进制，占用4字节，需放入EAX；\n123456789int main()&#123;    __asm    &#123;        mov ax, 10\tmov eax, 11223344H    &#125;    return 0;&#125;\n\n12345678910111213// mov ax, 10 =&gt;// mov eax, 11223344Hmov eax, 0AHmov eax, 11223344H// mov ax, 0AH此时：ax 低位 al这 =&gt; 000A此时：eax =&gt; CCCC000A// mov eax, 11223344H此时：eax =&gt; 11223344此时：ax =&gt; 00003344此时：al =&gt; 3344\n\n4. 汇编语法\n\n\n语法\n解释\n\n\n\nmov dest, src\nsrc来源，dest目标，mov赋值\n\n\n[指针值]\n内存地址\n\n\nword\\dword\\qword\nword2字节，dword4字节，qword8字节\n\n\ndword ptr\n指定内存大小\n\n\ncall 函数地址\n调用函数\n\n\nlea dest, [地址值]\n类似与指针，将地址赋值给dest\n\n\nret\n函数返回\n\n\nxor op1, op2\n将 op1 和 op2 异或的结果给 op1，类似 op1 = op1 ^ op2\n\n\nadd op1, op2\nop1 = op1 + op2\n\n\nsub op1, op2\nop1 = op1 - op2\n\n\ninc op\n自增op = op + 1\n\n\ndec op\n自减op = op -1\n\n\njmp 内存地址\n跳转到指定地址，执行机器码一般配合test，cmp进行使用，J开头基本都是jmp的特殊形态jmp是无条件跳转；jne : jump not equal\n\n\n\n代码示例：\n123456789int a = 3;cout &lt;&lt; &amp;a &lt;&lt; endl;// &amp;a = 010FFE4Ch# mov dword ptr [ebp-0Ch], 3// ebp-0Ch 是 变量a 的地址// ebp ：010FFE58h// &amp;a : 010FFE4Ch == ebp-0Ch\n\n","slug":"11_汇编_辅助C++_01","date":"2022-10-06T07:28:25.978Z","categories_index":"编程","tags_index":"Assemly,C/C++","author_index":"FangH"},{"id":"3316961ecf1671c6065b043220187c47","title":"Java基础","content":"Java基础[toc]\n1. Java环境配置1.1 手动配置Java环境1.1.1 Oracle官网获得JDK\nJava-JDK\n\n获得JDK，默认安装C盘即可\n\n\n1.1.2 配置环境变量\n在系统变量，设置三项属性：\n\nJAVA_HOME\nPATH\nCLASSPATH（JDK1.5版本以上，无需此项）\n\n\n配置：\n\nJAVA_HOME:C:\\Program Files\\Java\\[实际情况而定]\n\nPATH:\n\n%JAVA_HOME%\\bin\n\n%JAVA_HOME%\\jre\\bin\n\n\n\n\n\nCMD测试：\n\njava\njavac\njava -version\n\n\n\n1.1.3 测试Java编译\n在text中写入Java程序：Demo.text\n1234567891011public class Demo &#123;    public static void main(String[] args)&#123;        int appleNum = 10;        int day;        for (day = 1; day &lt;= 3; ++day)        &#123;            appleNum -= 2;        &#125;        System.out.println(&quot;Day &quot; + (day - 1) + &quot; , &quot; + &quot;Apple Count : &quot; + appleNum);    &#125;&#125;\n\n将text文件文件类型后缀名改为：Demo.java\n\n在文件所在地址，打开CMD或者Powershell\n\n通过命令来编译Demo.java–默认是在同地址创建同名的Demo.class，Demo.exe在系统文件System32中\n1javac Demo.java\n\n通过命令来执行Demo.exe\n1java Demo\n\n1.2 通过Intellij IDEA配置1.2.1 安装IDEA\nInterllij IDEA\n\n1.2.2 关键设置\nAdd Path\n选择安装Openjdk\n\n2. Java基础2.1 Java标识符\n标识符包括：字母，数字，_，$；\n标识符必须：字母，_，$开头，不能以数字开头；\n标识符不能使用关键字\n\n2.2 常量常量初始化后，不能再被修改；\n1final double PI = 3.14;\n\n\n\n2.3 数据类型2.3.1 数据类型的分类\n基本数据类型\n数值型\n整数类型：byte, short, int, long\n浮点类型：float, double\n\n\n字符型：char\n布尔型：bool\n\n\n引用数据类型\n类\n接口\n数组\n\n\n\n2.3.2 整型\nJava默认的整型是int\n\n\n\n\n数据类型\n名称\n字节\n数值范围\n\n\n\nbyte\n字节型\n1\n-128 ~ 127\n\n\nshort\n短整型\n2\n-32768 ~ 32767\n\n\nint\n整型\n4\n-2147483648 ~ 2147483647\n\n\nlong\n长整型\n8\n-2(63次方) ~ -2(63次方) - 1\n\n\n123long a = 12345678; // 编译成功long b = 12345678999; // 编译失败，超出int长度long c = 12345678999L; // 编译成功，标记 L ，数据是长整型\n\n\n\n2.3.3 浮点型\nJava默认的浮点型是double\n\n\n\n\n数据类型\n名称\n字节\n数值范围\n\n\n\nfloat\n单精度\n4\n-3.403E38 ~ 3.403E38\n\n\ndouble\n双精度\n8\n-1.798E308 ~ 1.798E308\n\n\n2.3.4 字符型\n占用2个字节\n可用于转义\n\n\n\n\n转义符\n含有\n\n\n\n\\b\n退格\n\n\n\\n\n换行\n\n\n\\r\n回车\n\n\n\\t\n制表符\n\n\n\\“\n双引号\n\n\n\\‘\n单引号\n\n\n\\\\\n反斜杠\n\n\n123char ec = &#x27;a&#x27;;char cc = &#x27;中&#x27;;char c = &#x27;\\n&#x27;;\n\n\nchar只能放一个字符\nstring可以方一串字符\n\n2.3.4 布尔型\n布尔型只有两个常量值：true，false\n\n12boolean flag;flag = true;\n\n\n\n2.4 Java输入\n语法\n\n1234567891011import java.util.Scanner;public class Demo()&#123;    public static void main(String[] args)    &#123;        Scanner scan = new Scanner(System.in);                int a = scan.nextInt();    &#125;&#125;\n\n\nScanner对象的方法说明\n\n\n\n方法\n说明\n\n\n\nnextByte()\n读取byte类型的整数\n\n\nnextShort()\n读取short类型的整数\n\n\nnextInt()\n读取int类型的整数\n\n\nnextLong()\n读取long类型的整数\n\n\nnextFloat()\n读取float类型的数\n\n\nnextDouble()\n读取double类型的数\n\n\nnext()\n读取字符串，遇到空白符结束\n\n\nnextLine()\n读取文本，回车结束\n\n\n\n\n2.5 三目运算符\n语法：a &gt; b ? a : b;\n\n实例：在三个数中，找到最大数；\n1234567891011import java.util.Scanner;public class Demo()&#123;    public static void main(String[] args)    &#123;        int a = 10, b = 20, c = 30, temp, max;        temp = a &gt; b ? a : b;        max = temp &gt; c ? temp : c;    &#125;&#125;\n\n2.6 Java例题2.6.1 输入三位数，将各个位数取出1234567891011121314151617181920import java.util.Scanner;public class Demo2&#123;    public static void main(String[] args)    &#123;        Scanner scanner = new Scanner(System.in);        System.out.print(&quot;输入三位数：&quot;);        int EnterNum = scanner.nextInt();        int GW, SW, BW;        GW = (EnterNum % 10);        SW = (EnterNum % 100) / 10;        BW = (EnterNum / 100);        System.out.println(&quot;个位：&quot; + GW + &quot; 十位：&quot; + SW + &quot; 百位：&quot; + BW);    &#125;&#125;\n\n\n\n2.6.2 将两个变量值互换2.6.2.1 设临时变量12345678910public class Demo&#123;    public static void main(String[] args)    &#123;        int a = 10, b = 20, temp;        temp = a;        a = b;        b = temp;    &#125;&#125;\n\n\n\n2.6.2.2 两数加减12345678910public class Demo&#123;    public static void main(String[] args)    &#123;        int a = 10, b = 20;        b = a + b;        a = b - a;        b = b - a;    &#125;&#125;\n\n\n\n2.6.2.3 异或123456789101112131415public class Demo&#123;    public static void main(String[] args)    &#123;        int a = 1, b = 2;        a = a ^ b;        b = a ^ b;        a = a ^ b;    &#125;&#125;//  a = 1 = 01, b = 2 = 10;# a = a ^ b; //  01 - 10 =&gt; 00 == a = 0;# b = a ^ b; // 00 - 10 =&gt; 01 == b = 1;# a = a ^ b; // 00 - 01 =&gt; 10 == a = 2\n\n\n\n\n\n2.7 switch选择语句2.7.1 例题1\n学号-姓名-爱好-出生日期，以及是否是闰年\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Scanner;class MySelf&#123;   private final String stu_ID;   private final String stu_Name;   private final String stu_Hobby;   private final int stu_Date;   MySelf()   &#123;       stu_ID = &quot;82104322666&quot;;       stu_Name = &quot;FHang&quot;;       stu_Hobby = &quot;发呆&quot;;       stu_Date = 1998;   &#125;    public String getStu_ID() &#123;        return stu_ID;    &#125;    public String getStu_Name() &#123;        return stu_Name;    &#125;    public String getStu_Hobby() &#123;        return stu_Hobby;    &#125;    public int getStu_Date() &#123;        return stu_Date;    &#125;    public String getIsLeapYear()    &#123;        return (stu_Date % 4 == 0 &amp;&amp; stu_Date % 100 != 0) || (stu_Date % 400 == 0) ? &quot;是&quot; : &quot;不是&quot;;    &#125;&#125;public class Demo3&#123;    public static void main(String[] args)    &#123;        Scanner scanner = new Scanner(System.in);        MySelf mySelf = new MySelf();        while (true)        &#123;            System.out.println(&quot;1_学号,2_姓名,3_爱好,4_出生日期,&lt;其它_退出&gt;&quot;);            System.out.print(&quot;选择: &quot;);            int num = scanner.nextInt();            switch (num) &#123;                case 1 -&gt; System.out.println(&quot;学号: &quot; + mySelf.getStu_ID());                case 2 -&gt; System.out.println(&quot;姓名: &quot; + mySelf.getStu_Name());                case 3 -&gt; System.out.println(&quot;爱好: &quot; + mySelf.getStu_Hobby());                case 4 -&gt; System.out.println(&quot;出生日期: &quot; + mySelf.getStu_Date() + &quot; - 闰年: &quot; + mySelf.getIsLeapYear());                default -&gt; System.exit(0);            &#125;        &#125;    &#125;&#125;\n\n\n\n2.7.2 例题2\n输入一个年份，判断是否是闰年以及每月的天数\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Scanner;class Prophet&#123;    int year;    boolean isLeapYear;    public void CalLeapYear(int year)    &#123;        this.year = year;        isLeapYear = (year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0;        String leapYear = isLeapYear ? &quot;是闰年&quot; : &quot;不是闰年&quot;;        System.out.println(year + leapYear);    &#125;    public void CalDaysEveryMonth()    &#123;        System.out.println(this.year + &quot;的每月天数：&quot;);        int[] days = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;        for (int i = 0; i &lt; days.length; ++i)        &#123;            if (this.isLeapYear &amp;&amp; i == 1)            &#123;                System.out.println(&quot;第&quot; + (i + 1) + &quot;月: &quot; + (days[i] + 1));            &#125;            else            &#123;                System.out.println(&quot;第&quot; + (i + 1) + &quot;月: &quot; + days[i]);            &#125;        &#125;    &#125;&#125;public class Demo4&#123;    public static void main(String[] args)    &#123;        Scanner scanner = new Scanner(System.in);        Prophet pro = new Prophet();        while (true)        &#123;            System.out.print(&quot;输入年份&lt;0_退出&gt;：&quot;);            int num = scanner.nextInt();            if (num == 0)            &#123;                System.exit(0);            &#125;            else            &#123;                pro.CalLeapYear(num);                pro.CalDaysEveryMonth();            &#125;        &#125;    &#125;&#125;\n\n\n\n2.7.3 例题3\n设计一个加减计算的答题系统，随机生成题目，最少1题，最多10题，并最终返回答题正确数\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import java.util.Scanner;import java.util.Random;class CalculatorSystem&#123;    private int questionCount;    private int scoreCount;    private enum CalculateOperation    &#123;        ADD, SUB, /*MULTI, DIVIDE*/    &#125;    Scanner scanner = new Scanner(System.in);    Random random = new Random(System.currentTimeMillis());    CalculatorSystem()    &#123;        this.scoreCount = 0;    &#125;    public void CalStart()    &#123;        System.out.println(&quot;&lt;&lt;-- 输入题数(最少1题--最多10题) --&gt;&gt;&quot;);        System.out.print(&quot;输入&gt;&gt;&quot;);        questionCount = scanner.nextInt();        if (questionCount &lt; 1 || questionCount &gt; 10)        &#123;            questionCount = questionCount &lt; 1 ? 1 : 10;        &#125;        CalRandomQuestion();    &#125;    public void CalRandomQuestion()    &#123;        int tempA, tempB, inputC, a, b, c;        CalculateOperation calOperation;        for (int i = 1; i &lt;= questionCount; ++i)        &#123;            System.out.print(&quot;第&quot; + i + &quot;题: &quot;);            int curRand = random.nextInt(2);            calOperation = CalculateOperation.class.getEnumConstants()[curRand];            tempA = random.nextInt(101);            tempB = random.nextInt(101);            a = Math.max(tempA, tempB);            b = Math.min(tempB, tempA);            switch (calOperation)            &#123;                case ADD -&gt;                        &#123;                            c = a + b;                            System.out.print(a + &quot;+&quot; + b + &quot;=&quot;);                            inputC = scanner.nextInt();                            CalCheckAnswer(c, inputC);                        &#125;                case SUB -&gt;                        &#123;                            c = a - b;                            System.out.print(a + &quot;-&quot; + b + &quot;=&quot;);                            inputC = scanner.nextInt();                            CalCheckAnswer(c, inputC);                        &#125;            &#125;        &#125;        CalSumScore();    &#125;    public void CalCheckAnswer(int c, int inputC)    &#123;        String printLog = (c == inputC) ? &quot;正确&quot; : &quot;错误&quot;;        boolean isRight = (c == inputC);        if (isRight)        &#123;            this.scoreCount++;        &#125;        System.out.println(printLog);    &#125;    public void CalSumScore()    &#123;        System.out.println(&quot;答对&quot; + scoreCount + &quot;题&quot;);        scoreCount = 0;        System.out.println();    &#125;    public void CalEnd()    &#123;        System.out.println(&quot;&lt;&lt;-- 已退出答题系统 --&gt;&gt;&quot;);    &#125;&#125;public class Demo5&#123;    public static void main(String[] args)    &#123;        Scanner scanner = new Scanner(System.in);        CalculatorSystem calSys = new CalculatorSystem();        while (true)        &#123;            System.out.println(&quot;&lt;&lt;-- (Y/y_开始)--(N/n_结束) --&gt;&gt;&quot;);            System.out.print(&quot;输入&gt;&gt;&quot;);            String inputChar = scanner.next();            if (inputChar.equalsIgnoreCase(&quot;Y&quot;))            &#123;                calSys.CalStart();            &#125;            else if (inputChar.equalsIgnoreCase(&quot;N&quot;))            &#123;                calSys.CalEnd();                System.exit(1);            &#125;            else            &#123;                System.out.println(&quot;输入正确的选项&quot;);            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n2.7.4 例题4\n提示输入信息—显示信息-退出，显示信息可返回上一级信息提示\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import java.util.Scanner;class PersonInfo&#123;    private String fh_ID;    private String fh_Name;    private String fh_Hobby;    private int fh_Date;    Scanner scanner = new Scanner(System.in);    public String getFh_ID() &#123;        return fh_ID;    &#125;    public void setFh_ID(String fh_ID) &#123;        this.fh_ID = fh_ID;    &#125;    public String getFh_Name() &#123;        return fh_Name;    &#125;    public void setFh_Name(String fh_Name) &#123;        this.fh_Name = fh_Name;    &#125;    public String getFh_Hobby() &#123;        return fh_Hobby;    &#125;    public void setFh_Hobby(String fh_Hobby) &#123;        this.fh_Hobby = fh_Hobby;    &#125;    public int getFh_Date() &#123;        return fh_Date;    &#125;    public void setFh_Date(int fh_Date) &#123;        this.fh_Date = fh_Date;    &#125;    public void StartPersonInfo()    &#123;        while (true)        &#123;            System.out.println(&quot;&lt;-- 1_输入信息,2_显示信息,3_退出 --&gt;&quot;);            System.out.print(&quot;选择&gt;&gt;&quot;);            int num = scanner.nextInt();            switch (num)            &#123;                case 1 -&gt; InputPersonInfo();                case 2 -&gt; ShowPersonInfoMenu();                case 3 -&gt; ExitPersonInfo();            &#125;        &#125;    &#125;    public void ShowPersonInfoMenu()    &#123;        System.out.println(&quot;&lt;-- 1_学号,2_姓名,3_爱好,4_年份,5_返回上一级 --&gt;&quot;);        while (true)        &#123;            System.out.print(&quot;选择&gt;&gt;&quot;);            int num = scanner.nextInt();            switch (num)            &#123;                case 1 -&gt; System.out.println(&quot;ID: &quot; + getFh_ID());                case 2 -&gt; System.out.println(&quot;姓名: &quot; + getFh_Name());                case 3 -&gt; System.out.println(&quot;爱好: &quot; + getFh_Hobby());                case 4 -&gt; System.out.println(&quot;生日: &quot; + getFh_Date());                case 5 -&gt; StartPersonInfo();            &#125;        &#125;    &#125;    public void InputPersonInfo()    &#123;        System.out.print(&quot;输入ID&gt;&gt;&quot;);        setFh_ID(scanner.next());        System.out.print(&quot;输入姓名&gt;&gt;&quot;);        setFh_Name(scanner.next());        System.out.print(&quot;输入爱好&gt;&gt;&quot;);        setFh_Hobby(scanner.next());        System.out.print(&quot;输入生日&gt;&gt;&quot;);        setFh_Date(scanner.nextInt());    &#125;    public void ExitPersonInfo()    &#123;        System.out.println(&quot;&lt;-- 已退出 --&gt;&quot;);        System.exit(1);    &#125;&#125;public class Demo6&#123;    public static void main(String[] args)    &#123;        new Scanner(System.in);        PersonInfo personInfo = new PersonInfo();        personInfo.StartPersonInfo();    &#125;&#125;\n\n\n\n\n\n2.8 for循环2.8.1 例题1\n1 - 1000内的水仙花数\n\n123456789101112131415161718192021222324252627class FhMath&#123;    int B, S, G;    public void CalShuiXianHua()    &#123;        for (int i = 100; i &lt;= 900; ++i)        &#123;            B = i / 100;            S = (i / 10) % 10;            G = i % 10;            if (Math.pow(B, 3) + Math.pow(S, 3) + Math.pow(G, 3) == i)            &#123;                System.out.println(&quot;水仙花数: &quot; + i);            &#125;        &#125;    &#125;&#125;public class Demo8&#123;    public static void main(String[] args)    &#123;        FhMath fhMath = new FhMath();        fhMath.CalShuiXianHua();    &#125;&#125;\n\n\n\n\n\n2.8.2 例题2\n公鸡5元一个，母鸡3元一个，三只小鸡一元钱，现有100元，要买100只鸡，怎么买？\n\n1234567891011121314151617181920212223242526class Swap&#123;    public void swap(int x, int y, int z)    &#123;        for (x = 1; x &lt;= 20; ++x)        &#123;            for (y = 1; y &lt;= 33; ++y)            &#123;                z = 100 - x - y;                if (x * 5 + y * 3 + z / 3.0 == 100.0)                &#123;                    System.out.println(&quot;X= &quot; + x + &quot; Y= &quot; + y + &quot; Z= &quot; + z);                &#125;            &#125;        &#125;    &#125;&#125;public class Demo9&#123;    public static void main(String[] args)    &#123;        Swap swap = new Swap();        swap.swap(1, 2, 3);    &#125;&#125;\n\n\n\n2.8.3 例题3\n计算5的阶乘值的和（递归）\n\n12345678910111213141516171819202122232425262728293031323334353637class MathJie&#123;    public int fact(int n)    &#123;        if (n == 0 || n == 1)        &#123;            return 1;        &#125;        else        &#123;            return n * fact(n - 1);        &#125;    &#125;    public int sum(int n)    &#123;        if (n == 1)        &#123;            return fact(n);        &#125;        else        &#123;            return fact(n) + fact(n - 1);        &#125;    &#125;&#125;public class Demo10&#123;    public static void main(String[] args)    &#123;        MathJie mathJie = new MathJie();        int S;        S = mathJie.sum(5);        System.out.println(S);    &#125;&#125;\n\n\n\n2.9 函数重载题目2.9.1 例题1\n输入n个数，利用重载，打印最大值\n\n12345678910111213141516171819202122232425class Calculator&#123;    void getMax(int...nums)    &#123;        int maxNum = nums[0];        for (int num : nums)        &#123;            maxNum = Math.max(maxNum, num);        &#125;        System.out.println(&quot;Max Num: &quot; + maxNum);    &#125;&#125;public class Demo11&#123;    public static void main(String[] args)    &#123;        Calculator calculator = new Calculator();        calculator.getMax(1, 2);        calculator.getMax(1, 2, 3);        calculator.getMax(1, 2, 3, 4);    &#125;&#125;\n\n\n\n\n\n3.0 Java对象3.0.1 例题1\n创建一个宠物类，按提示输入相关信息，并最终打印出来\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Scanner;class Pet&#123;    private String name;    private String type;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getType() &#123;        return type;    &#125;    public void setType(String type) &#123;        this.type = type;    &#125;    Scanner scanner = new Scanner(System.in);    Pet()    &#123;        TipInfo();        System.out.print(&quot;输入名称&gt;&gt;&quot;);        setName(scanner.next());        System.out.print(&quot;输入类别&gt;&gt;&quot;);        setType(scanner.next());        PrintPetInfo();    &#125;    void TipInfo()    &#123;        System.out.println(&quot;&lt;-- 输入宠物相关信息 --&gt;&quot;);    &#125;    void PrintPetInfo()    &#123;        System.out.println(&quot;&lt;-- 打印宠物相关信息 --&gt;&quot;);        System.out.println(&quot;宠物名称: &quot; + getName());        System.out.println(&quot;宠物类别: &quot; + getType());    &#125;&#125;public class Demo10&#123;    public static void main(String[] args)    &#123;        new Pet();    &#125;&#125;\n\n\n\n\n\n3.1 对象继承3.1.1 继承概念\n继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法或子类从父类继承方法，使得子类具有父类相同的行为\n\n继承的格式：\n12345class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125;\n\n3.1.2 代码示例\nDemo.java\n12345678910111213141516package project2;public class Demo&#123;    public static void main(String[] args)    &#123;        Human student = new Student();        Human teacher = new Teacher();        Getter getter = new Getter();        getter.getInfo((Student) student);        System.out.println();        getter.getInfo((Teacher) teacher);    &#125;&#125;\n\nHuman.java\n12345package project2;public class Human&#123;&#125;\n\nStudent.java\n123456789101112131415161718192021222324252627282930313233343536373839404142package project2;public class Student extends Human&#123;    private String name;    private int stuID;    private int roomID;    Student()    &#123;        name = &quot;QQ&quot;;        stuID = 1;        roomID = 304;    &#125;    public String getName()    &#123;        return name;    &#125;    public void setName(String name)    &#123;        this.name = name;    &#125;    public int getStuID()    &#123;        return stuID;    &#125;    public void setStuID(int stuID)    &#123;        this.stuID = stuID;    &#125;    public int getRoomID()    &#123;        return roomID;    &#125;    public void setRoomID(int roomID)    &#123;        this.roomID = roomID;    &#125;&#125;\n\nTeacher.java\n123456789101112131415161718192021222324252627282930313233343536373839404142package project2;public class Teacher extends Human&#123;    private String name;    private String job;    private int salary;    Teacher()    &#123;        name = &quot;WW&quot;;        job = &quot;MathTeacher&quot;;        salary = 1000;    &#125;    public String getName()    &#123;        return name;    &#125;    public void setName(String name)    &#123;        this.name = name;    &#125;    public String getJob()    &#123;        return job;    &#125;    public void setJob(String job)    &#123;        this.job = job;    &#125;    public int getSalary()    &#123;        return salary;    &#125;    public void setSalary(int salary)    &#123;        this.salary = salary;    &#125;&#125;\n\nGetter.java\n1234567891011121314package project2;public class Getter&#123;    void getInfo(Student student)    &#123;        System.out.println(&quot;Name: &quot; + student.getName() + &quot;\\nStuID: &quot; + student.getStuID() + &quot;\\nRoomID: &quot; + student.getRoomID());    &#125;    void getInfo(Teacher teacher)    &#123;        System.out.println(&quot;Name: &quot; + teacher.getName() + &quot;\\nJob: &quot; + teacher.getJob() + &quot;\\nSalary: &quot; + teacher.getSalary());    &#125;&#125;\n\n3.2 抽象类\n概念：\n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样\n由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类\n父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法\n在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口\n\n\n\n3.3 接口\n概念：\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念\n类描述对象的属性和方法，接口则包含类要实现的方法，除非实现接口的类是抽象类，否则该类要定义接口中的所有方法\n接口无法被实例化，但是可以被实现\n\n\n\n3.3.1 接口的声明1234[可见度] interface 接口名称 [extends 其他的接口名] &#123;        // 声明变量        // 抽象方法&#125;\n\n\n\n3.3.2 接口的特性\n接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字\n接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字\n接口中的方法都是公有的\n\n3.3.3 接口的实现1...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...\n\n\n\n\n\n3.3.4 代码示例–文件结构\nproject3\n\nappliance\nApplianceBase.java\nComputer.java\nLight.java\nTelePhone.java\nWashMachine\n\n\nfunction\ncall.java\ncharge.java\nplayGame.java\n\n\nDemo.java\n\n\n代码源码：\n\nDemo.java\n123456789101112131415161718192021222324252627282930313233343536373839package project3;import project3.appliance.Computer;import project3.appliance.Light;import project3.appliance.TelePhone;import project3.appliance.WashMachine;public class Demo&#123;    public static void main(String[] args)    &#123;        // Light        Light light = new Light(&quot;Light&quot;);        light.runStart();        light.startCharge();        light.overCharge();        light.runOver();        // WashMachine        WashMachine washMachine = new WashMachine(&quot;WashMachine&quot;);        washMachine.runStart();        washMachine.startCharge();        washMachine.runOver();        // TelePhone        TelePhone telePhone = new TelePhone(&quot;TelePhone&quot;);        telePhone.runStart();        telePhone.startCall();        telePhone.overCall();        telePhone.runOver();        // Computer        Computer computer = new Computer(&quot;Computer&quot;);        computer.runStart();        computer.playGames();        computer.overGames();        computer.runOver();    &#125;&#125;\n\nApplianceBase.java\n12345678910111213141516171819202122232425262728293031323334353637package project3.appliance;public class ApplianceBase&#123;    private boolean isRunning;    ApplianceBase(String name)    &#123;        isRunning = false;        System.out.println(&quot;&lt;-- &quot; + name + &quot; --&gt;&quot;);    &#125;    public boolean isRunning()    &#123;        return isRunning;    &#125;    public void runStart()    &#123;        isRunning = true;        System.out.println(&quot;Is Run Start&quot;);        getCurState();    &#125;    public void runOver()    &#123;        isRunning = false;        System.out.println(&quot;Is Run Over&quot;);        getCurState();        System.out.println();    &#125;    public void getCurState()    &#123;        String state = isRunning ? &quot;Running&quot; : &quot;Over&quot;;        System.out.println(&quot;CurState&gt;&gt; &quot; + state);    &#125;&#125;\n\nComputer.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package project3.appliance;import project3.function.charge;import project3.function.playGame;public class Computer extends ApplianceBase implements charge, playGame&#123;    public Computer(String name)    &#123;        super(name);    &#125;    @Override    public void runStart()    &#123;        super.runStart();    &#125;    @Override    public void runOver()    &#123;        super.runOver();    &#125;    @Override    public void getCurState()    &#123;        super.getCurState();    &#125;    @Override    public void startCharge()    &#123;        System.out.println(&quot;Computer Is Start Charge&quot;);    &#125;    @Override    public void overCharge()    &#123;        System.out.println(&quot;Computer Is Over Charge&quot;);    &#125;    @Override    public void playGames()    &#123;        System.out.println(&quot;Computer Play Games&quot;);    &#125;    @Override    public void overGames()    &#123;        System.out.println(&quot;Computer Over Games&quot;);    &#125;&#125;\n\nLight.java\n1234567891011121314151617181920212223242526272829303132333435363738394041package project3.appliance;import project3.function.charge;public class Light extends ApplianceBase implements charge&#123;    public Light(String name)    &#123;        super(name);    &#125;    @Override    public void runStart()    &#123;        super.runStart();    &#125;    @Override    public void runOver()    &#123;        super.runOver();    &#125;    @Override    public void getCurState()    &#123;        super.getCurState();    &#125;    @Override    public void startCharge()    &#123;        System.out.println(&quot;Light Is Start Charge&quot;);    &#125;    @Override    public void overCharge()    &#123;        System.out.println(&quot;Light Is Over Charge&quot;);    &#125;&#125;\n\nTelePhone.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package project3.appliance;import project3.function.call;import project3.function.charge;public class TelePhone extends ApplianceBase implements charge, call&#123;    public TelePhone(String name)    &#123;        super(name);    &#125;    @Override    public void runStart()    &#123;        super.runStart();    &#125;    @Override    public void runOver()    &#123;        super.runOver();    &#125;    @Override    public void getCurState()    &#123;        super.getCurState();    &#125;    @Override    public void startCharge()    &#123;        System.out.println(&quot;TelePhone Is Start Charge&quot;);    &#125;    @Override    public void overCharge()    &#123;        System.out.println(&quot;TelePhone Is Over Charge&quot;);    &#125;    @Override    public void startCall()    &#123;        System.out.println(&quot;TelePhone Start Call&quot;);    &#125;    @Override    public void overCall()    &#123;        System.out.println(&quot;TelePhone Over Call&quot;);    &#125;&#125;\n\nWashMachine.java\n1234567891011121314151617181920212223242526272829303132333435363738394041package project3.appliance;import project3.function.charge;public class WashMachine extends ApplianceBase implements charge&#123;    public WashMachine(String name)    &#123;        super(name);    &#125;    @Override    public void runStart()    &#123;        super.runStart();    &#125;    @Override    public void runOver()    &#123;        super.runOver();    &#125;    @Override    public void getCurState()    &#123;        super.getCurState();    &#125;    @Override    public void startCharge()    &#123;        System.out.println(&quot;WashMachine Is Start Charge&quot;);    &#125;    @Override    public void overCharge()    &#123;        System.out.println(&quot;WashMachine Is Over Charge&quot;);    &#125;&#125;\n\ncall.java\n1234567package project3.function;public interface call&#123;    void startCall();    void overCall();&#125;\n\ncharge.java\n1234567package project3.function;public interface charge&#123;    void startCharge();    void overCharge();&#125;\n\nplayGame.java\n1234567package project3.function;public interface playGame&#123;    void playGames();    void overGames();&#125;\n\n3.4 数组和常用类\n案例描述：在一个九个元素的数组中，通过两组的三位数相加等于第三组组成的三位数，九个元素不重复，取值范围：[0 - 9]\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package project4;import java.util.Arrays;public class Demo1&#123;    int x,y,z;    int[] flagNo=new int[]&#123;0,0,0, 0,0,0, 0,0,0&#125;;    public static void main(String[] args)    &#123;        Demo1 abc=new Demo1();        abc.findRes();    &#125;    public void stau(int i)    &#123;        for (int j = 0; j &lt;3 ; j++)        &#123;            if (i%10!=0)                flagNo[i%10-1]=1;            i=i/10;        &#125;    &#125;    public boolean isRepeat()    &#123;        boolean tmp=true;        for (int j:flagNo)        &#123;            if (j == 0)            &#123;                tmp = false;                break;            &#125;        &#125;        return tmp;    &#125;    public void findRes()    &#123;        int counter=0;        for (x=123;x&lt;=987;x++)            for (y=x+1;y&lt;987;y++)            &#123;                Arrays.fill(flagNo, 0);                z=x+y;                if (z&gt;123&amp;&amp;z&lt;=987)                &#123;                    if (isRepeatXYZ())                    &#123;                        counter++;                        System.out.println(x+&quot;+&quot;+y+&quot;=&quot;+z+&quot;【&quot;+counter+&quot;】&quot;);                    &#125;                &#125;            &#125;    &#125;    public boolean isRepeatXYZ()    &#123;        boolean tmp;        stau(x);        stau(y);        stau(z);        tmp=isRepeat();        return tmp;    &#125;&#125;\n\n3.5 集合框架\n集合框架的概念：\n\n接口：代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象\n实现类：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap\n算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序\n\n\nSet 和 List的区别\n\nSet 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素\nSet检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;\nList和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt;\n\n\n代码示例：ArrayList\n123456789101112131415161718192021222324252627282930import java.util.*; public class Test&#123; public static void main(String[] args) &#123;     List&lt;String&gt; list=new ArrayList&lt;String&gt;();     list.add(&quot;Hello&quot;);     list.add(&quot;World&quot;);     list.add(&quot;HAHAHAHA&quot;);     //第一种遍历方法使用 For-Each 遍历 List     for (String str : list) &#123;            //也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式        System.out.println(str);     &#125;      //第二种遍历，把链表变为数组相关的内容进行遍历     String[] strArray=new String[list.size()];     list.toArray(strArray);     for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为  for(String str:strArray) 这种形式     &#123;        System.out.println(strArray[i]);     &#125;         //第三种遍历 使用迭代器进行相关遍历          Iterator&lt;String&gt; ite=list.iterator();     while(ite.hasNext())//判断下一个元素之后有值     &#123;         System.out.println(ite.next());     &#125; &#125;&#125;\n\n代码解析：第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度\n\n代码示例：Map\n123456789101112131415161718192021222324252627282930313233343536import java.util.*; public class Test&#123;     public static void main(String[] args) &#123;      Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();      map.put(&quot;1&quot;, &quot;value1&quot;);      map.put(&quot;2&quot;, &quot;value2&quot;);      map.put(&quot;3&quot;, &quot;value3&quot;);            //第一种：普遍使用，二次取值      System.out.println(&quot;通过Map.keySet遍历key和value：&quot;);      for (String key : map.keySet()) &#123;       System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key));      &#125;            //第二种      System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;);      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();      while (it.hasNext()) &#123;       Map.Entry&lt;String, String&gt; entry = it.next();       System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());      &#125;            //第三种：推荐，尤其是容量大时      System.out.println(&quot;通过Map.entrySet遍历key和value&quot;);      for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;       System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());      &#125;          //第四种      System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;);      for (String v : map.values()) &#123;       System.out.println(&quot;value= &quot; + v);      &#125;     &#125;&#125;\n\n3.5.1 集合排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package project8;import java.util.Comparator;import java.util.Vector;class Student&#123;    int id;    String name;    String sex;    int computerGrade;    int cGrade;    int mathGrade;    int physicalGrade;    Student(int id, String name, String sex, int computerGrade, int cGrade, int mathGrade, int physicalGrade)    &#123;        this.id = id;        this.name = name;        this.sex = sex;        this.computerGrade = computerGrade;        this.cGrade = cGrade;        this.mathGrade = mathGrade;        this.physicalGrade = physicalGrade;    &#125;&#125;class DownSort implements Comparator&lt;Student&gt;&#123;    public int compare(Student s1, Student s2)    &#123;        int g1 = s1.computerGrade + s1.cGrade + s1.mathGrade + s1.physicalGrade;        int g2 = s2.computerGrade + s2.cGrade + s2.mathGrade + s2.physicalGrade;        return Integer.compare(g2, g1);    &#125;&#125;public class Demo&#123;    public static void main(String[] args)    &#123;        Vector&lt;Student&gt; vS = new Vector&lt;&gt;();        Comparator&lt;Student&gt; comparator = new DownSort();        Student s1 = new Student(1001, &quot;mary&quot;, &quot;女&quot;, 90, 80, 78, 83);        Student s2 = new Student(1002, &quot;tom&quot;, &quot;男&quot;, 80, 81, 79, 84);        Student s3 = new Student(1003, &quot;jerry&quot;, &quot;男&quot;, 93, 82, 80, 85);        Student s4 = new Student(1004, &quot;john&quot;, &quot;男&quot;, 90, 83, 81, 86);        vS.add(s1);        vS.add(s2);        vS.add(s3);        vS.add(s4);        System.out.println(&quot;全部显示》》&quot;);        printInfo(vS);        vS.sort(comparator);        System.out.println(&quot;按总分排序》》&quot;);        printInfo(vS);        System.out.println(&quot;查询》》&quot;);        searcher(vS, 1001);    &#125;    static void printInfo(Vector&lt;Student&gt; vS)    &#123;        for (Student s : vS)        &#123;            System.out.println(s.id + &quot; &quot; + s.name + &quot; &quot; + s.sex + &quot; &quot; + s.computerGrade + &quot; &quot; + s.cGrade + &quot; &quot; + s.mathGrade + &quot; &quot; + s.physicalGrade);        &#125;        System.out.println();    &#125;    static void searcher(Vector&lt;Student&gt; vs, int id)    &#123;        for (Student s : vs)        &#123;            if (s.id == id)            &#123;                System.out.println(s.id + &quot; &quot; + s.name + &quot; &quot; + s.sex + &quot; &quot; + s.computerGrade + &quot; &quot; + s.cGrade + &quot; &quot; + s.mathGrade + &quot; &quot; + s.physicalGrade);            &#125;        &#125;        System.out.println();    &#125;&#125;\n\n\n\n\n\n3.6 异常处理\n异常概念：\n\n检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的\n运行时异常： 运行时异常是可能被程序员避免的异常\n错误： 错误不是异常，而是脱离程序员控制的问题\n\n\nException类的层次\n\nIOException 类\nRuntimeException 类\n\n\n\n3.6.1 异常方法\n\n\n序号\n方法及说明\n\n\n\n1\npublic String getMessage()返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。\n\n\n2\npublic Throwable getCause()返回一个Throwable 对象代表异常原因。\n\n\n3\npublic String toString()使用getMessage()的结果返回类的串级名字。\n\n\n4\npublic void printStackTrace()打印toString()结果和栈层次到System.err，即错误输出流。\n\n\n5\npublic StackTraceElement [] getStackTrace()返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\n\n\n6\npublic Throwable fillInStackTrace()用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。\n\n\n3.6.2 捕获异常\n使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方\n\n1234567try&#123;   // 程序代码&#125;catch(ExceptionName e1)&#123;   //Catch 块&#125;\n\n12345678910111213import java.io.*;public class ExcepTest&#123;    public static void main(String args[])&#123;      try&#123;         int a[] = new int[2];         System.out.println(&quot;Access element three :&quot; + a[3]);      &#125;catch(ArrayIndexOutOfBoundsException e)&#123;         System.out.println(&quot;Exception thrown  :&quot; + e);      &#125;      System.out.println(&quot;Out of the block&quot;);   &#125;&#125;\n\n\n\n3.6.3 多重捕获块\n一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获\n\n123456789try&#123;   // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123;  // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123;  // 程序代码&#125;catch(异常类型3 异常的变量名3)&#123;  // 程序代码&#125;\n\n12345678910try &#123;    file = new FileInputStream(fileName);    x = (byte) file.read();&#125; catch(FileNotFoundException f) &#123; // Not valid!    f.printStackTrace();    return -1;&#125; catch(IOException i) &#123;    i.printStackTrace();    return -1;&#125;\n\n\n\n\n\n3.6.4 throws &#x2F; throw 关键字\n如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明\n\n12345678910import java.io.*;public class className&#123;  public void deposit(double amount) throws RemoteException  &#123;    // Method implementation    throw new RemoteException();  &#125;  //Remainder of class definition&#125;\n\n\n\n3.6.5 finally 关键字\nfinally 关键字用来创建在 try 代码块后面执行的代码块\n无论是否发生异常，finally 代码块中的代码总会被执行\n在 finally 代码块中，可以运行清理类型等收尾善后性质的语句\n\n123456789try&#123;  // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123;  // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123;  // 程序代码&#125;finally&#123;  // 程序代码&#125;\n\n123456789101112131415public class ExcepTest&#123;  public static void main(String args[])&#123;    int a[] = new int[2];    try&#123;       System.out.println(&quot;Access element three :&quot; + a[3]);    &#125;catch(ArrayIndexOutOfBoundsException e)&#123;       System.out.println(&quot;Exception thrown  :&quot; + e);    &#125;    finally&#123;       a[0] = 6;       System.out.println(&quot;First element value: &quot; +a[0]);       System.out.println(&quot;The finally statement is executed&quot;);    &#125;  &#125;&#125;\n\n\n注意：\ncatch 不能独立于 try 存在\n在 try&#x2F;catch 后面添加 finally 块并非强制性要求的\ntry 代码后不能既没 catch 块也没 finally 块\ntry, catch, finally 块之间不能添加任何代码\n\n\n\n3.6.6 声明自定义异常\nJava 中可以自定义异常\n\n所有异常都必须是 Throwable 的子类\n如果写一个检查性异常类，则需要继承 Exception 类\n如果写一个运行时异常类，那么需要继承 RuntimeException 类\n\n1class MyException extends Exception&#123;&#125;\n\n代码示例：\n\nBankDemo.java\n123456789101112131415161718192021public class BankDemo&#123;   public static void main(String [] args)   &#123;      CheckingAccount c = new CheckingAccount(101);      System.out.println(&quot;Depositing $500...&quot;);      c.deposit(500.00);      try      &#123;         System.out.println(&quot;\\nWithdrawing $100...&quot;);         c.withdraw(100.00);         System.out.println(&quot;\\nWithdrawing $600...&quot;);         c.withdraw(600.00);      &#125;catch(InsufficientFundsException e)      &#123;         System.out.println(&quot;Sorry, but you are short $&quot;                                  + e.getAmount());         e.printStackTrace();      &#125;    &#125;&#125;\n\nInsufficientFundsException.java\n12345678910111213141516import java.io.*; //自定义异常类，继承Exception类public class InsufficientFundsException extends Exception&#123;  //此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱  private double amount;  public InsufficientFundsException(double amount)  &#123;    this.amount = amount;  &#125;   public double getAmount()  &#123;    return amount;  &#125;&#125;\n\nCheckingAccount.java\n123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*; //此类模拟银行账户public class CheckingAccount&#123;  //balance为余额，number为卡号   private double balance;   private int number;   public CheckingAccount(int number)   &#123;      this.number = number;   &#125;  //方法：存钱   public void deposit(double amount)   &#123;      balance += amount;   &#125;  //方法：取钱   public void withdraw(double amount) throws                              InsufficientFundsException   &#123;      if(amount &lt;= balance)      &#123;         balance -= amount;      &#125;      else      &#123;         double needs = amount - balance;         throw new InsufficientFundsException(needs);      &#125;   &#125;  //方法：返回余额   public double getBalance()   &#123;      return balance;   &#125;  //方法：返回卡号   public int getNumber()   &#123;      return number;   &#125;&#125;\n\n\n\n代码示例：自定义异常处理–验证码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package project5;import java.util.Random;import java.util.Scanner;class MyException extends Exception&#123;    MyException(String s)    &#123;        super(s);    &#125;&#125;class VerifyDemo&#123;    int[] verifyArr = new int[6];    void printArr(int[] arr)    &#123;        for (int j : arr)        &#123;            System.out.print(Character.toString(j) + &quot; &quot;);        &#125;    &#125;    void createVerifyCode()    &#123;        int verifySeed = 65;        Random random = new Random(System.currentTimeMillis());        for (int i = 0; i &lt; 6; ++i)        &#123;            int rand = random.nextInt(26);            verifyArr[i] = verifySeed + rand;        &#125;        printArr(verifyArr);    &#125;    int[] transformStringToArrInt(String s)    &#123;        int[] arr = new int[6];        char[] charArr = s.toCharArray();        for (int i = 0; i &lt; charArr.length; ++i)        &#123;            arr[i] = charArr[i];        &#125;        return arr;    &#125;    boolean checkVerifyCode(int[] arr)    &#123;        boolean isTrue = true;        for (int i = 0; i &lt; arr.length; ++i)        &#123;            if (arr[i] != verifyArr[i])            &#123;                isTrue = false;                break;            &#125;        &#125;        return isTrue;    &#125;&#125;public class Demo&#123;    public static void main(String[] args)    &#123;        Scanner scanner = new Scanner(System.in);        VerifyDemo verifydemo = new VerifyDemo();        String inputStr;        System.out.print(&quot;Verify Code: &quot;);        verifydemo.createVerifyCode();        System.out.println();        System.out.print(&quot;&gt;&gt; &quot;);        inputStr = scanner.next();        int[] verifyArr = verifydemo.transformStringToArrInt(inputStr);        boolean isVerifyTrue = verifydemo.checkVerifyCode(verifyArr);        try        &#123;            if (isVerifyTrue)            &#123;                throw new MyException(&quot;&lt;-- Verification Code True! --&gt;&quot;);            &#125;            else            &#123;                throw new MyException(&quot;&lt;-- Verification Code Error! --&gt;&quot;);            &#125;        &#125;        catch (MyException exception)        &#123;            System.out.println(exception.getMessage());        &#125;    &#125;&#125;\n\n3.7 多线程3.7.1 线程的生命周期\n新建状态:\n使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程\n\n\n就绪状态:\n当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度\n\n\n运行状态:\n如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态\n处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态\n\n\n阻塞状态:\n如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态\n在睡眠时间已到或获得设备资源后可以重新进入就绪状态，可以分为三种：\n等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态\n同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)\n其他阻塞：\n通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态\n当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态\n\n\n\n\n\n\n死亡状态:\n一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态\n\n\n\n3.7.2 线程的优先级\n作用：每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序\n方法：其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）\n\n3.7.3 线程的创建\n创建方法：\n\n通过实现 Runnable 接口\n通过继承 Thread 类本身\n通过 Callable 和 Future 创建线程\n\n\n代码示例：两个各自跑完100m\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package project6;public class Demo&#123;    public static void main(String[] args)    &#123;        FH_Thread fh_thread_1 = new FH_Thread();        FH_Thread fh_thread_2 = new FH_Thread();        Thread thread_1 = new Thread(fh_thread_1, &quot;&lt;Fang&gt; 跑&gt;&gt;&quot;);        Thread thread_2 = new Thread(fh_thread_2, &quot;&lt;张三&gt; 跑&gt;&gt;&quot;);        thread_1.start();        thread_2.start();    &#125;&#125;class FH_Thread implements Runnable&#123;    int all = 100;    public void run()    &#123;        while (true)        &#123;            if (all &gt; 0)            &#123;                try                &#123;                    Thread.sleep((int)(100+Math.random()*500));                &#125;                catch (InterruptedException e)                &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot; 5m&quot;);                all -= 5;            &#125;            else            &#123;                System.out.println(Thread.currentThread().getName() + &quot; 完100m&quot;);                break;            &#125;        &#125;    &#125;&#125;\n\n3.8 文件IO\n文件IO类：\nFile Class(类)\nFileReader Class(类)\nFileWriter Class(类)\n\n\n\n3.8.1 代码示例：\n案例描述：通过文件IO，创建排行榜和排序\n\n文件结构：\n\nproject7\nDemo.java\nLeaderBoard.java\nPlayer.java\nUpSort.java\nLeaderBoard.txt\n\n\n\n\n源码：\n\nDemo.java\n1234567891011121314package project7;public class Demo&#123;    public static void main(String[] args)    &#123;        LeaderBoard leaderBoard = new LeaderBoard();        leaderBoard.initPage();        leaderBoard.writePage();        leaderBoard.readPage();        leaderBoard.updatePage();        leaderBoard.readPage();    &#125;&#125;\n\nLeaderBoard.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package project7;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.*;public class LeaderBoard&#123;    Scanner scanner =new Scanner(System.in);    Vector&lt;Player&gt; vPlayer = new Vector&lt;&gt;();    Comparator&lt;Player&gt; comparator = new UpSort();    public void initPage()    &#123;        System.out.println(&quot;&lt;-- Origin Leader Board --&gt;&quot;);        Player player1 = new Player(&quot;A&quot;, 1);        Player player2 = new Player(&quot;B&quot;, 4);        Player player3 = new Player(&quot;C&quot;, 5);        Player player4 = new Player(&quot;D&quot;, 8);        vPlayer.add(player1);        vPlayer.add(player2);        vPlayer.add(player3);        vPlayer.add(player4);        vPlayer.sort(comparator);    &#125;    public void readPage()    &#123;        FileReader fileReader = null;        try        &#123;            fileReader = new FileReader(&quot;src\\\\project7\\\\leaderBoard.txt&quot;);            int i;            while ((i = fileReader.read()) != -1)            &#123;                System.out.print((char)i);            &#125;        &#125;        catch (Exception e)        &#123;            System.out.println(&quot;Page Can&#x27;t Read&quot;);        &#125;        finally        &#123;            try            &#123;                assert fileReader != null;                fileReader.close();            &#125;            catch (IOException e)            &#123;                System.out.println(&quot;Page Not Found&quot;);            &#125;        &#125;    &#125;    public void writePage()    &#123;        FileWriter fileWriter = null;        try        &#123;            fileWriter = new FileWriter(&quot;src\\\\project7\\\\leaderBoard.txt&quot;);            for (Player player : vPlayer)            &#123;                fileWriter.write(player.grade + &quot;: &quot; + player.name + &quot;\\r\\n&quot;);            &#125;        &#125;        catch (Exception e)        &#123;            System.out.println(&quot;Page Can&#x27;t Write&quot;);        &#125;        finally        &#123;            try            &#123;                assert fileWriter != null;                fileWriter.close();            &#125;            catch (IOException e)            &#123;                System.out.println(&quot;Page Not Found&quot;);            &#125;        &#125;    &#125;    public void updatePage()    &#123;        System.out.println(&quot;Add New Player &gt;&gt;&quot;);        System.out.print(&quot;Input Name: &quot;);        String newName = scanner.next();        System.out.print(&quot;Input Grade: &quot;);        int newGrade = scanner.nextInt();        Player newPlayer = new Player(newName, newGrade);        vPlayer.add(newPlayer);        vPlayer.sort(comparator);        System.out.println();        System.out.println(&quot;### Updated Leader Board ###&quot;);        System.out.println();        System.out.println(&quot;&lt;-- New Leader Board --&gt;&quot;);        writePage();    &#125;&#125;\n\nPlayer.java\n12345678910111213package project7;public class Player&#123;    String name;    int grade;    Player(String name, int grade)    &#123;        this.name = name;        this.grade = grade;    &#125;&#125;\n\nUpSort.java\n1234567891011package project7;import java.util.Comparator;public class UpSort implements Comparator&lt;Player&gt;&#123;    public int compare(Player player1, Player player2)    &#123;        return Integer.compare(player1.grade, player2.grade);    &#125;&#125;\n\nLeaderBoard.txt\n123451: A2: E4: B5: C8: D\n\n","slug":"10.Java基础","date":"2022-10-06T07:28:25.975Z","categories_index":"编程","tags_index":"Java","author_index":"FangH"},{"id":"9db7fbf272adb83d4da91baa664ab4df","title":"Dart基础","content":"Dart[toc]\n1. Dart 安装\n配套Flutter使用，安装Flutter SDK 1.21之后的版本，默认包含了最新的Dart SDK，不需要再额外安装Dart SDK\n\n运行命令\n12PS C:\\Windows\\System32&gt; dart --versionDart SDK version: 2.12.3 (stable) (Wed Apr 14 11:02:39 2021 +0200) on &quot;windows_x64&quot;\n\n2. Dart 环境配置\n安装完Flutter之后，打开VSCode\n在VSCode的扩展项里，搜索 Dart 和 Code Runner 安装即可\n\n3. Dart 项目文件\n打开VSCode，Ctrl + N，新建文件\n\nCtrl + S，另存为，修改文件后缀名 .dart，即可 (demo.dart)\n123void main() &#123;  print(&quot;Hello World !&quot;);&#125;\n\nCtrl + Alt + N，运行即可看到打印结果\n或者进入项目内：\n12345dart demo1.dart// 实际效果PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo1.dartHello World !\n\n5. Dart 基本语法5.1 Dart 变量类型12345678910111213void main() &#123;  // var 可以自动通过类型声明变量  var str1 = &quot;Hello World 1&quot;;  var num1 = 1111;  print(str1);  print(num1);  // 常规的指定变量类型  String str2 = &quot;Hello World 2&quot;;  int num2 = 2222;  print(str2);  print(num2);&#125;\n\n\n\n\n\n5.2 Dart 常量\nconst 修饰，需要赋初值\n\nfinal 修饰，可不赋初值，只能赋值一次\n\n永远不改变的值，需要用 const 或 final 修饰，不可用 var 或 其他类型\n123456789101112131415161718192021222324252627void main() &#123;  var str = &quot;Hello World 01&quot;;  str = &quot;Hello World 02&quot;;  var num = 1111;    num = 2222;      print(str);  print(num);  const str1 = &quot;Fang&quot;;  const num1 = 2222;  // const 修饰后，再次赋值无效  str1 = &quot;Hang&quot;;  num1 = 1234;  print(str1);  print(num1);&#125;#打印效果：显示错误#PS C:\\Users\\Admin&gt; dart &quot;c:\\Users\\Admin\\Desktop\\dart_demo\\demo1.dart&quot;Desktop/dart_demo/demo1.dart:13:3: Error: Can&#x27;t assign to the const variable &#x27;str1&#x27;.  str1 = &quot;Hang&quot;;  ^^^^Desktop/dart_demo/demo1.dart:14:3: Error: Can&#x27;t assign to the const variable &#x27;num1&#x27;.  num1 = 1234;  ^^^^\n\nfinal 和 const 的区别：（final只有在在运行时才会赋值一次，而const必须提前赋值）\n1234567891011121314void main() &#123;  final f_timeNow = new DateTime.now();  print(f_timeNow);  // 错误的用法  const c_timeNow = new DateTime.now();  print(c_timeNow);&#125;#打印效果：显示错误#PS C:\\Users\\Admin&gt; dart &quot;c:\\Users\\Admin\\Desktop\\dart_demo\\demo1.dart&quot;Desktop/dart_demo/demo1.dart:5:21: Error: New expression is not a constant expression.  const c_timeNow = new DateTime.now();                    ^^^\n\n5.3 Dart 数据类型\n常用的数据类型：\nNumber（数值）\nint\ndouble\n\n\nString（字符串）\nString\n\n\nBoolen（布尔）\nbool\n\n\nList（数组）\n在Dart中，数组是列表的对象，大部分情况下称之为列表\n\n\nMap（字典）\nMap是一个（键，值）对的对象，（键，值）可以是任何类型的对象\n\n\n\n\n不常用的数据类型：\nRune：Dart中UTF-32编码字符串，可以通过文字转换成符号表情或特定的字\nSymbol：Dart程序中声明的运算符和标识符\n\n\n\n5.4 Dart 字符串5.4.1 Dart 字符串定义\n不换行（示例）：单引号 &#x2F;&#x2F; 双引号\n1234567void main() &#123;  var str1 = &#x27;test string 01&#x27;;  String str2 = &quot;test string 02&quot;;  print(str1);  print(str2);&#125;\n\n不换行（打印）：\n123PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.darttest string 01test string 02\n\n换行（示例）：三个单引号 &#x2F;&#x2F; 三对双引号\n1234567891011121314void main() &#123;  String str1 = &#x27;&#x27;&#x27;  Test String 01  Test String 02  &#x27;&#x27;&#x27;;  String str2 = &quot;&quot;&quot;  Test String 03  Test String 04  &quot;&quot;&quot;;  print(str1);  print(str2);&#125;\n\n换行（打印）：\n123456PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart  Test String 01  Test String 02  Test String 03  Test String 04\n\n5.4.2 Dart 字符串拼接\n将两个字符串拼接\n123&#x27;$str1 $str2&#x27;&quot;$str1 $str2&quot; str1 + str2\n\n1234567void main() &#123;  String str1 = &#x27;Hello&#x27;;  String str2 = &#x27;Wrold&#x27;;  print(str1 + &#x27; &#x27; + str2);  print(&#x27;$str1 $str2&#x27;);&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dartHello WroldHello Wrold\n\n5.5 Dart 数值计算1234567891011121314151617181920212223void main() &#123;  int a = 12;  double b = 24.0;  double c = 48;  print(a);  print(b);  print(c);  print(&#x27;-------&#x27;);  var d = a + c;  var e = c - a;  var f = a * b;  var g = c / a;  var h = b % a;  print(d);  print(e);  print(f);  print(g);  print(h);&#125;\n\n12345678910PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart1224.0   48.0   -------60.0   36.0288.04.00.0\n\n\n\n\n\n5.6 Dart 布尔类型1234567891011121314151617void main() &#123;  int a = 12;  int b = 12;  if (a == b) &#123;    print(&#x27;a = b&#x27;);  &#125; else &#123;    print(&#x27;a != b&#x27;);  &#125;  bool c = true;  bool d = false;  if (c == d) &#123;    print(&#x27;c = d&#x27;);  &#125; else &#123;    print(&#x27;c != d&#x27;);  &#125;&#125;\n\n123PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.darta = bc != d\n\n\n\n\n\n5.7 List 集合类型\n不指定类型\n1234567891011121314151617181920212223void main() &#123;  var list1 = [&quot;FHang&quot;, 24, true];  print(&quot;list1:&quot;);  print(list1);  print(&quot;--------&quot;);  print(&quot;list frist:&quot;);  print(list1.first);  print(list1[0]);  print(&quot;--------&quot;);  print(&quot;list second:&quot;);  print(list1[1]);  print(&quot;--------&quot;);  print(&quot;list last:&quot;);  print(list1.last);  print(list1[2]);  print(&quot;--------&quot;);  print(&quot;list length:&quot;);  print(list1.length);&#125;\n\n1234567891011121314151617PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dartlist1:[FHang, 24, true]--------list frist:      FHangFHang--------list second:24--------list last:truetrue--------list length:3\n\n指定类型\n12345void main() &#123;  var list1 = &lt;String&gt;[&quot;Fang&quot;, &quot;Hang&quot;];  print(list1.first);  print(list1.last);&#125;\n\n123PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dartFangHang\n\n添加&#x2F;删除数据到集合\n123456789101112131415161718void main() &#123;  var list1 = [];  print(list1.length);  print(&quot;--------&quot;);  //添加  list1.add(&quot;Fang&quot;);  list1.add(&quot;Hang&quot;);  list1.add(24);  print(list1);  print(list1.length);  print(&quot;--------&quot;);  //删除  list1.removeAt(1);  print(list1);  print(list1.length);&#125;\n\n12345678PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart0--------        [Fang, Hang, 24]3--------        [Fang, 24]2\n\n通过List.filled 来创建固定大小的集合\n123456789101112void main() &#123;  // 不指定类型  var list1 = List.filled(2, &quot;&quot;);  // 指定类型  // var list2 = List&lt;String&gt;.filled(2, &quot;&quot;);  print(list1.length);  print(list1);  list1[0] = &quot;Fang&quot;;  list1[1] = &quot;hang&quot;;  print(list1);&#125;\n\n1234PS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart2[, ]        [Fang, hang]\n\n","slug":"9.Dart基础_01","date":"2022-10-06T07:28:25.973Z","categories_index":"编程","tags_index":"Dart","author_index":"FangH"},{"id":"d3adb67f358afb69b06b3570d65b1657","title":"Flutter基础","content":"Flutter[toc]\n1. Flutter 安装\n\n开始使用 — Windows — 获取 Flutter SDK — 下载\n\n将压缩包解压 — 找到 bin 目录 — 复制 bin 目录路径\n\n进入Win10 环境变量设置 — 系统变量 — Path — 将复制的目录添加\n\n回到中国Flutter的官网，来到网页底端 — 使用镜像\n\n选择Flutter 社区镜像 — 再次进入Win10环境变量设置 — 系统变量\n123添加：FLUTTER_STORAGE_BASE_URL: https://storage.flutter-io.cnPUB_HOSTED_URL: https://pub.flutter-io.cn\n\n检查Flutter版本：\n12345PS C:\\Windows\\System32&gt; flutter --versionFlutter 2.0.5 • channel stable • https://github.com/flutter/flutter.gitFramework • revision adc687823a (5 days ago) • 2021-04-16 09:40:20 -0700Engine • revision b09f014e96Tools • Dart 2.12.3\n\n检查Flutter配置是否完好\n12345678910111213141516PS C:\\Windows\\System32&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, 2.0.5, on Microsoft Windows [Version 10.0.19042.804], locale zh-CN)[✗] Android toolchain - develop for Android devices    ✗ Unable to locate Android SDK.      Install Android Studio from: https://developer.android.com/studio/index.html      On first launch it will assist you in installing the Android SDK components.      (or visit https://flutter.dev/docs/get-started/install/windows#android-setup for detailed instructions).      If the Android SDK has been installed to a custom location, please use      `flutter config --android-sdk` to update to that location.[✓] Chrome - develop for the web[!] Android Studio (not installed)[✓] Connected device (2 available)! Doctor found issues in 2 categories.\n\n可以看到 Android 栏是错误，因为没有安装 Android Studio，安装Android Studio后\n\n运行命令，即可\n\n\n   1flutter config --android-sdk\n\n\n默认可以使用Web\n\n2. Flutter 项目","slug":"8.Flutter基础_01","date":"2022-10-06T07:28:25.970Z","categories_index":"编程","tags_index":"Flutter","author_index":"FangH"},{"id":"2d7038c614ab5b62d3dc8aa389662f8e","title":"UE4 智能指针","content":"UE4 智能指针[toc]\n1. 虚幻智能指针库\n为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担\n该实现包括行业标准 共享指针、弱指针 和 唯一指针。其还可添加 共享引用，此类引用的行为与不可为空的共享指针相同\n虚幻Objects使用更适合游戏代码的单独内存追踪系统，因此这些类无法与 UObject 系统同时使用\n\n2. 智能指针类型前提：\n\n智能指针可影响其包含或引用对象的寿命\n不同智能指针对对象有不同的限制和影响\n\n下表可用于协助决定各类型智能指针的适用情况：\n\n\n\n智能指针类型\n适用情形\n\n\n\n**共享指针**（TSharedPtr）\n共享指针拥有其引用的对象，无限防止该对象被删除，并在无共享指针或共享引用（见下文）引用其时，最终处理其的删除共享指针可为空白，意味其不引用任何对象任何非空共享指针都可对其引用的对象生成共享引用\n\n\n**共享引用(ProgrammingAndScripting&#x2F;ProgrammingWithCPP&#x2F;UnrealArchitecture&#x2F;SmartPointerLibrary&#x2F;SharedReference)**（TSharedRef）\n共享引用的行为与共享指针类似，即其拥有自身引用的对象对于空对象而言，其存在不同；共享引用须固定引用非空对象共享指针无此类限制，因此共享引用可固定转换为共享指针，且该共享指针固定引用有效对象要确认引用的对象是非空，或者要表明共享对象所有权时，请使用共享引用\n\n\n**弱指针(ProgrammingAndScripting&#x2F;ProgrammingWithCPP&#x2F;UnrealArchitecture&#x2F;SmartPointerLibrary&#x2F;WeakPointer)**（TWeakPtrTSharedPtr）\n弱指针类与共享指针类似，但不拥有其引用的对象，因此不影响其生命周期此属性中断引用循环，因此十分有用，但也意味弱指针可在无预警的情况下随时变为空因此，弱指针可生成指向其引用对象的共享指针，确保程序员能对该对象进行安全临时访问\n\n\n唯一指针（TUniquePtr）\n唯一指针仅会显式拥有其引用的对象仅有一个唯一指针指向给定资源，因此唯一指针可转移所有权，但无法共享复制唯一指针的任何尝试都将导致编译错误唯一指针超出范围时，其将自动删除其所引用的对象\n\n\n注意：\n\n对唯一指针引用的对象进行共享指针或共享引用的操作十分危险\n即使其他智能指针继续引用该对象，此操作不会取消唯一指针自身被销毁时删除该对象的行为\n同样，不应为共享指针或共享引用引用的对象创建唯一指针\n\n3. 智能指针\n\n\n优点\n描述\n\n\n\n防止内存泄漏\n共享引用不存在时，智能指针（弱指针除外）会自动删除对象\n\n\n弱引用\n弱指针会中断引用循环并阻止悬挂指针\n\n\n可选择的线程安全）\n虚幻智能指针库包括线程安全代码，可跨线程管理引用计数，如无需线程安全，可用其换取更好性能\n\n\n运行时安全\n共享引用从不为空，可固定随时取消引用\n\n\n授予意图\n可轻松区分对象所有者和观察者\n\n\n内存\n智能指针在64位下仅为C++指针大小的两倍（加上共享的16字节引用控制器），唯一指针除外，其与C++指针大小相同\n\n\n4. 助手类和函数\n\n\n助手类\n描述\n\n\n\nTSharedFromThis\n在添加 AsShared 或 SharedThis 函数的 TSharedFromThis 中衍生类，利用此类函数可获取对象的 TSharedRef\n\n\n\n\n\n函数\n描述\n\n\n\nMakeSharedMakeShareable\n在常规C++指针中创建共享指针MakeShared 会在单个内存块中分配新的对象实例和引用控制器，但要求对象提交公共构造函数MakeShareable 的效率较低，但即使对象的构造函数为私有，其仍可运行利用此操作可拥有非自己创建的对象，并在删除对象时支持自定义行为\n\n\nStaticCastSharedRefStaticCastSharedPtr\n静态投射效用函数，通常用于向下投射到衍生类型\n\n\nConstCastSharedRefConstCastSharedPtr\n将 const 智能引用或智能指针分别转换为 mutable 智能引用或智能指针\n\n\n5. 智能指针实现细节注：在功能和效率方面，虚幻智能指针库中的智能指针具有一些共同特征\n5.1 运行速度注：\n\n要使用智能指针时，始终考虑性能\n智能指针非常适合某些高级系统、资源管理或工具编程\n但部分智能指针类型比原始C++指针更慢，这种开销使得其在低级引擎代码（如渲染）中用处不大\n\n智能指针的部分一般性能优势包括：\n\n所有运算均为常量时间\n取消引用多数智能指针的速度和原始C++指针的相同（在发布版本中）\n复制智能指针永不会分配内存\n线程安全智能指针是无锁的\n\n智能指针的性能缺陷包括：\n\n创建和复制智能指针比创建和复制原始C++指针需要更多开销\n保持引用计数增加基本运算的周期\n部分智能指针占用的内存比原始的C++更多\n引用控制器有两个堆分配。使用 MakeShared 代替 MakeShareable 可避免二次分配，并可提高性能\n\n5.2 侵入性访问器定义：\n\n共享指针是非侵入性的，意味对象不知道其是否为智能指针拥有\n\n此通常是可以接受的，但在某些情况下，可能要将对象作为共享引用或共享指针进行访问\n\n为此，使用对象的类作为模板参数，在 TSharedFromThis 衍生对象的类\n\nTSharedFromThis 提供两个函数：AsShared 和 SharedThis，可将对象转换为共享引用（并从共享引用转换为共享指针）\n\n使用固定返回共享引用的类factory时，或需将对象传到需要共享引用或共享指针的系统时，此操作十分有用\n\nAsShared 会将类返回为最初作为模板参数传到 TSharedFromThis 的类型返回，其可能是调用对象的父类型，而 SharedThis 将直接从该类型衍生类型，并返回引用该类型对象的智能指针\n\n以下范例代码中演示这两种函数：\n123456789101112131415161718192021222324252627282930class FRegistryObject;class FMyBaseClass: public TSharedFromThis&lt;FMyBaseClass&gt;&#123;    virtual void RegisterAsBaseClass(FRegistryObject* RegistryObject)    &#123;        // 访问对&quot;this&quot;的共享引用。        // 直接继承自&lt; TSharedFromThis &gt;，因此AsShared()和SharedThis(this)会返回相同的类型。        TSharedRef&lt;FMyBaseClass&gt; ThisAsSharedRef = AsShared();        // RegistryObject需要 TSharedRef&lt;FMyBaseClass&gt;，或TSharedPtr&lt;FMyBaseClass&gt;。TSharedRef可被隐式转换为TSharedPtr.        RegistryObject-&gt;Register(ThisAsSharedRef);    &#125;&#125;;class FMyDerivedClass : public FMyBaseClass&#123;    virtual void Register(FRegistryObject* RegistryObject) override    &#123;        // 并非直接继承自TSharedFromThis&lt;&gt;，因此AsShared()和SharedThis(this)不会返回相同类型。        // 在本例中，AsShared()会返回在TSharedFromThis&lt;&gt; - TSharedRef&lt;FMyBaseClass&gt;中初始指定的类型。        // 在本例中，SharedThis(this)会返回具备&quot;this&quot;类型的TSharedRef - TSharedRef&lt;FMyDerivedClass&gt;。        // SharedThis()函数仅在与 &#x27;this&#x27;指针相同的范围内可用。        TSharedRef&lt;FMyDerivedClass&gt; AsSharedRef = SharedThis(this);        // FMyDerivedClass是FMyBaseClass的一种类型，因此RegistryObject将接受TSharedRef&lt;FMyDerivedClass&gt;。        RegistryObject-&gt;Register(ThisAsSharedRef);    &#125;&#125;;class FRegistryObject&#123;    // 此函数将接受到FMyBaseClass或其子类的TSharedRef或TSharedPtr。    void Register(TSharedRef&lt;FMyBaseClass&gt;);&#125;;\n\n\n\n注意：要在构造函数中调用 AsShared 或 Shared，共享引用此时并未初始化，将导致崩溃或断言\n\n\n5.3 投射可通过虚幻智能指针库包含的多个支持函数投射共享指针(和共享引用)\nUp-casting是隐式的，与C++指针相同\n可使用 ConstCastSharedPtr 函数进行常量投射，使用 StaticCastSharedPtr 进行静态投射（通常是向下投射到衍生类指针）\n无run-type类型的信息（RTTI），因此不支持动态转换；应使用静态投射\n如以下代码所示：\n1234// 假设通过其他方式验证了FDragDropOperation实际为FAssetDragDropOp。TSharedPtr&lt;FDragDropOperation&gt; Operation = DragDropEvent.GetOperation();//现在可使用StaticCastSharedPtr进行投射。TSharedPtr&lt;FAssetDragDropOp&gt; DragDropOp = StaticCastSharedPtr&lt;FAssetDragDropOp&gt;(Operation);\n\n\n\n\n\n5.4 线程安全通常仅在单线程上访问智能指针的操作才是安全的\n如需访问多线程，请使用智能指针类的线程安全版本：\n\nTSharedPtr&lt;T, ESPMode::ThreadSafe&gt;\nTSharedRef&lt;T, ESPMode::ThreadSafe&gt;\nTWeakPtr&lt;T, ESPMode::ThreadSafe&gt;\nTSharedFromThis&lt;T, ESPMode::ThreadSafe&gt;\n\n由于原子引用计数，此类线程安全版本比默认版本稍慢，但其行为与常规C++指针一致：\n\n读取和复制固定为线程安全\n写入和重置须同步后才安全\n\n注：\n\n如了解多线程永不访问指针，可通过避免使用线程安全版本获得更好性能\n\n6. 提示和限制\n避免将数据作为 TSharedRef 或 TSharedPtr 参数传到函数，此操作将因取消引用和引用计数而产生开销\n\n相反，建议将引用对象作为 const &amp; 进行传递\n\n可将共享指针向前声明为不完整类型\n\n共享指针与虚幻对象(UObject 及其衍生类)不兼容\n\n引擎具有 UObject 管理的单独内存管理系统（对象处理文档），两个系统未互相重叠\n\n\n7. 共享指针定义：\n\n一种支持共享拥有、自动失效、弱引用等特性的智能指针\n共享指针（Shared Pointers） 是指既健壮、又能为空指针的智能指针\n共享指针沿袭了普通智能指针的所有优点，它能避免出现内存泄漏、悬挂指针，还能避免指针指向未初始化的内存\n\n其他特点：\n\n共享所有权（Shared Ownership）： 引用计数支持多个共享指针，以确保它们引用的数据对象永远不被删除，前提是它们中的任意一个仍指向数据对象\n自动失效（Automatic Invalidation）： 你可安全引用易变对象，无需担心出现悬挂指针\n弱引用： 弱指针可中断引用循环\n意向指示（Indication of Intent）： 区分拥有者（参见共享引用）和观察者，并提供不可为空的引用\n\n其他特性：\n\n语法非常健壮\n非侵入式（但能反射）\n线程安全（视情况而定）\n性能佳，占用内存少\n\n注意：\n\n共享指针类似于共享引用，主要区别在于共享引用不可为空，因此会始终引用有效对象\n在共享引用和共享指针之间进行选择时，除非需要空对象或可为空的对象，否则建议你优先选择共享引用\n\n7.1 声明和初始化\n因为共享指针可为空，所以无论有无数据对象，都可以对它们进行初始化\n\n创建共享指针的一些示例：\n123456789// 创建一个空白的共享指针TSharedPtr EmptyPointer;// 为新对象创建一个共享指针TSharedPtr&lt;FMyObjectType&gt; NewPointer(new FMyObjectType());// 从共享引用创建一个共享指针TSharedRef&lt;FMyObjectType&gt; NewReference(new FMyObjectType());TSharedPtr&lt;FMyObjectType&gt; PointerFromReference = NewReference;// 创建一个线程安全的共享指针TSharedPtr&lt;FMyObjectType, ESPMode::ThreadSafe&gt; NewThreadsafePointer = MakeShared&lt;FMyObjectType, ESPMode::ThreadSafe&gt;(MyArgs);\n\n在第二个示例中，NodePtr 实际上拥有新的 FMyObjectType 对象，因为没有其他共享指针引用该对象\n\n如果 NodePtr 超出范围，并且没有其他共享指针或共享引用指向该对象，那么该对象将被销毁\n\n复制共享指针时，系统将向它引用的对象添加一个引用\n12// 增加任意对象ExistingSharedPointer引用的引用数。TSharedPtr&lt;FMyObjectType&gt; AnotherPointer = ExistingSharedPointer;\n\n对象将持续存在，直到不再有共享指针（或共享引用）引用它为止\n\n可以使用 Reset 函数、或分配一个空指针来重设共享指针，如下所示：\n123PointerOne.Reset();PointerTwo = nullptr;// PointerOne和PointerTwo现在都引用nullptr。\n\n\n\n使用 MoveTemp（或 MoveTempIfPossible）函数将一个共享指针的内容转移到另一个共享指针，将原始的共享指针保留为空：\n1234// 将PointerOne的内容移至PointerTwo。在此之后，PointerOne将引用nullptr。PointerTwo = MoveTemp(PointerOne);// 将PointerTwo的内容移至PointerOne。在此之后，PointerTwo将引用nullptr。PointerOne = MoveTempIfPossible(PointerTwo);\n\n注意：MoveTemp 和 MoveTempIfPossible 的唯一不同之处在于 MoveTemp 包含静态断言，强制其只能在非常量左值（lvalue）上执行\n\n\n7.2 共享指针与引用转换\n在共享指针与共享引用之间进行转换是一种常见的做法。共享引用隐式地转换为共享指针，并提供新的共享指针将引用有效对象的额外保证\n\n转换由普通语法处理：\n1TSharedPtr&lt;FMyObjectType&gt; MySharedPointer = MySharedReference;\n\n\n\n只要共享指针引用了一个非空对象，你就可以使用 Shared Pointer 函数 ToSharedRef 从此共享指针创建一个共享引用\n\n试图从空共享指针创建共享引用将导致程序断言\n12345// 在解引用之前，请确保共享指针有效，以避免可能出现的断言。if (MySharedPointer.IsValid())&#123;    MySharedReference = MySharedPointer.ToSharedRef();&#125;\n\n7.3 对比\n目的：测试共享指针彼此间的相等性\n12345TSharedPtr&lt;FTreeNode&gt; NodeA, NodeB;if (NodeA == NodeB)&#123;    // ...&#125;\n\n\n\nIsValid 函数和 bool 运算符有助于判断共享指针是否引用了有效对象\n\n可以调用 Get，查看它是否返回有效的（非空）对象指针\n123456789101112if (Node.IsValid())&#123;    // ...&#125;if (Node)&#123;    // ...&#125;if (Node.Get() != nullptr)&#123;    // ...&#125;\n\n7.4 解引用和访问说明：\n\n像使用普通C++指针那样解引用，调用方法和访问成员\n可以像使用其他C++指针那样，通过调用 IsValid 函数或使用重载的 bool 运算符，在取消引用之前执行空检查\n\n12345678// 在解引用前，检查节点是否引用了一个有效对象。if (Node)&#123;    // 以下三行代码中的任意一行都能解引用节点，并且对它的对象调用ListChildren：    Node-&gt;ListChildren();    Node.Get()-&gt;ListChildren();    (*Node).ListChildren();&#125;\n\n\n\n\n\n\n\n7.5 自定义删除器\n说明：共享指针和共享引用支持对它们引用的对象使用自定义删除器\n\n如需运行自定义删除代码，请提供lambda函数，作为创建智能指针时使用的参数，就像这样：\n1234567void DestroyMyObjectType(FMyObjectType* ObjectAboutToBeDeleted)&#123;    // 此处添加删除代码。&#125;// 这些函数使用自定义删除器创建指南指针。TSharedRef&lt;FMyObjectType&gt; NewReference(new FMyObjectType(), [](FMyObjectType* Obj)&#123; DestroyMyObjectType(Obj); &#125;);TSharedPtr&lt;FMyObjectType&gt; NewPointer(new FMyObjectType(), [](FMyObjectType* Obj)&#123; DestroyMyObjectType(Obj); &#125;);\n\n8. 共享引用\n不能为未初始化或分配为空的智能指针类型\n\n说明：\n\n共享引用 是一类强大且不可为空的 智能指针，其被用于引擎的 Uobject 系统外的数据对象\n此意味无法重置共享引用、向其指定空对象，或创建空白引用\n因此共享引用固定包含有效对象，甚至未拥有 IsValid 方法\n在共享引用和 [共享指针]（Shared Pointers） 间选择时，除非需要空白或可为空的对象，否则共享引用为优先选项\n如需可能空白或可为空的引用，则应使用共享指针\n\n注意：与标准的C++引用不同，可在创建后将共享引用重新指定到另一对象\n8.1 声明和初始化\n共享引用不可为空，因此初始化需要数据对象\n\n在无有效对象的情况下尝试创建的共享引用将不会编译，并尝试将共享引用初始化为空指针变量\n12//创建新节点的共享引用TSharedRef&lt;FMyObjectType&gt; NewReference = MakeShared&lt;FMyObjectType&gt;();\n\n\n\n在无有效对象的情况下尝试创建的共享引用将不会编译：\n12345//以下两者均不会编译：TSharedRef&lt;FMyObjectType&gt; UnassignedReference;TSharedRef&lt;FMyObjectType&gt; NullAssignedReference = nullptr;//以下会编译，但如NullObject实际为空则断言。TSharedRef&lt;FMyObjectType&gt; NullAssignedReference = NullObject;\n\n8.2 共享指针与引用转换说明：共享引用会隐式转换为共享指针，并为新共享指针引用有效对象提供额外保证\n\n使用普通语法处理转换：\n1TSharedPtr&lt;FMyObjectType&gt; MySharedPointer = MySharedReference;\n\n\n\n如共享指针引用非空对象，即可使用 共享指针 函数 ToSharedRef，在共享指针中创建共享引用\n\n尝试在空共享指针中创建共享引用，将导致程序断言\n12345//在取消引用前，确保共享指针为有效，避免潜在断言。If (MySharedPointer.IsValid())&#123;    MySharedReference = MySharedPointer.ToSharedRef();&#125;\n\n8.3 对比\n可测试共享引用彼此是否相等。在此情况下，相等表示引用相同对象\n12345TSharedRef&lt;FMyObjectType&gt; ReferenceA, ReferenceB;if (ReferenceA == ReferenceB)&#123;    // ...&#125;\n\n9. 弱指针\n存储弱引用且不阻止其对象被销毁的智能指针\n\n说明：\n\n弱指针 存储对象的弱引用\n\n与 共享指针 或 共享引用 不同，弱指针不会阻止其引用的对象被销毁\n\n在访问弱指针引用的对象前，应使用 Pin 函数生成共享指针\n\n此操作确保使用该对象时其将继续存在\n\n如只需要确定弱指针是否引用对象，可将其与 nullptr 比较，或在之上调用 IsValid\n\n\n注意：\n\n弱指针的使用有助于授予意图——弱指针表明对引用对象的观察，而无需所有权，同时不控制其生命周期\n\n9.1 声明初始化和分配\n可创建空白弱指针，或在共享引用、共享指针或其他弱指针中进行\n1234//分配新的数据对象，并创建对其的强引用。TSharedRef&lt;FMyObjectType&gt; ObjectOwner = MakeShared&lt;FMyObjectType&gt;();//创建指向新数据对象的弱指针。TWeakPtr&lt;FMyObjectType&gt; ObjectObserver(ObjectOwner);\n\n\n\n弱指针不会阻止对象被销毁\n\n无论 ObjectOwner 是否在范围内，重置 ObjectOwner 都将销毁对象：\n12345678//假设ObjectOwner是其对象的唯一拥有者，ObjectOwner停止引用该对象时，该对象将被销毁。ObjectOwner.Reset();//ObjectOwner引用空对象，因此Pin()生成的共享指针将也将为空。被视为布尔时，空白共享指针的值为false。if (ObjectObserver.Pin())&#123;    //只当ObjectOwner非对象的唯一拥有者时，此代码才会运行。    check(false);&#125;\n\n\n\n与共享指针相同，弱指针是否引用有效对象，均可进行安全复制：\n1TWeakPtr&lt;FMyObjectType&gt; AnotherObjectObserver = ObjectObserver;\n\n\n\n使用完弱指针后，可进行重置\n1234//可通过将弱指针设为nullptr进行重置。ObjectObserver = nullptr;//也可使用重置函数。AnotherObjectObserver.Reset();\n\n9.2 转换为共享指针说明：\n\nPin 函数将创建指向弱指针对象的共享指针\n只要共享指针在范围内且引用对象，则该对象将持续有效\n此外，共享指针（包括由 Pin 函数返回的指针）可在条件句中作为 布尔 类型进行求值，其中 true 表示有效对象\n以下代码模式检查弱指针是否引用有效对象\n如是，至少在共享指针（由 Pin 函数创建）超出范围或被显式清除前，将保证其持续有效\n\n1234567//获取弱指针中的共享指针，并检查其是否引用有效对象。if (TSharedPtr&lt;FMyObjectType&gt; LockedObserver = ObjectObserver.Pin())&#123;    //共享指针仅在此范围内有效。    //该对象已被验证为存在，而共享指针阻止其被删除。    LockedObserver-&gt;SomeFunction();&#125;\n\n\n\n\n\n\n\n9.3 取消引用和访问\n要访问弱指针的对象，首需使用 Pin 函数，将其提升为共享指针\n然后可通过共享指针或弱指针上的 Get 函数进行访问\n此方法可确保使用该对象时，其将持续有效\n\n9.4 打破引用循环\n两个或多个对象使用智能指针保持彼此间的强引用时，将出现引用循环\n在此类情况下，对象间会相互保护以免被删除\n各对象固定被另一对象引用，因此对象无法在另一对象存在时被删除\n如外部对象未对引用循环中对象进行引用，其实际上将出现泄漏\n弱指针不会保留自身引用的对象，因此其可中断此类引用循环\n要在未拥有对象时对其进行引用，并延长其寿命时，可使用软指针\n\n9.5 使用警告如不想保证数据对象会持续存在时，弱指针将非常有用，但该属性可能会变得异常危险\n在以下情况中请谨慎使用弱指针：\n\n在集或映射中用作键。弱指针可能会在未通知容器的情况下随时无效，因此共享指针或共享引用更适用于充当键，可安全地将弱指针用作数值\n虽然弱指针提供 IsValid 函数，但是检查 IsValid 无法保证对象在任何时间长度内均可持续有效\n线程安全共享指针可能会因另一线程上的活动而随时无效，因此使用线程安全共享指针应尤其注意\nPin 返回的共享指针将使对象在代码将其清除或其超出范围前保持活跃状态，因此 Pin 函数是用于检查的首选方法，此类检查会导致取消引用或访问存储对象\n\n","slug":"7_UE4智能指针_07","date":"2022-10-06T07:28:25.968Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"97e60817d770107d3926456a0105594d","title":"UE4 委托","content":"UE4 委托[toc]\n1. 委托定义介绍：在C++对象上引用和执行成员函数的数据类型\n定义：\n\n是一种泛型但类型安全的方式，可在C++对象上调用成员函数\n可使用委托动态绑定到任意对象的成员函数，之后在该对象上调用函数，即使调用程序不知对象类型也可进行操作\n复制委托对象很安全。你也可以利用值传递委托，但这样操作需要在堆上分配内存，因此通常并不推荐\n尽量通过引用传递委托\n\n种类：\n\n单点委托\n组播委托\n事件\n\n\n动态(UObject, serializable)\n\n2. 基本使用2.1 声明委托前提：\n\n根据与委托相绑定的函数（或多个函数）的函数签名来选择宏\n每个宏都为新的委托类型名称、函数返回类型（如果不是 void 函数）及其参数提供了参数\n\n提供的函数签名：\n\n返回一个值的函数\n声明为 const 函数\n最多4个”载荷”变量\n最多9个函数参数（可自定义）\n\n参照表格查找用于声明委托的生命宏：\n\n\n\n函数签名\n声明宏\n\n\n\nvoid Function()\nDECLARE_DELEGATE(DelegateName)\n\n\nvoid Function(Param1)\nDECLARE_DELEGATE_OneParam(DelegateName, Param1Type)\n\n\nvoid Function(Param1, Param2)\nDECLARE_DELEGATE_TwoParams(DelegateName, Param1Type, Param2Type)\n\n\nvoid Function(Param1, Param2, ...)\nDECLARE_DELEGATE_&lt;Num&gt;Params(DelegateName, Param1Type, Param2Type, ...)\n\n\n&lt;RetValType&gt; Function()\nDECLARE_DELEGATE_RetVal(RetValType, DelegateName)\n\n\n&lt;RetValType&gt; Function(Param1)\nDECLARE_DELEGATE_RetVal_OneParam(RetValType, DelegateName, Param1Type)\n\n\n&lt;RetValType&gt; Function(Param1, Param2)\nDECLARE_DELEGATE_RetVal_TwoParams(RetValType, DelegateName, Param1Type, Param2Type)\n\n\n&lt;RetValType&gt; Function(Param1, Param2, ...)\nDECLARE_DELEGATE_RetVal_&lt;Num&gt;Params(RetValType, DelegateName, Param1Type, Param2Type, ...)\n\n\n注意：\n\n委托函数支持与UFunctions的说明符相同，但使用UDELEGATE而不是宏UFUNCTION\n\n代码BlueprintAuthorityOnly说明添加到FInstigatedAnyDamageSignature委托符中\n12UDELEGATE(BlueprintAuthorityOnly)DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FInstigatedAnyDamageSignature, float, Damage, const UDamageType*, DamageType, AActor*, DamagedActor, AActor*, DamageCauser);\n\n组播委托、动态委托和封装委托，上述宏的变体如下：\n\nDECLARE_MULTICAST_DELEGATE…\nDECLARE_DYNAMIC_DELEGATE…\nDECLARE_DYNAMIC_MULTICAST_DELEGATE…\nDECLARE_DYNAMIC_DELEGATE…\nDECLARE_DYNAMIC_MULTICAST_DELEGATE…\n\n委托签名声明可存在于全局范围内、命名空间内、甚至类声明内，此类声明可能不在于函数体内\n委托函数支持与UFunctions相同的说明符，但使用 UDELEGATE 宏而不是 UFUNCTION\n2.2 绑定委托委托系统理解某些类型的对象，使用此类对象时将启用附加功能\n将委托绑定到UObject或共享指针类的成员， 委托系统可保留对该对象的弱引用，因此对象在委托下方被销毁时，可通过调用 IsBound() 或 ExecuteIfBound() 函数进行处理\n注意各类受支持对象的特殊绑定语法：\n\n\n\n函数\n描述\n\n\n\nBind\n绑定到现有委托对象\n\n\nBindStatic\n绑定原始C++指针全局函数委托\n\n\nBindRaw\n绑定原始C++指针委托由于原始指针不使用任何类型的引用，因此在删除目标对象后调用Execute 或 ExecuteIfBound 会不安全\n\n\nBindLambda\n绑定一个函子这通常用于Lambda函数\n\n\nBindSP\n绑定基于指针的共享成员函数委托共享指针委托会保留对对象的弱引用可使用 ExecuteIfBound() 进行调用\n\n\nBindUObject\n绑定 UObject 的成员函数委托UObject 委托会保留对你的对象 UObject 的弱引用可使用 ExecuteIfBound() 进行调用\n\n\nUnBind\n取消绑定此委托\n\n\n参见 DelegateSignatureImpl.inl（位于 ..\\UE4\\Engine\\Source\\Runtime\\Core\\Public\\Templates\\），了解此类函数的变体、参数和实现\n2.3 载荷数据说明：\n\n绑定到委托时，可同时传递载荷数据\n其为调用时被直接传到绑定函数的任意变量\n此操作是为了使代码更安全，因为有时委托可能含有未初始化且被后续访问的返回值和输出参数\n执行未绑定的委托在某些情况下确实可能导致内存混乱\n\n使用：\n\n可调用 IsBound() 检查是否可安全执行委托\n同时，对于无返回值的委托，可调用 ExecuteIfBound()，但需注意输出参数可能未初始化\n\n注意输出参数可能未初始化：\n\n\n\n执行函数\n描述\n\n\n\nExecute\n不检查其绑定情况即执行一个委托\n\n\nExecuteIfBound\n检查一个委托是否已绑定，如是，则调用Execute\n\n\nIsBound\n检查一个委托是否已绑定，经常出现在包含 Execute 调用的代码前\n\n\n2.4 用法示例\n设类拥有可在任何地方随意调用的方法：\n\n1234class FLogWriter&#123;    void WriteToLog(FString);&#125;;\n\n\n\n\n要调用WriteToLog函数，需创建该函数签名的委托类型：\n\n123DECLARE_DELEGATE_OneParam(FStringDelegate, FString);// 此将创建名为 FStringDelegate 的委托类型，该类型使用 FString 类型的单个参数\n\n\n\n\n在类中使用此 FStringDelegate 的方法范例：\n\n1234class FMyClass&#123;    FStringDelegate WriteToLogDelegate;&#125;;\n\n\n利用此操作，类可保有指向任意类中的方法的指针\n该类唯一真正了解的信息就是，此委托是其的函数签名\n\n\n如要分配委托，现在只需创建委托类的实例，将拥有该方法的类作为模板参数传递\n同时还需传递对象的实例和方法的实际函数地址\n创建 FLogWriter 类的实例， 然后创建该对象实例 WriteToLog 方法的委托：\n\n123TSharedRef&lt;FLogWriter&gt; LogWriter(new FLogWriter());WriteToLogDelegate.BindSP(LogWriter, &amp;FLogWriter::WriteToLog);\n\n\n此操作可将委托动态绑定到类的方法\n\n注意：\n\n绑定到的对象由共享指针拥有，因此 BindSP 的SP部分代表共享指针\n还有不同对象类型的版本，例如BindRaw()和BindUObject()\nFMyClass现在可调用 WriteToLog 方法，甚至无需了解 FLogWriter 类的任何信息\n\n\n要调用委托，只需使用 Execute() 方法：\n\n1WriteToLogDelegate.Execute(TEXT(&quot;Delegates are great!&quot;));\n\n\n\n\n如将函数绑定到网络前调用Execute()，将触发断言，多数情况下，建议进行以下操作：\n\n1WriteToLogDelegate.ExecuteIfBound(TEXT(&quot;Only executes if a function was bound!&quot;));\n\n\n\n\n\n\n\n3. 动态委托\n可序列化且支持反射的委托\n动态委托可序列化，其函数可按命名查找，但其执行速度比常规委托慢\n\n3.1 声明动态委托介绍：动态委托的声明方式与声明标准委托相同， 只是前者使用动态委托专属的宏变体\n\n\n\n声明宏\n描述\n\n\n\nDECLARE_DYNAMIC_DELEGATE[_RetVal, ...]( DelegateName )\n创建一个动态委托\n\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE[_RetVal, ...]( DelegateName )\n创建一个动态组播委托\n\n\n3.2 动态委托绑定\n\n\n辅助宏\n说明\n\n\n\nBindDynamic( UserObject, FuncName )\n用于在动态委托上调用BindDynamic()的辅助宏，自动生成函数命名字符串\n\n\nAddDynamic( UserObject, FuncName )\n用于在动态组播委托上调用AddDynamic()的辅助宏，自动生成函数命名字符串\n\n\nRemoveDynamic( UserObject, FuncName )\n用于在动态组播委托上调用RemoveDynamic()的辅助宏，自动生成函数命名字符串\n\n\n3.3 执行动态委托使用：通过调用委托的 Execute() 函数执行绑定到委托的函数\n注意：\n\n执行前须检查委托是否已绑定\n此操作是为了使代码更安全，因为有时委托可能含有未初始化且被后续访问的返回值和输出参数\n执行未绑定的委托在某些情况下确实可能导致内存混乱\n可调用 IsBound() 检查是否可安全执行委托\n同时，对于无返回值的委托，可调用 ExecuteIfBound()，但需注意输出参数可能未初始化\n\n\n\n\n执行函数\n描述\n\n\n\nExecute\n不检查其绑定情况即执行一个委托\n\n\nExecuteIfBound\n检查一个委托是否已绑定，如是，则调用Execute\n\n\nIsBound\n检查一个委托是否已绑定，经常出现在包含 Execute 调用的代码前\n\n\n4. 事件\n可绑定到多个函数并同时全部执行的委托\n\n说明：\n\n虽然任意类均可绑定事件，但只有声明事件的类可以调用事件 的 Broadcast、IsBound 和 Clear 函数\n意味着事件对象可在公共接口中公开，而无需让外部类访问这些敏感度函数\n\n事件使用情况有：\n\n在纯抽象类中包含回调、限制外部类调用 Broadcast、IsBound 和 Clear 函数\n\n4.1 声明事件\n事件的声明和 组播委托声明 方式几乎相同，唯一的区别是它们使用事件特有的宏变体\n\n\n\n\n声明宏\n描述\n\n\n\nDECLARE_EVENT( OwningType, EventName )\n创建一个事件\n\n\nDECLARE_EVENT_OneParam( OwningType, EventName, Param1Type )\n创建带一个参数的事件\n\n\nDECLARE_EVENT_TwoParams( OwningType, EventName, Param1Type, Param2Type )\n创建带两个参数的事件\n\n\nDECLARE_EVENT_&lt;Num&gt;Params( OwningType, EventName, Param1Type, Param2Type, ...)\n创建带 N 个参数的事件\n\n\n注意：DECLARE_EVENT 宏的首个参数是”拥有”此事件的类，因此可调用 Broadcast() 函数\n4.2 绑定事件\n事件绑定与 组播委托绑定 方式相同\n\n4.3 事件执行说明：\n\n事件允许附带多个函数委托，然后调用事件的 Broadcast() 函数将它们一次性全部执行\n事件签名不允许使用返回值。对于事件而言，只有定义事件的类才能调用 Broadcast() 函数\n\n使用：\n\n即使不存在绑定，在事件上调用 Broadcast() 也是安全操作\n唯一需要注意的情况是使用事件初始化输出变量，通常不建议执行此操作\n\n注意：\n\n调用 Broadcast() 函数时，被绑定函数的执行顺序尚未定义\n有可能不按照函数的添加顺序执行\n\n\n\n\n函数\n描述\n\n\n\nBroadcast()\n将此事件广播到所有绑定对象，已失效的对象除外\n\n\n4.4 实现范例4.4.1 简单事件12345678public:/** Broadcasts whenever the layer changes */DECLARE_EVENT( FLayerViewModel, FChangedEvent )FChangedEvent&amp; OnChanged() &#123; return ChangedEvent; &#125;private:/** Broadcasts whenever the layer changes */FChangedEvent ChangedEvent;\n\n\n\n注意：事件的访问器应该依照 OnXXX 模式，而非常规的 GetXXX 模式\n4.4.2 继承的抽象事件基础类实现\n123/** Register/Unregister a callback for when assets are added to the registry */DECLARE_EVENT_OneParam( IAssetRegistry, FAssetAddedEvent, const FAssetData&amp;);virtual FAseetAddedEvent&amp; OnAssetAdded() = 0;\n\n\n\n派生类实现\n12DECLARE_DERIVED_EVENT( FAssetRegistry, IAssetRegistry::FAssetAddedEvent, FAssetAddedEvent);virtual FassetAddedEvent&amp; OnAssetAdded() override &#123; return AssetAddedEvent; &#125;\n\n\n\n注意：\n\n在派生类中声明一个派生事件时，不要在 DECLARE_DERIVED_EVENT 宏中重复函数签名\n此外，DECLARE_DERIVED_EVENT 宏的最后一个参数是事件的新命名，通常与基础类型相同\n\n4.4.3 继承事件\n派生类不会继承对基础类敏感事件成员的访问\n允许派生类广播其事件的基础类需要公开事件受保护的广播函数\n\n基础类\n1234567891011121314public:/** Broadcasts whenever the layer changes */DECLARE_EVENT( FLayerViewModel, FChangedEvent )FChangedEvent&amp; OnChanged() &#123; return ChangedEvent; &#125;protected:void BroadcastChanged()&#123;    ChangedEvent.Broadcast();&#125;private:/** Broadcasts whenever the layer changes */FChangedEvent ChangedEvent;\n\n\n\n\n\n\n\n5. 多播委托说明：\n\n可以绑定到多个函数并一次性同时执行它们的委托\n\n功能：\n\n多播委托拥有大部分与单播委托相同的功能\n它们只拥有对对象的弱引用，可以与结构体一起使用，可以四处轻松复制\n\n注意：\n\n像常规委托一样，多播委托可以远程加载&#x2F;保存和触发；但多播委托函数不能使用返回值\n它们最适合用来 四处轻松传递一组委托\n事件是一种特殊类型的多播委托，它在访问Broadcast()、IsBound()和Clear()函数时会受到限制\n\n5.1 声明多播委托多播委托在声明方式上与声明标准委托相同，只是前者使用特定于多播委托的宏变体。\n\n\n\n声明宏\n说明\n\n\n\nDECLARE_MULTICAST_DELEGATE[_RetVal, ...]( DelegateName )\n创建一个多播委托。\n\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE[_RetVal, ...]( DelegateName )\n创建一个动态多播委托。\n\n\n5.2 绑定多播委托\n多播委托可以绑定多个函数，当委托触发时，将调用所有这些函数\n因此，绑定函数在语义上与数组更加类似\n\n\n\n\n函数\n说明\n\n\n\n“Add()”\n将函数委托添加到该多播委托的调用列表中\n\n\n“AddStatic()”\n添加原始C++指针全局函数委托\n\n\n“AddRaw()”\n添加原始C++指针委托原始指针不使用任何类型的引用，因此如果从委托下面删除了对象，则调用此函数可能不安全调用Execute()时请小心！\n\n\n“AddSP()”\n添加基于共享指针的（快速、非线程安全）成员函数委托共享指针委托保留对对象的弱引用\n\n\n“AddUObject()”\n添加基于UObject的成员函数委托UObject委托保留对对象的弱引用\n\n\n“Remove()”\n从该多播委托的调用列表中删除函数（性能为O(N)）注意，委托的顺序可能不会被保留\n\n\n“RemoveAll()”\n从该多播委托的调用列表中删除绑定到指定UserObject的所有函数注意，委托的顺序可能不会被保留\n\n\n注意：\n\n“RemoveAll()”将删除绑定到所提供指针的所有已注册委托\n未绑定到对象指针的原始委托不会被该函数所删除\n\n参阅”DelegateSignatureImpl.inl”（位于”..\\UE4\\Engine\\Source\\Runtime\\Core\\Public\\Delegates&quot;中）了解这些函数的变体、参数和实现\n5.3 多播执行说明：\n\n多播委托允许您附加多个函数委托，然后通过调用多播委托的”Broadcast()”函数一次性同时执行它们\n多播委托签名不得使用返回值\n\n注意：\n\n在多播委托上调用”Broadcast()”总是安全的，即使是在没有任何绑定时也是如此\n唯一需要注意的是，如果您使用委托来初始化输出变量，通常会带来非常不利的后果\n调用”Broadcast()”时绑定函数的执行顺序尚未定义\n执行顺序可能与函数的添加顺序不相同\n\n\n\n\n函数\n说明\n\n\n\n“Broadcast()”\n将该委托广播给所有绑定的对象，但可能已过期的对象除外\n\n\n6. 委托示例6.1 单播委托定义单播委托\n\n新建一个测试类MyActor\n\nMyActor.h\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;MyActor.generated.h&quot;/* * 定义单播委托 */// 无返回值，无参数DECLARE_DELEGATE(FTestDelegateNoParam);// 无返回值，一个参数DECLARE_DELEGATE_OneParam(FTestDelegateOneParam, float);// 无返回值，多个参数（两个参数为例）DECLARE_DELEGATE_TwoParams(FTestDelegateTwoParams, float, const FString&amp;);// 有返回值，多个参数（两个参数为例）DECLARE_DELEGATE_RetVal_TwoParams(int32, FTestDelegateRetValTwoParams, float, const FString&amp;);UCLASS()class A_03_DELEGATE_API AMyActor : public AActor&#123;\tGENERATED_BODY()public:\tAMyActor();protected:\tvirtual void BeginPlay() override;/* * 声明委托，定义函数，绑定委托 */protected:\t// 声明委托\tFTestDelegateRetValTwoParams DelegateRetValTwoParams;\tpublic:\t// 测试单播委托，有返回值，两个参数\tUFUNCTION()\tint32 Func(float a, const FString&amp; s);    // 测试单播委托，绑定静态函数\tUFUNCTION()\tstatic int32 Func_Static(float a, const FString &amp;s);&#125;;\n\nMyActor.cpp\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &quot;MyActor.h&quot;class FTest&#123;public:\tint32 Func(float a, const FString &amp;s)\t&#123;\t\treturn 1;\t&#125;&#125;;AMyActor::AMyActor()&#123;&#125;void AMyActor::BeginPlay()&#123;\tSuper::BeginPlay();\t// 委托-通过对象-绑定函数\tDelegateRetValTwoParams.BindUObject(this, &amp;AMyActor::Func);\t\t// 委托-直接绑定Lambda函数\tDelegateRetValTwoParams.BindLambda([this](float a, const FString &amp;s)-&gt;int32\t&#123;\t\treturn 1;\t&#125;);\t// 委托-通过原生Cpp类-绑定函数\tFTest TestA;\tDelegateRetValTwoParams.BindRaw(&amp;TestA, &amp;FTest::Func);\t// 委托-通过共享指针-绑定函数\tconst TSharedPtr&lt;FTest&gt; TestB = MakeShareable(new FTest);\tDelegateRetValTwoParams.BindSP(TestB.ToSharedRef(), &amp;FTest::Func);\t// 委托-绑定静态函数\tDelegateRetValTwoParams.BindStatic(&amp;Func_Static);\t// 委托-通过线程安全共享指针-绑定函数\tconst TSharedPtr&lt;FTest, ESPMode::ThreadSafe&gt; TestC = MakeShareable(new FTest);\tDelegateRetValTwoParams.BindThreadSafeSP(TestC.ToSharedRef(), &amp;FTest::Func);\t// 委托-通过函数名称的反射-绑定UFUNCTION()修饰的函数\tDelegateRetValTwoParams.BindUFunction(this, &quot;Func&quot;);\t// 顺手通过委托调用绑定的函数\tif (DelegateRetValTwoParams.IsBound())\t&#123;\t\t// ExecuteIfBound 是无参委托的调用方法\t\tint a = DelegateRetValTwoParams.Execute(24.f, &quot;FTestDelegateRetValTwoParams&quot;);\t&#125;&#125;/* My Code */int32 AMyActor::Func(float a, const FString &amp;s)&#123;\treturn 1;&#125;int32 AMyActor::Func_Static(float a, const FString&amp; s)&#123;\treturn 1;&#125;\n\n6.2 多播委托定义多播委托\n\nMyActor.h\n123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;MyActor.generated.h&quot;/* * 定义多播委托，绑定多个形式相同的函数，同时执行（顺序随机） * 无返回值类型 */// 无返回值，无参数DECLARE_MULTICAST_DELEGATE(FTestMulDelegateNoParam);// 无返回值，一个或多个参数（两个参数为例）DECLARE_MULTICAST_DELEGATE_TwoParams(FTestMulDelegateTwoParams, float, const FString &amp;);UCLASS()class A_03_DELEGATE_API AMyActor : public AActor&#123;\tGENERATED_BODY()public:\tAMyActor();protected:\tvirtual void BeginPlay() override;/* * 声明委托，定义函数，绑定委托 */protected:\t// 声明委托\tFTestMulDelegateTwoParams MulDelegateTwoParams;\tpublic:\t// 测试多播委托，无返回值，两个参数\tUFUNCTION()\tvoid Func_Mul(float a, const FString &amp;s);&#125;;\n\nMyActor.cpp\n12345678910111213141516171819202122#include &quot;MyActor.h&quot;AMyActor::AMyActor()&#123;&#125;void AMyActor::BeginPlay()&#123;\tSuper::BeginPlay();\t/*\t * 多播委托\t */    // 多播委托-通过对象-绑定函数\tMulDelegateTwoParams.AddUObject(this, &amp;AMyActor::Func_Mul);        // 调用函数\tMulDelegateTwoParams.Broadcast(24.f, &quot;FTestMulDelegateTwoParams&quot;);&#125;/* My Code */void AMyActor::Func_Mul(float a, const FString&amp; s)&#123;&#125;\n\n6.3 动态委托6.3.1 动态单播委托定义动态单播委托\n\nMyActor.h\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;MyActor.generated.h&quot;/* * 定义动态单播委托 * 可以用于蓝图中 * 所以定义时，参数列表中的参数类型后要跟上参数名 */// 无返回值，无参数DECLARE_DYNAMIC_DELEGATE(FTestDynamicDelegateNoParam);// 无返回值，有参数（一个参数为例）DECLARE_DYNAMIC_DELEGATE_OneParam(FTestDynamicDelegateOneParam, int32, a);// 有返回值，有参数（一个参数为例）DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam(int32, FTestDynamicDelegateRetValOneParam, int32, a);UCLASS()class A_03_DELEGATE_API AMyActor : public AActor&#123;\tGENERATED_BODY()public:\tAMyActor();protected:\tvirtual void BeginPlay() override;/* * 声明委托，定义函数，绑定委托 */protected:\t// 声明委托\tFTestDynamicDelegateRetValOneParam DynamicDelegateRetValOneParam;    public:\t// 测试动态单播委托，蓝图中使用\tUFUNCTION(BlueprintCallable)\tvoid Func_Dynamic(FTestDynamicDelegateRetValOneParam DynamicDelegateRetValOneParam);\t// 测试动态单播委托，cpp使用\tUFUNCTION()\tint32 Func_DynamicCpp(int32 a);&#125;;\n\nMyActor.cpp\n123456789101112131415161718192021222324#include &quot;MyActor.h&quot;AMyActor::AMyActor()&#123;&#125;void AMyActor::BeginPlay()&#123;\tSuper::BeginPlay();\t/*\t * 动态单播委托\t */\tDynamicDelegateRetValOneParam.BindDynamic(this, &amp;AMyActor::Func_DynamicCpp);\tint32 b = DynamicDelegateRetValOneParam.Execute(24);&#125;/* My Code */void AMyActor::Func_Dynamic(FTestDynamicDelegateRetValOneParam DynamicDelegateRetValOneParam)&#123;&#125;int32 AMyActor::Func_DynamicCpp(int32 a)&#123;\treturn 1;&#125;\n\n6.3.2 动态多播委托定义动态多播委托\n\nMyActor.h\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;MyActor.generated.h&quot;/* * 动态多播委托 * 可以用于蓝图中 * 等同于蓝图中的事件调度器 * 多播委托没有返回值 */// 无返回值，无参数DECLARE_DYNAMIC_MULTICAST_DELEGATE(FTestDynamicMulDelegate);// 无返回值，有参数（一个参数为例）DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FTestDynamicMulDelegateOnParam, int32, a);UCLASS()class A_03_DELEGATE_API AMyActor : public AActor&#123;\tGENERATED_BODY()public:\tAMyActor();protected:\tvirtual void BeginPlay() override;/* * 声明委托，定义函数，绑定委托 */protected:\t// 声明委托\tUPROPERTY(BlueprintAssignable)\tFTestDynamicMulDelegate DynamicMulDelegate;\tFTestDynamicMulDelegateOnParam DynamicMulDelegateOnParam;\tpublic:\t// 测试动态多播委托，cpp使用\tUFUNCTION()\tvoid Func_DynamicMulCpp();\t// 测试动态多播委托，有参数，cpp使用\tUFUNCTION()\tvoid Func_DynamicMul_One(int32 a);&#125;;\n\nMyActor.cpp\n12345678910111213141516171819202122232425262728#include &quot;MyActor.h&quot;AMyActor::AMyActor()&#123;&#125;void AMyActor::BeginPlay()&#123;\tSuper::BeginPlay();\t/*\t * 动态多播委托\t */\t// 无参数\tDynamicMulDelegate.AddDynamic(this, &amp;AMyActor::Func_DynamicMulCpp);\tDynamicMulDelegate.Broadcast();\t// 有参数\tDynamicMulDelegateOnParam.AddDynamic(this, &amp;AMyActor::Func_DynamicMul_One);\tDynamicMulDelegateOnParam.Broadcast(24);&#125;/* My Code */void AMyActor::Func_DynamicMulCpp()&#123;&#125;void AMyActor::Func_DynamicMul_One(int32 a)&#123;&#125;\n\n7. 原生Cpp委托Delegate.cpp单播\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;functional&gt;// 函数指针的两种定义方式typedef int (*FuncMethod)(int, int);// using FuncMethod = int(*)(int, int);class TestA&#123;public:    int TestAddNum(int a, int b)    &#123;        const int c = a + b;        std::cout &lt;&lt; c &lt;&lt; std::endl;        return c;    &#125;&#125;;typedef int (TestA::*TestFuncMethod)(int , int);//using TestFuncMethod = int(TestA::*)(int, int);// 单播代理class FDelegateTwoParams&#123;private:    std::function&lt;int()&gt; Func;public:    void BindGlobalFunc(FuncMethod FuncPtr, int a, int b)    &#123;        Func = std::bind(FuncPtr, a, b);    &#125;    void BindRaw(TestA *UserClass, TestFuncMethod FuncPtr, int a, int b)    &#123;        Func = std::bind(FuncPtr, UserClass, a, b);    &#125;    bool IsBound() const    &#123;        return Func ? true : false;    &#125;    void Execute()    &#123;        Func();    &#125;    bool ExecuteIfBound()    &#123;        if (IsBound())        &#123;            Execute();            return true;        &#125;        return false;    &#125;&#125;;int AddNum(int a, int b)&#123;    const int c = a + b;    std::cout &lt;&lt; c &lt;&lt; std::endl;    return c;&#125;void DelegateDemo()&#123;    FDelegateTwoParams Delegate;    Delegate.BindGlobalFunc(&amp;AddNum, 10, 20);    Delegate.Execute();&#125;void DelegateDemo2()&#123;    TestA *testA = new TestA;    FDelegateTwoParams Delegate;    Delegate.BindRaw(testA, &amp;TestA::TestAddNum, 20, 30);    Delegate.Execute();&#125;int main()&#123;    // // 函数指针调用函数    // FuncMethod FuncPtr = &amp;AddNum;    // FuncPtr(1, 2);    // // 全局绑定调用函数    // std::function&lt;int()&gt; FuncPtr2 = std::bind(&amp;AddNum, 2, 3);    // FuncPtr2();    DelegateDemo();    DelegateDemo2();    return 0;&#125;\n\n\n\n\n\nDelegateMul.cpp多播\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;vector&gt;// 函数指针的两种定义方式typedef int (*FuncMethod)(int, int);class TestA&#123;public:    int TestAddNum(int a, int b)    &#123;        const int c = a + b;        std::cout &lt;&lt; c &lt;&lt; std::endl;        return c;    &#125;&#125;;typedef int (TestA::*TestFuncMethod)(int , int);// 多播代理class FDelegateTwoParams&#123;public:    void BindGlobalFunc(FuncMethod FuncPtr, int a, int b)    &#123;        FuncArray.push_back(std::bind(FuncPtr, a, b));    &#125;    void BindRaw(TestA *UserClass, TestFuncMethod FuncPtr, int a, int b)    &#123;        FuncArray.push_back(std::bind(FuncPtr, UserClass, a, b));    &#125;    void BroadCast()    &#123;        for (std::vector&lt;std::function&lt;int()&gt;&gt;::iterator itr = FuncArray.begin();              itr != FuncArray.end(); ++itr)        &#123;            (*itr)();        &#125;            &#125;private:    std::vector&lt;std::function&lt;int()&gt;&gt; FuncArray;&#125;;int AddNum(int a, int b)&#123;    const int c = a + b;    std::cout &lt;&lt; c &lt;&lt; std::endl;    return c;&#125;void DelegateDemo()&#123;    TestA *testA = new TestA;    FDelegateTwoParams Delegate;    Delegate.BindRaw(testA, &amp;TestA::TestAddNum, 10, 20);    Delegate.BindRaw(testA, &amp;TestA::TestAddNum, 20, 30);    Delegate.BroadCast();&#125;int main()&#123;    DelegateDemo();    return 0;&#125;\n\n\n\n\n\nDelegateMarco.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;functional&gt;class TestA&#123;public:    void FuncNoParam()    &#123;        std::cout &lt;&lt; &quot;FuncNoParamDelegate&quot; &lt;&lt; std::endl;    &#125;        void FuncTwoParam(int a, int b)    &#123;        const int c = a + b;        std::cout &lt;&lt; &quot;FuncTwoParam : &quot; &lt;&lt; c &lt;&lt; std::endl;    &#125;&#125;;// 定义类 作用域下的函数指针typedef void (TestA::*FuncMethodNoParam)(void);typedef void (TestA::*FuncMethodTwoParam)(int, int);// 宏定义 代理// 无参数，无返回值#define DECLARE_DELEGATE(DelegateName)\\class My##DelegateName\\&#123;\\public:\\    void BindRaw(TestA *UserClass, FuncMethodNoParam FuncPtr)\\    &#123;\\        Func = std::bind(FuncPtr, UserClass);\\    &#125;\\    bool IsBound() const\\    &#123;\\        return Func ? true : false;\\    &#125;\\    void Execute()\\    &#123;\\        Func();\\    &#125;\\    bool ExecuteIfBound()\\    &#123;\\        if (IsBound())\\        &#123;\\            Execute();\\            return true;\\        &#125;\\        return false;\\    &#125;\\private:\\    std::function&lt;void()&gt; Func;\\&#125;;// 有参数，无返回值#define DECLARE_DELEGATE_TWO_PARAM(DelegateName, TypeParam1, TypeParam2)\\class My##DelegateName\\&#123;\\public:\\    void BindRaw(TestA *UserClass, FuncMethodTwoParam FuncPtr, TypeParam1 p1, TypeParam2 p2)\\    &#123;\\        Func = std::bind(FuncPtr, UserClass, p1, p2);\\    &#125;\\    bool IsBound() const\\    &#123;\\        return Func ? true : false;\\    &#125;\\    void Execute()\\    &#123;\\        Func();\\    &#125;\\    bool ExecuteIfBound()\\    &#123;\\        if (IsBound())\\        &#123;\\            Execute();\\            return true;\\        &#125;\\        return false;\\    &#125;\\private:\\    std::function&lt;void()&gt; Func;\\&#125;;// 创建自定义宏代理DECLARE_DELEGATE(TestDelegateNoParam);DECLARE_DELEGATE_TWO_PARAM(TestDelegateTwoParam, int, int);void DelegateDemo()&#123;    TestA testA;    MyTestDelegateNoParam Delegate;    Delegate.BindRaw(&amp;testA, &amp;TestA::FuncNoParam);    Delegate.Execute();&#125;void DelegateDemo2()&#123;    TestA testB;    MyTestDelegateTwoParam Delegate;    Delegate.BindRaw(&amp;testB, &amp;TestA::FuncTwoParam, 10, 20);    Delegate.Execute();&#125;int main()&#123;    DelegateDemo();    DelegateDemo2();    return 0;&#125;\n\n\n\n\n\nDelegateTemplate.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;functional&gt;template&lt;typename Class, typename FuncType&gt;struct TMemFuncPtrType;template&lt;typename Class, typename RetType, typename... ArgTypes&gt;struct TMemFuncPtrType&lt;Class, RetType(ArgTypes...)&gt;&#123;    typedef RetType(Class::*Type)(ArgTypes...);&#125;;// 定义一个模板代理template &lt;typename RetValType, typename... ParamTypes&gt;class TBaseDelegate&#123;private:    std::function&lt;RetValType()&gt; Func;public:    template&lt;typename UserClass&gt;    void BindRaw(UserClass *MyUserClass,             typename TMemFuncPtrType&lt;UserClass, RetValType(ParamTypes...)&gt;::Type FuncPtr,             ParamTypes... Vars)    &#123;        Func = std::bind(FuncPtr, MyUserClass, Vars...);    &#125;    bool IsBound() const    &#123;        return Func ? true : false;    &#125;    void Execute()    &#123;        Func();    &#125;    bool ExecuteIfBound()    &#123;        if (IsBound())        &#123;            Execute();            return true;        &#125;        return false;    &#125;&#125;;#define DECLARE_DELEGATE(DelegateName) class DelegateName : public TBaseDelegate&lt;void&gt;&#123;&#125;;#define DECLARE_DELEGATE_TWO_PARAMS(DelegateName, ParamType1, ParamType2) class DelegateName : public TBaseDelegate&lt;void, ParamType1, ParamType2&gt;&#123;&#125;;#define DECLARE_DELEGATE_RETVAL_TWO_PARAMS(RetType, DelegateName, ParamType1, ParamType2) class DelegateName : public TBaseDelegate&lt;RetType, ParamType1, ParamType2&gt;&#123;&#125;;DECLARE_DELEGATE(TestDelegate);DECLARE_DELEGATE_TWO_PARAMS(TestDelegateTwoParams, int, int);DECLARE_DELEGATE_RETVAL_TWO_PARAMS(int, TestDelegateRetValTwoParams, int, int);class TestA&#123;public:    void Print()    &#123;        std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    &#125;    void Print2(int a, int b)    &#123;        const int c = a + b;        std::cout &lt;&lt; c &lt;&lt; std::endl;    &#125;    int Print3(int a, int b)    &#123;        const int c = a + b;        std::cout &lt;&lt; c &lt;&lt; std::endl;        return c;    &#125;&#125;; void DelegateDemo()&#123;    TestDelegate TD;    TestA testA;    TD.BindRaw(&amp;testA, &amp;TestA::Print);    TD.Execute();&#125;void DelegateDemo2()&#123;    TestDelegateTwoParams TDTwoParams;    TestA testB;    TDTwoParams.BindRaw(&amp;testB, &amp;TestA::Print2, 10, 20);    TDTwoParams.Execute();&#125;void DelegateDemo3()&#123;    TestDelegateRetValTwoParams TDRTwoParams;    TestA testC;    TDRTwoParams.BindRaw(&amp;testC, &amp;TestA::Print3, 99, 100);    TDRTwoParams.Execute();&#125;int main()&#123;    DelegateDemo();    DelegateDemo2();    DelegateDemo3();    return 0;&#125;\n\n","slug":"7_UE4委托_06","date":"2022-10-06T07:28:25.965Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"d2dc88f9aa1b74a2f377fe04af877f8c","title":"UE4 联网和多人游戏","content":"UE4 联网和多人游戏[toc]\n复制Replication：在客户端服务器间同步数据和调用程序的过程\n1. 网络概述1.1 尽早规划多人游戏\n若项目可能需要多人游戏功能，则从项目开始阶段起，构建所有gameplay时都应将多人游戏功能考虑在内，便于进行调试和维护，且支持单人\n若是单人游戏改为多人，重构无网络情况下编译的基本代码需要梳理整个项目，几乎所有gameplay都需要重新编写\n\n1.2 客户端-服务器模型\n单人游戏或本地多人游戏：\n\n游戏在 独立游戏上本地运行。玩家将输入连接到一台计算机，直接控制其上所有内容，而包括Actor、场景和各玩家的用户界面在内的所有游戏项目均存在于这台本地机器上\n\n\n网络多人游戏：\n\n虚幻引擎使用 客户端-服务器模型\n\n网络中的一台计算机作为 服务器 主持多人游戏会话，而所有其他玩家的计算机作为 客户端 连接到该服务器。然后，服务器与连接的客户端分享游戏状态信息，并提供一种客户端之间通信的方法\n客户端和服务端：\n\n在网络多人游戏中，游戏将在服务器（1）与多个与之连接的客户端（2）之间进行。服务器处理gameplay，客户端向用户显示游戏\n服务器是多人游戏实际发生的地方\n客户端会远程控制其在服务器上各自拥有的 Pawn， 发送过程调用以使其执行游戏操作\n服务器不会将视觉效果直接流送至客户端显示器。服务器会将游戏状态信息 复制 到各客户端，告知应存在的Actor、此类Actor的行为，以及不同变量应拥有的值\n客户端使用此信息，对服务器上正在发生的情况进行高度模拟\n\n\n\n\n\n1.2.1 客户端-服务器游戏范例\n分别以本地游戏和多人游戏为范例，说明GamePlay的处理逻辑\n本地游戏：玩家1\n多人游戏：玩家2\n\n\n\n\n本地游戏\n网络游戏\n\n\n\n\n\n\n\n玩家1按下输入以发射武器玩家1的Pawn将发射其当前武器以响应此操作。玩家1的武器生成发射物，并播放附带音效和视觉效果。\n玩家1在本地机器上按下输入以发射武器玩家1的本地Pawn将武器发射命令传送给服务器上对应的Pawn。玩家1在服务器上的武器生成发射物。服务器告知所有连接的客户端各自生成玩家1发射物的副本。玩家1在服务器上的武器告知所有客户端播放武器发射音效和视觉效果。\n\n\n玩家1的发射物从武器中射出并前移\n玩家1的发射物从在服务器上的武器中射出并前移此时，服务器告知所有客户端复制玩家1发射物发生的移动，因此各客户端上的玩家1发射物便相应移动。\n\n\n玩家1的发射物撞击玩家2的Pawn碰撞将触发摧毁玩家1发射物的函数，对玩家2的Pawn造成伤害，并播放附带音效和视觉效果。玩家2播放画面效果，作为对伤害的响应。\n玩家1在服务器上的发射物撞击玩家2的Pawn碰撞触发摧毁服务器上玩家1发射物的函数。服务器自动告知所有客户端各自摧毁玩家1发射物副本。碰撞触发告知所有客户端播放附带碰撞音效和视觉效果的函数。玩家2在服务器上的Pawn承受发射物碰撞造成的伤害。玩家2在服务器上的Pawn告知玩家2客户端播放画面效果，作为对伤害的响应。\n\n\n\n网络游戏中：\n此类交互发生在多个不同场景，这一过程将在基础游戏交互（碰撞、移动、伤害）、美化效果（视觉效果和音效）和私人玩家信息（HUD更新）间进行划分。这三者各自与网络中的特定机器或机组关联\n此信息的复制过程并非完全自动，游戏编程时须指定要复制的信息和接收副本的机器\n主要的难点在于选择应复制的信息及方式，以向所有玩家提供一致的游戏体验，同时需最小化信息复制量，尽可能减少网络带宽占用率\n\n\n\n1.3 基本网络概念1.3.1 网络模式和服务器类型\n网络模式：\n描述了计算机与网络多人游戏会话的关系\n游戏实例可采用以下任意网络模式\n\n\n\n\n\n\n网络模式\n说明\n\n\n\n独立\n游戏作为服务器运行，不接受远程客户端连接参与游戏的玩家必须为本地玩家此模式用于单人游戏和本地多人游戏其将运行本地玩家适用的服务器逻辑和客户端逻辑\n\n\n客户端\n游戏作为网络多人游戏会话中与服务器连接的客户端运行其不会运行服务器逻辑\n\n\n聆听服务器\n游戏作为主持网络多人游戏会话的服务器运行其接受远程客户端中的连接，且直接在服务器上拥有本地玩家此模式通常用于临时合作和竞技多人游戏\n\n\n专属服务器\n游戏作为主持网络多人游戏会话的服务器运行其接受远程客户端中的连接，但无本地玩家，因此为了高效运行，其将废弃图形、音效、输入和其他面向玩家的功能此模式常用于需要更固定、安全和大型多人功能的游戏\n\n\n\n独立游戏服务器可同时作为服务器和客户端，为多人游戏创建的逻辑可在无需额外工作的情况下，在单人游戏中运行\n\n1.3.2 Actor复制\n描述：\n复制是指在网络会话中的不同机器间复制游戏状态信息\n若正确设置复制，将可同步不同机器的游戏实例\n在C++ Actor类中设置 bReplicates 变量，或将Actor蓝图的 复制（Replicates）设置设为 true，可启用给定类的Actor复制\n\n\n\n1.3.2.1 常见复制功能\n\n\n复制功能\n说明\n\n\n\n创建和销毁\n服务器上生成复制Actor的授权版本时，其会在所有连接客户端上自动生成远程代理。其之后会将信息复制到这些远程代理。若销毁授权Actor，则将自动销毁所有连接客户端上的远程代理。\n\n\n移动复制\n若授权Actor启用了 复制移动，或将C++中的 bReplicateMovement 设为 true，其将自动复制位置、旋转和速度。\n\n\n变量复制\n在指定为复制变量的值变更时，其将自动从授权Actor复制到其远程代理。\n\n\n组件复制\nActor组件复制为其所属Actor的一部分。组件内指定为复制变量将复制，而组件内调用的RPC将与Actor类中调用的RPC保持一致。\n\n\n远程过程调用（RPC）\nRPC是传输到网络游戏中特定机器的特殊函数。无论初始调用RPC的是哪台机器，其的实现仅在目标机器上运行。此类RPC可指定为服务器（仅在服务器上运行）、客户端（仅在Actor的拥有客户端上运行）或NetMulticast（在连接会话的所有机器上运行，包括服务器）。\n\n\n\n虽然创建、销毁和移动等常见使用可自动处理，但即使启用复制，其他所有gameplay功能也不会默认自动复制\n必须根据游戏的需求明确指定要复制的变量和函数\n\nActor、Pawn和角色的部分常用功能不会复制：\n\n骨架网格体 和 静态网格体 组件\n材质\n动画蓝图\n粒子系统\n音效发射器\n物理对象\n\n1.3.2.2 网络角色和授权\n描述：\nActor的 网络角色 将决定网络游戏期间控制Actor的机器\n授权 Actor被认为可控制Actor的状态，并可将信息复制到网络多人游戏会话中的其他机器上\n远程代理 是该Actor在远程机器上的副本，其将接收授权Actor中的复制信息，由 Local Role 和 Remote Role 变量进行追踪\n\n\n\n\n\n\n网络角色\n说明\n\n\n\n无\nActor在网络游戏中无角色，不会复制。\n\n\n授权\nActor为授权状态，会将其信息复制到其他机器上的远程代理。\n\n\n模拟代理\nActor为远程代理，由另一台机器上的授权Actor完全控制。网络游戏中如拾取物、发射物或交互对象等多数Actor将在远程客户端上显示为模拟代理。\n\n\n自主代理\nActor为远程代理，能够本地执行部分功能，但会接收授权Actor中的矫正。自主代理通常为玩家直接控制的actor所保留，如pawn。\n\n\n\n虚幻引擎使用的默认模型是 服务器授权，意味着服务器对游戏状态固定具有权限，而信息固定从服务器复制到客户端\n服务器上的Actor应具有授权的本地角色，而其在远程客户端上的对应Actor应具有模拟或自主代理的本地角色\n\n1.3.2.3 客户端拥有权\n特定客户端机器上的 PlayerController 拥有网络游戏中的pawn\nPawn调用纯客户端函数时，其将无视调用函数的机器，而仅指向拥有玩家的机器\n将Actor的 Owner 变量设为特定Pawn，则通关关联，该Actor属于该Pawn的拥有客户端，并将纯客户端函数指向其拥有者的机器\nC++中的 IsLocallyControlled 函数，或蓝图中的 Is Locally Controlled 节点，以决定Pawn是否在其拥有客户端上\n由于构造期间Pawn可能未指定控制器，因此避免在自定义Pawn类的构造函数中使用 IsLocallyControlled\n\n1.3.2.4 相关性和优先级\n相关性：用于决定是否需要在多人游戏期间复制Actor\n\n复制期间将剔除被认为不相关的actor，此操作可节约带宽，以便相关Actor可更加高效地复制\n若Actor未被玩家拥有，且不在玩家附近，将其被视为不相关，而不会进行复制\n不相关Actor会存在于服务器上，且会影响授权游戏状态，但在玩家靠近前不会向客户端发送信息\n覆盖 IsNetRelevantFor 函数以手动控制相关性，并可使用 NetCullDistanceSquared 属性决定成为相关Actor所需距离\n\n\n优先级：有时在游戏单帧内，没有足够带宽供复制所有相关Actor，因此，Actor拥有 优先级(Priority) 值，用于决定优先复制的Actor\n\nPawn和PlayerController的 NetPriority 默认为 3.0，从而使其成为游戏中最高优先级的Actor，基础Actor的 NetPriority 为 1.0\nActor在被复制前经历的时间越久，每次成功通过时所处的优先级便越高\n\n\n\n1.3.3 变量复制\n描述：授权Actor上复制变量的值变更时，其信息将自动从授权Actor发送到连接会话的远程代理\n\nC++中使用对应 UPROPERTY 宏内的 Replicated 或 ReplicateUsing 说明符\n\n蓝图的细节面板中将它们指定为已复制，可将复制添加到变量和对象引用\n\n\n\n\n1.3.3.1 RepNotify\n描述：可指定在Actor成功接收特定变量的复制信息时要调用的 RepNotify 函数\n\nRepNotify仅在变量更新时本地触发\n触发gameplay逻辑响应授权Actor上的变量更改时，使用RepNotify可减少开销\n在C++中使用变量的 UPROPERTY 宏的 ReplicatedUsing 说明符可访问此功能\n蓝图中变量的复制设置以使用RepNotify\n\n\n补充：由于RepNotify可添加到需复制的变量中，而无需考虑其他gameplay功能，创建额外网络调用时刻节约大量带宽，因此RepNotify比RPC或复制函数更加好用\n\n\n1.3.4 远程过程调用(RPC)\n描述：远程过程调用也称为复制函数\n可在任何机器上进行调用，但会指示其的实现在与网络会话连接的特定机器上发生\n有三种类型的RPC\n\n\n\n\n\n\nRPC类型\n说明\n\n\n\nServer\n仅在主持游戏的服务器上调用。\n\n\nClient\n仅在拥有该函数所属Actor的客户端上调用。若Actor无拥有连接，将不会执行此逻辑。\n\n\nNetMulticast\n在与服务器连接的所有客户端及服务器本身上调用。\n\n\n蓝图：\n\nCustomEvent 的 Replicates 选项设置为其中一个\nRun On Server\nRun On Owning Client\nNet MultiCast\n\n\n要勾选Reliable\n\nC++：\n\n将一个自定义的函数声明为RPC，需要添加反射UFUNCTION()\n\nServer\nClient\nNetMultiCast\n\n\n额外添加Reliable\n\n其代码将在代码实现中使用后缀 _Implementation\n\nExampleClass.h\n123//服务器RPC MyFunction的声明。UFUNCTION(Server, Reliable, WithValidation)void MyFunction(int myInt);\n\nExampleClass.cpp\n12345//服务器RPC MyFunction的实现。void AExampleClass::MyFunction_Implementation(int myInt)&#123;    //游戏代码在此。&#125;\n\n1.3.4.1 可靠性\n描述：必须将RPC指定为 可靠 或 不可靠\n\n不可靠：\n\n不可靠RPC无法保证必会到达预定目的地，但其发送速度和频率高于可靠的RPC\n最适用于对gameplay而言不重要或经常调用的函数\n例如，由于Actor移动每帧都可能变换，因此使用不可靠RPC复制该Actor移动\n\n\n可靠：\n\n可靠的RPC保证到达预定目的地，并在成功接收之前一直保留在队列中\n最适合用于对gameplay很关键或者不经常调用的函数\n相关例子包括碰撞事件、武器发射的开始或结束，或生成Actor\n\n\n\n\n注意：\n\n滥用可靠函数可能导致其队列溢出，此操作将强制断开连接\n若逐帧调用复制函数，应将其设为不可靠\n若拥有与玩家输入绑定的可靠函数，应限制玩家调用该函数的频率\n\n\n\n1.3.4.2 验证\n描述：WithValidation 说明符表明除函数的实现外，还有可验证传入函数调用的数据的函数\n\n此验证函数与其负责的函数使用同一签名，但其将返回布尔而非原本返回值\n若返回 true，则其允许执行RPC的 Implementation；若返回 false，则防止执行\n\n\nExampleClass.cpp\n123456789//服务器RPC MyFunction的验证bool AExampleClass::MyFunction_Validation(int myInt)&#123;    /*         若myInt的值为负，建议不允许运行MyFunction_Implementation。         因此仅在myInt大于零时返回true。    */    return myInt &gt;= 0;&#125;\n\n2. 提示和深入阅读\n描述：戏中实现高效、稳定多人游戏系统的基本指南\n\n2.1 基本复制Actor清单\n将Actor的复制设置设为True\n若复制Actor需要移动，将复制移动（Replicates Movement）设为True\n生成或销毁复制Actor时，确保在服务器上执行该操作\n设置必须在机器间共享的变量，以便进行复制。这通常适用于以gameplay为基础的变量\n尽量使用虚幻引擎的预制移动组件，其已针对复制进行构建\n若使用服务器授权模型，需确保玩家可执行的新操作均由服务器函数触发\n\n2.2 网络提示\n尽可能少用RPC或复制蓝图函数。在合适情况下改用RepNotify\n组播函数会导致会话中各连接客户端的额外网络流量，需尤其少用\n若能保证非复制函数仅在服务器上执行，则服务器RPC中无需包含纯服务器逻辑\n将可靠RPC绑定到玩家输入时需谨慎。玩家可能会快速反复点击按钮，导致可靠RPC队列溢出。应采取措施限制玩家激活此项的频率\n若游戏频繁调用RPC或复制函数，如tick时，则应将其设为不可靠\n部分函数可重复使用。调用其响应游戏逻辑，然后调用其响应RepNotify，确保客户端和服务器拥有并列执行即可\n检查Actor的网络角色可查看其是否为 ROLE_Authority。此方法适用于过滤函数中的执行，该函数同时在服务器和客户端上激活\n使用C++中的 IsLocallyControlled 函数或蓝图中的Is Locally Controlled函数，可检查Pawn是否受本地控制。基于执行是否与拥有客户端相关来过滤函数时，此方法十分有用\n构造期间Pawn可能未被指定控制器，因此避免在构造函数脚本中使用 IsLocallyControlled\n\n3. Actor 复制Actor 主要通过两种方式进行更新：\n\n属性更新\nRPC （远程过程调用）\n属性更新和 RPC 的主要区别在于，属性可以在发生变化时随时自动更新，而 RPC 只能在被执行时获得调用更新\n\n复制例子：Actor 的健康值\n\n当健康值发生变化时，您通常都希望告知客户端。如果健康值没有变化，则不会发送任何数据\n即使这个属性没有变化（因此不消耗任何带宽），它仍然会消耗 CPU 资源来判断这个值是否发生变化\n适合那些经常变化的属性\n\nRPC例子：同一场爆炸\n\n可以以位置和半径为参数的 RPC 函数，同时在每次发生爆炸时调用它\n也可以将此存储为一组属性，通过同步的方式将其传达给客户端\n这种做法会损失一些效率，因为爆炸出现的频繁度也许不会高得有必要将它们作为属性\n\n3.1 组件复制3.1.1 组件复制介绍介绍：\n\n虚幻引擎 4 支持组件复制\n大多数组件都不会复制\n多数游戏逻辑都是在 Actor 类和组件中完成，而它们 通常只代表了构成 Actor 的零散部分\n实际复制的是 Actor 中的游戏逻辑，而这样做的结果，有时会调用&#x2F;更改组件\n有些情况下，组件本身的属性或事件必须要直接复制\n一旦复制了 Actor，它就可以复制自身组件\n这些组件 可以按 Actor 的方式复制属性和 RPC\n组件必须以 Actor 的方式实施 ::GetLifetimeReplicatedProps (...) 函数\n\n组件复制涉及两大类组件：\n\n静态组件：一种是随 Actor 一起创建的组件\n\n在客户端或服务器上生成 所属 Actor 时，这些组件也会同时生成，与组件是否被复制无关\n服务器不会告知客户端显式生成这些组件\n静态组件无需通过复制存在于客户端\n只有在属性或事件需要在服务器和客户端之间自动同步时，才需要进行复制\n\n\n动态组件：运行时在服务器上生成的组件种，其创建和删除操作也将被复制到客户端\n\n运行方式与 Actor 极为一致\n动态组件需通过复制的方式存在于所有客户端\n客户端可以生成自己的本地非复制组件，当那些在服务器上触发的 属性或事件需要自动同步到客户端时，才会出现复制行为\n\n\n\n3.1.2 使用方式\n在组件上设置属性和 RPC 的过程与 Actor 并无区别\n\n将一个类设置为具有复本后，这些组件的实际实例也必须经过设置后才能复制\n\nC++\n\n调用 AActorComponent::SetIsReplicated(true) 即可\n\n如果组件是一个默认子对象，就应当在生成组件之后通过类构造函数来完成此调用\n\n示例：\n1234567891011121314151617ACharacter::ACharacter()&#123;    // Etc...    CharacterMovement = CreateDefaultSubobject&lt;UMovementComp_Character&gt;(TEXT(&quot;CharMoveComp&quot;));    if (CharacterMovement)    &#123;        CharacterMovement-&gt;UpdatedComponent = CapsuleComponent;        CharacterMovement-&gt;GetNavAgentProperties()-&gt;bCanJump = true;        CharacterMovement-&gt;GetNavAgentProperties()-&gt;bCanWalk = true;        CharacterMovement-&gt;SetJumpAllowed(true);        CharacterMovement-&gt;SetNetAddressable(); // Make DSO components net addressable        CharacterMovement-&gt;SetIsReplicated(true); // Enable replication by default    &#125;&#125;\n\n\n\n蓝图\n\n要进行静态蓝图组件复制，只需在组件默认设置中切换 Replicates 布尔变量\n\n静态组件需要在客户端和服务器上隐式创建\n\n并非所有组件都会如此显示，必须要支持某种复制形式才会显示\n\n\n通过动态生成的组件来实现这一点，可以调用 SetIsReplicated 函数\n\n\n\n3.1.3 时间轴\n时间轴必须通过其属性中的 Replicated 选项来启用复制\n会将服务器控制的运行位置、速率和方向复制到客户端\n大多数时间轴都无需复制\n时间轴复本只应当在服务器上直接 操作 (start&#x2F;stop etc)\n客户端只应当查看运行位置的复本，而不应尝试改变时间轴本身\n在进行复制更新的间歇，客户端将推测 运行位置\n\n3.1.4 带宽开销\n复制组件时的资源开销是比较低的\n复制的 Actor 中的每个组件都需要添加一个额外的 NetGUID（4 字节）”标头”和一个大约 1 字节的”标脚”（footer） 及其属性\n在 CPU 层面上，基于 Actor 的属性复制与基于组件的复制之间应当有一个最小差异\n\n3.1.5 一般性子对象复制\n所有 Actor 子对象都可以复制，而不只限于组件\n\n对于希望复制非 ActorComponent 子对象的类，应当实施三种方法\n12345678/** FActory 方法，用于对模板化 TobjectReplicator 类进行实例化，以便实现子对象复制 */virtual class FObjectReplicatorBase * InstantiateReplicatorForSubObject(UClass *SubobjClass);/** 能让 Actor 在其 Actor 通道上复制子对象的方法 */virtual bool ReplicateSubobjects(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags);/** 通过复制来动态创建新的子对象时，在 Actor 上进行调用 */virtual void OnSubobjectCreatedFromReplication(UObject *NewSubobject);\n\n3.1.5.1 使用情形\n能在 Actor 通道的层面上使用 UObject 和多态（polymorphism）\n之前用于复杂数据结构的复制方法只适合那些 在 Actor 类中对类型进行静态定义的结构\n利用子对象复制，建立一个道具栏系统，使其中的每个物品作为一个从基本道具栏类扩展而来的类， 也可以进行完整复制，同时无需让这些项成为 Actor（资源负担太大）\n\n3.1.5.2 优化\n有很多子对象需要复制，Actor 只需了解哪些子对象（如存在）最近发生过变化且需要复制，从而节省了大量时间\n\n通过访问器（accessor）函数来持续跟踪子对象的更改情况\n\n所用的接口位于 UActorChannel 中\n1bool KeyNeedsToReplicate(int32 ObjID, int32 RepKey);\n\n该函数应当由 Actor 在其 ::ReplicateSubobjects 实施中调用\n\nActor 类可以设置一个任意的对象 ID 和复制键，供复制系统跟踪每个客户端\n\n对象 ID 和复制键完全是任意指定的\n\n对象 ID 仅用于引用”事情”\n\n可以是整个子对象列表、部分列表或单个对象\n\n\n复制键同样可以任意指定\n\n可以是一个在对象 ID 跟踪变化时递增的计数器\n\n\n\n3.2 Actor及其所属连接3.2.1 连接\n每个连接都有一个专门为其创建的 PlayerController\n确定一个 actor 是否归某一连接所有，您可以查询这个 actor 最外围的所有者\n所有者是一个 PlayerController，则这个 actor 同样归属于拥有 PlayerController 的那个连接\n\n3.2.2 确定连接\n在确定所属连接方面，组件有一些特殊之处\n首先确定组件所有者，方法是遍历组件的”外链”，直到找出所属的 actor\n确定这个 actor 的所属连接，像上面那样继续下去\n连接所有权是以下情形中的重要因素：\nRPC 需要确定哪个客户端将执行运行于客户端的 RPC\nActor 复制与连接相关性\n在涉及所有者时的 Actor 属性复制条件\n\n\n\n\n\n3.2.3 连接的作用\n连接所有权对于 RPC 这样的机制至关重要，因为当您在 actor 上调用 RPC 函数时\n\n除非 RPC 被标记为多播，否则就需要知道要在哪个客户端上执行该 RPC\n\n它可以查找所属连接来确定将 RPC 发送到哪条连接\n\n连接所有权会在 actor 复制期间使用，用于确定各个 actor 上有哪些连接获得了更新\n\n对于那些将 bOnlyRelevantToOwner 设置为 true 的 actor，只有拥有此 actor 的连接才会接收这个 actor 的属性更新\n\n默认情况下，所有 PlayerController 都设置了此标志，正因如此，客户端才只会收到它们拥有的 PlayerController 的更新\n\n最主要的是防止玩家作弊和提高效率\n\n对于那些要用到所有者的 需要复制属性的情形 来说，连接所有权具有重要意义：\n\n当使用 COND_OnlyOwner 时，只有此 actor 的所有者才会收到这些属性更新\n\n\n所属连接对那些作为自治代理的 actor（角色为 ROLE_AutonomousProxy）来说也很重要\n\n这些 actor 的角色会降级为 ROLE_SimulatedProxy，其属性则被复制到不拥有这些 actor 的连接中\n\n\n\n3.3 Actor相关性与优先级3.3.1 相关性前提：\n\n场景的规模可能非常大，在特定时刻某个玩家只能看到关卡中的一小部分 Actor\n场景中的其他大多数 Actor 都不会被看到和听到， 对玩家也不会产生显著的影响\n被服务器认为可见或能够影响客户端的 Actor 组会被视为该客户端的相关 Actor 组\n\n虚幻引擎的网络代码中包含一处重要的带宽优化：\n\n服务器只会让客户端知道其相关组内的 Actor\n\n参照以下规则确定玩家的相关 Actor 组：在虚拟函数 AActor::IsNetRelevantFor() 中实施\n\n如果 Actor 是 bAlwaysRelevant、归属于 Pawn 或 PlayerController、本身为 Pawn 或者 Pawn 是某些行为（如噪音或伤害）的发起者，则其具有相关性\n如果 Actor 是 bNetUseOwnerRelevancy 且拥有一个所有者，则使用所有者的相关性\n如果 Actor 是 bOnlyRelevantToOwner 且没有通过第一轮检查，则不具有相关性\n如果 Actor 被附加到另一个 Actor 的骨架模型，它的相关性将取决于其所在基础的相关性\n如果 Actor 是不可见的 (bHidden &#x3D;&#x3D; true) 并且它的 Root Component 并没有碰撞，那么则不具有相关性\n如果没有 Root Component 的话，AActor::IsNetRelevantFor() 会记录一条警告，提示是否要将它设置为 bAlwaysRelevant&#x3D;true\n\n\n如果 AGameNetworkManager 被设置为使用基于距离的相关性，则只要 Actor 低于净剔除距离，即被视为具有相关性\n\n注意：\n\nPawn 和 PlayerController 将覆盖 AActor::IsNetRelevantFor() 并最终具有不同的相关性条件\n\n缺点：\n\n距离检查在遇到大型 Actor 时可能会出现漏报（尽管我们用了一些启发式方法来应对），也不能处理环境声音的吸收\n相对于互联网的延迟和数据包丢失这些网络环境所固有的问题来说，这种近似法产生的错误就不那么明显了\n\n3.3.2 优先级设定介绍：虚幻引擎采用了负载平衡技术来安排所有 Actor 的优先级，并根据它们对游戏的重要性为其分别提供一个公平的带宽份额\n原理：\n\n每个 Actor 都有一个名为 NetPriority 的浮点变量\n变量的数值越大，Actor 相对于其他”同伴”的带宽就越多\n和优先级为 1.0 的 Actor 相比，优先级是 2.0 的 Actor 可以得到两倍的更新频度\n唯一影响优先顺序的就是它们的比值\n所以无法通过提高所有优先级的数值来增加虚幻引擎的网络性能\n\n例子：\n\nActor &#x3D; 1.0\nMatinee &#x3D; 2.7\nPawn &#x3D; 3.0\nPlayerController &#x3D; 3.0\n\n使用：\n\n计算 Actor 的当前优先级时使用了虚拟函数 AActor::GetNetPriority()\n为避免出现饥荒（starvation），AActor::GetNetPriority() 使用 Actor 上次复制后经过的时间 去乘以 NetPriority\n同时，GetNetPriority 函数还考虑了 Actor 与观察者的相对位置以及两者之间的距离\n\n3.4 Actor复制流程详述介绍：\n\n大多数 actor 复制操作都发生在 UNetDriver::ServerReplicateActors 内\n服务器将收集所有被认定与各个客户端相关的 actor，并发送那些自上次（已连接的）客户端更新后出现变化的所有属性\n\n3.4.1 复制流程复制连接流程：指定了 actor 的更新方式、要调用的特定框架回调，以及在此过程中使用的特定属性\n\nAActor::NetUpdateFrequency - 用于确定 actor 的复制频度\nAActor::PreReplication - 在复制发生前调用\nAActor::bOnlyRelevantToOwner - 如果此 actor 仅复制到所有者，则值为 true\nAActor::IsRelevancyOwnerFor - 用于确定 bOnlyRelevantToOwner 为 true 时的相关性\nAActor::IsNetRelevantFor - 用于确定 bOnlyRelevantToOwner 为 false 时的相关性\n\n高级流程：\n\n循环每一个主动复制的 actor（AActor::SetReplicates( true )）\n\n确定这个 actor 是否在一开始出现休眠（DORM_Initial），如果是这样，则立即跳过\n通过检查 NetUpdateFrequency 的值来确定 actor 是否需要更新，如果不需要就跳过\n如果 AActor::bOnlyRelevantToOwner 为 true，则检查此 actor 的所属连接以寻找相关性（对所属连接的观察者调用 AActor::IsRelevancyOwnerFor），如果相关，则添加到此连接的已有相关列表\n此时，这个 actor 只会发送到单个连接\n\n\n对于任何通过这些初始检查的 actor，都将调用 AActor::PreReplication\nPreReplication 可以让您决定是否针对连接来复制属性，这时要使用 DOREPLIFETIME_ACTIVE_OVERRIDE\n\n\n如果同过了以上步骤，则添加到所考虑的列表\n\n\n对于每个连接：\n\n对于每个所考虑的上述 actor\n确定是否休眠\n是否还没有通道\n确定客户端是否加载了 actor 所处的场景\n如未加载则跳过\n\n\n针对连接调用 AActor::IsNetRelevantFor，以确定 actor 是否相关\n如不相关则跳过\n\n\n\n\n\n\n在归连接所有的相关列表上添加上述任意 actor\n这时，我们拥有了一个针对此连接的相关 actor 列表\n按照优先级对 actor 排序\n对于每个排序的 actor：\n如果连接没有加载此 actor 所在的关卡，则关闭通道（如存在）并继续\n每 1 秒钟调用一次 AActor::IsNetRelevantFor，确定 actor 是否与连接相关\n如果不相关的时间达到 5 秒钟，则关闭通道\n如果相关且没有通道打开，则立即打开一个通道\n如果此连接出现饱和\n对于剩下的 actor\n如果保持相关的时间不到 1 秒，则强制在下一时钟单位进行更新\n如果保持相关的时间超过 1 秒，则调用 AActor::IsNetRelevantFor 以确定是否应当在下一时钟单位更新\n\n\n\n\n对于通过了以上这几点的 actor，将调用 UChannel::ReplicateActor 将其复制到连接\n\n\n\n\n\n3.4.2 Actor复制到连接流程：UChannel::ReplicateActor 将负责把 actor 及其所有组件复制到连接中\n\n确定这是不是此 actor 通道打开后的第一次更新\n如果是，则将所需的特定信息（初始方位、旋转等）序列化\n\n\n确定该连接是否拥有这个 actor\n如果没有，而且这个 actor 的角色是 ROLE_AutonomousProxy，则降级为 ROLE_SimulatedProxy\n\n\n复制这个 actor 中已更改的属性\n复制每个组件中已更改的属性\n对于已经删除的组件，发送专门的删除命令\n\n3.5 Role和RemoteRole介绍： Actor 的复制过程中，有两个属性扮演了重要角色，分别是 Role 和 RemoteRole\n作用：有了这两个属性，可以知道\n\n谁拥有 actor 的主控权\nactor 是否被复制\n复制模式\n\n前提：\n\n首先一件要确定的事，就是谁拥有特定 actor 的主控权\n确定当前运行的引擎实例是否有主控者，需要查看 Role 属性是否为 ROLE_Authority\n如果是，就表明这个运行中的引擎实例负责掌管此 actor（决定其是否被复制）\n如果 Role 是 ROLE_Authority，RemoteRole 是 ROLE_SimulatedProxy 或 ROLE_AutonomousProxy\n就说明这个引擎实例负责将此 actor 复制到远程连接\n\n\n\n注意：\n\n只有服务器能够向已连接的客户端同步 Actor （客户端永远都不能向服务器同步）\n只有 服务器才能看到 Role == ROLE_Authority 和 RemoteRole == ROLE_SimulatedProxy 或者 ROLE_AutonomousProxy\n\n3.5.1 Role&#x2F;RemoteRole对调对于不同的数值观察者，它们的 Role 和 RemoteRole 值可能发生对调\n例子：\n\n服务器上有这样的配置：\n\nRole == ROLE_Authority\nRemoteRole == ROLE_SimulatedProxy\n\n\n客户端会将其识别为以下形式：\n\nRole == ROLE_SimulatedProxy\nRemoteRole == ROLE_Authority\n\n\n这种情况是正常的，因为服务器要负责掌管 actor 并将其复制到客户端\n\n而客户端只是接收更新，并在更新的间歇模拟 actor\n\n\n3.5.2 复制模式前提：\n\n服务器不会在每次更新时复制 actor\n会消耗太多的带宽和 CPU 资源\n服务器会按照 AActor::NetUpdateFrequency 属性指定的频度来复制 actor\n因此在 actor 更新的间歇，会有一些时间数据被传递到客户端\n会导致 actor 呈现出断续、不连贯的移动\n弥补这个缺陷，客户端将在更新的间歇中模拟 actor\n\n两种模拟：\n\nROLE_SimulatedProxy\n\n标准的模拟途径，通常是根据上次获得的速率对移动进行推算\n服务器为特定的 actor 发送更新时，客户端将向着新的方位调整其位置，然后利用更新的间歇，根据由服务器发送的最近的速率值来继续移动 actor\n\n\nROLE_AutonomousProxy\n\n这种模拟通常只用于 PlayerController 所拥有的 actor\n说明此 actor 会接收来自真人控制者的输入，所以在我们进行推算时，我们会有更多一些的信息，而且能使用真人输入内容来补足缺失的信息（而不是根据上次获得的速率来进行推算）\n\n\n\n3.6 RPC简介：\n\nRPC （远程过程调用）是在本地调用但在其他机器（不同于执行调用的机器）上远程执行的函数\n允许客户端或服务器通过网络连接相互发送消息\n\n作用：\n\n执行那些不可靠的暂时性&#x2F;修饰性游戏事件\n包括播放声音、生成粒子或产生其他临时效果 之类的事件，它们对于 Actor 的正常运作并不重要\n在此之前，这些类型的事件往往要通过 Actor 属性进行复制\n\n3.6.1 使用RPC\n声明：将一个函数声明为 RPC，您只需将 Server、Client 或 NetMulticast 关键字添加到 UFUNCTION 声明\n\n例子1：要将某个函数声明为一个要在服务器上调用、但需要在客户端上执行的 RPC\n12UFUNCTION( Client )void ClientRPCFunction();\n\n\n\n例子2：将某个函数声明为一个要在客户端上调用、但需要在服务器上执行的 RPC，您可以采取类似的方法，但需要使用 Server 关键字\n12UFUNCTION( Server )void ServerRPCFunction();\n\n\n\n例子3：多播 RPC 可以从服务器调用，然后在服务器和当前连接的所有客户端上执行，需使用 NetMulticast 关键字\n12UFUNCTION( NetMulticast )void MulticastRPCFunction();\n\n注：多播 RPC 还可以从客户端调用，但这时就只能在本地执行\n\n\n3.6.2 快速提示\n在函数的开头预置 Client、Server 或 Multicast 关键字\n这是我们在内部所做的一个约定，用来告诉程序员所用的函数将分别在客户端、服务器或所有客户端上调用\n事先确定该函数将在多人游戏会话期间被哪些机器调用\n\n3.6.3 要求和注意事项前提：\n\n它们必须从 Actor 上调用\nActor 必须被复制\n如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数\n如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor\n多播 RPC 则是个例外：\n如果它们是从服务器调用，服务器将在本地和所有已连接的客户端上执行它们\n如果它们是从客户端调用，则只在本地而非服务器上执行\n有一个简单的多播事件限制机制：在特定 Actor 的网络更新期内，多播函数将不会复制两次以上\n\n\n\n3.6.3.1 从服务器调用的RPC\n\n\nActor 所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nClient-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在 actor 的所属客户端上运行\n\n\nServer-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\nUnowned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n3.6.3.2 从客户端调用的RPC\n\n\nActor 所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nOwned by invoking client\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n在服务器上运行\n在执行调用的客户端上运行\n\n\nOwned by a different client\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nServer-owned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nUnowned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\n3.6.4 可靠性\n默认情况下，RPC 并不可靠\n\n要确保在远程机器上执行 RPC 调用，可以指定 Reliable 关键字\n12UFUNCTION( Client, Reliable )void ClientRPCFunction();\n\n3.6.5 蓝图前提：\n\n如果被标记为 RPC 的函数是从蓝图中调用，它们也会被复制\n它们将遵循相同的规则，就像是从 C++ 调用一样\n在此情况下，无法将函数动态标记为蓝图的 RPC\n自定义事件可以从蓝图编辑器内部被标记为复制\n\n使用：\n\n使用此功能，您需要在您的事件图表中新建一个自定义事件\n\n单击自定义事件并在详细信息视图中编辑复制设置\n\n\n\n3.6.6 验证使用验证的原因：\n\n作为检测错误数据&#x2F;输入的一个手段\n如果 RPC 的验证函数检测到任何 参数存在问题，就会通知系统将发起 RPC 调用的客户端&#x2F;服务器断开\n会通知系统将发起 RPC 调用的客户端&#x2F;服务器断开\n\n例：\n\n要为 RPC 声明一个验证函数，只需将 WithValidation 关键字添加到 UFUNCTION 声明语句\n12UFUNCTION( Server, WithValidation )void SomeRPCFunction( int32 AddHealth );\n\n然后在实施函数旁边加入验证函数\n12345678910111213bool SomeRPCFunction_Validate( int32 AddHealth )&#123;    if ( AddHealth &gt; MAX_ADD_HEALTH )    &#123;        return false;                       // This will disconnect the caller    &#125;return true;                              // This will allow the RPC to be called&#125;void SomeRPCFunction_Implementation( int32 AddHealth )&#123;    Health += AddHealth;&#125;\n\n\n\n注：\n\n被添加到 UHT，以便要求客户端 -&gt; 服务器 RPC 具有一个 _Validate 函数\n鼓励使用安全的服务器 RPC 函数，同时尽可能方便其他人 添加代码以检查所有参数，确保其符合所有已知的输入限制\n\n\n\n3.7 属性复制说明：\n\n每个Actor维护一个全属性列表，其中包含Replicated 说明符\n每当复制的属性值发生变化时，服务器会向所有客户端发送更新\n客户端会将其应用到Actor的本地版本上\n这些更新只会来自服务器，客户端永远不会向服务器或其他客户端发送属性更新\n\n注意：\n\n不推荐在客户端上更改复制的变量值\n该值将始终与服务器端的值不一致，直到服务器下一次侦测到变更并发送更新为止\n如果服务器版本的属性不是经常更新，那客户端就需要等待很长时间才能被纠正\n\nTips：\n\nActor属性复制可靠\n\n意味着，Actor的客户端版本的属性最终将反映服务器上的值，但客户端不必接受服务器上某个属性的每一个单独变更\n\n例：\n\n如果一个整数属性的值快速从100变成200，然后又变成了300\n客户端将最终接受一个值为300的变更，但客户端不一定会知道这个值曾经变成过200\n\n\n\n3.7.1 设置要复制的属性\n复制属性：在定义属性的Actor类标头处，您需要确保replicated关键字作为UPROPERTY声明的参数之一\n12345class ENGINE_API AActor : public UObject&#123;    UPROPERTY( replicated )    AActor * Owner;&#125;;\n\n\n\n在Actor类的实现过程中，需要实现GetLifetimeReplicatedProps函数\n1234void AActor::GetLifetimeReplicatedProps( TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps ) const&#123;    DOREPLIFETIME( AActor, Owner );&#125;\n\n\n\n在Actor的构造函数中，确保将bReplicates标记设置为true\n1234AActor::AActor( const class FPostConstructInitializeProperties &amp; PCIP ) : Super( PCIP )&#123;     bReplicates = true;&#125;\n\n注：对于当前实例化的Actor类型的每个副本，成员变量”Owner”现在将同步到所有连接的客户端（在本例中为基础Actor类）\n\n\n3.7.2 网络更新优化3.7.2.1 数据驱动型网络更新频率\nActor将观察在其NetUpdateFrequency变量中设置的最大更新频率\n通过在不太重要或不太频繁变化的Actor上降低该变量，网络更新可以变得更高效，同时在有限带宽的场景中可能会带来更流畅的游戏体验\n常见的更新频率值为：\n重要且不可预知的Actor：射击游戏中由玩家控制的角色，为10（每0.1秒更新一次）\n对于行动缓慢的角色：\n合作类游戏中由AI控制的怪物，为5（每0.2秒更新一次）\n对于游戏进程不是很重要但仍通过网络同步的以及&#x2F;或者由服务器端逻辑控制因而需要复制的后台Actor，为2（每0.5秒更新一次）\n\n\n\n\n\n3.7.2.2 自适应型网络更新频率Tips：\n\n在默认情况下，该功能是关闭的\n将控制台变量 net.UseAdaptiveNetUpdateFrequency 设置到 1 可以将其激活\n\n作用：\n\n节省CPU周期，这些CPU周期通常会在没有任何实际更改的情况下多次尝试复制Actor而浪费掉\n\n启用了该功能时，系统将根据各个Actor的更新是否有意义，动态调整其更新频率\n\n有意义：\n\n初始化了Actor、添加或删除了子对象（即拥有的组件）\n更改了Actor上或其任何子对象上复制字段值的任何更新\n\n\n每个Actor可能的更新速率范围由Actor本身的两个变量决定：NetUpdateFrequency和MinNetUpdateFrequency\n\nNetUpdateFrequency表示Actor每秒尝试更新自己的最大次数，而MinNetUpdateFrequency表示每秒尝试更新的最小次数\n\n使用该功能可以大大提高复制性能\n\n\n3.7.2.3 更新频率降低算法\n在更新尝试期间，Actor将确定最近一次有意义的更新发送到现在有多长时间，如果它们发送了有意义的更新，将记录新的时间\n例1：\n进行更新的Actor超过2秒没有发送有意义的更新，那么它将开始降低更新频率\n在没有发送有意义的更新的情况下，更新频率将在7秒后达到最小\n\n\n例2：\n更新延迟在0.1秒到0.6秒之间的Actor在3秒内没有任何有意义的更新\n那么它将在0.2秒内尝试下一次更新\n\n\n\n3.7.2.4 更新频率增加算法\n在发送一个有意义的更新之后，Actor将安排下一个更新发生的时间，使其比前两次有意义的更新之间的时间短30%，并且处于最小更新频率与最大更新频率之间\n\n如果Actor在两次有意义的更新之间恰好间隔了一秒，那么它会将下一次更新尝试安排在未来0.7秒\n\n或者接近指定的最小与最大更新频率的时间\n\n接下来每次有意义的更新，都将重复该计算，如果Actor开始频繁地进行数据或子对象更改，将快速缩短更新之间的时间\n\n\n3.8 条件属性复制前提：\n\n当属性被注册进行复制后，您将无法再取消注册（涉及到生存期）\n因为要预制尽可能多的信息，以便针对同一组属性将某一工作分担给多个连接\n可以节省大量的计算时间\n\n说明：\n\n默认情况下，每个复制属性都有一个内置条件：如果不发生变化就不会进行复制\n\n为了加强对属性复制的控制，使用一个专门的宏来添加附加条件\n\n这个宏被称为 DOREPLIFETIME_CONDITION\n\n1234void AActor::GetLifetimeReplicatedProps( TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps ) const&#123;    DOREPLIFETIME_CONDITION( AActor, ReplicatedMovement, COND_SimulatedOnly );&#125;\n\n传递给条件宏的 COND_SimulatedOnly 标志甚至可以在考虑复制属性前执行一次额外检查\n\n这时，它只会复制到拥有此 actor 模拟复本的客户端\n\n\n作用：\n\n最明显的好处在于节省带宽\n因为我们确信拥有此 actor 的自治代理版本的客户端无需了解这个属性\n例：\n该客户端为了进行预测而直接设置了这一属性\n对于不接收该属性的客户端而言，服务器无需干涉这个客户端的本地复本\n\n\n\n使用：\n\n目前支持的条件，在 Engine\\Source\\Runtime\\CoreUObject\\Public\\UObject\\CoreNet.h 的 ELifetimeCondition 枚举中指定\n\n\n\n\n条件\n说明\n\n\n\nCOND_InitialOnly\n该属性仅在初始数据组尝试发送\n\n\nCOND_OwnerOnly\n该属性仅发送至 actor 的所有者\n\n\nCOND_SkipOwner\n该属性将发送至除所有者之外的每个连接\n\n\nCOND_SimulatedOnly\n该属性仅发送至模拟 actor\n\n\nCOND_AutonomousOnly\n该属性仅发送给自治 actor\n\n\nCOND_SimulatedOrPhysics\n该属性将发送至模拟或 bRepPhysics actor\n\n\nCOND_InitialOrOwner\n该属性将发送初始数据包，或者发送至 actor 所有者\n\n\nCOND_Custom\n该属性没有特定条件，但需要通过 SetCustomIsActiveOverride 得到开启&#x2F;关闭能力\n\n\n补充：\n\n有一个名叫 DOREPLIFETIME_ACTIVE_OVERRIDE 的宏可以进行全面控制\n\n利用任何定制条件来决定何时复制&#x2F;不复制某个属性\n\n需要注意的是：\n\n这种控制需针对每个 actor（而不是每条连接）逐一进行\n在定制条件中使用一个可根据连接而发生变化的状态，会存在一定的安全风险\n\n1234void AActor::PreReplication( IRepChangedPropertyTracker &amp; ChangedPropertyTracker )&#123;    DOREPLIFETIME_ACTIVE_OVERRIDE( AActor, ReplicatedMovement, bReplicateMovement );&#125;\n\n现在 ReplicatedMovement 属性只会在 bReplicateMovement 为 true 时复制\n\n不使用这个宏的原因：\n\n如果定制条件的值变化太大，这种做法会降低执行速度\n您不能使用根据连接而变化的条件（此时不检查 RemoteRole）\n\n\n\n条件属性复制的好处：\n\n属性复制条件可以很好的实现控制力与性能之间的平衡\n可以使引擎以更快的速度针对多条连接检查并发送属性\n同时让程序员对复制属性的方式和时机进行精细控制\n\n3.9 复制对象引用前提：\n\n一般而言，对象引用会在 UE4 多人游戏架构中自动处理\n一个已经复制的 UObject 属性，该对象的引用将作为服务器分配的专门 ID 通过网络进行发送\n这个专门 id 是一个 FNetworkGUID\n服务器将负责分配此 id，然后向所有已连接的客户端告知这一分配\n\n使用：\n\n需将一个 UObject 属性标记为已复制\n12345class ENGINE_API AActor : public UObject&#123;    UPROPERTY( replicated )    AActor * Owner;&#125;;\n\nOwner 属性将作为其引用的 actor 的一个复制引用\n\n注意：\n\n通过网络合法引用的对象，必须对其提供支持以保证网络连接\n要进行检查，可以调用 UObject::IsSupportedForNetworking()\n这是一个底层函数，所以一般不需要在游戏代码中对其进行检查\n\n\n\n其他方式：\n\n任何复制的 actor 都可以复制为一个引用\n任何未复制的 actor 都必须有可靠命名（直接从数据包加载）\n任何复制的组件都可以复制为一个引用\n任何未复制的组件都必须有可靠命名。\n其他所有 UObject（非 actor 或组件）必须由加载的数据包直接提供\n\n3.9.1 拥有可靠命名的对象说明：\n\n拥有可靠命名的对象指的是存在于服务器和客户端上的同名对象\n如果 Actor 是从数据包直接加载（并非在游戏期间生成），它们就被认为是拥有可靠命名\n\n方式：\n\n从数据包直接加载\n通过简单构建脚本添加\n采用手动标记（通过 UActorComponent::SetNetAddressable 进行）\n只有当您知道要手动命名组件以便其在服务器和客户端上具有相同名称时，才应当使用这种方法\n（最好的例子就是 AActor C++ 构造函数中添加的组件）\n\n\n\n3.10 蓝图使用RPC远程调用函数主要包括 3 种类型：\n\nMulticast 广播：广播函数在服务器上调用和执行，然后自动转发给客户端\nServer的函数，Server调用，Server执行，复制给所有在场的Actor\n\n\nRun on Server 在服务端执行：在服务端执行的函数由客户端调用，然后仅在服务器上执行\nServer的函数，Client调用，Server执行\n\n\nRun on owning Client 在客户端执行：在客户端执行的函数由服务器调用，然后仅在自有客户端上执行\nClient的函数，Server调用，Client执行\n\n\n\n3.10.1 Multicast广播\n自定义事件\n\n然后在 Details 面板中将 Replicates 下拉菜单设置为 Multicast\n\n\n从 Space Bar 按键事件连出来，搜索并添加调用函数MulticastSpawn\n\n\n编译 并 保存，关闭蓝图，然后单击 运行 按钮在编辑器中开始游戏\n\n在游戏中，定位服务器所在的窗口，然后按 Space Bar 跳转\n\n\n服务器上的玩家按跳转时，服务器和所有客户端上都将生成喷火效果\n\n其他玩家跳转仍只能在本地喷火，因为我们并未告知服务器客户端已生成该效果\n\n\n3.10.2 RunOnServer\n选择 MulticastSpawn 自定义事件，然后将 Replicates 下拉选项更改为 Run on Server\n\n\n编译 并 保存，关闭蓝图，然后单击 运行 按钮在编辑器中开始游戏\n\n在游戏中，定位非服务器的任何游戏窗口，然后按 Space Bar 跳转\n\n\n注意，喷火效果只在服务器上生成，无论哪个玩家跳转，其他玩家都看不到，只有服务器端才能看到\n\n我们需确保该效果已设置为复制，以便其传递给所有客户端和服务器\n\n在 Content&#x2F;StarterContent&#x2F;Blueprints 文件夹中，打开 Blueprint_Effect_Fire 蓝图\n\n从主工具栏中选择 Class Defaults 后，在 Details 面板中，选中 Replicates 复选框\n\n\n编译 并 保存，关闭蓝图，然后单击 运行 按钮在编辑器中开始游戏\n\n在游戏中，定位非服务器的任何游戏窗口，然后按 Space Bar 跳转\n\n\n向服务器发送消息，以在服务器运行部分脚本来生成 Actor，由于此 Actor 已设置为复制，因此我们可以在所有客户端上看到它\n\n\n3.10.3 RunOnOwningClient说明：在此示例中，我们要做到是创建一个发生服务器事件时仅在特定客户端上更新的变量\n步骤：设置 Run on owning Client 复制函数\n\n在 Content&#x2F;ThirdPersonBP&#x2F;Blueprints 文件夹中，打开 ThirdPersonCharacter 蓝图\n\n在 MyBlueprint 窗口中，创建新变量并将其命名为 Inventory，然后单击 Compile\n\n\n在此变量的 Details 面板中，将其设置为 String、Editable 和 Replicated，然后为 Default Value 输入 Empty\n\n\n将此变量设置为 Replicated 可确保其通过网络复制到所连接的机器上\n\n我们将使用此变量模拟人物在多人游戏中进入触发卷时收集道具，退出触发卷时删除道具\n\n\n\n添加一个与 Print String 连接的 P 按键事件，然后按住 Control 并拖入 Inventory 变量，并按所示方式连接\n\n\nCompile 并 Save，然后关闭 ThirdPersonCharacter 蓝图\n\n在 放置Actor（Place Actors） 的 基础（Basic） 选项卡中，将 盒体触发器（Box Trigger） 拖入你的关卡\n\n\n当玩家人物进入触发器时，我们将更新创建的变量，但仅在进入触发器盒的客户端上更新。\n\n\n在 Rendering 下 Box Trigger 的 Details 面板中，取消选中 Actor Hidden In Game。\n\n\n在编辑器中玩游戏时，这可让我们在关卡中看到此盒，使得测试更加轻松\n\n\n单击 Box Trigger 将其选中，然后从主工具栏打开Level Blueprint。\n\n\n在图表中 右键 ，然后搜索 Begin Overlap 并选择 Add On Actor Begin Overlap 事件\n\n\n重复上一步，但搜索并添加 Add On Actor End Overlap 事件\n\n将每个节点连接到 Switch Has Authority 节点\n\n\nSwitch Has Authority 节点用于检查当前正在运行的脚本正在从何处执行，然后基于脚本是在网络授权者（通常为服务器）还是远程机器（客户端）上运行将其分成两个不同的方向\n\n通常，你会对只希望在服务器上发生的事情使用授权者（这些通常为游戏关键性事件，例如调整玩家的生命值或赠送奖励或掠夺物品，因为你不想让客户端确定这些更改何时发生，以防作弊）\n\n在此示例中，我们将更新文本变量，此变量也完全可以是包含玩家生命值的变量，或所收集道具的变量\n\n\n\n在图表中 右键 并添加一个称作 Add Item 的 Custom Event 节点\n\n将 Replicates 选项设置为 Run on owning Client，并添加称作 Character 的输入，将其设置为 Actor\n\n\n创建另一个称作 Remove Item 的 Custom Event，其设置与 Add Item 事件的设置相同\n\n如下所示，从两个重叠事件连出来，接 Add Item 和 Remove Item 节点\n\n\n这里我们指的是，当重叠触发器时，如果重叠发生在服务器上，在服务器上运行 Add Item 事件，并将它复制到自有客户端（即重叠触发器的人物所在的客户端）\n“它”是指 Add Item 启动并仅在服务器上执行但复制到客户端时所调用的脚本\n当人物退出触发器盒时 — 这也由服务器决定，在服务器上运行 Remove Item 事件，并将其复制到自有客户端\n\n\n从 Add Item 事件连出来，添加 Print String （文本设置为 Item Added ），然后拖开 Character 和 Cast To ThirdPersonCharacter\n\n\n从 As Third Person Character 针连出来，搜索并添加 Set Inventory 节点，将文本设置为 Has the Item\n\n\n此处，我们选取的是在服务器上执行并复制到客户端的事件，此事件将在屏幕上显示item added\n然后将自有客户端的 Inventory 文本变量设置为Has the item\n\n\n在 Add Item 事件之后复制三个节点，并将其连接到 Remove Item 事件\n\n将 Print String 更改为 Item Removed，将 Inventory 文本变量更改为 Empty\n\n\n现在，当人物退出触发器时，文本变量将在服务器上更新并复制到自有客户端\n\n\n编译 并 保存，然后关闭 Level Blueprint 并在编辑器中开始游戏\n\n    \n    \n\n\n\n在以上视频中，当游戏启动时，按 P 可将文本变量打印到屏幕上，可对每个角色显示 “empty”\n但是，当其中一个角色退出触发器盒时，将显示文本 “item added”\n当人物按 P 时，文本将更改为 “has the item”，但其他人物仍显示 “empty”\n当人物退出触发器盒时，将显示文本 “item removed”，再次按 P 时，文本将更改回 “empty”\n\n\n\n4. 客户端-服务器模式说明：\n\nUE4 多人游戏基于客户端-服务器模式\n\n一个服务器担当游戏状态的主控者，而连接的客户端将保持近似复本\n\n\n作用：\n\n做出所有重要决定，包含所有的主控状态，处理客户端连接，转移到新的地图以及处理比赛开始&#x2F;结束时的总体游戏流程等\n\n4.1 启动服务器基本命令：\n\n\n\n类型\n命令\n\n\n\n监听服务器\nUE4Editor.exe ProjectName MapName?Listen -game\n\n\n专用服务器\nUE4Editor.exe ProjectName MapName -server -game -log\n\n\n客户端\nUE4Editor.exe ProjectName ServerIP -game\n\n\n注：\n\n专用服务器在默认情况下并不会显示窗口\n如果不使用 -log，您将不会看到任何呈现专用服务器的窗口\n\n4.2 服务器游戏流程说明：\n\n服务器的职责是在游戏开始&#x2F;结束以及 actor 复制更新等情况下通知客户端转移到新地图\n游戏状态和流程一般是通过 GameMode 这一 actor 来驱动\n只有服务器才包含此 actor 的有效复本（客户端不包含复本）\n要向客户端传达该状态，可以使用 GameState actor 显示 GameMode actor 的重要状态\n这个 GameState actor 被标记为复制到每个客户端\n客户端将包含此 GameState actor 的一个近似复本，而且能使用这个 actor 作为引用，用于了解游戏的一般状态\n\n4.3 连接过程前提：一个服务器需要从网络连接的角度实现某种目的，它就必须要有客户端连接\n说明：新的客户端初次连接时\n\n首先，客户端要向即将连接的服务器发送一个请求\n服务器将处理这条请求\n如果它不拒绝连接，服务器会向客户端发回一个包含了继续运行所需信息的响应\n\n主要步骤如下：\n\n客户端发送连接请求\n如果服务器接受连接，则发送当前地图\n服务器等待客户端加载此地图\n加载之后，服务器将在本地调用 AGameModeBase::PreLogin\n这样可以使 GameMode 有机会拒绝连接\n\n\n如果接受连接，服务器将调用 AGameModeBase::Login\n该函数的作用是创建一个 PlayerController，可用于在今后复制到新连接的客户端\n成功接收后，这个 PlayerController 将替代客户端的临时 PlayerController （之前被用作连接过程中的占位符）\n此时将调用 APlayerController::BeginPlay\n应当注意的是，在此 actor 上调用 RPC 函数尚存在安全风险。您应当等待 AGameModeBase::PostLogin 被调用完成\n\n\n如果一切顺利，AGameModeBase::PostLogin 将被调用\n这时，可以放心的让服务器在此 PlayerController 上开始调用 RPC 函数\n\n\n\n5. 角色移动组件说明：\n\n角色移动组件 是一种 Actor 组件，提供封装的移动系统和类人 角色 的常见移动模式，包括行走、跌倒、游泳和飞行\n角色移动组件还具备强大的网络gameplay整合\n默认移动模式全都默认用于复制，并提供框架来帮助开发者创建自定义的联网移动\n\n5.1 角色移动基础\nUCharacterMovementComponent前附于 ACharacterActor类及其派生的所有 蓝图\n\n\n在其 TickComponent 函数期间，UCharacterMovementComponent 将调用 PerformMovement\n\n基于当前所用 移动模式 以及玩家的输入变量来计算世界场景中所需的加速度\n\n通常在APlayerController中以 control input 变量表示\n\n一旦完成移动计算，UCharacterMovementComponent 将把最终移动应用于拥有的角色\n\n\n注：\n\n虽然 ACharacter 派生自APawn，但角色并不只是增加了角色移动组件的Pawn\nUCharacterMovementComponent 和 ACharacter 需要一同使用，因为 ACharacter 覆盖数个复制的变量和函数，专为在 UCharacterMovementComponent 中进行复制\n\n5.2 PerformMovement说明：\n\nPerformMovement 函数负责游戏世界场景中的角色物理移动\n在非联网游戏中，UCharacterMovementComponent 每次tick将直接调用一次 PerformMovement\n在联网游戏中，由专用函数为服务器和客户端调用 PerformMovement，在玩家的本地机器上执行初始移动，或在远程机器上再现移动\n\n作用：\n\n应用外部物理效果，例如脉冲、力和重力\n根据动画根运动和 根运动源 计算移动\n调用 StartNewPhysics，它基于角色使用的移动模式选择 Phys* 函数\n\n5.3 移动物理效果每个移动模式都有各自的 Phys* 函数，负责计算速度和加速度：\n\nPhysWalking 决定角色在地面上移动时的移动物理效果\nPhysFalling 决定在空中移动时的移动物理效果\n\n若移动模式在一个tick内发生变化（例如角色开始跌倒或撞到某个对象）：\n\nPhys* 函数会再次调用 StartNewPhysics，在新移动模式中继续角色的运动\nStartNewPhysics 和 Phys* 函数各自通过已发生的 StartNewPhysics 迭代的次数\n参数 MaxSimulationIterations 是此递归所允许的最大次数\n\n5.4 移动复制摘要UCharacterMovementComponent 使用其所有者的 网络角色 来确定移动的复制方式：\n\n\n\n网络角色\n说明\n\n\n\n自主代理（Autonomous Proxy）\n角色在其 所属客户端 机器上，由玩家本地控制\n\n\n权威（Authority）\n角色存在于建立游戏的服务器上\n\n\n模拟代理（Simulated Proxy）\n角色存在于可查看远程控制角色的其他客户端上，无论角色受服务器AI控制，还是由不同客户端上的自主代理控制\n\n\n\n复制进程遵循 TickComponent 函数中的循环，每tick重复一次\n角色执行移动时，为同步移动信息，网络游戏中所有不同机器上的副本会相互进行 **远程进程调用 (RPC)**，不同网络角色使用相应的不同执行路径\n\n下表逐步概述此进程中 UCharacterMovementComponent 在各个机器上所执行的操作：\n\n\n\n步骤\n说明\n\n\n\n自主代理（所属玩家的客户端）\n\n\n\n1\n所属客户端本地控制自主代理。PerformMovement 运行移动组件的物理移动逻辑\n\n\n2\n代理构建 FSavedMove_Character，其中包含其所做移动的相关数据，然后在 SavedMoves 中将其排入队列\n\n\n3\n类似的 FSavedMove 条目组合在一起。自主代理通过 ServerMove RPC将压缩版数据发送到服务器\n\n\n权威Actor（服务器）\n\n\n\n4\n服务器接收ServerMove并使用 PerformMovement 复制客户端移动\n\n\n5\n服务器检查其在ServerMove后的位置是否与客户端报告的最终位置匹配\n\n\n6\n若服务器和客户端的最终位置匹配，则向客户端发回信号，表示移动有效。否则将使用 ClientAdjustPosition RPC 发送矫正\n\n\n7\n服务器复制 ReplicatedMovement 结构，将其位置、旋转和当前状态发送到其他已连接客户端上的模拟代理\n\n\n自主代理（所属玩家的客户端）\n\n\n\n8\n若客户端收到ClientAdjustPosition，则复制服务器的移动，并使用它的 SavedMoves 队列重新追踪其步骤，以获得新的最终位置。成功解析移动后，从队列中移除已保存的移动\n\n\n模拟代理（所有其他客户端）\n\n\n\n9\n模拟代理直接应用复制的移动信息。网络平滑 提供最终运动的可视化清理\n\n\n5.5 复制角色移动详解5.5.1 所属客户端上的本地移动说明：自主代理在 TickComponent 中本地处理移动，予以记录，然后发送到服务器以授权方式再现和应用\n5.5.1.1 编译客户端预测数据说明：\n\n自主代理编译名为 ClientPredictionData 的 FNetworkPredictionData_Client_Character 对象\n其部分流程负责记录移动情况和处理来自服务器的矫正\n\n参数：\n\n客户端与服务器通信时的时间戳\n\n已保存或待定移动情况的列表\n\n来自服务器矫正的已保存信息\n\n指示如何应用矫正的标记\n\n决定平滑行为的参数\n\nClientPredictionData 还包括与这些参数交互的效用函数\n\n可在FNetworkPredictionData_Client_Character 的API参考中找到此对象信息和函数的完整列表\n\n客户端执行本地移动、准备要发送到服务器的移动并处理矫正时，它的参数将被频繁引用和更改\n\n\n5.5.1.2 复制服务器矫正\n处理玩家的输入或世界场景中的力之前，自主代理将调用 ClientUpdatePositionAfterServerUpdate\n这将检查服务器是否已向所属玩家发送矫正\n若是，ClientPredictionData 中的变量 bUpdatePosition 将为true，且该角色将再现服务器通过客户端矫正进程发送的移动\n\n5.5.1.3 执行和记录移动\n自主代理角色在 TickComponent 期间调用 ReplicateMoveToServer，而非直接调用 PerformMovement\n\n此函数围绕 PerformMovement 提供必要的逻辑，以便在角色执行它时记录移动，然后将移动提交到服务器\n\nFSavedMove_Character 结构记录自主代理在每个tick中如何开始和结束移动，之后通过ServerMove RPC将其数据的最小子集发送到服务器\n\n其参数包括：\n\n角色最终位置和旋转的相关信息\n\n已采集哪些移动输入\n\n角色拥有的速度和加速度\n\n从 AnimMontages 采集的根运动信息\n\n\n\n可在FSavedMove_Character 的API参考中查看此结构的完整参数列表\n\n此信息使服务器能够再现玩家执行的移动，然后检查客户端的最终位置\n\n处理 PerformMovement 之后，ReplicateMoveToServer 函数利用名为 NewMove 的 FSavedMove_Character 结构在客户端预测数据中记录角色移动的结果，然后将其添加到名为 SavedMoves 的缓冲\n\n此缓冲将保存的移动按最旧到最新的顺序排列，并用作队列，直至保存的移动可提交到服务器为止。提交之前，为缓解带宽压力，缓冲中的所有类似移动将合并成单个 FSavedMove_Character\n\n移动正等着与即将到来的移动相结合，那么参数 PendingMove 将用于存储移动\n\n当这些移动被确认或 ACK 后，会从缓冲中移除\n\n服务器可通过确认客户端位置有效来直接确认移动，客户端也可以在处理来自服务器的矫正时确认移动\n\n最新确认的移动保存在 LastAckedMove 中，以供处理未来的矫正时使用\n\n\n5.5.1.4 向服务器提交移动说明：\n\nReplicateMoveToServer 通过运行函数 CallServerMove 来完成，该函数接受队列中未获得服务器确认的最新和最旧移动\n这将执行向服务器提交移动的最后准备工作，先尝试提交旧移动（若适用），然后调用正确的ServerMove函数来提交新移动的最终移动\n最终ServerMove直接提交给 UCharacterMovementComponent 的所属角色，作为 不可靠的 服务器RPC\n\nServerMove函数不可靠的原因有二：\n\n正常游戏期间经常会调用ServerMove函数，如果它们被视为可靠，大量调用可靠函数可能会导致缓冲溢出，迫使所属玩家断开连接\n用于缓冲已保存移动的系统可确保传输进程中丢失的移动信息会被重新提交和计算，这为可靠函数提供了类似的安全保障，但却没有可靠RPC缓冲溢出的风险，并增加了一些规定来确保丢弃太旧的移动数据\n\n5.5.2 计算服务器上的移动说明：\n\n服务器不会定期tick移动来与游戏的tick循环同步，而是等待从自主代理处接收ServerMove调用\nServerMove_Implementation 处理服务器端的移动，重新构造客户端的移动并检查细微差异\n\n5.5.2.1 编译服务器预测数据\n角色移动组件的权威版本创建名为 ServerPredictionData 的 FNetworkPredictionData_Server_Character 对象，该对象在角色生命周期内存在\n在 ServerMove_Implementation 期间，此对象将存储信息，供以后的进程再现所属客户端的移动\n服务器接收数据时，此对象在后台被不断修改，参数包括：\n用于计算服务器差量时间的时间戳\n待定的客户端调整\n与解决时间差异相关的标记\n指示服务器确认还是矫正移动的标记\n\n\n可在FNetworkPredictionData_Server_Character 的API参考指南中查看它的参数和函数的完整列表\n\n5.5.2.2 验证客户端时间戳\n与ServerMove RPC一同发送的信息包括移动发生时的时间戳\n若服务器时间戳和客户端时间戳差异太大，客户端时间戳将视为已过期，移动将被丢弃\n否则该差异将标记为已解决，且 UCharacterMovementComponent 使用 ProcessClientTimeStampForTimeDiscrepancy 在下一步中创建差量时间的覆盖\n\n5.5.2.3 计算差量时间说明：\n\n差量时间通常是通过追踪当前tick与上一个tick之间经过的时间来获取\n但服务器上的角色并不使用 TickComponent 来计算移动\n\n原理：\n\nServerMove_Implementation 调用 GetServerMoveDeltaTime 并在收到ServerMove后计算移动\n若服务器预测数据被标记为尝试解决时间戳差异，它将使用 TimeDiscrepancyResolutionMoveDeltaOverride\n若无时间差异，则根据当前ServerMove RPC时间戳和最后一个ServerMove RPC时间戳之间的差异，使用服务器预测数据来创建差量时间\n为多一层安全，执行这些计算时多半使用服务器时间戳而非客户端时间戳，以防止客户端加快本地游戏时间进行速度作弊\n\n5.5.2.4 计算移动说明：\n\n服务器使用来自ServerMove RPC的数据重新构造所属玩家控制器的控制旋转\n然后调用函数 MoveAutonomous 来处理角色的加速、旋转和跳跃输入\n\n原理：\n\nMoveAutonomous 使用 PerformMovement 函数，根据之前重新构造的数据和上一步中提供的差量时间来模拟角色的移动物理效果\n服务器从获取ServerMove调用时自身角色副本所在的位置模拟运动，而非从客户端开始位置模拟\n\n注意：\n\n若角色正在计算来自动画的根运动，MoveAutonomous还会使用提供的差量时间tick角色的动画姿势\n所有动画事件都将相应触发。否则动画将正常tick\n\n5.5.3 处理客户端错误和矫正说明：\n\n服务器移动的工作原理是假设服务器和所属客户端在相同位置开始移动，且若服务器执行的移动与客户端报告的相同，则移动结束的位置也将相同\n若客户端的移动由于连接问题而丢失，或者客户端提交了错误数据，则两者的移动将在不同的位置结束，因此需要矫正\n函数 ServerMoveHandleClientError 负责这些操作\n\n5.5.3.1 确定是否需要调整说明：\n\n频繁发送矫正会导致带宽紧张，并导致客户端过于频繁地重新模拟大量已保存的移动\n因此要首先检查从 WithinUpdateDelayBounds 返回的值，查看移动间歇是否已超过最小时间量\n若返回 false，则不发出矫正，若返回true，则可运行其余进程\n\n原理：\n\n使用 ServerCheckClientError 查看服务器与客户端之间的误差是否大到需要矫正\n若返回true 或 bForceClientUpdate 因故被设为true而强制矫正，则 ServerMoveHandleClientError 将继续执行余下进程\n\n注：\n\n可在 BaseGame.ini 中找到用于调整这两个操作的参数，并可在 DefaultGame.ini 中提供项目特定的覆盖\n\nClientErrorUpdateRateLimit 值决定着服务器向客户端发送错误矫正的最小延迟（单位为秒）MAXPOSITIONERRORSQUARED 值是网络游戏中可接受未矫正最大位置误差的平方\n\n两者都可在配置文件的 [/Script/Engine.GameNetworkManager] 部分中找到\n\n若需要调整，服务器预测数据用从角色的服务器副本中采集的当前移动变量样本填充名为 PendingAdjustment 的 **FClientAdjustment**，包括位置、旋转、速度和可能充当角色移动基础的对象\n\n否则将 PendingAdjustment 的 bAckGoodMove 值设为 true，将客户端的移动标记为有效\n\n\n5.5.3.2 发送客户端调整或确认移动说明：\n\n确认到客户端的移动的最后一步由 SendClientAdjustment 完成\n此函数不作为 ServerMove_Implementation 的一部分，而是作为 UNetDriver::ServerReplicateActors 的一部分，在服务器端的tick结束时调用，并同样负责调用其他客户端调整RPC\n调用 SendClientAdjustment 时，操作方式将取决于之前步骤中编译的预测数据的标记方式\n\n作用：\n\n若服务器预测数据的 PendingAdjustment 的 bAckGoodMove 标记为 true，则将调用 ClientAckGoodMove RPC来确认移动，告知所属客户端机器上的自主代理该移动为有效\n这将从所属客户端的 SavedMoves 缓冲中移除原始移动，并将其记录为 LastAckedMove，用于编译未来的预测数据\n\n注：\n\n若 PendingAdjustment 的 bAckGoodMove 标记为false，则将调用客户端调整函数，将最终矫正发送到客户端\n\n5.5.3.3 自主代理接收客户端调整说明：\n\n客户端调整RPC包括 ClientAdjustPosition、ClientAdjustRotation、这两者在速度为零时发生的缩略版、以及这两者专用于根运动移动的版本\n作为 SendClientAdjustment 的一部分，服务器可调用多个此类函数，具体取决于待矫正内容的性质和严重程度\n每个此类函数都可告知 ClientPredictionData 在应用必要矫正后确认移动，且都会将 bUpdatePosition 标记为true\n\n注：\n\n然后在客户端的下一个 TickComponent 开始时使用 ClientUpdatePosition 应用最终矫正\n\n5.5.4 将移动复制到模拟代理说明：\n\n客户端机器上的角色（其所有者除外）为模拟代理，而非自主代理、\n由于模拟代理的唯一工作就是响应服务器，因此将移动从服务器复制到模拟代理的进程为高度简化\n从服务器接收移动更新时不会模拟运动物理效果，而是将其位置、旋转和速度设为服务器想要的值，并使用一些额外的进程让移动更流畅、更可信\n\n5.5.4.1 存储复制的移动信息说明：\n\nActor复制移动时，其不会直接复制自身的变换。所有Actor都维持名为 ReplicatedMovement 的复制变量，该变量使用结构FRepMovement\n\n作用：\n\n布尔 bReplicateMovement 由蓝图中的 Replicate Movement 变量表示，标记Actor将移动信息存储在此结构中，并将其复制到客户端\n\n客户端收到 ReplicatedMovement 的更新时，RepNotify 函数 OnRep_ReplicatedMovement 将解压缩存储的移动数据，并相应地更新Actor的位置和速度\n\n在蓝图中无法访问 ReplicatedMovement 或其 OnRep，但可在C++中覆盖 OnRep_ReplicatedMovement，还可在GetLifetimeReplicatedProps 中覆盖 ReplicatedMovement 的复制条件\n\n用户因此能够自定义移动复制在基于C++的Actor类中的行为\n\n在 ACharacter 中，仅为模拟代理复制 ReplicatedMovement 结构\n\n自主代理上会忽略此结构，而使用服务器移动和客户端调整RPC来处理移动\n\n\n注：\n\n若角色用另一个Actor作为基础，则将使用 ReplicatedBasedMovement，从而应用额外的逻辑来确保客户端是依据服务器而正确建立\n若角色使用根运动系统，则忽略所有这些进程，而倾向于使用 RepRootMotion\n\n5.5.4.2 在模拟代理上tick移动\n当 UCharacterMovementComponent 在模拟代理上运行 TickComponent 时，其将调用 SimulatedTick 来处理模拟移动的逻辑\n这不会执行上述复制移动。相反，SimulatedTick 会根据最近提供的复制移动数据继续移动\n执行标准移动物理效果时，调用 SimulateMovement 函数，然后使用 SmoothClientPosition 执行最终的验证和网络平滑\n\n5.5.4.3 执行模拟移动说明：\n\nSimulateMovement 函数负责移动模拟代理角色\n除了会被 SimulatedTick 调用，其还会被 OnRep_ReplicateMovement 调用\n此函数执行以下进程：\n调用所属角色的 GetReplicatedMovement 函数，以获取对 ReplicatedMovement 的引用\n执行安全检查，确保复制的移动数据有效，且客户端的基础被解析\n检查是否已收到网络更新\n从服务器应用通过 GetReplicatedMovementMode 获取的角色移动模式\n重置有关网络更新的所有标记\n基于当前 MovementMode 和角色的当前状态信息执行模拟移动的逻辑\n\n\n\n注：\n\n与标准运动物理效果相比，模拟运动的逻辑高度简化，因此主要包含在 SimulateMovement 函数本身中，不会分解成更小的函数\n但是，此函数仍负责更新角色的本地移动状态，包括应转换为哪个移动模式，角色是否已经降落至地面，以及应拥有的速度\n这些信息可确保角色正确更新动画，让动作看起来十分准确\n\n5.5.4.4 网络平滑说明：\n\n若单纯通过复制角色的位置和旋转来复制移动，则角色看起来每隔数分钟就会瞬移一次\n这是因为本地机器的渲染速率比网络发送数据速率更快\n举例而言，客户端可能以240 Hz刷新率渲染显示器，而复制的移动可能仅以30 Hz发送\n\n作用：\n\n网络平滑是使此运动平滑的进程，将角色从源位置逐渐向目标位置插入，而非立即将其对齐到目标位置\n源位置由角色当前位置提供，而目标位置由客户端预测数据提供\n内插本身在 SmoothClientPosition 中处理，使用NetworkSmoothingMode确定应使用的内插类型\n\n5.6 特殊移动情况\n包含常见特殊移动情况的信息，包括传送、自定义移动，以及可能在特殊技能中看到的代码驱动移动\n\n5.6.1 多人游戏中传送角色说明：可调用 SetLocation 函数或 Teleport 蓝图节点在网络游戏中传送角色\n\n必须在服务器上调用\n若使用 SetLocation 函数，将 bTeleport 变量设为true，使其将该移动视为传送\n\n\n\n若满足这些条件，移动会作为传送记录到服务器的预测数据和复制移动中，且所有客户端会将角色对齐到所需位置（而非应用平滑）来做出相应的响应\n\n5.6.2 自定义移动模式说明：移动模式 MOVE_Custom 会中止所有其他移动物理效果，可实现自定义移动逻辑，不受 UCharacterMovementComponent 正常进程的干扰\n作用：\n\nUCharacterMovementComponent 通常不可蓝图化，因此蓝图中的自定义移动通常是使用 UpdateCustomMovement 事件直接在角色内实现\n\n可使用 Custom Movement Mode 字节变量通过整数开关或自定义列举转换提供子模式\n\n\nUpdateCustomMovement 由 UCharacterMovementComponent 中的 PhysCustom 函数调用\n\n函数 StartNewPhysics、PhysCustom 和所有其他移动物理效果函数都是虚拟函数，因此若要在C++中创建自定义 UCharacterMovementComponent，可直接将其覆盖\n\n\n5.6.3 通根运动复制说明：\n\n有时需要在短时间内直接控制角色的移动，例如在使用 Gameplay Ability System 创建的技能发动期间、或在动画驱动操作发生期间\n虽然这在纯本地游戏中很容易做到，但复制的特殊移动情况需要使用根运动（通常指应用动画中的移动）\n根运动系统也已调整为允许代码驱动的特殊移动情况\n\n作用：\n\n无论 UCharacterMovementComponent 使用哪种运动模式，根运动始终优先于标准移动物理状态。完成根运动后将继续正常移动\n\n5.6.3.1 来自动画蒙太奇说明：\n\n根运动的大部分应用来自动画蒙太奇，而动画蒙太奇用于代码触发的一次性动画\n根运动的这种用法会中止角色正在执行的其他移动，直至动画结束\n角色从其骨架的根骨骼使用移动，并将其转换为场景空间的移动，使动画能够控制角色的移动方式\n完成这一步后，角色恢复使用普通物理效果\n\n注：\n\n若角色处于下落移动模式，即使角色正在执行根运动，重力仍将作用于角色的Z轴移动\n\n在上述复制进程中，根运动信息由 FSavedMove_Character 结构采集，包括作为其来源的动画蒙太奇、角色在蒙太奇中的轨迹位置，以及角色移动本身的参数\n\n\n服务器和所属客户端上的自主代理不会检查播放的动画是否相同，因为这通常被视为是一种装饰功能\n\n因此必须对游戏逻辑进行编程，确保所有动画蒙太奇都能在所有连接游戏的机器上正确触发\n但是模拟代理拥有上述进程的并行进程，用于同步基于根运动的移动\n\nGameplay Ability System插件将复制触发动画蒙太奇和根运动的技能，以此同步这些动画蒙太奇和根运动。\n5.6.3.2 来自根运动源说明：\n\n有时需要手动控制角色的位置来处理特殊情况\n举例而言，可能需要创造一种特殊技能，使角色跳到空中特定的高度，然后落到移动目标上\n\n原理：\n\n在standalone游戏中，可以用 SetLocation 和 SetRotation 手动控制角色，但在网络游戏中，上述复制进程无法捕捉此运动，因此服务器将把客户端的最终位置视为错误并发出矫正\n同时，来自动画蒙太奇的根运动仅遵循动画中预计算的运动\n这意味着根运动通常无法从游戏世界获取实时信息，比如其他角色的位置，而且也不能使用游戏变量进行轻松微调\n\n注：\n\n根运动源 为程序员提供了一种手动控制角色根运动的方法\n\n因此可以通过编程来控制角色的移动，同时还可以利用上述系统在联网期间处理根运动\n\n根运动源应应用于所属客户端上的自主代理\n\n\n使用：\n\n必须创建新的FRootMotionSource结构\n\n不同类型的移动对应不同的FRootMotionSource变体\n\n举例而言，FRootMotionSource_MoveToForce用于从开始位置到目标位置的直线移动，而FRootMotionSource_JumpForce遵循的是弹跳式弧线移动\n\n创建适当的根运动源后，可使用所需源位置、目标位置和移动行为相关参数将其属性初始化\n\n函数 UCharacterMovementComponent::ApplyRootMotionSource 将把根运动源应用于角色，并返回一个可供之后引用的柄\n\n根运动源本身不处理移动，而是由角色移动组件执行与所提供 FRootMotionSource 中参数一致的移动，以代替动画\n\n最终这将添加到 FSavedMove_Character 结构中的 SavedRootMotion，并在复制周期中采集，前提是 FRootMotionSource 应用于自主代理\n\n完成移动后，必须调用 UCharacterMovementComponent::RemoveRootMotionSource，使用从 ApplyRootMotionSource 返回的柄将其移除\n\n\nGameplay Ability System插件包含几个利用根运动源的技能任务，使技能可以执行复杂的程序化移动序列\n\n基础范例请参见 AbilityTask_ApplyRootMotionMoveToForce\n\n6. OnlineBeacon介绍：\n\nOnline Beacons 是一个特殊类型的 Actor，可提供一种简易的方式与服务器联络并进行交互（通过 RPC），而无需让普通游戏连接来执行此任务\n可以使用内置类，因为在一些情况下它们将被延展为自定义类，执行项目特定的交互、逻辑和信息请求\n\n6.1 OnlineBeacon 基类说明：\n\nBeacon 类执行的常规操作是请求服务质量信息\n在客户端需要加入的游戏中预留空位\n接收游戏中玩家名列表、\n获取正在进行的游戏中的得分和运行时间，等等\n\n6.1.1 AOnlineBeacon说明：\n\n这是 AOnlineBeaconClient 和 AOnlineBeaconHost 的基类\n它直接派生自 AActor\n\n6.1.2 AOnlineBeaconHost说明：\n\n此类使用其自身的 UNetDriver 获得来自远程客户端电脑的传入 Online Beacon 连接\n接收到连接时，它将在注册 AOnlineBeaconHostObject 实例列表中进行查找，找到与传入客户端匹配的实例并转交连接\n此类通常不需要被派生，因其只管理客户端和注册 AOnlineBeaconHostObject 之间的初始连接\n\n6.1.3 AOnlineBeaconClient说明：\n\n此类的子项连接到主机并执行实际的 RPC\n它们其中一个将在客户端电脑上生成，一个由正确的 AOnlineBeaconHostObject（注册到服务器的 AOnlineBeaconHost）在服务器上生成\nGetBeaconType 函数的输出（即为类名称）将用于对比此类的实例和正确主机对象类的注册实例\n\n注意：\n\n这和普通的 Actor 生成方式（服务器生成 Actor 然后复制到客户端）不同\n然而，客户端和服务器对象副本之间的连接建立后，对象复制将正常进行，任意一方均可向对方执行 RPC，而对象的服务器版本可对属性复制发送命令\n该基类实现 OnConnected 和 OnFailure 函数\n这两个函数可由子类覆盖，在连接时执行 RPC，或处理失败连接\n此类是 Online Beacon 系统的主力，将执行 Beacon 所需的客户端端的工作\n在成功连接事件中，服务器上将生成和源实例同步的另一个实例，此例也可执行服务器端的工作，通过客户端和服务器 RPC（或服务器到客户端的复制属性）进行协调和交流\n\n6.1.4 AOnlineBeaconHostObject说明：\n\n此类也应被覆盖，使其和覆盖的 AOnlineBeaconClient 类配对\n将客户端 GetBeaconType 的返回值和保存在 BeaconTypeName 成员变量中的值进行匹配即可完成配对\n服务器的 AOnlineBeaconHost 检测到传入 AOnlineBeaconClient 的配对 AOnlineBeaconHostObject 时，它将指示 AOnlineBeaconHostObject 通过虚拟 SpawnBeaconActor 函数生成 AOnlineBeaconClient 的本地副本\n此函数默认使用 ClientBeaconActorClass 成员变量确定要生成的 actor 类，此类应被设为配对的 AOnlineBeaconClient 类\n它还将在生成对象的服务器副本上调用 SetBeaconOwner，以便客户端对象的服务器端实例与主机对象进行交流\n此设置多数建立在基类中，无需被覆盖\n\n6.2 OnlineBeacon 范例说明：\n\n引擎中已自带大量预建 Beacon 类配对\n也可自行构建，Test Beacon 就是一个简单的好例子\nATestBeaconClient 派生自 AOnlineBeaconClient，ATestBeaconHost 派生自 AOnlineBeaconHostObject\n\n使用：Test Beacon 就是简单地在客户端和服务器之间来回执行重复的函数调用\n\n在 ATestBeaconHost 的构建函数中，ClientBeaconActorClass 设为 ATestBeaconClient 的类、BeaconTypeName 设为 ClientBeaconActorClass 的命名（调用 GetName 函数获得），这样可确保 AOnlineBeaconHost 将两个 Test Beacon 类正确配对\n客户端的 ATestBeaconClient 成功连上服务器时，服务器的 AOnlineBeaconHost 实例将指引注册 ATestBeaconHost 生成其自身的 ATestBeaconClient，并在服务器上将其和 ATestBeaconClient 关联， 这很重要，因为它使客户端和服务器 RPC 在两个 ATestBeaconClient 实例之间传递\n服务器的 ATestBeaconHost 将在它的 ATestBeaconClient 实例上调用 OnClientConnected（客户端 RPC）， 因为此函数为客户端 RPC，调用函数的命令将被传至客户端电脑，而不会在服务器上调用函数\nRPC 将在客户端的 ATestBeaconClient 实例上运行虚拟 OnConnected 函数，此函数已被覆盖，以便调用 ClientPing\nClientPing 将输出一些文本到调试日志，然后调用服务器 RPC ServerPong，它将在网络连接中传递，并在服务器的 ATestBeaconClient 实例上执行\nServerPong 将输出调试文本并调用 ClientPing，再触发对客户端联网 RPC 调用\n此过程将无限继续，这通常并非理想状态，尤其是这些 RPC 并未执行具体任务，它可用于记录相同 RPC 在两次分步运行之间的时间，以追踪服务器的 ping 时，因为可能存在延迟，所以这个 ping 检查不会按电脑和网络的最佳频率进行，或者客户端&#x2F;服务器可能直接在数次 ping 后直接停止返回 ping，其他的使用范例可能涉及到唯一的 RPC 回叫到客户端，而不是继续循环，如连续询问一连串的问题 该服务器的游戏使用的是哪张地图？或  这是一个夺旗服务器吗？，这些问题的内容视特定游戏或项目的相关信息而定\n\n7. 测试多人游戏介绍：\n\n更改编辑器的某些设置\n测试不同的多人场景\n\n7.1 设置玩家数量增加玩家数量\n\n单击 Play 按钮旁的下箭头，然后输入 Number of Players 的值\n\n\n默认情况下，服务器将使用 Selected Viewport 作为游戏窗口，并为添加的每位玩家创建新窗口\n\n\n\n7.2 调整游戏窗口为服务器调整窗口\n\n单击 Play 按钮旁的下箭头，然后选择 New Editor Window\n\n\n虽然模拟客户端拥有自己的窗口，但此设置还会模拟服务器创建独立窗口\n\n\n7.3 高级设置调整窗口大小\n\n单击 Play 按钮旁的下箭头，然后选择 Advanced Settings\n\n\n在 Play in New Window 部分下设置所需的窗口大小\n\n\nPlay in New Window 大小选项允许您设置所创建的窗口的大小和默认位置\n可以从若干预设窗口大小中选择或手动输入窗口大小（此例中，我们指定为 640x480)\n可以将所创建的窗口设置为 Left 和 Top 位置或单击 Always center window to screen 的复选框\n\n\n输入窗口大小后，当您在编辑器中玩游戏时，每个新窗口的大小相同。\n\n\n\n\n当在编辑器中使用每个游戏会话的新窗口玩游戏时，将注意到每个窗口顶部将显示玩家是服务器玩家还是客户端玩家\n同时，在 Play 模式下，移动窗口时，系统将为下次在编辑器会话中 Play 记住其位置（因此，无需一直移动窗口，这样使得更简单）\n\n7.4 多人选项Advanced Settings 中还包括用于设置附加多人选项的部分：\n\n\n\n\n选项\n说明\n\n\n\nNumber of Players\n此选项定义游戏启动时其中将生成的玩家数量编辑器和监听服务器均视为玩家，而专用服务器则不会客户端组成剩余玩家\n\n\nServer Game Options\n您可在此指定将作为 URL 参数传输到服务器的附加选项\n\n\nRun Dedicated Server\n如果选中，则将启动独立的专用服务器否则，第一个玩家将充当所有其他玩家均可连接的监听服务器\n\n\nRoute 1st Gamepad to 2nd Client\n在单个进程中运行多个玩家窗口时，此选项将决定游戏手柄输入的路由方式如果未选中（默认），第一个游戏手柄将连接到第一个窗口，第二个连接到第二个窗口，以此类推如果选中，则第一个游戏手柄将连接第二个窗口然后即可通过键盘&#x2F;鼠标控制第一个窗口，如果两人在同一台计算机上进行测试则十分便利\n\n\nUse Single Process\n此选项将在虚幻引擎 4 的单个实例中生成多个玩家窗口其加载速度更快，但也有存在更多问题的可能性。未选中此选项时，附加选项将可用\n\n\nCreate Audio Device for Every Player\n启用此选项将允许从每位玩家的角度渲染精确音频，但将占用更多 CPU 资源\n\n\nPlay In Editor Description\n此选项根据当前应用的多人设置说明玩游戏时将发生的事情\n\n\n\n当选中 Use Single Process 时，虚幻引擎 4 的单个实例中将生成多个窗口\n当未选中此选项时，将为分配的每位玩家启动多个 UE4 的实例，而且附加选项将可用：\n\n\n\n\n\n选项\n说明\n\n\n\nEditor Multiplayer Mode\n此选项是用于 Play In Editor（Play Offline、Play As Listen Server 或 Play As Client）的 NetMode\n\n\nCommand Line Arguments\n您可在此分配将传输到独立游戏实例的附加命令行选项\n\n\nMultiplayer Window Size (in pixels)\n定义生成附加独立游戏实例时所采用的宽度&#x2F;高度\n\n\n7.5 监听服务器与专用服务器介绍：启动多人游戏时，游戏托管方式有两种\n\n通过使用 Listen Server（默认设置），这表示拥有权限的机器也可以运行客户端，并可在为其他玩家托管时正常玩游戏\n通过使用 Dedicated Server，顾名思义，专用服务器仅专用于托管游戏，而没有本地玩家在此机器上玩游戏，因为连接的每位玩家均是客户端玩家\n\n\n通常情况下，相比作为监听服务器运行，作为专用服务器运行性能因为没有图像或输入而更优化\n默认情况下，在编辑器或独立游戏中玩游戏时，服务器类型设置为监听服务器\n\n使用：运行专用服务器\n\n单击 Play 按钮旁的下箭头，然后选中 Run Dedicated Server 复选框\n\n\n\n8. 蓝图中的多人功能8.1 Gameplay框架评估说明：要向游戏添加多人功能，必须理解引擎提供的主要Gameplay类的角色，以及它们彼此的协作关系，尤其是它们在多人情境下如何工作：\n\nGameInstance\nGameMode\nGameState\nPawn（以及从Pawn继承而来的Character）\nPlayerController\nPlayerState\n\n使用：参阅Gameplay框架文档以了解更多信息，但在设计多人游戏模式时，至少需要记住以下提示：\n\nGameInstance\n在引擎会话的持续时间内一直存在，意味着在引擎启动时创建，并在引擎关闭后才会销毁或更换\n服务器和每个客户端上都存在一个独立的GameInstance，这些实例彼此不通信\n由于GameInstance存在于游戏会话之外，并且是在关卡加载期间唯一存在的游戏结构体，因此非常适合于保存特定类型的持久数据，如终生玩家统计信息（如获胜总次数）、帐户信息（如特殊物品的锁定&#x2F;解锁状态），甚至在像《虚幻竞技场》等竞技游戏中，用来保存用来切换的地图列表\n\n\nGameMode\n对象仅存在于服务器上\n它通常存储客户端不需要明确知道的游戏信息\n例如，如果游戏有”仅火箭发射装置”等特殊规则，客户端或许不需要知道这条规则，但在地图上随机产生武器时，服务器需要知道仅从”火箭发射装置”类别中选取\n\n\nGameState\n存在于服务器和客户端上，因此服务器可以在GameState上使用复制变量让所有客户端保持最新的游戏数据\n与所有玩家和旁观者有关、而不是与任何一个特定玩家有关的信息最适合于GameState复制\n例如，棒球游戏可以通过GameState复制每个团队的分数和当前局次\n\n\nPlayerController\n每一台客户端上的每一个玩家存在一个PlayerController\n它们在服务器和关联的客户机之间进行复制，但不会复制到其他客户端，因此在服务器上每个玩家都有PlayerController，但本地客户端只有本地玩家的PlayerController\n客户端保持连接时存在PlayerController，PlayerController与Pawn关联，但不会像Pawn一样被销毁和重新产生\n它们非常适用于在客户端和服务器之间传达信息，而不必将该信息复制到其他客户端\n例如，服务器告知客户端对其迷你地图进行ping，以响应只有该玩家能检测到的游戏事件\n\n\nPlayerState\n服务器和客户端上存在与游戏相连的每个玩家的PlayerState\n这个类可以用于所有客户端感兴趣的复制属性，而不仅仅是所属客户端，如单个玩家在自由竞赛游戏中的当前分数\n与PlayerController类似，它们与单个Pawn关联，但不会像Pawn那样被销毁和重新产生\n\n\nPawn（包括Character）\n也存在于服务器和所有客户端上，可以包含复制变量和事件\n决定对特定变量或事件使用PlayerController、PlayerState还是Pawn取决于具体情况，但务必要记住的是，只要所属玩家保持与游戏相连，且游戏没有加载新关卡，则PlayerController和PlayerState就保持不变，而Pawn则不然\n例如，如果Pawn在游戏期间死亡，它通常会被销毁并替换为一个新Pawn，而PlayerController和PlayerState将持续存在，并在新Pawn产生后与新Pawn关联\n因此，Pawn的生命值将存储在Pawn自身上，因为该信息特定于该Pawn的实际实例，应在该Pawn替换为新Pawn时重置\n\n\n\n8.2 Actor复制\n\nUE4中的联网技术的核心是Actor复制\n“复制”标志设置为true的Actor将自动从服务器同步到与该服务器相连的客户端\n必须理解的一点是，Actor仅从服务器复制到客户端，而不能从客户端复制到服务器\n当然，客户端仍需要能够向服务器发送数据，它们通过复制的”在服务上运行”事件来实现\n\n请参阅概在蓝图中同步 Actor指南以了解具体示例的逐步演示，以及Actor 的复制文档\n8.2.1 权限\n对于场景中的每个Actor，会将其中一个连接的玩家视为拥有对该Actor的权限\n对于服务器上存在的每个Actor，服务器拥有对该Actor的权限，包括所有复制的Actor\n因此，拥有权限 函数在客户端上运行，而目标是复制到客户端的Actor时，将返回false\n你还可以使用 切换拥有权限 便捷宏，作为针对复制Actor中不同服务器和客户端行为进行分支的快捷方法\n\n\n8.2.2 变量\n在Actor上的变量的细节面板中，有一个 复制（Replication） 下拉列表，让你可以控制如何复制变量\n\n\n\n\n\n选项\n说明\n\n\n\n无（None）\n这是新变量的默认值，表示不通过网络向客户端发送值\n\n\n复制（Replicated）\n服务器复制该Actor时，它会将该变量发送到客户端。接收客户端上的变量值将自动更新，因此下一次访问该客户端时，它会反映服务器上的值当然，在真实网络上游戏时，更新会有所延迟，具体取决于网络的延迟时间请记住，复制的变量仅沿一个方向传递，从服务器到客户端！要从客户端向服务器发送数据，请参见”事件”部分\n\n\n复制通知（RepNotify）\n变量将按照”复制”（Replicated）选项进行复制，此外，还将在蓝图中创建OnRep_函数当该变量的值发生变化时，引擎会自动在客户端和服务器上调用该函数你可以根据游戏需要随意实现该函数 \n\n\n\n引擎内置类中的许多变量已经启用了复制，因此许多功能在多人情境下会自动工作\n\n请参阅概在蓝图中同步变量指南以了解具体变量复制示例的逐步演示，以及属性复制文档\n8.2.3 产生和销毁介绍：\n\n在服务器上产生复制的Actor时，这个信息会传达给客户端，他们也会自动产生该Actor的副本\n但总体而言，由于不会从客户端复制到服务器，因此如果在客户端上产生了复制的Actor，则该Actor只会存在于产生这个Actor的客户端上\n\n影响：\n\n服务器和任何其他客户端都不会收到该Actor的副本\n但产生客户端拥有对该Actor的权限\n这对于某些Actor还是十分有用的，比如对Gameplay没有实际影响的装饰Actor，但对于会影响Gameplay并应当复制的Actor，最好确保在服务器上产生这类Actor\n\n销毁复制的Actor也属于类似情况：\n\n如果服务器销毁一个复制的Actor，则所有客户端也会销毁相应的副本\n客户端可以随意销毁他们拥有权限的Actor，即，客户端自己产生的Actor，因为这些Actor不会复制到其他玩家，也不会影响其他玩家\n如果客户端尝试销毁没有权限的Actor，这个销毁请求会被忽略\n关键在于，产生Actor亦是如此：如果你需要销毁复制的Actor，则需要在服务器上销毁\n\n8.3 事件复制介绍：\n\n在蓝图中，除了复制Actor及其变量，还可以跨客户端和服务器运行事件\n\n请参阅在蓝图中使用远程调用函数指南以了解具体示例的逐步演示，以及RPC文档\n注：\n\n可能还会看到RPC（远程过程调用）一词\n如果看到，只需注意蓝图中的复制事件基本上编译到引擎中的RPC，这是C++中的常用说法\n\n8.3.1 所有权介绍：\n\n在使用多人时需要理解的一个重要概念是（尤其是在使用复制事件时），哪个连接被视为特定Actor或组件的所有者\n\n就我们的目的而言，需要知道”在服务器上运行”事件只会从客户端拥有的Actor（或其组件）调用\n\n通常，这表示只能从以下Actor或其中某个Actor的组件发送”在服务器上运行”事件：\n\n客户端本身的PlayerController\n\n客户端PlayerController支配的Pawn\n\n客户端的PlayerState\n\n\n\n\n注：\n\n同样，对于发送”在所属客户端上运行”事件的服务器，这些事件也应当在上述某个Actor上调用\n否则，服务器不知道要将事件发送到哪个客户端，这样就只会在服务器上运行\n\n8.3.2 事件\n在自定义事件的细节面板中，你可以设置如何复制事件\n\n\n\n\n\n选项\n说明\n\n\n\n不复制（Not Replicated）\n这是默认值，表示该事件不进行复制如果在客户端上调用，它仅在该客户端上运行，如果在服务器上调用，则仅在服务器上运行\n\n\n组播（Multicast）\n如果在服务器上调用组播事件，则该事件将复制到所有连接的客户端，无论拥有目标对象的是哪个连接如果客户端调用组播事件，该事件会被视为未复制，并仅在调用该事件的客户端上运行\n\n\n在服务器上运行（Run on Server）\n如果从服务器调用该事件，则仅在该服务器上运行如果从客户端调用，并且目标归该客户端所有，则事件将复制到服务器并在服务器上运行“在服务器上运行”事件是客户端向服务器发送数据的主要方法\n\n\n在所属客户端上运行（Run on Owning Client）\n如果从服务器调用，则该事件将在拥有目标Actor的客户端上运行由于服务器可以拥有Actor本身，因此”在所属客户端上运行”事件实际上可以在服务器上运行，而无论名称为何如果从客户端调用，该事件会被视为未复制，并仅在调用该事件的客户端上运行\n\n\n以下各表描述了不同复制模式根据调用方式对事件运行位置的影响\n\n如果事件从服务器调用，假设左列是目标，则运行位置将是…\n\n\n\n\n\n未复制\n组播\n在服务器上运行\n在所属客户端上运行\n\n\n\n客户端拥有目标\n服务器\n服务器和所有客户端\n服务器\n目标的所属客户端\n\n\n服务器拥有目标\n服务器\n服务器和所有客户端\n服务器\n服务器\n\n\n无主目标\n服务器\n服务器和所有客户端\n服务器\n服务器\n\n\n\n如果事件从客户端调用，假设左列是目标，则运行位置将是…\n\n\n\n\n\n未复制\n组播\n在服务器上运行\n在所属客户端上运行\n\n\n\n目标归调用客户端所有\n调用客户端\n调用客户端\n服务器\n调用客户端\n\n\n目标归其他客户端所有\n调用客户端\n调用客户端\n丢弃\n调用客户端\n\n\n服务器拥有目标\n调用客户端\n调用客户端\n丢弃\n调用客户端\n\n\n无主目标\n调用客户端\n调用客户端\n丢弃\n调用客户端\n\n\n\n从上表可见，任何从一个客户端调用并且没有设为”在服务器上运行”的事件都被视为没有复制\n\n注：\n\n从客户端向服务器发送复制的事件是唯一一种从客户端向服务器传达信息的方法，因为一般的Actor复制设计为仅从服务器到客户端\n\n此外，还需注意组播事件只能从服务器发送\n\n虚幻采用客户端-服务器模型，因此客户端不会直接连接任何其他客户端，它们只是连接到服务器\n\n因此，客户端无法直接向其他客户端发送组播事件，只能与服务器通信\n\n但你可以使用两个复制事件来模拟这种行为：一个”在服务器上运行”事件和一个”组播”事件\n\n“在服务器上运行”事件实现可以在需要时执行验证，然后调用组播事件\n\n“组播”事件实现将执行你想要对所有连接玩家运行的逻辑\n\n下图代表了不执行任何验证的示例：\n\n\n\n8.3.2.1 “进行中加入”注意事项说明：\n\n在使用复制事件以传达游戏状态更改时需要记住的一点是它们如何与支持”进行中加入”的游戏交互\n如果玩家在游戏进行期间加入游戏，则加入前发生的任何复制事件都不会对新玩家执行\n重点是，如果你希望游戏正确地支持”进行中加入”，通常最好通过复制的变量同步重要的Gameplay数据\n经常用的一种模式是客户端在场景中执行一些操作，通过”在服务器上运行”事件将操作通知给服务器，然后在该事件的实现中，服务器根据该操作更新一些复制的变量\n然后没有执行该操作的其他客户端仍会通过复制的变量看到操作结果\n此外，任何在操作发生后在进行期间加入的客户端仍会看到场景的正确状态，因为它们从服务器获得了最新的复制变量值\n如果服务器仅发送事件，则进行中加入的玩家不会知道之前执行的操作\n\n8.3.2.2 可靠性介绍：\n\n对于任何复制的事件，你可以选择是 可靠 还是 不可靠\n\n可靠事件：\n\n可靠事件保证可到达目标（假设遵守上述所有权规则），但为了兑现这个承诺，它们会使用更多带宽，还可能会存在延迟\n尽可能频繁地尝试避免发送可靠事件，例如每个tick事件，因为引擎的内部可靠事件缓冲区可能会溢出，如果溢出，则关联的玩家会断开连接\n\n不可靠事件：\n\n不可靠事件顾名思义，它们不能到达目标，比如网络上丢包，或者引擎确定有许多更高优先级的流量需要发送\n因此，不可靠事件使用的带宽低于可靠事件，你可以更频繁地安全调用此类事件\n\n9. Replication Graph介绍：\n\n概述Replication Graph功能\nReplication Graph节点\n\n说明：\n\nReplication Graph 插件是一个用于多人游戏的网络复制系统，它的设计可以很好地适应大量玩家和复制Actor\n例如，Epic自己的Fortnite Battle Royale从一开始就支持每场比赛100名玩家，包含大约50,000个复制的Actor\n标准的网络复制策略（要求每个复制的Actor决定是否应该向每个连接的客户端发送更新）在这种情况下表现很差，并且会限制服务器的CPU\n像将Actor划分为交错的组，或者只是降低更新频率，这样的解决方案可能会缓解这个问题，但降低更新频率也会降低客户端体验\nReplication Graph消除了Actor单独评估每个连接的客户端的需要，同时在不牺牲客户端体验的情况下，解决了CPU性能问题\n\n9.1 结构介绍：\n\nReplication Graph包含一系列 Replication Graph节点，它们负责按需创建要复制到每个客户端的Actor列表\n由于此系统是由持久对象构建的，而不是仅仅由复制的Actor自己处理函数调用，因此数据可以跨多个帧存储并在客户端连接之间共享\n这种持久、共享的数据减少了Replication Graph系统为每个客户端生成复制列表所需的时间\n\n说明：\n\nReplication Graph节点（我们简称为”节点”）执行以下实际工作：确定哪些Actor可能需要更新、将它们分组、存储要发送到客户端的预计算列表等\n它们的最终任务是，尽可能快地为每个客户端连接按需提供Actor”复制列表”，以便服务器在每个Actor、每个客户端上花费尽可能少的CPU周期\n每个节点都可以以一种独特的方式运行，鼓励开发者根据需要为自己的游戏编写自定义节点\n节点可能与游戏无关，也可能利用特定于游戏的信息\n根据Actor在游戏中的角色将它们放到不同的节点中，可以让你更好地控制它们复制的方式和时间\n构建新节点，并根据Actor在游戏中的行为方式使用Replication Graph将Actor分配到最佳节点，这将极大地减少服务器CPU为准备网络复制列表所花费的时间\n\n9.2 启用此系统你可以通过以下两种方式之一，配置你的项目使用自定义 Replication Driver（Replication Graph的父类）：\n\n在”DefaultEngine.ini”文件中指定Replication Driver类\n将返回Replication Driver类实例的函数绑定到Replication Driver的默认创建委托\n\n注：\n\nShooterGame项目是如何设置和实现Replication Graph的一个很好的示例\n但是，请注意Replication Graph在控制台版本中是禁用的，因为它目前不适用于分屏游戏\n\n9.2.1 配置(.ini)文件使用：\n\n要配置引擎的默认Replication Driver\n\n打开项目的”DefaultEngine.ini”文件\n\n找到（或添加）[/Script/OnlineSubsystemUtils.IpNetDriver]部分，并设置（或添加）”ReplicationDriverClassName”条目，以便它指示希望使用的Replication Driver（或Replication Graph）类的名称\n\n这应该大致如下所示，用实际项目的名称替换”ProjectName”，用自定义类名称替换”ClassName”：\n12[/Script/OnlineSubsystemUtils.IpNetDriver]ReplicationDriverClassName=&quot;/Script/ProjectName.ClassName&quot;\n\n\n\n9.2.2 在代码中绑定使用：\n\n如果你的项目有多个游戏模式或地图，而这些模式或地图的网络要求有很大的不同，那么绑定到委托将使你能够在代码中为当前游戏模式或地图创建适当的Replication Driver\n\n要使用此方法，将一个函数绑定到名为CreateReplicationDriverDelegate的UReplicationDriver函数\n\n绑定函数必须返回所需Replication Driver类的一个有效实例，就像下面的lambda函数示例所做的：\n1234UReplicationDriver::CreateReplicationDriverDelegate().BindLambda([](UNetDriver* ForNetDriver, const FURL&amp; URL, UWorld* World) -&gt; UReplicationDriver*&#123;\treturn NewObject&lt;UMyReplicationDriverClass&gt;(GetTransientPackage());&#125;);\n\n9.3 高级示例说明：\n\n对于具有大量连接客户端甚至更多同步Actor的游戏而言，根据不同节点的类型和状态分配Actor的Replication Graph可以节省大量CPU时间\n\n这使得构建传统复制方法无法实现的游戏成为可能\n\n在概念层面上，这种规模的游戏可以构建具有以下功能的Replication Graph和Replication Graph节点，以处理数量庞大的复制Actor和连接客户端：\n\n根据位置将Actor分组\n\n场景可以划分为游戏的网格空间（在大逃杀、MOBA或MMORPG流派游戏中），预定义房间或区域（对于地牢爬行游戏或走廊风格的第一人称或第三人称射击游戏），或任何适合你游戏空间的方法\n将Actor添加到每个网格单元或房间中，以便可以从其中潜在地看到或听到Actor，这将加快客户端的更新速度，因为节点可以简单地为客户端摄像机所在的任何网格单元或房间内，向客户端提供持久性Actor列表\n\n\n确定”休眠”放置的Actor，并将它们放在单独的列表中\n\n虽然一些Actor，比如那些表示玩家或由AI控制角色的Actor，可能需要频繁的更新，但也有许多Actor可能是预先放置在关卡中的，在玩家与它们交互之前，它们是不会自己移动或改变状态的\n这些Actor可能会维持很长时间（可能是整个游戏会话），而无需发送网络更新\n例如，在Fortnite Battle Royale中，玩家和发射物可能会不断地更新，直到从游戏中移除为止\n另一方面，树可能会休眠很长时间，无需对任何客户端进行更新\n当树被损坏时，任何能够看到树的客户端都会需要接收关于此树的更新\n最后，当树被销毁时，任何接收描述树被销毁更新的客户端都不需要接收关于此树的任何进一步更新\n\n\n如果你游戏中的角色 能够拾取并携带物品，随物品的携带者一起更新这些物品\n\n当一个玩家取出一个物品或者武器并携带它，或者穿一件衣服或盔甲时，将表示该物品的Actor（假设这是一个单独的Actor，而不仅仅是一个组件）添加到一个特殊组，该组始终在拥有玩家更新时进行更新，否则绝不进行更新\n\n\n制定所有客户端始终已知的特殊Actor的列表\n\n特殊Actor始终通过与每个玩家相关，并且可以放在一个简单的节点中来跟踪这些Actor，这样就可以将它们排除在其他列表之外，它们可能会占用CPU周期来进行不必要的计算\n\n\n制定始终（或从不）与特定客户端相关的特殊Actor的列表\n\n可以为单个玩家或玩家团队创建一个类似的始终相关的列表节点\n这对于类似以下情况特别有用：确保玩家的队友始终更新，或者通过特殊的游戏内检测能力”暴露”对手，使对手对玩家的整个团队都是可见。如果”暴露”到期，可以将这些Actor添加回它们的默认节点\n\n\n\n\n\n注：\n\n构建一个Replication Graph，并根据对Actor在游戏中角色的了解，明智地将Actor分配到不同的节点，这可以充分利用服务器的CPU时间\n最终的结果是为游戏提供稳定的服务器性能，否则游戏将无法在当前硬件上运行\nReplication Graph插件包含几个Replication Graph节点类，你可以在大型在线游戏中使用它们\n此外，鼓励开发者基于对特定游戏内部工作原理的了解来构建自定义节点类\n\n10. 多人游戏中的关卡切换10.1 无缝与非无缝切换介绍：\n\nUE4 中主要有两种转移方式：\n无缝和非无缝方式\n两者的主要区别在于，无缝转移是一种非阻塞（non-blocking）操作，而非无缝转移则是一种阻塞（blocking）操作\n\n\n当客户端执行非无缝转移时，客户端将与服务器断开连接，然后重新连接到同一服务器，而服务器将准备新的地图以供加载\n\n建议：\n\nUE4 多人模式游戏尽量采用无缝转移\n这样做通常可以提供更流畅的体验，同时避免重新连接过程中可能出现的问题\n\n有三种情形中必然产生非无缝转移：\n\n初次加载地图时\n初次作为客户端连接服务器时\n想要终止一个多人模式游戏并启动新游戏时\n\n有三个用来驱动转移的主要函数：UEngine::Browse、UWorld::ServerTravel 和 APlayerController::ClientTravel\n在确定使用哪个函数时，您可能会感到有些困惑，所以请遵循下面的准则：\n详细：\nUEngine::Browse\n\n就像是加载新地图时的硬重置\n将始终导致非无缝切换\n将导致服务器在切换到目标地图前与当前客户端断开连接\n客户端将与当前服务器断开连接\n专用服务器无法切换至其他服务器，因此地图必须存储在本地（不能是 URL）\n\nUWorld::ServerTravel\n\n仅适用于服务器\n会将服务器跳转到新的世界&#x2F;场景\n所有连接的客户端都会跟随\n这就是多人游戏在地图之间转移时所用的方法，而服务器将负责调用此函数\n服务器将为所有已连接的客户端玩家调用 APlayerController::ClientTravel\n\nAPlayerController::ClientTravel\n\n如果从客户端调用，则转移到新的服务器\n如果从服务器调用，则要求特定客户端转移到新地图（但仍然连接到当前服务器）\n\n10.2 启用无缝切换前提：启用无缝切换，您需要设置一个过渡地图\n\n需要通过 UGameMapsSettings::TransitionMap 属性进行配置\n该属性默认为空，如果您的游戏保持这一默认状态，就会为过渡地图创建一个空地图\n\n原理：\n\n因为必须始终有一个被加载的世界（用于存放地图），所以在加载新地图之前，我们不能释放原有的地图\n由于地图可能会非常大，因此让新旧地图同时存放在存储器内绝对是个坏主意，这时就需要过渡地图来帮忙了\n\n好处：由于过渡地图非常小，因此在”中转”当前地图和最终地图时不会造成太大的资源消耗\n注意：设置好过渡地图后，您需要将 AGameModeBase::bUseSeamlessTravel 设置为 true，这样就可以实现无缝切换了\n10.3 无缝切换流程下面是执行无缝切换时的一般流程：\n\n标记出要在过渡关卡中存留的 actor（更多信息请见下面）\n转移到过渡关卡\n标记出要在最终关卡中存留的 actor（更多信息请见下面）\n转移到最终关卡\n\n10.4 无缝切换中的存留 Actor介绍：\n\n在使用无缝切换时，可以将（存留） actor 从当前关卡带到新的关卡\n\n这适用于一些特定的 actor，如道具栏物品和玩家等\n\n\n默认情况下，这些 actor 将自动存留：\n\nGameMode actor（仅限服务器）\n通过 AGameModeBase::GetSeamlessTravelActorList 额外添加的任何 actor\n\n\n拥有一个有效的 PlayerState （仅限服务器）的所有控制器\n所有 PlayerControllers （仅限服务器）\n所有本地 PlayerControllers （服务器和客户端）\n通过 APlayerController::GetSeamlessTravelActorList （在本地PlayerControllers上调用）额外添加的任何 actor\n\n\n\n11. 网络性能分析工具介绍：\n\nNetwork Profiler 是一款独立工具，可用于显示网络流量和性能信息，上述信息可在游戏运行时由引擎捕捉\n它是一种极其有效的方式，可识别多人游戏中占用极高带宽的区域，因为您可以查看各个 actor、PRC 和属性在总带宽中的占比\n\n11.1 录制分析会话前提：\n\n在使用 network profiler 之前，您必须录制相同的数据才能进行分析\n\n为此，您需要使用启用了进程状态跟踪功能的引擎，通常这说明是个调试 build、用于非调试配置或编辑器 build（更具体地来说，对引擎进行编译时，STATS 宏已定义为非零值）\n\n还可以在引擎启动的时候增加 “networkprofiler&#x3D;true” 命令行参数，以便于引擎已启动就能够开始记录，也可以用以下这些命令行指令在运行时控制是否要记录网络数据：\n\nnetprofile：切换录制的开启和关闭\n\nnetprofile enable：如果尚未录制，则开始录制\n\nnetprofile disable：如果当前在录制，则停止录制\n\n\n\n\n使用：\n\n数据将被保存至 &lt;project directory&gt;/Saved/Profiling/&lt;project name&gt;-&lt;timestamp&gt;.nprof\n如果您在相同文件夹中看到一个名为 NetworkProfiling.tmp 的文件，这只是引擎在收集数据时使用的临时文件\n当前分析会话停止时，该文件将根据以上方案进行重命名，然后即可在独立工具中打开它\n\n11.2 查看分析会话Chart, Filters, Details选项卡\n\n默认条件下，选定的是 “Chart, Filters, Details（图表、筛选器和详细信息）” 选项卡\n下文将对此选项卡的不同区域进行介绍\n\n\n\n图表视图\n统计数据列表\n汇总视图\n帧详细信息\n筛选器\n性能视图\n\n图表视图\n\n这是主图表视图。它类似于其他分析应用程序中的图表，可显示随时间推移已启用统计数据的图表\n单击特定帧可使用该帧相关数据填充其他视图，也可在图表上点击并拖动以放大相应区域，并查看该时间范围内的汇总情况。\n\n统计数据列表\n\n该列表中包含了 network profiler 所跟踪的所有统计数据\n切换复选框将显示或隐藏图表中的特定统计数据。对于大多数统计数据，您可选择原始计数、每秒计数、字节数或每秒字节数\n\n汇总视图\n\n该视图中显示图表中所选时间范围内的数据汇总\n其中显示了原始总数以及每秒信息\n注意，”Outgoing bandwidth（输出带宽）” 将大于 “Game socket send size（游戏套接字发送大小）”，因为 “Outgoing bandwidth（输出带宽）” 也包括了 IP 和 UDP 标头大小的近似值\n\n帧详细信息\n\n该视图对当前选定帧所发送的数据进行了分类统计\n可以查看发送了哪些 actor、属性和远程函数，以及各项分别占到多少字节\n注意，数据组中包括了 actor 和 PRC，因此 “SEND BUNCH” 部分中的 “NumBytes” 字段中包含了 “SEND RPC” 和 “REPLICATE ACTOR” 部分的字节\n最后，”SOCKET SEND TO” 条目将精确显示引擎发送到输出套接字的字节数\n注意，此处不包含标准 UDP 数据包资源消耗\n\n筛选器\n\n可为 actor、属性和 RPC 输入筛选器，在单击 “Apply Filters（应用筛选器）” 按钮后，图表将更新为只显示包含筛选器字段中输入文本的相关 actor、属性和 RPC\n在应用了筛选器之后，选择图表中的单个帧或一系列帧也将相应地筛选汇总和帧详细信息视图中的数据\n\n性能视图\n\n选择了图表中的单个帧时，该视图将显示该帧内复制的 actor 类型列表，并按照 CPU 复制它们所需的时间排序\n如果某个 actor 具有相关的复制属性，则展开该 actor 的树形视图将显示各属性\n在 actor 选项卡中，第一栏数值表示 CPU 复制该 actor 所花费的时间（以毫秒计）\n第二栏是用于表示数据包中 actor 的字节数，第三栏是当前帧中复制的指定类型的 actor 数\n在属性行中，第一列是用于属性的字节数，第二列表示为 actor 复制了多少具有指定名称的属性\n\n&quot;Actors&quot; 选项卡、&quot;Properties（属性）&quot; 选项卡和 &quot;RPCs&quot; 选项卡\n\n\n每个选项卡都显示了整个分析会话中各复制数据的汇总情况\n注意，这些选项卡中显示的数据不受 “Chart, Filters, Details” 选项卡的图表中选定的当前帧或时间范围的影响\n选项卡上分别显示了 actor、属性或 PRC 的列表\n“Total Size（总体大小）” 和 “Average Size（平均大小）” 列显示了特定项需要多少带宽，”Count（计数）” 列表示在分析会话期间复制了多少次特定项。单击各列的表头，可在升序或降序之间切换\n\n11.3 服务器和客户端\n从客户端和服务器都可录制分析数据\n但是，请注意，由于只有服务器复制 actor 及其属性，因此在查看客户端上录制的分析数据时，只能看到从该客户端发送的 RPC 的详细数据\n\n12. 性能与带宽提示介绍：\n\n复制 actor 是一件耗费时间的工作\n\n引擎会尽量让这个过程变得更有效率，但您也可以做一些额外的工作来简化这个过程\n\n\n使用：在收集 actor 用于复制时，服务器将检查一些事项，如相关性、更新频度、休眠情况等。您可以调整这些检查项以改善性能\n要最大限度提升这一过程的效率，最好是遵循以下优先顺序：\n\n关闭复制（AActor::SetReplicates( false )）\n当 actor 未进行复制时，它最初不会出现在列表中，我们可以充分利用这一点，确保那些无需复制的 actor 会有相应标记\n\n\n减少 NetUpdateFrequency 值\nactor 的更新次数越少，更新所用的时间就越短\n最好是尽量压低这个数值。该数值代表了这个 actor 每秒复制到客户端的频度\n\n\n休眠情况\n相关性\nNetClientTicksPerSecond\n\n注：\n\n如果属性并非是绝对必需，则不要将其标记为复制\n\n如果可以，最好能尝试从现有的已复制属性中派生状态\n\n尝试利用已有的量化函数，如 FVector_NetQuantize\n\n这样能大大减少向客户端复制此状态时所需的大小，如果使用得当，就不会导致任何明显的偏差\n\nFName 一般不会被压缩，所以在使用它们作为 RPC 的参数时，请记住它们通常会向字符串发送所有调用\n\n这会产生很大的资源消耗\n\n\n","slug":"7_UE4联网和多人游戏_05","date":"2022-10-06T07:28:25.963Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"8d0c33a1aee99d366309310c2d2adece","title":"UE4 功能整理","content":"UE4 功能整理[toc]\n1. SpawnActor情景：\n\n我有一个Cpp类\n这个Cpp类要生成一个其他Cpp或蓝图类\n可以使用TSubclassOf&lt;&gt;\n\n示例：\n\n定义\n123private:\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tTSubclassOf&lt;AActor&gt; SpawnActorTest;\n\n实现\n1234567891011void AActor_SpawnTest::BeginPlay()&#123;\tSuper::BeginPlay();\tFActorSpawnParameters SpawnParameters;\tSpawnParameters.Name = FName(&quot;SpawnActorTest&quot;);\tSpawnParameters.Owner = this;\tSpawnParameters.Instigator = nullptr;    \tGetWorld()-&gt;SpawnActor&lt;AActor&gt;(SpawnActorTest, GetActorTransform(), SpawnParameters);&#125;\n\n说明：\n\n定义中的SpawnActorTest是私有变量，若要保持私有，其蓝图可以Get, Set和参数列表中显示继承中：\n\nUPOPERTY()中加入BlueprintReadWrite，meta=(AllowPrivateAccess=true)\n\n\nFActorSpawnParameters是可以自定义生成参数，默认可以不写\n\nGetActorTransform()可以是GetActorLocation和GetActorRotation\n\n\n2. LineTrace\nTrace模式\nTraceSingle 单个结果\nTraceMulti 多个结果\n\n\nTrace 的检测依据\nByChanne\nByObjectType\nByProfile\n\n\n\n2.1 UWorldLineTraceSingleByChannel\n情景：\n\n场景中的某个Actor需要发射检测射线\n可以直接在Actor上写，也可以通过组件SceneComponent，ActorComponent\n示例采用SceneComponent\n\nSyntax：\n12345678bool LineTraceSingleByChannel(\tstruct FHitResult&amp; OutHit,\tconst FVector&amp; Start,\tconst FVector&amp; End,\tECollisionChannel TraceChannel,\tconst FCollisionQueryParams&amp; Params = FCollisionQueryParams::DefaultQueryParam,\tconst FCollisionResponseParams&amp; ResponseParam = FCollisionResponseParams::DefaultResponseParam) const;\n\n\n\n示例：\n\n定义\n123private:\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category=&quot;Trace&quot;, meta=(AllowPrivateAccess=true))\tfloat TraceDistance;\n\n实现\n1234567891011const FVector Start = GetOwner()-&gt;GetActorLocation();const FVector End = Start + (GetForwardVector() * TraceDistance);FHitResult HitResult;const bool IsHit = GetWorld()-&gt;LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility);DrawDebugLine(GetWorld(), Start, End, FColor::Red, false, 0.5f);if (!IsHit)&#123;return;&#125;GEngine-&gt;AddOnScreenDebugMessage(-1, 1.f, FColor::Green,\t\tFString::Printf(TEXT(&quot;Trace Hit: %s&quot;), *HitResult.GetActor()-&gt;GetName()));\n\n说明：\n\nHitResult会包含射线检测到的Actor的信息\n\n2.2 Kismet2.2.1 LineTraceSingle情景：\n\n根据 Channel 检测单个物体\n\nSyntax：\n1234567891011121314static bool LineTraceSingle(\tconst UObject* WorldContextObject,\tconst FVector Start,\tconst FVector End, \tETraceTypeQuery TraceChannel, \tbool bTraceComplex, \tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore, \tEDrawDebugTrace::Type DrawDebugType,\tFHitResult&amp; OutHit, \tbool bIgnoreSelf, \tFLinearColor TraceColor = FLinearColor::Red, \tFLinearColor TraceHitColor = FLinearColor::Green, \tfloat DrawTime = 5.0f);\n\n\n\n示例：\n\n定义：\n123private:\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category=&quot;Trace&quot;, meta=(AllowPrivateAccess=true))\tfloat TraceDistance;\n\n\n\n实现：\n12345678910111213const FVector Start = GetOwner()-&gt;GetActorLocation();const FVector End = Start + (GetForwardVector() * TraceDistance);FHitResult HitResult;const TArray&lt;AActor*&gt; ActorsToIgnore;const bool IsHit = UKismetSystemLibrary::LineTraceSingle(\t\tthis, Start, End, TraceTypeQuery1,\t\tfalse, ActorsToIgnore, EDrawDebugTrace::ForDuration, HitResult, true,\t\tFLinearColor::Red, FLinearColor::Green, 1.f);if (!IsHit)&#123;return;&#125;GEngine-&gt;AddOnScreenDebugMessage(-1, 1.f, FColor::Green,\t\tFString::Printf(TEXT(&quot;Trace Hit: %s&quot;), *HitResult.GetActor()-&gt;GetName()));\n\n说明：\n\nETraceTypeQuery 说明\n默认 TraceTypeQuery1 —— Visibility\n默认 TraceTypeQuery2 —— Camera\n可在 ProjectSettings-&gt;Engine-&gt;Collision-&gt;Trace Channels 添加自定义\n\n\n\n2.2.2 LineTraceSingleForObjects情景：\n\n根据 Object Type 检测单个物体\n\nSyntax\n1234567891011121314static bool LineTraceSingleForObjects(\tconst UObject* WorldContextObject,\tconst FVector Start,\tconst FVector End,\tconst TArray&lt;TEnumAsByte&lt;EObjectTypeQuery&gt; &gt; &amp; ObjectTypes,\tbool bTraceComplex,\tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore,\tEDrawDebugTrace::Type DrawDebugType,\tFHitResult&amp; OutHit,\tbool bIgnoreSelf,\tFLinearColor TraceColor = FLinearColor::Red,\tFLinearColor TraceHitColor = FLinearColor::Green,\tfloat DrawTime = 5.0f );\n\n\n\n示例：\n\n实现：\n12345678910// 设置要检测的 Object TypeTArray&lt;TEnumAsByte&lt;EObjectTypeQuery&gt; &gt; ObjectTypes;ObjectTypes.Add(EObjectTypeQuery::ObjectTypeQuery1);//开始检测bool bIsHit = UKismetSystemLibrary::LineTraceSingleForObjects(GetWorld(), BeginLoc, EndLoc, ObjectTypes, false, IgnoreActors, EDrawDebugTrace::ForDuration, HitResult, true);if (bIsHit)&#123;\tUKismetSystemLibrary::PrintString(GetWorld(), HitResult.GetActor()-&gt;GetName());&#125;\n\n说明：\n\nEObjectTypeQuery 对应 ObjectType\n默认 ObjectTypeQuery1 —— WorldStatic\n默认 ObjectTypeQuery2 —— WorldDynamic\n默认 ObjectTypeQuery3 —— Oawn\n默认 ObjectTypeQuery4 —— PhysicasBody\n默认 ObjectTypeQuery5 —— Vehicle\n默认 ObjectTypeQuery6 —— Destructible\n可以再 ProjectSettings-&gt;Engine-&gt;Collision-&gt;Object Channels 添加自定义\n\n\n\n2.2.3 LineTraceSingleByProfile情景：\n\n根据 Collision Preset 检测单个物体\n\nSyntax\n1234567891011121314static bool LineTraceSingleByProfile(\tconst UObject* WorldContextObject,\tconst FVector Start, \tconst FVector End, \tFName ProfileName,\tbool bTraceComplex,\tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore,\tEDrawDebugTrace::Type DrawDebugType,\tFHitResult&amp; OutHit,\tbool bIgnoreSelf,\tFLinearColor TraceColor = FLinearColor::Red,\tFLinearColor TraceHitColor = FLinearColor::Green,\tfloat DrawTime = 5.0f);\n\n\n\n示例：\n\n实现：\n123456789bool bIsHit = UKismetSystemLibrary::LineTraceSingleByProfile(    GetWorld(), BeginLoc, EndLoc,TEXT(&quot;BlockAll&quot;),     false, IgnoreActors, EDrawDebugTrace::ForDuration,     HitResult, true);if (bIsHit)&#123;\tUKismetSystemLibrary::PrintString(GetWorld(), HitResult.GetActor()-&gt;GetName());&#125;\n\n说明：\n\nProfileName 对应 Collision Preset 的名称\n\n3. SweepTrace情景：\n\n使用UWorld生成\n\n生成一个范围检测周边的Actor\n\n\n示例：\n\n定义：\n123private:\tUPROPERTY(EditDefaultsOnly, Category=&quot;Trace&quot;, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat TraceRadius;\n\n\n\n实现：\n12345678910111213141516TArray&lt;FHitResult&gt; HitResults;const FVector Start, End = GetOwner()-&gt;GetActorLocation();const FCollisionShape CollisionShape = FCollisionShape::MakeSphere(TraceRadius);const bool IsHit = GetWorld()-&gt;SweepMultiByChannel(\t\t\tHitResults, Start, End, FQuat::Identity,\t\t\tECC_Visibility, CollisionShape);DrawDebugSphere(GetWorld(), Start, TraceRadius, 50, FColor::Green, true);if (!IsHit)&#123;return;&#125;for (const auto &amp;result : HitResults)&#123;\tGEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green,\t\tFString::Printf(TEXT(&quot;Hit: %s&quot;), *result.GetActor()-&gt;GetName()));&#125;\n\n说明：\n\nFQuat四元数\nIndentity：无旋转\n\n\n\n4. SphereTrace情景：\n\n使用Kismet生成\n生成一个范围检测周边的Actor\n\n示例：\n\n定义：\n123private:\tUPROPERTY(EditDefaultsOnly, Category=&quot;Trace&quot;, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat TraceRadius;\n\n\n\n实现：\n12345678910111213141516171819202122232425262728const FVector Start, End = GetOwner()-&gt;GetActorLocation();TArray&lt;AActor*&gt; ActorsToIgnore;ActorsToIgnore.Add(GetOwner());TArray&lt;FHitResult&gt; HitResults;\tconst bool IsHit = UKismetSystemLibrary::SphereTraceMulti(\t\tthis,\t\tStart,\t\tEnd,\t\tTraceRadius,\t\tTraceTypeQuery1, \t\tfalse,\t\tActorsToIgnore,\t\tEDrawDebugTrace::ForDuration,\t\tHitResults,\t\ttrue,\t\tFLinearColor::Green,\t\tFLinearColor::Red,\t\t60.f);\tif (!IsHit)&#123;return;&#125;for (const auto &amp;result : HitResults)&#123;\tGEngine-&gt;AddOnScreenDebugMessage(        -1, 60.f, FColor::Green,\t\tFString::Printf(TEXT(&quot;Hit: %s&quot;),         *result.GetActor()-&gt;GetName()));&#125;\n\n5. Character情景：\n\n第三人称\n自由视角\n角色朝向鼠标输入和控制器指向\n\n示例：\n\n准备：\n\n编辑 &gt;&gt; 项目设置 &gt;&gt; 引擎 &gt;&gt; 输入\n添加操作映射\nJump &#x3D;&#x3D; 空格键\n\n\n添加轴映射\nMoveForward\nW &#x3D;&#x3D; 1.0\nS &#x3D;&#x3D; -1.0\n\n\nMoveRight\nD &#x3D;&#x3D; 1.0\nA &#x3D;&#x3D; -1.0\n\n\nPitchCamera\n鼠标Y &#x3D;&#x3D; -1.0\n\n\nYawCamera\n鼠标X &#x3D;&#x3D; 1.0\n\n\n\n\n\n\n定义：\n12345678910111213141516class USpringArmComponent;class UCameraComponent;private:\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, Category=&quot;Player&quot;, meta=(AllowPrivateAccess=true))\tUSpringArmComponent *PlayerSpringArmComponent;\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, Category=&quot;Player&quot;, meta=(AllowPrivateAccess=true))\tUCameraComponent *PlayerCameraComponent;\tpublic:\tUFUNCTION()\tvoid MoveForward(float Value);\tUFUNCTION()\tvoid MoveRight(float Value);\n\n\n\n实现：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293ACharacterBase::ACharacterBase()&#123;\tPrimaryActorTick.bCanEverTick = true;\tGetCapsuleComponent()-&gt;InitCapsuleSize(36.f, 92.f);\t\tPlayerSpringArmComponent = CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT(&quot;SpringArm&quot;));\tPlayerSpringArmComponent-&gt;SetupAttachment(RootComponent);    PlayerSpringArmComponent-&gt;bUsePawnControlRotation = true;    // 以下是详细配置\tPlayerSpringArmComponent-&gt;SetRelativeLocation(FVector(0.f, 0.f, 90.f));\tPlayerSpringArmComponent-&gt;TargetArmLength = 300.f;\tPlayerSpringArmComponent-&gt;bEnableCameraLag = true;\tPlayerSpringArmComponent-&gt;bEnableCameraRotationLag = true;\tPlayerSpringArmComponent-&gt;CameraLagSpeed = 10.f;\tPlayerSpringArmComponent-&gt;CameraRotationLagSpeed = 10.f;\tPlayerSpringArmComponent-&gt;CameraLagMaxDistance = 100.f;\tPlayerCameraComponent = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;Camera&quot;));\tPlayerCameraComponent-&gt;SetupAttachment(PlayerSpringArmComponent, USpringArmComponent::SocketName);\tPlayerCameraComponent-&gt;bUsePawnControlRotation = false;\tGetCharacterMovement()-&gt;bOrientRotationToMovement = true;    // 以下是详细配置\tGetCharacterMovement()-&gt;RotationRate = FRotator(0.f, 90.f, 0.f);\tGetCharacterMovement()-&gt;GravityScale = 1.5f;\tGetCharacterMovement()-&gt;MaxAcceleration = 980.f;\tGetCharacterMovement()-&gt;JumpZVelocity = 600.f;\tGetCharacterMovement()-&gt;AirControl = 0.2f;\tbUseControllerRotationPitch = false;\tbUseControllerRotationRoll = false;\tbUseControllerRotationYaw = false;&#125;void ACharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)&#123;\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\t// Bind Axis =&gt; MoveForward, MoveRight\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveForward&quot;), this, &amp;ACharacterBase::MoveForward);\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveRight&quot;), this, &amp;ACharacterBase::MoveRight);    // Pawn, Character 已经写好了内部的鼠标输入\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;PitchCamera&quot;), this, &amp;ACharacter::AddControllerPitchInput);\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;YawCamera&quot;), this, &amp;ACharacter::AddControllerYawInput);\t// Bind Action =&gt; Jump\tPlayerInputComponent-&gt;BindAction(TEXT(&quot;Jump&quot;), IE_Pressed, this, &amp;ACharacter::Jump);\tPlayerInputComponent-&gt;BindAction(TEXT(&quot;Jump&quot;), IE_Released, this, &amp;ACharacter::StopJumping);&#125;void ACharacterBase::MoveForward(float Value)&#123;    // 这种方法有问题：人物应用摄像机旋转，摄像机应用控制器旋转时，鼠标完全朝上或朝下，将无法正常行走\t//const FVector Direction = FRotationMatrix(GetController()-&gt;GetControlRotation()).GetScaledAxis(EAxis::X);        // 这个方法简单，通用    const FVector Direction = GetActorForwardVector();\tAddMovementInput(Direction, Value);        ###### 官方写法 ######\tif ((Controller != nullptr) &amp;&amp; (Value != 0.0f))\t&#123;\t\t// find out which way is forward\t\tconst FRotator Rotation = Controller-&gt;GetControlRotation();\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\t\t// get forward vector\t\tconst FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\t\tAddMovementInput(Direction, Value);\t&#125;&#125;void ACharacterBase::MoveRight(float Value)&#123;\t// const FVector Direction = FRotationMatrix(GetController()-&gt;GetControlRotation()).GetScaledAxis(EAxis::Y);        const FVector Direction = GetActorRightVector();\tAddMovementInput(Direction, Value);        ###### 官方写法 ######    if ( (Controller != nullptr) &amp;&amp; (Value != 0.0f) )\t&#123;\t\t// find out which way is right\t\tconst FRotator Rotation = Controller-&gt;GetControlRotation();\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\t\t\t// get right vector \t\tconst FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\t\t// add movement in that direction\t\tAddMovementInput(Direction, Value);\t&#125;&#125;\n\n6. Pawn情景：\n\n使用Pawn去写非人型\n\n示例：\n\n定义：\n12345678910111213private:\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category=&quot;Pawn&quot;, meta=(AllowPrivateAccess=true))\tFVector MovementDirection;\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category=&quot;Pawn&quot;, meta=(AllowPrivateAccess=true))\tfloat MovementSpeed;\tpublic:\tUFUNCTION()\tvoid MoveForward(float Value);\tUFUNCTION()\tvoid MoveRight(float Value);\n\n\n\n实现：\n1234567891011121314151617181920212223242526272829void APawnBase::Tick(float DeltaTime)&#123;\tSuper::Tick(DeltaTime);\tif (!MovementDirection.IsZero())\t&#123;\t\tconst FVector NewLocation = GetActorLocation() + (MovementDirection * DeltaTime * MovementSpeed);\t\tSetActorLocation(NewLocation);\t&#125;&#125;void APawnBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)&#123;\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\t// Bind Axis =&gt; MoveForward, MoveRight\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveForward&quot;), this, &amp;APawnBase::MoveForward);\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveRight&quot;), this, &amp;APawnBase::MoveRight);&#125;void APawnBase::MoveForward(float Value)&#123;\tMovementDirection.X = FMath::Clamp(Value, -1.f, 1.f);&#125;void APawnBase::MoveRight(float Value)&#123;\tMovementDirection.Y = FMath::Clamp(Value, -1.f, 1.f);&#125;\n\n7. Impulse Force情景：\n\n反射一条射线，朝向可移动，开启模拟物理的Actor\n使得Actor往射线方向添加脉冲力\n\n示例：\n\n定义：\n123456private:\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat TraceDistance;\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat ImpulseForce;\n\n\n\n实现：\n12345678910111213141516FHitResult HitResult;const FVector Start = GetComponentLocation();const FVector End = Start + (GetComponentRotation().Vector() * TraceDistance);const bool IsHit = GetWorld()-&gt;LineTraceSingleByChannel(\tHitResult,\tStart,\tEnd,\tECC_Visibility);if (!IsHit)&#123;return;&#125;DrawDebugLine(GetWorld(), Start, End, FColor::Green, false, 0.1f);UStaticMeshComponent *StaticMeshComponent = Cast&lt;UStaticMeshComponent&gt;(HitResult.GetActor()-&gt;GetRootComponent());if (!StaticMeshComponent || !HitResult.GetActor()-&gt;IsRootComponentMovable())&#123;return;&#125;StaticMeshComponent-&gt;AddImpulse(GetForwardVector() * ImpulseForce * StaticMeshComponent-&gt;GetMass());\n\n说明：\n\nHitResult.GetActor()-&gt;GetRootComponent()是针对根组件是UStaticMeshComponent\n最好改为HitResult.GetActor()-&gt;GetStaticMeshComponent()\n目的确保任意可移动，模拟物理的Actor都能收到影响\nGetStaticMeshComponent()可在任意Actor内实现此函数，返回UStaticMeshComponent*\n\n8. Add Force情景：\n\n不发射射线\n给可以模拟物理的Actor添加力\n\n示例：\n\n定义：\n12345678class UStaticMeshComponent;private:\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta=(AllowPrivateAccess=true))\tUStaticMeshComponent *StaticMeshComponent;\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat Force;\n\n\n\n实现：\n1234567891011121314void UAddForce_SComp::BeginPlay()&#123;\tSuper::BeginPlay();\tStaticMeshComponent = Cast&lt;UStaticMeshComponent&gt;(GetOwner()-&gt;GetRootComponent());&#125;void UAddForce_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)&#123;\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\tconst FVector UpForce = GetUpVector();\tStaticMeshComponent-&gt;AddForce(UpForce * Force * StaticMeshComponent-&gt;GetMass());&#125;\n\n9. Radia Impulse Force情景：\n\n实现爆炸力\n\n示例：\n\n定义：\n123456private:\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat ImpulseRadius;\t\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat ImpulseForceStrength;\n\n\n\n实现：\n123456789101112131415161718192021222324252627282930313233343536void URadiaImpulse_SComp::BeginPlay()&#123;\tSuper::BeginPlay();\tTArray&lt;FHitResult&gt; HitResults;\tconst FVector Start, End = GetComponentLocation();\tconst bool IsHit = GetWorld()-&gt;SweepMultiByChannel(\t\tHitResults,\t\tStart,\t\tEnd,\t\tFQuat::Identity,\t\tECC_WorldStatic,\t\tFCollisionShape::MakeSphere(ImpulseRadius));\tDrawDebugSphere(\t\tGetWorld(),\t\tStart,\t\tImpulseRadius,\t\t50,\t\tFColor::Green,\t\ttrue);\t\tif (!IsHit)&#123;return;&#125;\tfor (const auto &amp;result : HitResults)\t&#123;\t\tUStaticMeshComponent *MeshComponent = Cast&lt;UStaticMeshComponent&gt;(result.GetActor()-&gt;GetRootComponent());\t\tif (!MeshComponent)&#123;continue;&#125;\t\tMeshComponent-&gt;AddRadialImpulse(\t\t\tStart,\t\t\tImpulseRadius,\t\t\tImpulseForceStrength,\t\t\tRIF_Linear,\t\t\ttrue);\t&#125;&#125;\n\n10. TimerHandle情景：\n\n需要使用定时器\n\n示例：\n\n定义：\n123456789101112#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)private:\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tint32 CallTracker;\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta=(AllowPrivateAccess=true))\tFTimerHandle TimerHandle;\tpublic:\tUFUNCTION()\tvoid TimerFunction();\n\n\n\n实现：\n123456789101112131415161718192021void ATimerHandle_Actor::BeginPlay()&#123;\tSuper::BeginPlay();\tGetWorldTimerManager().SetTimer(\t\tTimerHandle,\t\tthis,\t\t&amp;ATimerHandle_Actor::TimerFunction,\t\t1.f,\t\ttrue,\t\t1.f);&#125;void ATimerHandle_Actor::TimerFunction()&#123;\tCallTracker == 0 ?\t\tPrintScreen(&quot;Timer End&quot;), GetWorldTimerManager().ClearTimer(TimerHandle) :\t\tPrintScreen(FString::Printf(TEXT(&quot;Timer: %d&quot;), CallTracker));\t--CallTracker;&#125;\n\n\n\n注意：\n\n但类作为父类时，要使子类也可使用TimerHandle，需要用protected修饰\n\n\n\n11. Disable Actor情景：\n\n编辑场景中的Actor\n不希望直接从场景中删除\n可以在生成的实例编辑中关闭\n不消耗性能\n\n示例：\n\n定义：\n123456789101112#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)private:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tbool isOverrideTick = false;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tbool isAutoDisable = false;public:\tUFUNCTION()\tvoid SetActive(bool isActive);\n\n\n\n实现：\n1234567891011121314151617181920212223242526272829303132333435ADisableActor::ADisableActor()&#123;\tPrimaryActorTick.bCanEverTick = true;&#125;void ADisableActor::BeginPlay()&#123;\tSuper::BeginPlay();\tisOverrideTick = !PrimaryActorTick.bCanEverTick;\tif (isAutoDisable)&#123;SetActive(false);&#125;&#125;void ADisableActor::Tick(float DeltaSeconds)&#123;\tSuper::Tick(DeltaSeconds);\tPrintScreen(&quot;Tick&quot;);&#125;void ADisableActor::SetActive(bool isActive)&#123;\tif (isOverrideTick)\t&#123;\t\tSetActorTickEnabled(false);\t&#125;\telse\t&#123;\t\tSetActorTickEnabled(isActive);\t&#125;\tSetActorHiddenInGame(!isActive);\tSetActorEnableCollision(isActive);&#125;\n\n说明：\n\n在场景中，只需要实例中的isAutoDisable进行勾选\n重新运行，Actor将会被禁用，不会作用于场景中\n\n12. Hit Event情景：\n\n通过一个Actor和场景中的其他Actor碰撞\n产生碰撞事件\n\n示例：\n\n定义：\n123456789101112#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)class UBoxComponent;private:\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUBoxComponent *HitBox;public:\tUFUNCTION()\tvoid OnHitComp(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\t\tFVector NormalImpulse, const FHitResult&amp; Hit);\n\n\n\n实现：\n12345678910111213141516171819AHitEventActor::AHitEventActor()&#123;\tPrimaryActorTick.bCanEverTick = false;\tHitBox = CreateDefaultSubobject&lt;UBoxComponent&gt;(TEXT(&quot;Hit Box&quot;));&#125;void AHitEventActor::BeginPlay()&#123;\tSuper::BeginPlay();\tHitBox-&gt;OnComponentHit.AddDynamic(this, &amp;AHitEventActor::OnHitComp);&#125;void AHitEventActor::OnHitComp(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\tFVector NormalImpulse, const FHitResult&amp; Hit)&#123;\tPrintScreen(FString::Printf(TEXT(&quot;Hit: %s&quot;), *OtherActor-&gt;GetName()));&#125;\n\n说明：\n\nHitBox需要些设置，碰撞事件才能生效\n配置：\n方便查看：\n设置形状\n设置渲染\n\n\n产生事件：设置碰撞\n打开模拟生成命中事件\n设置碰撞预设\n\n\n\n\n\n13. Set Material情景：\n\n材质的创建\n材质的使用\n\n示例：\n\n定义：\n1234567891011121314151617181920212223class UStaticMeshComponent;class UMaterialInterface;class UMaterial;class UMaterialInstance;private:\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUStaticMeshComponent *Mesh;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUMaterialInterface *MaterialOne;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUMaterialInterface *MaterialTwo;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUMaterial *Material;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUMaterialInstance *MaterialInstance;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tbool IsChooseOne = true;\n\n\n\n实现：\n1234567891011121314151617ASetMaterial::ASetMaterial()&#123;\tPrimaryActorTick.bCanEverTick = false;\tMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;Mesh_Comp&quot;));\tRootComponent = Mesh;\tMaterialOne = CreateDefaultSubobject&lt;UMaterialInterface&gt;(TEXT(&quot;Material_One&quot;));\tMaterialTwo = CreateDefaultSubobject&lt;UMaterialInterface&gt;(TEXT(&quot;Material_Two&quot;));&#125;void ASetMaterial::BeginPlay()&#123;\tSuper::BeginPlay();\tMesh-&gt;SetMaterial(0, IsChooseOne ? MaterialOne : MaterialTwo);&#125;\n\n14. Dynamic Material情景：\n\n有一个基本的材质\n通过创建材质实例\n对其中的ScaleParam，VectorParam进行动态修改\n\n示例：\n\n定义：\n12345678910111213class UStaticMeshComponent;class UMaterialInterface;class UMaterialInstanceDynamic;private:\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUStaticMeshComponent *Mesh;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUMaterialInterface *MaterialInterface;\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUMaterialInstanceDynamic *DynamicInstance;\n\n\n\n实现：\n1234567891011121314151617181920ADynamicMaterial::ADynamicMaterial()&#123;\tPrimaryActorTick.bCanEverTick = false;\tMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));\tRootComponent = Mesh;&#125;void ADynamicMaterial::BeginPlay()&#123;\tSuper::BeginPlay();\tMaterialInterface = Mesh-&gt;GetMaterial(0);\tDynamicInstance = UMaterialInstanceDynamic::Create(MaterialInterface, this);\t\tMesh-&gt;SetMaterial(0, DynamicInstance);\tDynamicInstance-&gt;SetScalarParameterValue(TEXT(&quot;EmissiveStrength&quot;), 50.f);\tDynamicInstance-&gt;SetVectorParameterValue(TEXT(&quot;Color&quot;), FLinearColor::Yellow);&#125;\n\n15. Interp Target情景：\n\n指定Actor插值移动到Target\n\n示例：\n\n定义：\n123456789101112private:\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tAActor *Origin = nullptr;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tAActor *Target;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat InterpSpeed = 3.f;\t\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat WaitTime = 1.f;\n\n\n\n实现：\n1234567891011121314151617181920212223242526void UInterpTarget_SComp::BeginPlay()&#123;\tSuper::BeginPlay();\t\tOrigin = GetOwner();&#125;void UInterpTarget_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)&#123;\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\tif (WaitTime &gt; 0)\t&#123;\t\tWaitTime -= DeltaTime;\t\treturn;\t&#125;\tif (!Target || !Origin)&#123;return;&#125;\t\tOrigin-&gt;SetActorLocation(\t\tFMath::VInterpTo(\t\t\tOrigin-&gt;GetActorLocation(),\t\t\tTarget-&gt;GetActorLocation(),\t\t\tDeltaTime,\t\t\tInterpSpeed));&#125;\n\n说明：\n\nOrigin = GetOwner();写在构造函数里无效\n\n16. Lerp情景：\n\n需要使用Lerp\n修改Actor的位置和材质\n\n示例：\n\n定义：\n12345678910111213141516171819202122232425262728293031class UMaterialInterface;class UMaterialInstanceDynamic;class UStaticMeshComponent;private:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUMaterialInterface *MaterialInter;\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUMaterialInstanceDynamic *InstanceDynamic;\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tAActor *OriginActor = nullptr;\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tUStaticMeshComponent *Mesh;\t\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tFVector StartLocation;\tUPROPERTY(EditAnywhere, meta=(MakeEditWidget=true))\tFVector TargetLocation;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat TimeElapsed = 0;\t\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat LerpDuration = 3.f;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess=true))\tfloat WaitTime = 1.f;\n\n\n\n实现：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;Lerp_SComp.h&quot;ULerp_SComp::ULerp_SComp()&#123;\tPrimaryComponentTick.bCanEverTick = true;\tMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));&#125;void ULerp_SComp::BeginPlay()&#123;\tSuper::BeginPlay();\tOriginActor = GetOwner();\tStartLocation = GetComponentLocation();\tMaterialInter = Mesh-&gt;GetMaterial(0);\tInstanceDynamic = UMaterialInstanceDynamic::Create(MaterialInter, this);\tMesh-&gt;SetMaterial(0, InstanceDynamic);\tInstanceDynamic-&gt;SetVectorParameterValue(TEXT(&quot;Color&quot;), FLinearColor::Blue);&#125;void ULerp_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)&#123;\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\tif (!OriginActor)&#123;return;&#125;\tif (WaitTime &gt; 0)&#123;WaitTime -= DeltaTime; return;&#125;\tif (TimeElapsed &lt; LerpDuration)\t&#123;\t\tOriginActor-&gt;SetActorLocation(\t\t\tFMath::Lerp(\t\t\t\tStartLocation,\t\t\t\tTargetLocation,\t\t\t\tTimeElapsed / LerpDuration));\t\tInstanceDynamic-&gt;SetVectorParameterValue(\t\t\tTEXT(&quot;Color&quot;),\t\t\tFMath::Lerp(\t\t\t\tFLinearColor::Blue,\t\t\t\tFLinearColor::Red,\t\t\t\tTimeElapsed / LerpDuration));\t\tTimeElapsed += DeltaTime;\t&#125;&#125;\n\n18. 黑洞情景：\n\n一个球，可以在一定范围内吸引开启模拟物理的Actor\n吸到黑洞的Actor会被销毁\n\n示例：\n\n简单的材质\n黑洞要黑，不能反光\n创建材质Mat_BlackHole\n创建节点VectorParameter，设置RGBA(0, 0, 0, 1)，连接基础颜色\n创建常量节点，设置为0， 连接其余的选项\n\n定义：\nBlackHole_Actor.h\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;BlackHole_Actor.generated.h&quot;class UStaticMeshComponent;class USphereComponent;struct FTimerHandle;UCLASS()class FPSGAME_API ABlackHole_Actor : public AActor&#123;\tGENERATED_BODY()\tpublic:\tABlackHole_Actor();\tvirtual void BeginPlay() override;/* My Code */\t// Propertyprivate:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;BlackHole&quot;, meta=(AllowPrivateAccess=true))\tfloat BlackHoleActionRate;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;BlackHole&quot;, meta=(AllowPrivateAccess=true))\tfloat BlackHoleStrength;\tpublic:\tFTimerHandle BlackHoleActionHandle;\t\t// Componentprivate:\tUPROPERTY(VisibleAnywhere, Category=&quot;A_Hole&quot;)\tUStaticMeshComponent *BlackHoleStaticMeshComp;\tUPROPERTY(VisibleAnywhere, Category=&quot;A_Hole&quot;)\tUSphereComponent *InnerSphereComp;\tUPROPERTY(VisibleAnywhere, Category=&quot;A_Hole&quot;)\tUSphereComponent *OuterSphereComp;public:\tUFUNCTION()\tvoid OverlapInnerSphere(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\t\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult &amp;SweepResult);\tUFUNCTION()\tvoid OnBlackHoleAction();&#125;;\n\n\n\n实现\nBlackHole_Actor.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &quot;BlackHole_Actor.h&quot;#include &quot;Components/SphereComponent.h&quot;ABlackHole_Actor::ABlackHole_Actor()&#123;\tPrimaryActorTick.bCanEverTick = false;\tBlackHoleActionRate = 0.05f;\tBlackHoleStrength = 10000.f;\tBlackHoleStaticMeshComp = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;BlackStaticMesh&quot;));\tBlackHoleStaticMeshComp-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);\tBlackHoleStaticMeshComp-&gt;CastShadow = false;\tRootComponent = BlackHoleStaticMeshComp;\tInnerSphereComp = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;InnerSphereComp&quot;));\tInnerSphereComp-&gt;SetSphereRadius(100.f);\tInnerSphereComp-&gt;SetupAttachment(BlackHoleStaticMeshComp);\t\tOuterSphereComp = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;OuterSphereComp&quot;));\tOuterSphereComp-&gt;SetSphereRadius(3000.f);\tOuterSphereComp-&gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly);\tOuterSphereComp-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\tOuterSphereComp-&gt;SetupAttachment(BlackHoleStaticMeshComp);&#125;void ABlackHole_Actor::BeginPlay()&#123;\tSuper::BeginPlay();\tcheck(InnerSphereComp);\tcheck(OuterSphereComp);\t\tif (InnerSphereComp)\t&#123;\t\tInnerSphereComp-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;ABlackHole_Actor::OverlapInnerSphere);\t&#125;\tif (GetWorld())\t&#123;\t\tGetWorldTimerManager().SetTimer(\t\t\tBlackHoleActionHandle,\t\t\tthis,\t\t\t&amp;ABlackHole_Actor::OnBlackHoleAction,\t\t\tBlackHoleActionRate,\t\t\ttrue\t\t\t);\t&#125;&#125;void ABlackHole_Actor::OverlapInnerSphere(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&amp; SweepResult)&#123;\tif (!OtherActor)&#123;return;&#125;\tOtherActor-&gt;Destroy();&#125;void ABlackHole_Actor::OnBlackHoleAction()&#123;\tTArray&lt;UPrimitiveComponent*&gt; OverlappingComp;\tif (!OuterSphereComp)&#123;return;&#125;\tOuterSphereComp-&gt;GetOverlappingComponents(OverlappingComp);\tfor (int i = 0; i &lt; OverlappingComp.Num(); ++i)\t&#123;\t\tif (OverlappingComp[i] &amp;&amp; OverlappingComp[i]-&gt;IsSimulatingPhysics())\t\t&#123;\t\t\tconst float SphereRadius = OuterSphereComp-&gt;GetScaledSphereRadius();\t\t\tOverlappingComp[i]-&gt;AddRadialForce(\t\t\t\tGetActorLocation(),\t\t\t\tSphereRadius,\t\t\t\t-BlackHoleStrength,\t\t\t\tRIF_Constant,\t\t\t\ttrue);\t\t&#125;\t&#125;&#125;\n\n\n\n\n\n\n\n19. 玩家死亡后进入观察情景：\n\n但玩家死亡后\n播放死亡动画\n禁用玩家输入\n控制器切换控制到Spectator\n玩家不与其他玩家产生碰撞\n玩家外的胶囊体组件无碰撞\n死亡动画播放带有布娃娃效果\n一定时间后销毁\n\n示例：\n\n前提：\n\n将死亡动画创建为蒙太奇动画\n设置蒙太奇的启用自动混出为false\n\n\n代码：\n\n定义\n1234567class UAnimMontage;UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Montage&quot;, meta=(AllowPrivateAccess=true))UAnimMontage *AnimMontage_Death;UFUNCTION()void OnDead();\n\n\n\n实现\n12345678910111213141516void ASTUCharacterBase::OnDead()&#123;\tif (!AnimMontage_Death)&#123;return;&#125;\tPlayAnimMontage(AnimMontage_Death);\tGetCharacterMovement()-&gt;DisableMovement();\tif (GetController())\t&#123;\t\tGetController()-&gt;ChangeState(NAME_Spectating);\t&#125;\tGetCapsuleComponent()-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);\tSetLifeSpan(5.0f);\tGetMesh()-&gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\tGetMesh()-&gt;SetSimulatePhysics(true);&#125;\n\n\n\n20. 高处坠落伤害情景：\n\n高处下落的速度达到指定值\n玩家受到相应的伤害\n使用ACharacter自带的功能实现\nvirtual void Landed(const FHitResult&amp; Hit);\nFLandedSignature LandedDelegate;\n\n\n\n示例：\n\n介绍：\nACharacter.h\n12345678910111213141516171819\t/**\t * Called upon landing when falling, to perform actions based on the Hit result. Triggers the OnLanded event.\t * Note that movement mode is still &quot;Falling&quot; during this event. Current Velocity value is the velocity at the time of landing.\t * Consider OnMovementModeChanged() as well, as that can be used once the movement mode changes to the new mode (most likely Walking).\t *\t * @param Hit Result describing the landing that resulted in a valid landing spot.\t * @see OnMovementModeChanged()\t */\tvirtual void Landed(const FHitResult&amp; Hit);/*** 落地时调用，根据命中结果执行动作。 触发 OnLanded 事件。* 请注意，此活动期间移动模式仍为“下降”。 当前速度值是着陆时的速度。* 还要考虑 OnMovementModeChanged()，因为一旦移动模式更改为新模式（很可能是步行），就可以使用它。** @param Hit Result 描述了导致有效着陆点的着陆。* @see OnMovementModeChanged()*/\tFLandedSignature LandedDelegate;\t\n\n\n\n定义：\n12345678UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;FallingDamage&quot;, meta=(AllowPrivateAccess=true))FVector2D LandedDamageVelocity;UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;FallingDamage&quot;, meta=(AllowPrivateAccess=true))FVector2D LandedDamage;UFUNCTION()void OnGroundLanded(const FHitResult&amp; HitResult);\n\n\n\n实现：\n123456789101112131415161718192021void ASTUCharacterBase::BeginPlay()&#123;\tSuper::BeginPlay();\tLandedDelegate.AddDynamic(this, &amp;ASTUCharacterBase::OnGroundLanded);&#125;void ASTUCharacterBase::OnGroundLanded(const FHitResult&amp; HitResult)&#123;\tconst float FallVelocityZ = -GetVelocity().Z;\tif (FallVelocityZ &lt; LandedDamageVelocity.X)&#123;return;&#125;\tconst float FinalDamage = FMath::GetMappedRangeValueClamped(LandedDamageVelocity,\t\tLandedDamage, FallVelocityZ);\tTakeDamage(FinalDamage, FDamageEvent&#123;&#125;, nullptr, nullptr);&#125;# FMath::GetMappedRangeValueClamped() --&gt; UnrealMathUtility.h// For the given Value clamped to the [Input:Range] inclusive, returns the corresponding percentage in [Output:Range] Inclusive// 对于钳制到 [Input:Range] 的给定值，返回 [Output:Range] 包含的相应百分比\n\n21. FindAnimNotifyByClass情景：\n\n按类型UAnimSequenceBase中查找FAnimNotifyEvent\n再绑定对应的通知事件\n\n示例：\n\n前提：\n创建AnimNotifyEventUntility.h\n123456789101112131415161718192021#pragma onceclass AnimNotifyEventUntility&#123;public:\ttemplate&lt;typename T&gt;\tstatic T* FindNotifyByClass(UAnimSequenceBase* AnimSequenceBase)\t&#123;\t\tif (!AnimSequenceBase)&#123;return nullptr;&#125;\t\tconst auto NotifyEvents = AnimSequenceBase-&gt;Notifies;\t\tfor (const auto&amp; NotifyEvent : NotifyEvents)\t\t&#123;\t\t\tif (const auto AnimNotify = Cast&lt;T&gt;(NotifyEvent.Notify))\t\t\t&#123;\t\t\t\treturn AnimNotify;\t\t\t&#125;\t\t&#125;\t\treturn nullptr;\t&#125;&#125;;\n\n\n\n创建AnimNotifyBase.h\n12345678910111213141516171819202122232425#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Animation/AnimNotifies/AnimNotify.h&quot;#include &quot;STUAnimNotifyBase.generated.h&quot;class USkeletalMeshComponent;DECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifySignature, USkeletalMeshComponent*)UCLASS()class B_01_TPS_API UAnimNotifyBase : public UAnimNotify&#123;\tGENERATED_BODY()public:\tvirtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation) override;/* My Code */\t// Property\tFOnNotifySignature OnNotify;\t&#125;;# Notify// 是 AnimNotify 自带的函数，同时不建议 UE5 使用\n\n\n\n实现AnimNotifyBase.cpp\n12345678#include &quot;AnimNotifyBase.h&quot;void USTUAnimNotifyBase::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation)&#123;\tSuper::Notify(MeshComp, Animation);\tOnNotify.Broadcast(MeshComp);&#125;\n\n\n\n\n\n定义：\n1234567891011UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Weapon&quot;, meta=(AllowPrivateAccess=true))UAnimMontage *EquipAnimMontage;UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category=&quot;Weapon&quot;, meta=(AllowPrivateAccess=true))bool IsEquipAnimInProgress;UFUNCTION()void InitAnimations();UFUNCTION()void OnEquipFinished(USkeletalMeshComponent* SkeletalMeshComponent);\n\n\n\n实现：\n12345678910111213141516171819202122232425262728293031323334#include &quot;AnimNotify/AnimNotifyEventUntility.h&quot;void USTUWeaponActorComponent::BeginPlay()&#123;\tSuper::BeginPlay();\tInitAnimations();&#125;void USTUWeaponActorComponent::InitAnimations()&#123;\tif (const auto EquipFinishedNotify =         AnimUtils::FindNotifyByClass&lt;USTUAnimNotifyEquipFinished&gt;(EquipAnimMontage))\t&#123;\t\tEquipFinishedNotify-&gt;OnNotify.AddUObject(this, &amp;USTUWeaponActorComponent::OnEquipFinished);\t&#125;\telse\t&#123;\t\tcheckNoEntry();\t&#125;&#125;void USTUWeaponActorComponent::OnEquipFinished(USkeletalMeshComponent* SkeletalMeshComponent)&#123;\tconst ASTUCharacterBase *Character = Cast&lt;ASTUCharacterBase&gt;(GetOwner());\tif (!Character || !(Character-&gt;GetMesh() == SkeletalMeshComponent))&#123;return;&#125;\tIsEquipAnimInProgress = false;&#125;# USTUAnimNotifyEquipFinished// 是AnimNotifyBase的子类// 里面不用写东西// 主要是用来：修改备注名，修改颜色，绑定事件\n\n22. 类生成附加到插槽情景：\n\n用指定的组件开始生成\n\nBeginPlay()时开始\n\n指定要生成的class\n\n以有需要附加的插槽&#96;&#96;\n\n将生成的对象附加到插槽上，并应用插槽的transform\n\nEndPlay()结束后，生成的Actor也要销毁\n\n\n示例：\n\n定义：UWeaponActorComponent.h\n1234567891011121314151617181920212223242526272829303132UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )class B_01_TPS_API USTUWeaponActorComponent : public UActorComponent&#123;\tGENERATED_BODY()public:\tUSTUWeaponActorComponent();protected:\tvirtual void BeginPlay() override;\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\t/* My Code */\t// Propertyprivate:    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Weapon&quot;, meta=(AllowPrivateAccess=true))\tTSubclassOf&lt;ASTUWeaponBase&gt; WeaponClass;        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Weapon&quot;, meta=(AllowPrivateAccess=true))\tFName WeaponEquipSocketName;        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Weapon&quot;, meta=(AllowPrivateAccess=true))\tASTUWeaponBase *CurrentWeapon;        // Functionpublic:\tUFUNCTION()\tvoid SpawnWeapons();        UFUNCTION()\tvoid AttachWeaponToSocket(ASTUWeaponBase* Weapon, USceneComponent* SceneComponent, const FName&amp; SocketName);&#125;\n\n\n\n实现：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849USTUWeaponActorComponent::USTUWeaponActorComponent()&#123;\tPrimaryComponentTick.bCanEverTick = false;\tWeaponEquipSocketName = TEXT(&quot;WeaponSocket&quot;);    WeaponClass = nullptr\tCurrentWeapon = nullptr;&#125;void USTUWeaponActorComponent::BeginPlay()&#123;\tSuper::BeginPlay();\tSpawnWeapons();&#125;void USTUWeaponActorComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)&#123;\tCurrentWeapon-&gt;DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);\tCurrentWeapon-&gt;Destroy();    CurrentWeapon = nullptr;\tSuper::EndPlay(EndPlayReason);&#125;void USTUWeaponActorComponent::SpawnWeapons()&#123;\tif (!GetWorld())&#123;return;&#125;\tASTUCharacterBase *Character = Cast&lt;ASTUCharacterBase&gt;(GetOwner());\tif (!Character)&#123;return;&#125;    const auto Weapon = GetWorld()-&gt;SpawnActor&lt;ASTUWeaponBase&gt;(WeaponClass);    \tif (!Weapon)&#123;continue;&#125;    CurrentWeapon = Weapon;        // 此处留一个伏笔，当前武器指定了 Onwer 是当前的玩家\tCurrentWeapon-&gt;SetOwner(Character);    \tAttachWeaponToSocket(CurrentWeapon, Character-&gt;GetMesh(), WeaponEquipSocketName);&#125;void USTUWeaponActorComponent::AttachWeaponToSocket(ASTUWeaponBase* Weapon, USceneComponent* SceneComponent,                                                    const FName&amp; SocketName)&#123;\tif (!Weapon || !SceneComponent)&#123;return;&#125;\tconst FAttachmentTransformRules AttachmentTransformRules(EAttachmentRule::SnapToTarget, false);\tWeapon-&gt;AttachToComponent(SceneComponent, AttachmentTransformRules, SocketName);&#125;\n\n23. CameraShake情景：\n\n在UHealthActorComponent中实现CameraShake\n\n示例：\n\n定义：\n12345678910public:\tUSTUHealthActorComponent();private:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;HPComp|Camera&quot;, meta=(AllowPrivateAccess=true))\tTSubclassOf&lt;UCameraShakeBase&gt; CameraShake;public:\tUFUNCTION()\tvoid PlayCameraShake();\n\n\n\n实现：\n12345678910111213141516171819#include &quot;STUHealthActorComponent.h&quot;USTUHealthActorComponent::USTUHealthActorComponent()&#123;\tPrimaryComponentTick.bCanEverTick = false;\tCameraShake = nullptr;&#125;void USTUHealthActorComponent::PlayCameraShake()&#123;\tconst auto Player = Cast&lt;APawn&gt;(GetOwner());\tif (!Player)&#123;return;&#125;\tconst auto Controller = Player-&gt;GetController&lt;APlayerController&gt;();\tif (!Controller || !Controller-&gt;PlayerCameraManager)&#123;return;&#125;\tController-&gt;PlayerCameraManager-&gt;StartCameraShake(CameraShake);&#125;\n\n24. HealthComponent情景：\n\n设计一个角色的生命组件\n有生命值\n有伤害处理\n呼吸回血效果\n有处理玩家死亡效果\n\n前提：\n\n定义玩家类：ACharacterBase\n定义生命组件类：UHealthComponent\n\n结构分析：\n\n玩家类中的OnDead效果对应于生命组件类中的OnDead\n生命组件类：\n可以通过蓝图获得CurrentHP，MaxHP，IsDead\n通过TimerHandle实现呼吸回血效果\n\n\n\n示例：\n\n生命组件类\n\n定义：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263DECLARE_MULTICAST_DELEGATE(FOnDead);DECLARE_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float);struct FTimerHandle;UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )class B_01_TPS_API USTUHealthActorComponent : public UActorComponent&#123;\tGENERATED_BODY()public:\tUSTUHealthActorComponent();protected:\tvirtual void BeginPlay() override;/* My Code */\t// Propertyprivate:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;HPComp&quot;, meta=(AllowPrivateAccess=true))\tfloat Health;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;HPComp&quot;, meta=(AllowPrivateAccess=true))\tfloat MaxHealth;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;HPComp|Heal&quot;, meta=(AllowPrivateAccess=true))\tbool IsAutoHeal;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;HPComp|Heal&quot;,\t\tmeta=(AllowPrivateAccess=true, EditCondition=&quot;IsAutoHeal&quot;))\tfloat HealUpdateTime;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;HPComp|Heal&quot;,\tmeta=(AllowPrivateAccess=true, EditCondition=&quot;IsAutoHeal&quot;))\tfloat HealDelayTime;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;HPComp|Heal&quot;,\tmeta=(AllowPrivateAccess=true, EditCondition=&quot;IsAutoHeal&quot;))\tfloat HealModifierValue;\tpublic:\tFTimerHandle HealTimerHandle;\tFOnDead OnDead;\tFOnHealthChanged OnHealthChanged;\t\t// Function\tpublic:\tUFUNCTION(BlueprintCallable)\tFORCEINLINE float GetHP() const &#123;return Health;&#125;\t\tUFUNCTION()\tvoid OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType,\t\tclass AController* InstigatedBy, AActor* DamageCauser);\t\tUFUNCTION(BlueprintCallable)\tbool IsDead() const &#123;return FMath::IsNearlyZero(Health);&#125;\tUFUNCTION()\tvoid HealUpdate();    \tUFUNCTION()\tvoid SetHealth(float NewHealth);&#125;;\n\n\n\n实现：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;STUHealthActorComponent.h&quot;USTUHealthActorComponent::USTUHealthActorComponent()&#123;\tPrimaryComponentTick.bCanEverTick = false;\tHealth = 0.f;\tMaxHealth = 100.f;\tIsAutoHeal = true;\tHealUpdateTime = 1.f;\tHealDelayTime = 4.f;\tHealModifierValue = 10.f;&#125;void USTUHealthActorComponent::BeginPlay()&#123;\tSuper::BeginPlay();    SetHealth(MaxHealth);\tif (GetOwner())\t&#123;\t\tGetOwner()-&gt;OnTakeAnyDamage.AddDynamic(this, &amp;USTUHealthActorComponent::OnTakeAnyDamage);\t&#125;&#125;/* My Code */void USTUHealthActorComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType,\tAController* InstigatedBy, AActor* DamageCauser)&#123;\tif (Health &lt;= 0.f || IsDead() || !GetWorld())&#123;return;&#125;\tSetHealth(Health -  Damage);\tif (IsDead())\t&#123;\t\tOnDead.Broadcast();\t&#125;\telse if (IsAutoHeal)\t&#123;\t\tGetWorld()-&gt;GetTimerManager().SetTimer(HealTimerHandle, this, &amp;USTUHealthActorComponent::HealUpdate,\t\t\tHealUpdateTime, IsAutoHeal, HealDelayTime);\t&#125;&#125;void USTUHealthActorComponent::HealUpdate()&#123;\tSetHealth(Health += HealModifierValue);\tif (!FMath::IsNearlyEqual(Health, MaxHealth) || !GetWorld())&#123;return;&#125;\tGetWorld()-&gt;GetTimerManager().ClearTimer(HealTimerHandle);&#125;void USTUHealthActorComponent::SetHealth(float NewHealth)&#123;\tHealth = FMath::Clamp(NewHealth, 0.f, MaxHealth);&#125;\n\n\n\n玩家类\n\n定义：\n123456789101112131415161718class USTUHealthActorComponent;public:\tASTUCharacterBase();protected:\tvirtual void BeginPlay() override;/* My Code */\t// Componentprivate:\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category=&quot;Component&quot;, meta=(AllowPrivateAccess=true))\tUSTUHealthActorComponent *HealthActorComponent;\t// Functionpublic:\tUFUNCTION()\tvoid OnDead();\n\n\n\n实现：\n123456789101112131415161718192021#include &quot;STUHealthActorComponent.h&quot;ASTUCharacterBase::ASTUCharacterBase()&#123;    PrimaryActorTick.bCanEverTick = false;        HealthActorComponent = CreateDefaultSubobject&lt;USTUHealthActorComponent&gt;(TEXT(&quot;HPComp&quot;));&#125;void ASTUCharacterBase::BeginPlay()&#123;\tSuper::BeginPlay();\tcheck(HealthActorComponent);\tHealthActorComponent-&gt;OnDead.AddUObject(this, &amp;ASTUCharacterBase::OnDead);&#125;void ASTUCharacterBase::OnDead()&#123;    // OnDead Event&#125;\n\n25. GetActorComponent情景：\n\n需要通过已有的Actor获得其已添加的Component\n将这个方法提取成一个模板工具类\n\n示例：\n\n定义：\n12345678910111213141516#pragma onceclass FH_Utility&#123;public:\ttemplate&lt;typename T&gt;\tFORCEINLINE static T* GetActorComponent(const AActor* Actor)\t&#123;\t\tif (!Actor)&#123;return nullptr;&#125;\t\tconst auto Component = Actor-&gt;GetComponentByClass(T::StaticClass());\t\tT* ResultComponent = Cast&lt;T&gt;(Component);\t\tif (!ResultComponent)&#123;return nullptr;&#125;\t\treturn ResultComponent;\t&#125;&#125;;\n\n26. 设计结构体和委托情景：\n\n将一类结构体或Delegate写进单独的类中\n便于管理\n\n示例：\n\n定义：FH_CoreType.h\n123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &quot;FH_CoreType.generated.h&quot; // 因为使用了Delegate 和 USTRUCT，这里要手动加入class ASTUWeaponBase;class UAnimMontage;// Delegate 的定义可以写在这里DECLARE_MULTICAST_DELEGATE(FOnDead);DECLARE_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float);// 可以定义结构体，USTRCUT() 内加入 BlueprintType, 蓝图就可以或这个结构体USTRUCT(BlueprintType)struct FAmmoData&#123;\tGENERATED_USTRUCT_BODY() // 原：GENERATED_BODY() 需改为 GENERATED_USTRUCT_BODY()\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Ammo&quot;,  meta=(AllowPrivateAccess=true))\tint32 Bullets = 0;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Ammo&quot;,\t\t\t  meta=(AllowPrivateAccess=true, EditCondition=&quot;!IsInfinity&quot;))\tint32 Clips = 0;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Ammo&quot;,  meta=(AllowPrivateAccess=true))\tbool IsInfinity = false;&#125;;USTRUCT(BlueprintType)struct FWeaponData&#123;\tGENERATED_USTRUCT_BODY()\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;ReloadWeapon&quot;, meta=(AllowPrivateAccess=true))\tTSubclassOf&lt;ASTUWeaponBase&gt; WeaponClass = nullptr;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;ReloadWeapon&quot;, meta=(AllowPrivateAccess=true))\tUAnimMontage* ReloadAnimMontage = nullptr;&#125;;\n\n27. AIPerception获得最近Actor情景：\n\nAI绑定了AIPerceptionComponent\n设置AISense：例如–目光UAISense_Sight\n利用GetCurrentlyPerceivedActors获得目光内的有效Actor\n通过Actor获得其前面HealthComponent，判断Actor是否符合需求\n最后通过算法，求得并返回离AI最近的Actor\n\n示例：\n\n定义：\n1234567891011121314151617#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Perception/AIPerceptionComponent.h&quot;#include &quot;STUAIPerceptionComponent.generated.h&quot;UCLASS()class B_01_TPS_API USTUAIPerceptionComponent : public UAIPerceptionComponent&#123;\tGENERATED_BODY()/* My Code */\t// Functionpublic:\tUFUNCTION()\tAActor* GetClosetActor() const;&#125;;\n\n\n\n实现：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;STUAIPerceptionComponent.h&quot;#include &quot;AIController.h&quot;#include &quot;STUHealthActorComponent.h&quot;#include &quot;B_01_TPS/Dev/STUUtils.h&quot;#include &quot;Perception/AISense_Sight.h&quot;AActor* USTUAIPerceptionComponent::GetClosetActor() const&#123;\tTArray&lt;AActor*&gt; PerceptionActors;        // AIPerceptionComponent自带的函数，获得所有已经被感知的Actor\tGetCurrentlyPerceivedActors(UAISense_Sight::StaticClass(), PerceptionActors);    // 判断组件的拥有AI是否有AIController\tif (PerceptionActors.Num() &lt;= 0)&#123;return nullptr;&#125;\tconst auto Controller = Cast&lt;AAIController&gt;(GetOwner());    // 判断当前AI是否有效\tif (!Controller)&#123;return nullptr;&#125;\tconst auto Pawn = Controller-&gt;GetPawn();    // 开始计算最近的Actor\tif (!Pawn)&#123;return nullptr;&#125;        // MAX_FLT 是 UnrealEngine 自带的 UrealMathUtility 中的 宏    // #define MAX_FLT 3.402823466e+38F    // 表示可虚幻引擎可表达的 最大浮点数\tfloat NealDistance = MAX_FLT;\tAActor* NealPawn = nullptr;\tfor (const auto&amp; PerceptionActor : PerceptionActors)\t&#123;        // 此处使用了前面创建的 HealthComponent 和 FH_Utility        // 判断 感知到的Actor是否有生命组件，是否还活着\t\tconst auto HealthComp = STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(PerceptionActor);\t\t        if (!HealthComp || HealthComp-&gt;IsDead())&#123;return nullptr;&#125;        const auto CurrentDistance = (PerceptionActor-&gt;GetActorLocation() - Pawn-&gt;GetActorLocation()).Size();\t\t        // 找出最近距离的Actor        if (CurrentDistance &lt; NealDistance)\t\t&#123;\t\t\tNealDistance = CurrentDistance;\t\t\tNealPawn = PerceptionActor;\t\t&#125;\t&#125;\treturn NealPawn;&#125;\n\n28. GameMode情景：\n\n通过GameModeBase进行初始化\n\n示例：\n\n实现：\n123456ASTUGameModeBase::ASTUGameModeBase()&#123;\tDefaultPawnClass = ASTUCharacterBase::StaticClass();\tPlayerControllerClass = ASTUPlayerController::StaticClass();\tHUDClass = ASTUGameHUD::StaticClass();&#125;\n\n29. 拾取物-PickUp情景：\n\n创建PickUpBase\n可被放置在场景中\n可以Actor重叠检查\n不与Actor产生BlockHit\n拾取后不销毁，隐藏起来，一段时间重生，TimerHandle\n物品默认旋转，拾取后关闭旋转，重生后开启旋转，TimerHandle\n被拾取后，让拾取的Actor执行指定的GivePickUpTo，Virtual Function\n具体执行的功能，通过子类去实现\n\n示例：\n\n定义：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;STUBasePickUp.generated.h&quot;class USphereComponent;class UStaticMeshComponent;struct FTimerHandle;UCLASS()class B_01_TPS_API ASTUBasePickUp : public AActor&#123;\tGENERATED_BODY()\tpublic:\tASTUBasePickUp();protected:\tvirtual void BeginPlay() override;\tvirtual void NotifyActorBeginOverlap(AActor* OtherActor) override;/* My Code */\t// Propertyprotected:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;PickUp&quot;, meta=(AllowPrivateAccess=true))\tfloat RespawnTime;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;PickUp&quot;, meta=(ClampMin=0.0333, ClampMax=0.0083))\tfloat RotationYawRate;        FTimerHandle RespawnHandle;\tFTimerHandle RotationYawHandle;\t\t// Component\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category=&quot;PickUp&quot;, meta=(AllowPrivateAccess=true))\tUSphereComponent* CollisionComponent;\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category=&quot;PickUp&quot;, meta=(AllowPrivateAccess=true))\tUStaticMeshComponent* StaticMeshComponent;\t// Functionpublic:\tUFUNCTION()\tvoid PickUpWasTaken();\tUFUNCTION()\tvoid Respawn();\tUFUNCTION()\tvoid LoopRotationYawHandle();\tUFUNCTION()\tvoid BeginRotationYaw();\tUFUNCTION()\tvirtual bool GivePickUpTo(APawn* PlayerPawn) &#123; return false; &#125;&#125;;# NotifyActorBeginOverlap(AActor* OtherActor)\t/** \t *\tEvent when this actor overlaps another actor, for example a player walking into a trigger.\t *\tFor events when objects have a blocking collision, for example a player hitting a wall, see &#x27;Hit&#x27; events.\t *\t@note Components on both this and the other Actor must have bGenerateOverlapEvents set to true to generate overlap events.\t */\n\n\n\n实现：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &quot;STUBasePickUp.h&quot;#include &quot;Components/SphereComponent.h&quot;ASTUBasePickUp::ASTUBasePickUp()&#123;\tPrimaryActorTick.bCanEverTick = false;    RespawnTime = 5.0f;\tRotationYawRate = 0.0333f;        CollisionComponent = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;CollisionComp&quot;));\tRootComponent = CollisionComponent;\tCollisionComponent-&gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly);\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\tCollisionComponent-&gt;InitSphereRadius(50.f);\tStaticMeshComponent = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));\tStaticMeshComponent-&gt;SetupAttachment(RootComponent);\tStaticMeshComponent-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);\tStaticMeshComponent-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);&#125;void ASTUBasePickUp::BeginPlay()&#123;\tSuper::BeginPlay();\tcheck(CollisionComponent);\tcheck(StaticMeshComponent);\tLoopRotationYawHandle();&#125;void ASTUBasePickUp::NotifyActorBeginOverlap(AActor* OtherActor)&#123;\tSuper::NotifyActorBeginOverlap(OtherActor);\tconst auto Player = Cast&lt;APawn&gt;(OtherActor);\t\tif (!GivePickUpTo(Player))&#123;return;&#125;\tPickUpWasTaken();&#125;/* My Code */void ASTUBasePickUp::PickUpWasTaken()&#123;\tif (!GetRootComponent())&#123;return;&#125;\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);\tGetRootComponent()-&gt;SetVisibility(false, true);    \tGetWorldTimerManager().SetTimer(RespawnHandle, this, &amp;ASTUBasePickUp::Respawn, RespawnTime, false);\tGetWorldTimerManager().ClearTimer(RotationYawHandle);&#125;void ASTUBasePickUp::Respawn()&#123;\tif (!GetRootComponent())&#123;return;&#125;\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\tGetRootComponent()-&gt;SetVisibility(true, true);    \tGetWorldTimerManager().ClearTimer(RespawnHandle);\tLoopRotationYawHandle();&#125;void ASTUBasePickUp::LoopRotationYawHandle()&#123;\tif (!StaticMeshComponent &amp;&amp; !RespawnHandle.IsValid())&#123;return;&#125;\tGetWorldTimerManager().SetTimer(        RotationYawHandle,         this,         &amp;ASTUBasePickUp::BeginRotationYaw,         RotationYawRate,         true);&#125;void ASTUBasePickUp::BeginRotationYaw()&#123;\tStaticMeshComponent-&gt;AddRelativeRotation(FRotator(0, 1.f, 0.f));&#125;\n\n\n\n注意：\n1234567891011121314151617181920212223# 示例中是通过 AActor 自带的 NotifyActorBeginOverlap(AActor* OtherActor) 实现交互# 也可以通过 USphereComponent-&gt;UShapeComponent-&gt;UPrimitiveComponent 内的 FComponentHitSignature OnComponentHit; 实现交互################## 委托名称 ###############/** \t *\tEvent called when a component hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with &#x27;sweep&#x27; enabled, or physics simulation.\t *\tFor events when objects overlap (e.g. walking into a trigger) see the &#x27;Overlap&#x27; event.\t *\t *\t@note For collisions during physics simulation to generate hit events, &#x27;Simulation Generates Hit Events&#x27; must be enabled for this component.\t *\t@note When receiving a hit from another object&#x27;s movement, the directions of &#x27;Hit.Normal&#x27; and &#x27;Hit.ImpactNormal&#x27;\t *\twill be adjusted to indicate force from the other object against this object.\t *\t@note NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions.\t */\tUPROPERTY(BlueprintAssignable, Category=&quot;Collision&quot;)\tFComponentHitSignature OnComponentHit;################### 委托绑定的函数参数列表 ##################/** * Delegate for notification of blocking collision against a specific component.   * NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions.  */DECLARE_DYNAMIC_MULTICAST_SPARSE_DELEGATE_FiveParams( FComponentHitSignature, UPrimitiveComponent, OnComponentHit, UPrimitiveComponent*, HitComponent, AActor*, OtherActor, UPrimitiveComponent*, OtherComp, FVector, NormalImpulse, const FHitResult&amp;, Hit );\n\n30. AIController情景：\n\n与前面AIPerception获得最近Actor想关联\n利用AIPerceptionComponent获取最近的Actor\n通过TimerHandle控制检测频率\n通过获得黑板组件，获得设置的最近的Actor\n让AIControlller控制AI面向最近的Actor\nAIController获得自己绑定的AI，执行有效的BehaviorTree\n通过FName手动指定获得黑板组件中指定的Key\n\n示例：\n\n定义：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;AIController.h&quot;#include &quot;STUAIController.generated.h&quot;class USTUAIPerceptionComponent;struct FTimerHandle;UCLASS()class B_01_TPS_API ASTUAIController : public AAIController&#123;\tGENERATED_BODY()public:\tASTUAIController();\tprotected:\tvirtual void OnPossess(APawn* InPawn) override;\tvirtual void BeginPlay() override;/* My Code */\t// Propertyprivate:\tUPROPERTY()\tbool IsRunBehavior;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;AI&quot;, meta=(AllowPrivateAccess=true))\tfloat CheckRate;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;AI&quot;, meta=(AllowPrivateAccess=true))\tFName FocusOnKeyName;\tpublic:\tFTimerHandle CheckClosetEnemyTimerHandle;\t\t// Componentprivate:\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category=&quot;AI&quot;, meta=(AllowPrivateAccess=true))\tUSTUAIPerceptionComponent* AIPerceptionComponent;\t// Functionpublic:\tUFUNCTION()\tvoid OnCheckClosetEnemy();\tUFUNCTION()\tAActor* GetFocusOnActor() const;&#125;;\n\n\n\n实现：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &quot;STUAIController.h&quot;#include &quot;STUAI.h&quot;#include &quot;BehaviorTree/BlackboardComponent.h&quot;#include &quot;B_01_TPS/Component/STUAIPerceptionComponent.h&quot;ASTUAIController::ASTUAIController()&#123;\tIsRunBehavior = false;\tCheckRate = 0.1f;        // 此处指定要访问 黑板组件 的 keyName\tFocusOnKeyName = &quot;EnemyActor&quot;;\t    // 此处指定初始化 AIPerceptionComponent\tAIPerceptionComponent = CreateDefaultSubobject&lt;USTUAIPerceptionComponent&gt;(TEXT(&quot;AIPerceptionComp&quot;));\tif (AIPerceptionComponent)&#123;SetPerceptionComponent(*AIPerceptionComponent);&#125;&#125;void ASTUAIController::OnPossess(APawn* InPawn)&#123;\tSuper::OnPossess(InPawn);\tconst auto STUCharacter = Cast&lt;ASTUAI&gt;(InPawn);    // 此处执行 AI绑定的 BehaviorTree\tif (!STUCharacter || !STUCharacter-&gt;GetBehaviorTreeAsset())&#123;return;&#125;\tIsRunBehavior = RunBehaviorTree(STUCharacter-&gt;GetBehaviorTreeAsset());&#125;void ASTUAIController::BeginPlay()&#123;\tSuper::BeginPlay();    // 开始按频率 检测最近的Actor\tif (GetWorld() &amp;&amp; IsRunBehavior)\t&#123;\t\tGetWorldTimerManager().SetTimer(\t\t\tCheckClosetEnemyTimerHandle,\t\t\tthis,\t\t\t&amp;ASTUAIController::OnCheckClosetEnemy,\t\t\tCheckRate,\t\t\ttrue);\t&#125;&#125;// 设置 AI面向 最近的 Actorvoid ASTUAIController::OnCheckClosetEnemy()&#123;\tconst auto AimActor = GetFocusOnActor();\tSetFocus(AimActor);&#125;// 在黑板组件的指定key中 拿到以设置的 最近的ActorAActor* ASTUAIController::GetFocusOnActor() const&#123;\tif (!GetBlackboardComponent())&#123;return nullptr;&#125;\treturn Cast&lt;AActor&gt;(GetBlackboardComponent()-&gt;GetValueAsObject(FocusOnKeyName));&#125;\n\n31. AI初始化和过渡旋转情景：\n\n初始化一个基本的AI\n通过前面的AIController已经可以面向最近的Actor，但旋转没有过渡，需要实现过渡\n关联相应的BehaviorTree\n有Dead相关函数，方便通过AIcontroller停止AI的行为\n\n示例：\n\n定义：\n12345678910111213141516171819202122232425262728#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;B_01_TPS/Player/STUCharacterBase.h&quot;#include &quot;STUAI.generated.h&quot;class UBehaviorTree;UCLASS()class B_01_TPS_API ASTUAI : public ASTUCharacterBase&#123;\tGENERATED_BODY()protected:\tASTUAI(const FObjectInitializer&amp; ObjectInit);/* My Code */\t// Propertyprivate:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;AI&quot;, meta=(AllowPrivateAccess=true))\tUBehaviorTree* BehaviorTreeAsset;public:\tUFUNCTION()\tFORCEINLINE UBehaviorTree* GetBehaviorTreeAsset() const &#123;return BehaviorTreeAsset;&#125;\tvirtual void OnDead() override;&#125;;\n\n\n\n实现：\n123456789101112131415161718192021222324252627282930313233#include &quot;STUAI.h&quot;#include &quot;BrainComponent.h&quot;#include &quot;STUAIController.h&quot;#include &quot;B_01_TPS/Component/STUAIWeaponActorComponent.h&quot;#include &quot;B_01_TPS/Component/STUCharacterMovementComponent.h&quot;ASTUAI::ASTUAI(const FObjectInitializer&amp; ObjectInit) :Super(ObjectInit.SetDefaultSubobjectClass&lt;USTUAIWeaponActorComponent&gt;(&quot;WeaponActorComponent&quot;))&#123;    // 初始化 AI 和 AIController\tAutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;\tAIControllerClass = ASTUAIController::StaticClass();\t    // 利用 CharacterMovementComponent 设置 AI 旋转面向 最近Actor 的过渡效果\tif (GetCharacterMovement())\t&#123;\t\tbUseControllerRotationYaw = false;\t\tGetCharacterMovement()-&gt;bUseControllerDesiredRotation = true;\t\tGetCharacterMovement()-&gt;RotationRate = FRotator(0.f, 200.f, 0.f);\t&#125;&#125;void ASTUAI::OnDead()&#123;\tSuper::OnDead();    // 通知 AIController 停止 AI行为\tconst auto STUController = Cast&lt;AAIController&gt;(Controller);\tif (STUController &amp;&amp; STUController-&gt;BrainComponent)\t&#123;\t\tSTUController-&gt;BrainComponent-&gt;Cleanup();\t&#125;&#125;\n\n32. BeHaviorTree Task情景：\n\nAI Task的关键信息是AIController和BlackBoardComp\n通过AIController获得绑定的AI Pawn\n通过UNavigationSystemV1获得场景的NavMesh导航\n利用BlackBoardComp获得和设置Key值\n以玩家随机进入下一个场景随机点为例\n\n示例：\n\n定义：\n1234567891011121314151617181920212223242526272829303132333435#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;BehaviorTree/BTTaskNode.h&quot;#include &quot;STUNextLocationTask.generated.h&quot;struct FBlackboardKeySelector;UCLASS()class B_01_TPS_API USTUNextLocationTask : public UBTTaskNode&#123;\tGENERATED_BODY()public:\tUSTUNextLocationTask();protected:\tvirtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;/* My Code */\t// Propertyprivate:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;AI|Task&quot;, meta=(AllowPrivateAccess=true))\tfloat Radius;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;AI|Task&quot;, meta=(AllowPrivateAccess=true))\tFBlackboardKeySelector AimLocationKey;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;AI|Task&quot;, meta=(AllowPrivateAccess=true))\tbool IsSelfCenter;\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;AI|Task&quot;,\t\tmeta=(AllowPrivateAccess=true, EditCondition=&quot;!IsSelfCenter&quot;))\tFBlackboardKeySelector CenterActorKey;&#125;;\n\n\n\n实现：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;STUNextLocationTask.h&quot;#include &quot;AIController.h&quot;#include &quot;NavigationSystem.h&quot;#include &quot;BehaviorTree/BlackboardComponent.h&quot;USTUNextLocationTask::USTUNextLocationTask()&#123;\tRadius = 1000.f;\tNodeName = &quot;Next Location&quot;;\tIsSelfCenter = true;&#125;EBTNodeResult::Type USTUNextLocationTask::ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)&#123;    // 获得 AIController 和 BlackBoardComp\tconst auto Controller = OwnerComp.GetAIOwner();\tconst auto BlackBoard = OwnerComp.GetBlackboardComponent();    // 通过 AIController 获得 AI Pawn\tif (!Controller || !BlackBoard)&#123;return EBTNodeResult::Failed;&#125;\tconst auto Pawn = Controller-&gt;GetPawn();    // 获得场景中的 NavMeshSystem\tif (!Pawn)&#123;return EBTNodeResult::Failed;&#125;\tconst auto NavSys = UNavigationSystemV1::GetCurrent(Pawn);    // 先获得 AI 当前的位置\tif (!NavSys)&#123;return EBTNodeResult::Failed;&#125;\tFNavLocation NavLocation;\tauto Location = Pawn-&gt;GetActorLocation();    // 判断 AI 是否已经到达 随机的位置    // 通过 黑板组件获得 指定位置的 AI 的 key值\tif (IsSelfCenter)&#123;return EBTNodeResult::Failed;&#125;\tconst auto CenterActor = Cast&lt;AActor&gt;(BlackBoard-&gt;GetValueAsObject(CenterActorKey.SelectedKeyName));    // 但 AI到达随机位置，设置下个随机点的 位置\tif (!CenterActor)&#123;return EBTNodeResult::Failed;&#125;\tLocation = CenterActor-&gt;GetActorLocation();\tconst bool IsFound = NavSys-&gt;GetRandomReachablePointInRadius(Location, Radius, NavLocation);    // 设定好下个 随机位置，需要用 黑板组件 设置 新的位置 key值\tif (!IsFound)&#123;return EBTNodeResult::Failed;&#125;\tBlackBoard-&gt;SetValueAsVector(AimLocationKey.SelectedKeyName, NavLocation.Location);\treturn EBTNodeResult::Succeeded;&#125;\n\n33. BehaviorTree Service情景：\n\n利用前面AIPerceptionComponent，设置新的目标Actor\n以通过AIPerceptionComponent获得新目标，设置黑板组件为例\n\n示例：\n\n定义：\n12345678910111213141516171819202122232425#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;BehaviorTree/BTService.h&quot;#include &quot;STUFindEnemyBTService.generated.h&quot;struct FBlackboardKeySelector;UCLASS()class B_01_TPS_API USTUFindEnemyBTService : public UBTService&#123;\tGENERATED_BODY()public:\tUSTUFindEnemyBTService();protected:\tvirtual void TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;/* My Code */\t// Propertyprivate:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;AI&quot;, meta=(AllowPrivateAccess=true))\tFBlackboardKeySelector EnemyActorKey;&#125;;\n\n\n\n实现：\n1234567891011121314151617181920212223242526272829#include &quot;STUFindEnemyBTService.h&quot;#include &quot;AIController.h&quot;#include &quot;BehaviorTree/BlackboardComponent.h&quot;#include &quot;B_01_TPS/Component/STUAIPerceptionComponent.h&quot;#include &quot;B_01_TPS/Dev/STUUtils.h&quot;USTUFindEnemyBTService::USTUFindEnemyBTService()&#123;\tNodeName = &quot;Find Enemy&quot;;&#125;void USTUFindEnemyBTService::TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds)&#123;\tSuper::TickNode(OwnerComp, NodeMemory, DeltaSeconds);    // 获得 黑板 和 AIController\tconst auto BlackBoard = OwnerComp.GetBlackboardComponent();\tif (!BlackBoard)&#123;return;&#125;\tconst auto Controller = OwnerComp.GetAIOwner();    // 获得 PerceptionComponent\tif (!Controller)&#123;return;&#125;\tconst auto PerceptionComponent = STUUtils::GetSTUPlayerComponent&lt;USTUAIPerceptionComponent&gt;(Controller);    // 从 PerceptionComponent 得到新的 Actort 设置到 黑板 的 key值\tif (!PerceptionComponent)&#123;return;&#125;\tBlackBoard-&gt;SetValueAsObject(EnemyActorKey.SelectedKeyName, PerceptionComponent-&gt;GetClosetEnemy());&#125;\n\n34. HUD生成Widget情景：\n\n设置自己的HUD生成指定Widget\n\n示例：\n\n定义：\n1234567891011121314151617181920#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/HUD.h&quot;#include &quot;STUGameHUD.generated.h&quot;UCLASS()class B_01_TPS_API ASTUGameHUD : public AHUD&#123;\tGENERATED_BODY()protected:\tvirtual void BeginPlay() override;\t/* My Code */\t// Functionpublic:\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;UI&quot;, meta=(AllowPrivateAccess=true))\tTSubclassOf&lt;UUserWidget&gt; PlayerHUDWidgetClass;&#125;;\n\n\n\n实现：\n12345678910111213#include &quot;STUGameHUD.h&quot;#include &quot;Blueprint/UserWidget.h&quot;#include &quot;Engine/Canvas.h&quot;void ASTUGameHUD::BeginPlay()&#123;\tSuper::BeginPlay();\tconst auto PlayerHUDWidget = CreateWidget&lt;UUserWidget&gt;(GetWorld(), PlayerHUDWidgetClass);\tif (!PlayerHUDWidget)&#123;return;&#125;\tPlayerHUDWidget-&gt;AddToViewport();&#125;\n\n35. HUD绘制准星情景：\n\n直接通过HUD生成静态准星\n\n示例：\n\n定义：\n1234567891011121314151617#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/HUD.h&quot;#include &quot;STUGameHUD.generated.h&quot;UCLASS()class B_01_TPS_API ASTUGameHUD : public AHUD&#123;\tGENERATED_BODY()protected:\tvirtual void DrawHUD() override;public:\tUFUNCTION()\tvoid DrawCrossHair();&#125;;\n\n\n\n实现：\n123456789101112131415161718192021222324252627282930313233#include &quot;STUGameHUD.h&quot;#include &quot;Blueprint/UserWidget.h&quot;#include &quot;Engine/Canvas.h&quot;void ASTUGameHUD::DrawHUD()&#123;\tSuper::DrawHUD();\tDrawCrossHair();&#125;void ASTUGameHUD::DrawCrossHair()&#123;\tconst TInterval&lt;float&gt; Center(Canvas-&gt;SizeX * 0.5f, Canvas-&gt;SizeY * 0.5f);\tconstexpr float HalfLineSize = 10.f;\tconstexpr float LineThickness = 2.f;\tconst FColor LineColor = FColor::Green;\tDrawLine(\t\tCenter.Min - HalfLineSize,\t\tCenter.Max,\t\tCenter.Min + HalfLineSize,\t\tCenter.Max,\t\tLineColor,\t\tLineThickness);\tDrawLine(\t\tCenter.Min,\t\tCenter.Max - HalfLineSize,\t\tCenter.Min,\t\tCenter.Max + HalfLineSize,\t\tLineColor,\t\tLineThickness);&#125;\n\n36. Widget创建蓝图可用函数情景：\n\nC++创建的Widget\n创建蓝图可调用函数\n\n示例：\n\n定义：\n1234567891011121314151617UCLASS()class B_01_TPS_API USTUPlayerHUDWidget : public UUserWidget&#123;\tGENERATED_BODY()/* My Code */\t// Functionpublic:\tUFUNCTION(BlueprintCallable)\tfloat GetHealthPercent() const;\tUFUNCTION(BlueprintCallable)\tbool IsPlayerAlive() const;\tUFUNCTION(BlueprintCallable)\tbool IsPlayerSpectating() const;&#125;;\n\n\n\n实现：\n1234567891011121314151617181920212223#include &quot;STUPlayerHUDWidget.h&quot;#include &quot;B_01_TPS/Dev/STUUtils.h&quot;#include &quot;B_01_TPS/Component/STUHealthActorComponent.h&quot;#include &quot;B_01_TPS/Component/STUWeaponActorComponent.h&quot;float USTUPlayerHUDWidget::GetHealthPercent() const&#123;\tconst auto HealthComp = STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(GetOwningPlayerPawn());\tif (!HealthComp)&#123;return 0.f;&#125;\treturn HealthComp-&gt;GetHPPercent();&#125;bool USTUPlayerHUDWidget::IsPlayerSpectating() const&#123;\tconst auto Controller = GetOwningPlayer();\treturn Controller &amp;&amp; Controller-&gt;GetStateName() == NAME_Spectating;&#125;bool USTUPlayerHUDWidget::IsPlayerAlive() const&#123;\tconst auto HealthComp = STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(GetOwningPlayerPawn());\treturn HealthComp &amp;&amp; !HealthComp-&gt;IsDead();&#125;\n\n37. UPROPERTY()情景：\n\n\n\n\n\n\n\n\n\nprivate：需要在蓝图中可读可写，任意处编辑\n\nUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\n\n\n\n\n\n\n\n\n\n以 bool IsTrue;为判断标准，为false时，编辑器处为不可编辑状态\n\nUPROPERTY(EditAnywhere, meta&#x3D;(EditCondition&#x3D;”IsTrue”))\n\n\n\n\n\n\n\n\n\n\nfloat HP;为例，在编辑器中设置的值要符合一个固定的范围\n\nUPROPERTY(EditAnywhere, meta&#x3D;(ClampMin&#x3D;0, ClampMax&#x3D;100))\n\n38. check-checkf-checkNoEntry情景：\n\n需要在BeginPlay()检测组件是否有效\ncheck(GetMesh());：如果GetMesh()无效，程序会中断\n\n还需要通过条件判断是否有效，同时打印指定语句到日志\n\n以float HP;为例，默认BeginPlay()时，HP应该大于0\ncheckf(HP &gt; 0.f, TEXT(&quot;HP Shound Great 0&quot;));\n\n应用于不可到达的代码片段，当出现不应该出现的情况时，程序中断\n1234567891011void Function(AActor* Actor)&#123;    if (Actor)    &#123;        ....    &#125;    else    &#123;        checkNoEntry();    &#125;&#125;\n\n","slug":"7_UE4功能整理_09","date":"2022-10-06T07:28:25.960Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"cde83abaa86ff43674449a34230233bc","title":"UE4 反射编程","content":"UE4 反射编程[toc]\n1. 准备工作\n新建空白ue4 cpp项目：Reflective\n\n打开ReflectiveGameModeBase.h\n123456789101112#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/GameModeBase.h&quot;#include &quot;ReflectiveGameModeBase.generated.h&quot;UCLASS()class REFLECTIVE_API ReflectiveGameModeBase : public AGameModeBase&#123;\tGENERATED_UCLASS_BODY()\t&#125;;\n\n修改ReflectiveGameModeBase.cpp，创建构造函数\n12345678#include &quot;ReflectiveGameModeBase.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Reflection Succeed\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Hello Reflective ]&quot;));&#125;\n\n编译运行：\n1LogTemp: [ Hello Reflective ]\n\n2. 获取类名\n创建UE4 None类型 cpp文件：Student\n\nStudent.h\n12345678910#pragma once#include &quot;CoreMinimal.h&quot;class REFLECTIVE_API Student&#123;public:\tStudent();    ~Student();&#125;\n\nStudent.cpp\n123456789#include &quot;Student.h&quot;Student::Student()&#123;&#125;Student::~Student()&#123;&#125;\n\n需要进行修改，才能拥有虚幻的反射功能\n\nStudent.h\n12345678910111213#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Student.generated.h&quot; // 1. #include &quot;文件名.generated.h&quot;UCLASS() // 2. UCLASS() 是虚幻提供的类反射class REFLECTIVE_API UStudent : public UObject // 3. 需要继承UObject才能使用UCALSS(), 类名前面要加U&#123;\tGENERATED_BODY() // 4. 要加入 GENERATED_BODY()public:\tUStudent(); // 5. 类名前要统一加U    // 6. 因为继承UObject，不需要考虑垃圾回收，~Student()不需要&#125;;\n\nStudent.cpp\n1234567#include &quot;Student.h&quot;UStudent::UStudent() // 1. 类名前加 U&#123;&#125;// 2. 不需要 Student::~Student()&#123;&#125;\n\n开始获取类型\n\nReflectiveGameModeBase.cpp\n12345678910111213#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Get Class Name By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Name ]&quot;));\tUStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();\tconst FName StudentName = StudentClass-&gt;GetFName();\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Name: %s --&gt;&quot;), *StudentName.ToString());&#125;\n\n打印结果：\n12LogTemp: [ Get Class Name ]LogTemp: Warning: &lt;-- Class Name: Student --&gt;\n\n3. 获取类标签\nStudent.h\n123456789101112#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Student.generated.h&quot;UCLASS(BlueprintType) // 此次填入 BlueprintTypeclass REFLECTIVE_API UStudent : public UObject&#123;\tGENERATED_BODY()public:\tUStudent();&#125;;\n\nReflectiveGameModeBase.cpp\n12345678910111213141516#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;    UStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();\tconst FName StudentName = StudentClass-&gt;GetFName();\t// Get Class Flags By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Flags ]&quot;));\tEClassFlags StudentClassFlags = StudentClass-&gt;ClassFlags;\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Name: %s, Class Flags: %x --&gt;&quot;),\t\t*StudentName.ToString(), StudentClassFlags);&#125;\n\n打印结果\n12LogTemp: [ Get Class Flags ]LogTemp: Warning: &lt;-- Class Name: Student, Class Flags: 305000a0 --&gt;\n\n4. 获取类属性\nStudent.h\n12345678910111213141516171819#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Student.generated.h&quot;UCLASS(BlueprintType)class REFLECTIVE_API UStudent : public UObject&#123;\tGENERATED_BODY()public:\tUStudent();    private: // 添加属性，要加入UPROPERTY()，否则无法参与反射\tUPROPERTY()\tFString Name;\tUPROPERTY()\tFString Country;&#125;;\n\nStudent.cpp\n1234567#include &quot;Student.h&quot;UStudent::UStudent()&#123;\tName = &quot;FHang&quot;;\tCountry = &quot;China&quot;;&#125;\n\nReflectiveGameModeBase.cpp\n1234567891011121314151617181920212223242526#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;    UStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();\t// Get Class Property Value By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Property Value ]&quot;))\tfor (FProperty *Property = StudentClass-&gt;PropertyLink; Property; Property = Property-&gt;PropertyLinkNext)\t&#123;\t\tFString PropertyName = Property-&gt;GetName();\t\tFString PropertyType = Property-&gt;GetCPPType();\t\t\t\tif (PropertyType == &quot;FString&quot;)\t\t&#123;\t\t\tconst FStrProperty *StringProperty = CastField&lt;FStrProperty&gt;(Property);\t\t\tvoid *Address = StringProperty-&gt;ContainerPtrToValuePtr&lt;void&gt;(Student);\t\t\tFString PropertyValue = StringProperty-&gt;GetPropertyValue(Address);\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Property: %s, Type: %s, Value: %s--&gt;&quot;),\t\t\t\t*PropertyName, *PropertyType, *PropertyValue);\t\t&#125;\t&#125;&#125;\n\n打印结果：\n123LogTemp: [ Get Class Property Value ]LogTemp: Warning: &lt;-- Class Property: Name, Type: FString, Value: FHang --&gt;LogTemp: Warning: &lt;-- Class Property: Country, Type: FString, Value: China --&gt;\n\n5. 获取类属性元数据\nStudent.h\n12345678910111213141516171819#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Student.generated.h&quot;UCLASS(BlueprintType)class REFLECTIVE_API UStudent : public UObject&#123;\tGENERATED_BODY()public:\tUStudent();    private:\tUPROPERTY(VisibleAnywhere, Category=&quot;Info&quot;) // 添加元数据\tFString Name;\tUPROPERTY()\tFString Country;&#125;;\n\nReflectiveGameModeBase.cpp\n1234567891011121314151617181920212223242526#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;    UStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();\t// Get Class Property Value By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Property Value ]&quot;))\tfor (FProperty *Property = StudentClass-&gt;PropertyLink; Property; Property = Property-&gt;PropertyLinkNext)\t&#123;        // Get Class Property Meta By Reflection\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Property Meta ]&quot;))\t\tFString PropertyMeta = Property-&gt;GetMetaData(TEXT(&quot;Category&quot;));\t\t\t\tif (PropertyType == &quot;FString&quot;)\t\t&#123;\t\t\tconst FStrProperty *StringProperty = CastField&lt;FStrProperty&gt;(Property);\t\t\tvoid *Address = StringProperty-&gt;ContainerPtrToValuePtr&lt;void&gt;(Student);\t\t\tFString PropertyValue = StringProperty-&gt;GetPropertyValue(Address);\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Property Meta: %s --&gt;&quot;), *PropertyMeta);\t\t&#125;\t&#125;&#125;\n\n打印结果：\n1234LogTemp: [ Get Class Property Value ]LogTemp: [ Get Class Property Meta ]LogTemp: Warning: &lt;-- Class Property Meta: Info --&gt;LogTemp: Warning: &lt;-- Class Property Meta:  --&gt;\n\n6. 设置类属性值\nReflectiveGameModeBase.cpp\n123456789101112131415161718192021222324252627282930313233#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;    UStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();\t// Get Class Property Value By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Property Value ]&quot;))\tfor (FProperty *Property = StudentClass-&gt;PropertyLink; Property; Property = Property-&gt;PropertyLinkNext)\t&#123;\t\tFString PropertyName = Property-&gt;GetName();\t\tFString PropertyType = Property-&gt;GetCPPType();\t\t\t\tif (PropertyType == &quot;FString&quot;)\t\t&#123;\t\t\tconst FStrProperty *StringProperty = CastField&lt;FStrProperty&gt;(Property);\t\t\tvoid *Address = StringProperty-&gt;ContainerPtrToValuePtr&lt;void&gt;(Student);\t\t\tFString PropertyValue = StringProperty-&gt;GetPropertyValue(Address);\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Property: %s, Type: %s, Value: %s --&gt;&quot;),\t\t\t\t*PropertyName, *PropertyType, *PropertyValue);\t\t\t\t\t\t// Set Class Property Value By Reflection\t\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Set Class Property Value ]&quot;))\t\t\tStringProperty-&gt;SetPropertyValue(Address, &quot;XXXX&quot;);\t\t\tFString NewStringProperty = StringProperty-&gt;GetPropertyValue(Address);\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Property: %s, Type: %s, Value: %s --&gt;&quot;),\t\t\t\t*PropertyName, *PropertyType, *NewStringProperty);\t\t&#125;\t&#125;&#125;\n\n打印结果：\n1234567LogTemp: [ Get Class Property Value ]LogTemp: Warning: &lt;-- Class Property: Name, Type: FString, Value: FHang --&gt;LogTemp: [ Set Class Property Value ]LogTemp: Warning: &lt;-- Class Property: Name, Type: FString, Value: XXXX --&gt;LogTemp: Warning: &lt;-- Class Property: Country, Type: FString, Value: China --&gt;LogTemp: [ Set Class Property Value ]LogTemp: Warning: &lt;-- Class Property: Country, Type: FString, Value: XXXX --&gt;\n\n7. 获得类函数名\nStudent.h\n1234567891011121314151617181920212223242526#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Student.generated.h&quot;UCLASS(BlueprintType)class REFLECTIVE_API UStudent : public UObject&#123;\tGENERATED_BODY()public:\tUStudent();private:\tUPROPERTY(VisibleAnywhere, Category=&quot;Info&quot;)\tFString Name;\tUPROPERTY()\tFString Country;public:\tUFUNCTION(BlueprintCallable)\tvoid Study()&#123;&#125;;\tUFUNCTION()\tvoid Demo01(int a, bool isA)&#123;&#125;;&#125;;\n\nReflectiveGameModeBase.cpp\n12345678910111213141516171819202122#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;    UStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();    const FName StudentName = StudentClass-&gt;GetFName();\t    // Get Class Function Name By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function ]&quot;));\tfor (TFieldIterator&lt;UFunction&gt; IteratorOfFunction(StudentClass); IteratorOfFunction; ++IteratorOfFunction)\t&#123;\t\tconst UFunction *Function = *IteratorOfFunction;\t\tFString FunctionName = Function-&gt;GetName();\t\tif (FunctionName == &quot;ExecuteUbergraph&quot;)&#123;continue;&#125;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class: %s, Function: %s --&gt;&quot;), *StudentName.ToString(),\t\t\t*FunctionName);    &#125;&#125;\n\n打印结果：\n123LogTemp: [ Get Class Function ]LogTemp: Warning: &lt;-- Class: Student, Function: Study --&gt;LogTemp: Warning: &lt;-- Class: Student, Function: Demo01 --&gt;\n\n8. 获取类函数标签\nReflectiveGameModeBase.cpp\n12345678910111213141516171819202122232425#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;    UStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();    const FName StudentName = StudentClass-&gt;GetFName();\t    // Get Class Function Name By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function ]&quot;));\tfor (TFieldIterator&lt;UFunction&gt; IteratorOfFunction(StudentClass); IteratorOfFunction; ++IteratorOfFunction)\t&#123;\t\tconst UFunction *Function = *IteratorOfFunction;\t\tFString FunctionName = Function-&gt;GetName();\t\tif (FunctionName == &quot;ExecuteUbergraph&quot;)&#123;continue;&#125;        \t\t        // Get Class Function Flags\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function Flags ]&quot;))\t\tEFunctionFlags FunctionFlags = Function-&gt;FunctionFlags;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class: %s, Function: %s, Flags: %x --&gt;&quot;), *StudentName.ToString(),\t\t\t*FunctionName, FunctionFlags);    &#125;&#125;\n\n打印结果：\n12345LogTemp: [ Get Class Function ]LogTemp: [ Get Class Function Flags ]LogTemp: Warning: &lt;-- Class: Student, Function: Study, Flags: 4020401 --&gt;LogTemp: [ Get Class Function Flags ]LogTemp: Warning: &lt;-- Class: Student, Function: Demo01, Flags: 20401 --&gt;\n\n9. 获取类函数参数\nReflectiveGameModeBase.cpp\n1234567891011121314151617181920212223242526272829#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;    UStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();\t    // Get Class Function Name By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function ]&quot;));\tfor (TFieldIterator&lt;UFunction&gt; IteratorOfFunction(StudentClass); IteratorOfFunction; ++IteratorOfFunction)\t&#123;\t\tconst UFunction *Function = *IteratorOfFunction;\t\tFString FunctionName = Function-&gt;GetName();\t\tif (FunctionName == &quot;ExecuteUbergraph&quot;)&#123;continue;&#125;        \t\t        // Get Class Function Params By Reflection\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Function Params ]&quot;));\t\tfor (TFieldIterator&lt;FProperty&gt; IteratorOfParams(Function); IteratorOfParams; ++IteratorOfParams)\t\t&#123;\t\t\tconst FProperty *Param = *IteratorOfParams;\t\t\tFString ParamType = Param-&gt;GetCPPType();\t\t\tFString ParamName = Param-&gt;GetName();\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Function: %s, ParamType: %s, ParamName: %s --&gt;&quot;),\t\t\t\t*FunctionName, *ParamType, *ParamName);\t\t&#125;    &#125;&#125;\n\n打印结果：\n1234LogTemp: [ Get Class Function ]LogTemp: [ Get Function Params ]LogTemp: Warning: &lt;-- Function: Demo01, ParamType: int32, ParamName: a --&gt;LogTemp: Warning: &lt;-- Function: Demo01, ParamType: bool, ParamName: isA --&gt;\n\n10. 获取类函数参数标签\nReflectiveGameModeBase.cpp\n12345678910111213141516171819202122232425262728293031#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;    UStudent *Student = NewObject&lt;UStudent&gt;();\tconst UClass *StudentClass = Student-&gt;GetClass();\t    // Get Class Function Name By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function ]&quot;));\tfor (TFieldIterator&lt;UFunction&gt; IteratorOfFunction(StudentClass); IteratorOfFunction; ++IteratorOfFunction)\t&#123;\t\tconst UFunction *Function = *IteratorOfFunction;\t\tFString FunctionName = Function-&gt;GetName();\t\tif (FunctionName == &quot;ExecuteUbergraph&quot;)&#123;continue;&#125;        \t\t        // Get Class Function Params By Reflection\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Function Params ]&quot;));\t\tfor (TFieldIterator&lt;FProperty&gt; IteratorOfParams(Function); IteratorOfParams; ++IteratorOfParams)\t\t&#123;\t\t\tconst FProperty *Param = *IteratorOfParams;            // Get Function Params Flags By Reflection\t\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Params Flags ]&quot;));\t\t\tEPropertyFlags ParamFlag = Param-&gt;GetPropertyFlags();\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Function: %s, Flags: %x --&gt;&quot;),\t\t\t\t*FunctionName, ParamFlag);\t\t&#125;    &#125;&#125;\n\n打印结果：\n123456LogTemp: [ Get Class Function ]LogTemp: [ Get Function Params ]LogTemp: [ Get Params Flags ]LogTemp: Warning: &lt;-- Function: Demo01, ParamType: int32, ParamName: a, Flags: 40000280 --&gt;LogTemp: [ Get Params Flags ]LogTemp: Warning: &lt;-- Function: Demo01, ParamType: bool, ParamName: isA, Flags: 40000280 --&gt;\n\n11. 获取父类\n新建Student子类SubStudent\n\nReflectiveGameModeBase.cpp\n1234567891011121314#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;SubStudent.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Get SubClass FatherClass By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get FatherClass ]&quot;));\tconst USubStudent *SubStudent = NewObject&lt;USubStudent&gt;();\tconst UClass *FatherClass = SubStudent-&gt;GetClass()-&gt;GetSuperClass();\tconst FString SubClassName = SubStudent-&gt;GetClass()-&gt;GetName();\tconst FString FatherClassName = FatherClass-&gt;GetName();\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SubClass: %s, SuperClass: %s --&gt;&quot;), *SubClassName, *FatherClassName);&#125;\n\n打印结果：\n12LogTemp: [ Get FatherClass ]LogTemp: Warning: &lt;-- SubClass: SubStudent, SuperClass: Student --&gt;\n\n12. 判断是否是子类\nReflectiveGameModeBase.cpp\n1234567891011121314151617181920212223#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;#include &quot;SubStudent.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Determine if the current class is a subclass of another class By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Determine Is SubClass ]&quot;));\tconst UClass *Class1 = UStudent::StaticClass();\tconst UClass *Class2 = USubStudent::StaticClass();\tconst UClass *Class3 = AActor::StaticClass();\tif (Class2-&gt;IsChildOf(Class1))\t&#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s Is %s SubClass --&gt;&quot;), \t\t\t*Class2-&gt;GetName(), *Class1-&gt;GetName());\t&#125;\tif (!Class3-&gt;IsChildOf(Class1))\t&#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s Is Not %s SubClass --&gt;&quot;),\t\t\t*Class3-&gt;GetName(), *Class1-&gt;GetName());\t&#125;&#125;\n\n打印结果：\n123LogTemp: [ Determine Is SubClass ]LogTemp: Warning: &lt;-- SubStudent Is Student SubClass --&gt;LogTemp: Warning: &lt;-- Actor Is Not Student SubClass --&gt;\n\n13. 查找类的所有子类\n新建Student子类Sub1Student\n\nReflectiveGameModeBase.cpp\n12345678910111213141516171819#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\tconst *NewStudent = NewObject&lt;UStudent&gt;();\tconst UClass *FatherClass = NewStudent-&gt;GetClass();\t\t// Find Current Class All Of SubClass By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Current Class All Of SubClass ]&quot;));\tTArray&lt;UClass*&gt; ClassArray;\tGetDerivedClasses(FatherClass, ClassArray, false);\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SuperClass: %s --&gt;&quot;), *FatherClassName);\tfor (const auto &amp;Elem : ClassArray)\t&#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SubClass: %s --&gt;&quot;), *Elem-&gt;GetName());\t&#125;&#125;\n\n打印结果：\n1234LogTemp: [ Get Current Class All Of SubClass ]LogTemp: Warning: &lt;-- SuperClass: Student --&gt;LogTemp: Warning: &lt;-- SubClass: Sub1Student --&gt;LogTemp: Warning: &lt;-- SubClass: SubStudent --&gt;\n\n14. 查找类生成的所有对象\nReflectiveGameModeBase.cpp\n123456789101112131415161718#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;Sub1Student.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Get Current Class Generated Objects By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Current Class Generated Objects ]&quot;));\tTArray&lt;UObject*&gt; ObjectsArray;\tUSub1Student *Sub1Student = NewObject&lt;USub1Student&gt;(this, FName(&quot;Sub1Student&quot;));\tUSub1Student *Sub1 = NewObject&lt;USub1Student&gt;(this, FName(&quot;Sub1&quot;));\tGetObjectsOfClass(USub1Student::StaticClass(), ObjectsArray, false);\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Current Class: %s --&gt;&quot;), *Sub1Student-&gt;GetName());\tfor (const auto &amp;Elem : ObjectsArray)\t&#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Object: %s --&gt;&quot;), *Elem-&gt;GetName());\t&#125;&#125;\n\n打印结果：\n1234LogTemp: [ Get Current Class Generated Objects ]LogTemp: Warning: &lt;-- Current Class: Sub1Student --&gt;LogTemp: Warning: &lt;-- Object: Sub1Student --&gt;LogTemp: Warning: &lt;-- Object: Sub1 --&gt;\n\n15. 通过字符串查找类\nReflectiveGameModeBase.cpp\n12345678910111213#include &quot;ReflectiveGameModeBase.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Use String Find Class By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Class ]&quot;));\tUClass *FindedClass = FindObject&lt;UClass&gt;(ANY_PACKAGE, *FString(&quot;Student&quot;), true);\tif (FindedClass)\t&#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Find %s Succeed --&gt;&quot;), *FindedClass-&gt;GetName());\t&#125;&#125;\n\n打印结果：\n12LogTemp: [ Use String Find Class ]LogTemp: Warning: &lt;-- Find Student Succeed --&gt;\n\n16. 通过字符查找枚举\nStudent.h中定义EStudentType枚举\n123456789101112131415161718192021222324252627282930313233#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Student.generated.h&quot;UENUM()enum class EStudentType : uint8&#123;\tE_GOOD UMETA(DisplayName = &quot;GOOD&quot;),\tE_BAD UMETA(DisplayName = &quot;BAD&quot;)&#125;;UCLASS(BlueprintType)class REFLECTIVE_API UStudent : public UObject&#123;\tGENERATED_BODY()public:\tUStudent();private:\tUPROPERTY(VisibleAnywhere, Category=&quot;Info&quot;)\tFString Name;\tUPROPERTY()\tFString Country;public:\tUFUNCTION(BlueprintCallable)\tvoid Study()&#123;&#125;;\tUFUNCTION()\tvoid Demo01(int a, bool isA)&#123;&#125;;&#125;;\n\nReflectiveGameModeBase.cpp\n12345678910111213#include &quot;ReflectiveGameModeBase.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Use String Find Enum By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Enum ]&quot;));\tUEnum *FindedEnum = FindObject&lt;UEnum&gt;(ANY_PACKAGE, *FString(&quot;EStudentType&quot;), true);\tif (FindedEnum)\t&#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Find %s Succeed --&gt;&quot;), *FindedEnum-&gt;GetName());\t&#125;&#125;\n\n打印结果：\n12LogTemp: [ Use String Find Enum ]LogTemp: Warning: &lt;-- Find EStudentType Succeed --&gt;\n\n17. 获得枚举的所有项\nReflectiveGameModeBase.cpp\n12345678910111213141516171819#include &quot;ReflectiveGameModeBase.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Use String Find Enum By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Enum ]&quot;));\tUEnum *FindedEnum = FindObject&lt;UEnum&gt;(ANY_PACKAGE, *FString(&quot;EStudentType&quot;), true);\tif (FindedEnum)\t&#123;        \t\t        // Get Current Enum All Of Elements By Reflection\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Current Enum All Of Elements ]&quot;));\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Enum: %s --&gt;&quot;), *FindedEnum-&gt;GetName());\t\tfor (int8 Index = 0; Index &lt; FindedEnum-&gt;NumEnums(); ++Index)\t\t&#123;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;Elem: %s&quot;), *FindedEnum-&gt;GetNameStringByIndex(Index));\t\t&#125;\t&#125;&#125;\n\n打印结果：\n12345LogTemp: [ Get Current Enum All Of Elements ]LogTemp: Warning: &lt;-- Enum: EStudentType --&gt;LogTemp: Warning: Elem: E_GOODLogTemp: Warning: Elem: E_BADLogTemp: Warning: Elem: E_MAX\n\n18. 通过字符串查找蓝图类\nReflectiveGameModeBase.cpp\n12345678910111213#include &quot;ReflectiveGameModeBase.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Use String Find Blueprint Class\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Blueprint Class ]&quot;));\tUBlueprint *FindedBlueprint = FindObject&lt;UBlueprint&gt;(ANY_PACKAGE, *FString(&quot;BP_Student&quot;));\tif (FindedBlueprint)\t&#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Find %s Succeed --&gt;&quot;), *FindedBlueprint-&gt;GetName());\t&#125;&#125;\n\n打印结果：\n12LogTemp: [ Use String Find Blueprint Class ]LogTemp: &lt;-- Find BP_Student Succeed --&gt;\n\n19. 判断蓝图是否是Native\n在UE中通过Student.cpp类新建BP_Student蓝图类\n\nReflectiveGameModeBase.cpp\n12345678910111213141516171819202122#include &quot;ReflectiveGameModeBase.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Use String Find Blueprint Class\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Blueprint Class ]&quot;));\tUBlueprint *FindedBlueprint = FindObject&lt;UBlueprint&gt;(ANY_PACKAGE, *FString(&quot;BP_Student&quot;));\tif (FindedBlueprint)\t&#123;\t\t// Determine Is BlueprintClass Or Native(Cpp) Class By Reflection\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Determine Is BlueprintClass Or Native ]&quot;));\t\tif (!FindedBlueprint-&gt;IsNative())\t\t&#123;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s Is Blueprint Class --&gt;&quot;), *FindedBlueprint-&gt;GetName());\t\t&#125;\t\telse\t\t&#123;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s Is Native Class --&gt;&quot;), *FindedBlueprint-&gt;GetName());\t\t&#125;\t&#125;&#125;\n\n打印结果：\n123LogTemp: [ Use String Find Blueprint Class ]LogTemp: [ Determine Is BlueprintClass Or Native ]LogTemp: &lt;-- BP_Student Is Blueprint Class --&gt;\n\n20. 获取所有类\nReflectiveGameModeBase.cpp\n12345678910111213141516171819#include &quot;ReflectiveGameModeBase.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Get All Class By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get All Class ]&quot;));\tTArray&lt;FString&gt; AllClassNames;\tfor (TObjectIterator&lt;UClass&gt; ClassIt; ClassIt; ++ClassIt)\t&#123;\t\tFString ClassName = ClassIt-&gt;GetName();\t\tAllClassNames.Emplace(ClassName);\t&#125;\tfor (const auto &amp;Elem : AllClassNames)\t&#123;\t\tif (Elem == &quot;Student&quot;)\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s --&gt;&quot;), *Elem);\t&#125;&#125;\n\n打印结果：\n12LogTemp: [ Get All Class ]LogTemp: Warning: &lt;-- Student --&gt;\n\n21. 通过字符串查找类函数\nSubStudent.h定义函数\n123456789101112131415161718#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Student.h&quot;#include &quot;SubStudent.generated.h&quot;UCLASS()class REFLECTIVE_API USubStudent : public UStudent&#123;\tGENERATED_BODY()public:\tUFUNCTION()\tvoid PlayGame(FString GameName);\tUFUNCTION()\tint IsBoy();&#125;;\n\nSubStudent.cpp实现函数\n123456789101112#include &quot;SubStudent.h&quot;void USubStudent::PlayGame(FString GameName)&#123;\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SubStudent::PlayGame(FString)&gt;&gt; Play %s --&gt;&quot;), *GameName);&#125;int USubStudent::IsBoy()&#123;\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SubStudent::IsBoy&gt;&gt; Is Boy --&gt;&quot;));\treturn 1;&#125;\n\nReflectiveGameModeBase.cpp\n1234567891011121314151617181920#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;USubStudent.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Use String Find Class Function By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Class Function ]&quot;));\tUSubStudent *SubStudent01 = NewObject&lt;USubStudent&gt;();\tif (UClass *SubStudent01Class = SubStudent01-&gt;GetClass())\t&#123;\t\tUFunction *SubStudent01Function = SubStudent01Class-&gt;FindFunctionByName(\t\t\tTEXT(&quot;PlayGame&quot;), EIncludeSuperFlag::ExcludeSuper);\t\tif (SubStudent01Function)\t\t&#123;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class: %s, Function: %s --&gt;&quot;),\t\t\t\t*SubStudent01-&gt;GetClass()-&gt;GetName(), *SubStudent01Function-&gt;GetName());\t\t&#125;    &#125;&#125;\n\n打印结果：\n12LogTemp: [ Use String Find Class Function ]LogTemp: Warning: &lt;-- Class: SubStudent, Function: PlayGame --&gt;\n\n22. ProcessEvent调用类函数\nReflectiveGameModeBase.cpp\n12345678910111213141516171819202122232425262728293031323334353637#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;USubStudent.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Use String Find Class Function By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Class Function ]&quot;));\tUSubStudent *SubStudent01 = NewObject&lt;USubStudent&gt;();\tif (UClass *SubStudent01Class = SubStudent01-&gt;GetClass())\t&#123;\t\tUFunction *SubStudent01Function = SubStudent01Class-&gt;FindFunctionByName(\t\t\tTEXT(&quot;PlayGame&quot;), EIncludeSuperFlag::ExcludeSuper);\t\tif (!SubStudent01Function)&#123;break;&#125;        \t\t// ProcessEvent Transfer Class Function By Reflection\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ ProcessEvent Transfer Class Function ]&quot;));        \t\t// 1.Allocate Space For Parameters\t\tuint16 *AllParamMemory = static_cast&lt;uint16*&gt;FMemory_Alloca(SubStudent01Function-&gt;ParmsSize);\t\tFMemory::Memzero(AllParamMemory, SubStudent01Function-&gt;ParmsSize);\t\t\t\t// 2.Parameter assignment\t\tfor (TFieldIterator&lt;FProperty&gt; IteratorOfParams(SubStudent01Function); IteratorOfParams; ++IteratorOfParams)\t\t&#123;\t\t\tconst FProperty *Param = *IteratorOfParams;\t\t\tFString ParamName = Param-&gt;GetName();\t\t\tif (ParamName == FString(&quot;GameName&quot;))\t\t\t&#123;\t\t\t\t*Param-&gt;ContainerPtrToValuePtr&lt;FString&gt;(AllParamMemory) = &quot;CSGO&quot;;\t\t\t&#125;\t\t&#125;        \t\t        // 3.Call Function(Method)\t\tSubStudent01-&gt;ProcessEvent(SubStudent01Function, AllParamMemory);    &#125;&#125;\n\n打印结果：\n123LogTemp: [ Use String Find Class Function ]LogTemp: [ ProcessEvent Transfer Class Function ]LogTemp: Warning: &lt;-- SubStudent::PlayGame(FString)&gt;&gt; Play CSGO --&gt;\n\n23. Invoke调用类函数\nReflectiveGameModeBase.cpp\n12345678910111213141516171819202122232425262728293031323334#include &quot;ReflectiveGameModeBase.h&quot;#include &quot;USubStudent.h&quot;ReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\t:AGameModeBase(ObjectInitializer)&#123;\t// Use String Find Class Function By Reflection\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Class Function ]&quot;));\tUSubStudent *SubStudent01 = NewObject&lt;USubStudent&gt;();\tif (UClass *SubStudent01Class = SubStudent01-&gt;GetClass())\t&#123;   \t\t// \tInvoke Transfer Class Function By Reflection\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Invoke Transfer Class Function ]&quot;));\t\tif (UFunction *SubStudent02Function = SubStudent01Class-&gt;FindFunctionByName(\t\t\tTEXT(&quot;IsBoy&quot;), EIncludeSuperFlag::ExcludeSuper))\t\t&#123;\t\t\t// 1.Allocate Space For Parameters\t\t\tuint16 *AllParamMemory02 = static_cast&lt;uint16*&gt;FMemory_Alloca(SubStudent02Function-&gt;ParmsSize);\t\t\tFMemory::Memzero(AllParamMemory02, SubStudent02Function-&gt;ParmsSize);\t\t\t// 2.Create FFrame\t\t\tFFrame Frame(nullptr, SubStudent02Function, &amp;AllParamMemory02);\t\t\t// 3.Invoke Function\t\t\tSubStudent02Function-&gt;Invoke(SubStudent02Function, Frame,\t\t\t\t&amp;AllParamMemory02 + SubStudent02Function-&gt;ReturnValueOffset);\t\t\t// 4. Get Function Return Value\t\t\tint *ReturnValue = reinterpret_cast&lt;int*&gt;(&amp;AllParamMemory02 + SubStudent02Function-&gt;ReturnValueOffset);\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Return Value: %d --&gt;&quot;), *ReturnValue);\t\t&#125;    &#125;&#125;\n\n打印结果：\n123LogTemp: [ Invoke Transfer Class Function ]LogTemp: Warning: &lt;-- SubStudent::IsBoy&gt;&gt; Is Boy --&gt;LogTemp: Warning: &lt;-- Return Value: 1 --&gt;\n\n","slug":"7_UE4反射编程_08","date":"2022-10-06T07:28:25.958Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"c7d8b276a0f55310d3a5259cec001a89","title":"UE4初始设置及个人使用崩溃记录","content":"[toc]\n日志：txt1.第一次记录：2020.2.05 版本：4.24.2UnrealEngine的初始设置1.在Epic中下载UnrealEngine4之后1-1. 首先：启动-选项\n1-2. 接着\t：（勾选）输入调试用符号-应用以后出现新的崩溃问题，方便查看详细原因\n2.进行UE4相关的文件配置2-1. 删除C盘中的缓存及修改UE4缓存地址问项目地址参照内容来源于CSDN博客文章：https://blog.csdn.net/cc13813194235/article/details/53424866同时本人以\tUE4_4.24.2版本\t亲测有效\n1.首先随便创建一个游戏项目，选择自己的项目目录\n2.创建完成后关闭UE4\ntxt找到UE4的项目缓存目录\nC:\\Users\\用户名\\AppData\\Local\\UnrealEngine\\Common\\DerivedDataCache\n删除DerivedDataCache3.找到安装UE4的目录4.在 UE_4.24&#x2F;Engine&#x2F;Config 中找到 BaseEngine.ini 文件，直接用记事本打开\n5.编辑——查找——在查找框中输入 [InstalledDerivedDataBackendGraph]\n6.将 [InstalledDerivedDataBackendGraph] 下面的内容进行修改\ntxt1 Local=(Type=FileSystem, ReadOnly=false,Clean=false, Flush=false, PurgeTransient=true, DeleteUnused=true,UnusedFileAge=34, FoldersToClean=-1, Path=&quot;%ENGINEVERSIONAGNOSTICUSERDIR%DerivedDataCache&quot;)\n\n修改为：\n1 Local=(Type=FileSystem, ReadOnly=false,Clean=false, Flush=false, PurgeTransient=true, DeleteUnused=true,UnusedFileAge=34, FoldersToClean=-1,Path=&quot;%GAMEDIR%DerivedDataCache&quot;)7.修改后进行验证是否修改成功    1.在BaseEngine.ini 文件中，在查找框中输入 [DerivedDataBackendGraph]        2.找到图中选中的文本，即修改成功，项目缓存路径以及改到项目文件夹内    \n2-2. 删除联机构建SwarmAgent程序的缓存缓存目录：C:\\Users\\用户名\\AppData\\Local\\UnrealEngine\\4.24\\Saved\\Swarm\\SwarmCache删除 SwarmCache\n3. UE4的相关设置3-1. 设置UE4启动时不编译蓝图参照内容来源于知乎文章：https://zhuanlan.zhihu.com/p/104097525\n1.找到配置文件路径：C:\\Users\\用户名\\AppData\\Local\\UnrealEngine\\4.24\\Saved\\Config\\Windows\\Engine.ini\n2.打开Engine.ini文件\n3.文本内容中添加\ntxt[/Script/Engine.Blueprint]\nbRecompileOnLoad=False\n\n[/Script/Engine.LevelScriptBlueprint]\nbRecompileOnLoad=False\n\n[/Script/Engine.AnimBlueprint]\nbRecompileOnLoad=False4.保存，重启\n3-2. 设置仅编译成功时保存1.在随便打开一个蓝图，在编译的旁边有个倒三角，如图\n3-3. 显示编辑器实时信息1.编辑-编辑器偏好设置-通用-性能-勾选显示帧率和实时信息\n崩溃日志UE4崩溃日志（1）参照内容来源于虚幻4官方文档：https://docs.unrealengine.com/zh-CN/GettingStarted/RecommendedSpecifications/index.html里面有虚幻4的硬件配置要求，配套软件版本的需求，以及显卡驱动的需求\n因显卡驱动程序原因导致崩溃txt关键字：D3D11RHI、Rendering、Building\nD3D11 为Direct3D11（渲染管线），RHI 为Render hardware interface 渲染硬件层接口，d3d11.dll 为动态链接库Dynamic Link Library如图所示：解决方法：\n1.首先进入 NVIDIA GeForce Experience\n2.检查更新文件（旁边的三个点）-选择首选项-Studio驱动程序-检查更新文件（如图）3.检查到更新文件后，下载最新的驱动，自定义安装，勾选恢复默认设置\n4.重启电脑（最好重启一下）\nUE4崩溃日志（2）参考内容来源于知乎文章：https://zhuanlan.zhihu.com/p/45508890该知乎作者写了很多UE4的Bug以及部分崩溃解决方案\n虚幻4官方文档内容参考：https://docs.unrealengine.com/zh-CN/Engine/Rendering/Nvidia/NVIDIAAftermath/index.html\n因NVIDIA Aftermath 崩溃txt关键字：Aftermath、D3D11Query.cpp] [Line: 111] 、GPU has crashed\nAftermath 是一个轻量化的实用工具，可减轻部分调试工具对性能历史记录的要求。实际上，它相当轻量化，甚至可以包含在发布的游戏中，提供开发者需要的用户电脑数据。程序员可利用 Aftermath 在代码中插入标记，帮助追踪崩溃发生的根源。解决方法：    1.找到 ConsoleVariables.ini ，路径：安装的磁盘：UE_4.24\\Engine\\Config\\ConsoleVariables.ini    2.找到 [Startup]    3.在该区域文本内容下添加        r.DX11NVAfterMathEnabled&#x3D;0        r.GPUCrashDebugging&#x3D;0        如图：                4.保存，重启UE4\n","slug":"7_UE4初始设置及个人使用崩溃记录_01","date":"2022-10-06T07:28:25.955Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"01b2c0831f95e39e5fd56ec4f69b86cb","title":"UE4 RPC","content":"UE4 RPC[toc]\n1. RPC 架构1.1 架构简介\n一个服务器， 一个或多个客户端\n不能信任客户端，所有重要信息都需要通过服务器验证\nListen Server监听服务器和Dedicated Server专有服务器\n\n1.2 基本GamePlay结构\nServer\nGameMode 仅存在于Server\nGameState 同时存在与Server和Client\nPawn_Server, Pawn_A, Pawn_B 同时存在与Server和Client\nPlayerState_Server, PlayerState_A, PlayerState_B 同时存在与Server和Client\nPlayerController_Server 仅存在于Server\nPlayerController_A, PlayerController_B 同时存在与Server和各自所拥有的Client\nGameInstance, UI 同时存在与Server和各自所拥有的Client\n\n\nClient\n每个客户端都有独立的PlayerController和UI\n其余与Server同时拥有\n\n\n\n2. Listen Server2.1 Replication\n说明：\n信息从服务端同步到客户端(单向)\nActor及其派生类才有Replication的能力\n\n\n\n2.2 Replication类型\n类型：\n\nActor Replication\nProperty Replication\nComponent Replication\n\n\n在服务端进行操作：\n1234if (HasAuthority())&#123;\tTestNum = 999.f;&#125;\n\n2.2.1 Actor Replication\n两层意义：\n\n服务端生成，客户端也跟着生成(在服务端生成一个replication对象)\n当前Actor的所有属性复制，组件复制，RPC的总开关\n\n\n开启Replication\n\n蓝图：勾选Replicates\n\nC++：在构造函数中实现\n1234bReplicates = true;SetReplicates(true);其中Set要慢一点\n\n\n\n2.2.2 Property Replication\n开启方式：\n\n前提：Actor Replication是true\n\n蓝图：Replication设置为Replicated\n\nC++：\n12UPROPERTY(Replicated)float TestNum;\n\n12345678#include &quot;Net/UnrealNetwork.h&quot;void AMyActor::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const&#123;\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\t\tDOREPLIFETIME(AMyActor, TestNum);&#125;\n\nAMyActor是需要复制属性的类\n\nTestNum是待复制的属性\n\n\n\n\n2.2.3 Rep Notify\n说明：变量设为Rep_Notify，当变量发生复制时，服务端和收到的客户端都可以调用一个自定义的函数\n\n注意：C++中，自定义函数仅在客户端中调用\n\n设置方式：\n\n蓝图：Replication设置为RepNotify，会自动生成OnRep_属性()函数\n\nC++：\n12345UPROPERTY(ReplicatedUsing=OnRep_TestNum, BlueprintReadWrite)int TestNum;UFUNCTION()void OnRep_TestNum();\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;MyActor.h&quot;#include &quot;Kismet/KismetSystemLibrary.h&quot;#include &quot;Net/UnrealNetwork.h&quot;AMyActor::AMyActor()&#123;\tPrimaryActorTick.bCanEverTick = true;\tbReplicates = true;&#125;void AMyActor::BeginPlay()&#123;\tSuper::BeginPlay();&#125;void AMyActor::Tick(float DeltaTime)&#123;\tSuper::Tick(DeltaTime);\tif (HasAuthority())\t&#123;\t\t++TestNum;\t&#125;&#125;void AMyActor::OnRep_TestNum()&#123;\tif (HasAuthority())\t&#123;\t\tUKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT(&quot;%d&quot;), TestNum));\t&#125;\telse\t&#123;\t\tUKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT(&quot;%d&quot;), TestNum));\t&#125;&#125;void AMyActor::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const&#123;\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\tDOREPLIFETIME(AMyActor, TestNum);&#125;\n\n\n\n2.3 OwnerShip\n作用：\n\nRPC需要确定哪个客户端将执行于客户端的RPC\n\nActor复制与连接相关性\n\n在涉及所有者时的Actor属性复制条件\n\n说明：\n\n当 Pawn Actor 被 PlayerController 拥有时，它们的所有者将是它们所拥有的 PlayerController。\n在此期间，它们归 PlayerController 的连接所有。\nPawn 仅在同时由 PlayerController 拥有&#x2F;拥有时由该连接拥有。\n因此，一旦 PlayerController 不再拥有 Pawn，Pawn 就不再由连接拥有。\n\n\n注意：\n\n连接所有权对于 RPC 之类的东西很重要，因为当在 Actor 上调用 RPC 函数时，除非 RPC 被标记为多播，否则它需要知道在哪个客户端上执行该 RPC。\n它通过查找拥有的连接来确定将 RPC 发送到的连接。\n\n\n使用：\n\n蓝图\n\n设置\nSpawnActor中又Owner可以引用\nSetOwner\n\n\n改变\nPossess(OnPossess &gt; PossessedBy &gt; SetOwner), UnPossess\n\n\n获得\nGetOwner\n\n\n\n\nC++\n\n设置\n12345//SpawnParameters 内可以设置 OnwerGetWorld()-&gt;SpawnActor(Class, const* UserTransformPtr, const SpawnParameters);\t// SetOwnerSetOwner(NewOwner);\n\n获取\n1GetOwner();\n\n\n\n\n\n2.4 Actor Role\n分类：\n\nAuthority 权威\nSimulated Proxy 模拟代理\nAutonomous Proxy 自主代理\n\n\n基本结构：A， B， C A为房主\n\nServerA：A, B, C Authority\nClientB：A, C Simulated, B Autonomous\nClentC: A, B Simulated, C Autonomous\n\n\n说明：当涉及到复制时，actor 有两个很重要的属性。Role和RemoteRole。\n\n作用：\n\n谁对演员有权力\n演员是否被复制\n复制模式\n\n\n服务器复制到客户端的条件：Role == ROLE_Authorityand RemoteRole == ROLE_SimulatedProxyor ROLE_AutonomousProxy\n\n\n3. RPC介绍\n类似于函数调用，不过不一定是在本地执行\n\n可以实现：\n\n客户端调用，服务端执行\n服务端调用，客户端执行\n\n\n不可以有返回值\n\n默认不可靠（可以设置成Reliable）\n\n\n3.1 RPC设置蓝图：\n\nCustomEvent 的 Replicates 选项设置为其中一个\nRun On Server\nRun On Owning Client\nNet MultiCast\n\n\n要勾选Reliable\n\nC++：\n\n将一个自定义的函数声明为RPC，需要添加反射UFUNCTION()\nServer\nClient\nNetMultiCast\n\n\n额外添加Reliable\n\n3.2 RPC要求和注意要使 RPC 完全正常运行，需要满足一些要求：\n\n它们必须从 Actors 中调用\n必须复制 Actor\n如果从服务器调用 RPC 以在客户端上执行，则只有实际拥有该 Actor 的客户端将执行该函数\n如果从客户端调用 RPC 以在服务器上执行，则客户端必须拥有正在调用 RPC 的 Actor\n多播 RPC 是一个例外：\n如果从服务器调用它们，服务器将在本地执行它们以及在所有当前连接的客户端上执行它们\n如果从客户端调用，它们只会在本地执行，不会在服务器上执行\n目前，我们有一个简单的多播事件限制机制：多播函数在给定 Actor 的网络更新周期内不会复制超过两次。从长远来看，我们希望对此进行改进，并为跨渠道流量管理和节流提供更好的支持\n\n\n\n​\t\n从Server调用RPC\n\n\n\n演员所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\n客户拥有的演员\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在演员拥有的客户端上运行\n\n\n服务器拥有的演员\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n无名演员\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n从Client调用RPC\n\n\n\n演员所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\n由调用客户端拥有\n在调用客户端时运行\n在调用客户端时运行\n在服务器上运行\n在调用客户端时运行\n\n\n由不同的客户拥有\n在调用客户端时运行\n在调用客户端时运行\n掉落\n在调用客户端时运行\n\n\n服务器拥有的演员\n在调用客户端时运行\n在调用客户端时运行\n掉落\n在调用客户端时运行\n\n\n无名演员\n在调用客户端时运行\n在调用客户端时运行\n掉落\n在调用客户端时运行\n\n\n","slug":"7_UE4_RPC_04","date":"2022-10-06T07:28:25.953Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"392fe5e03b8c7afffa5955ae17305c17","title":"UE4 MySQL插件使用","content":"UE4 MySQL插件使用[toc]\n\n\n\n\n\n\n\n\n\nUpdate To 2.0\n修复了一些bool返回结果错误的bug\n优化了代码的可读性\n更新了新的2.0方法 《SelectOnTableToMap》 取代 1.0方法《SelectOnTableData》\n具体用法可以看项目源码里的注释xin’x\n1. 插件获取（1.0 版本的）MySQL Plugin 提取码:17um\n2. 插件安装\n新建UE4项目，类型随意\n在项目根目录中新建文件夹Plugins\n将FH_MySQL复制到Plugins中\n重新打开UE4项目\n\n3. 插件API3.1 连接数据库\n返回一个MySQL Connector\n1234567/* * Connection == MySQL Object * @return *UFH_ConnectionObject == MySQL Connector*/UFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)static UFH_ConnectionObject *ConnectToMySQL(FString Host, FString UserName, FString PassWord, FString DBName,                                            int32 Port, FString &amp;ConnectMessage);\n\n3.2 获得连接状态\n返回bool，正在连接返回true\n123456/* * ConnectionObject == MySQL Object * @return bool == ConnectionState*/UFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)static bool GetConnectionState(UFH_ConnectionObject *ConnectionObject);\n\n3.3 关闭数据库连接\n肯定会关掉，默认返回true\n123456/* * ConnectionObject == MySQL Object * @return bool == ConnectionState*/UFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)static bool CloseConnection(UFH_ConnectionObject *ConnectionObject);\n\n3.4 增-删-改处理\n实现增删改的处理，具体执行程序依据传入格式化SqlQuery\n\nInsert，Delete，Update\n123456/* * ConnectionObject == MySQL Object * @return bool == Insert, Update, Delete Data Is Succeed Or Failed*/UFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)static bool ActionOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery);\n\n3.4.1 Insert Format SqlQuery\n通用的 INSERT INTO TableName VALUES(InsertValues);格式化插入语句\n1234567/* * TableName = DataBase TableName * InsertValues = MySQL Insert Values to Table * @return FString = MySQL Insert Query -&gt; Insert*/UFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)static FString InsertFormatSqlQuery(FString TableName, FString InsertValues);\n\n3.4.2 Update Format SqlQuery\n更新所有字段的值UPDATE TableName SET RowName = UpdateValue;格式化更新语句\n1234567/* * TableName = DataBase TableName * RowName = Need Update Row * @return FString = MySQL Update Query -&gt; Update*/\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)static FString UpdateAllFormatSqlQuery(FString TableName, FString RowName, FString UpdateValue);\n\n\n\n依据条件更新字段值UPDATE TableName SET UpdateRowName = UpdateValue WHERE WhereName = WhereValue;格式化更新语句\n123456789101112/* * TableName = DataBase TableName * RowName = Need Update Row * WhereName = Update Where * WhereSymbol = Operator Or Symbol * WhereValue = Condition Name * UpdateValue = Need Update Date Value * @return FString = MySQL Update Query -&gt; Update*/\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)static FString UpdateByWhereFormatSqlQuery(FString TableName, FString RowName, FString WhereName,                                            FString WhereSymbol, FString WhereValue, FString UpdateValue);\n\n3.4.3 Delete Format SqlQuery\n删除整个表DELETE FROM TableName;格式化删除语句\n123456/* * TableName = DataBase TableName * @return FString = MySQL Delete Query -&gt; Delete*/UFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)static FString DeleteAllFormatSqlQuery(FString TableName);\n\n\n\n依据条件删除整行数据DELETE FROM TableName WHERE WhereName=‘WhereValue’;格式化删除语句\n12345678910/* * TableName = DataBase TableName * WhereName = Update Where * WhereSymbol = Operator Or Symbol * WhereValue = Condition Name * @return FString = MySQL Delete Query -&gt; Delete*/UFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)static FString DeleteByWhereFormatSqlQuery(FString TableName, FString WhereName, FString WhereSymbol,                                            FString WhereValue);\n\n3.5 查询语句处理\n实现基本常用的查询语句：\n\nSELECT * FROM TableName;\nSELECT Columns1, Columns2, Country FROM TableName;\n获得指定行的整行数据\n\n\n处理查询语句的通用，具体执行程序依据传入格式化SqlQuery\n\n函数公开生成并返回struct类型：\n\nResultRows整个表的数据\nResultRow整行的数据\nRowValue整行内字段名的数据\n\n\n\n3.5.1 Version1.0123456/* * ConnectionObject == MySQL Object * @return bool == Select Data Is Succeed Or Failed*/\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)static bool SelectOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery, FQueryResultRows &amp;ResultRows);\n\n\n\n3.5.2 Version2.012345/* * 2.0 Select All Results In TArray&lt;TMap&gt; ResArray */UFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)static bool SelectOnTableToMap(UFH_ConnectionObject* ConnectionObject, FString SqlQuery, FResArray&amp; ResArray);\n\n\n\n\n\n3.5.3 Select All Format SqlQuery\n查询整个表的数据SELECT * FROM TableName;格式化查询语句\n123456/* * TableName = DataBase TableName * @return FString = MySQL Select Query -&gt; Select*/UFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)static FString SelectAllFormatSqlQuery(FString TableName);\n\n3.5.4 Select Columns By Conditions\n依据条件查询表内数据SELECT Columns1, Columns2, Country FROM TableName;格式化查询语句\n123456/* * TableName = DataBase TableName * @return FString = MySQL Select Query -&gt; Select*/\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)static FString SelectByColumnsFormatSqlQuery(FString TableName, FString Columns);\n\n3.5.5 Select Get RowValues By Index\n指定表面和表内的行号，查询数据\n123456/* * TableName = DataBase TableName * @return TArray&lt;FString&gt; = Get All Rows -&gt; In All Columns Values*/\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)static FQueryResultRow GetRowByIndex(const FQueryResultRows &amp;ResultRows, int32 RowIndex);\n\n","slug":"7_UE4_MySQL插件使用_03","date":"2022-10-06T07:28:25.950Z","categories_index":"UnrealEngine,MySQL","tags_index":"UnrealEngine,MySQL","author_index":"FangH"},{"id":"ab5a123ef13f06a2127802a636203336","title":"UE4 MySQL插件开发","content":"UE4 MySQL插件开发[toc]\n1. 项目简介\n个人UrealEngine MySQL Plugin开发流程\n方便UnrealEngine项目链接和操作MySQL数据库\n\n2. 项目环境1234IDE -&gt; JetBrains Rider 2022.1 EAP7 内部版本号 221.4906.10UnrealEngine -&gt; 4.27.2Compiler Environment -&gt; Visual Studio 2022 提供编译组件MySQL -&gt; 8.0.28 MySQL Community Server - GPL\n\n\n\n\n\n3. 项目资源3.1 资源文件结构12345ConnectorLibs\t- ConnectorLibs\t\t+ include\t\t+ lib\t- ConnectorLibs.Build.cs\n\n\n\n\n\n3.2 资源链接「ConnectorLibs」https://www.aliyundrive.com/s/wTrvzpVdfxU 提取码: 0be0\n4. 项目创建4.1 创建UE4项目\n默认选择游戏项目\n默认选择空项目\n创建C++项目，包含初学者内容包\n选择项目的创建目录\n创建项目名FH_TestMySQL\n\n4.2 创建新插件\n找到Edit或Settings\n选择plugins进入插件界面\n选择New Plugin\n选择Blank\n设置插件名称FH_MySQL\nDescriptor Data随意填写\nCreate Plugin\n\n4.3 创建MySQL C++类4.3.1 FH_ConnectionObject\n创建ObjectC++类，类名FH_ConnectionObject\n选择添加到插件目录FH_MySQL(Runtime)，默认public .h，private .cpp\nCreate Class\n会弹出一个Message窗口，内容大致为创建成功，但需要重新编译，选择No\n\n4.3.2 BPFuncLib_FHSQL\n创建Blueprint Function LibraryC++类，类名BPFuncLib_FHSQL\n剩下步骤同上\n\n5. 项目配置5.1 引入MySQL环境库5.1.1 导入环境库\n准备好ConnectorLibs\n来到FH_TestMySQL\\Plugins\\FH_MySQL\\Source目录下\n创建目录ThirdParty\n将ConnectorLibs放入ThirdParty内\n\n5.1.2 配置项目属性\nRider打开创建好的UE4 C++项目\n在资源栏内找到项目名FH_TestMySQL，在Games目录下\n右键，选择Properties\n在Configurations内选择Development_Editor | x64\n选择VC++目录\n在包含目录(include)中填入绝对路径项目文件路径\\FH_TestMySQL\\Plugins\\FH_MySQL\\Source\\ThirdParty\\ConnectorLibs\\include\n在库目录(lib)中填入绝对路径项目文件路径\\FH_TestMySQL\\Plugins\\FH_MySQL\\Source\\ThirdParty\\ConnectorLibs\\lib\nOK\n\n5.1.3 配置项目文件\n修改FH_MySQL.uplugin，文件位置项目文件路径\\FH_TestMySQL\\Plugins\\FH_MySQL，只需要添加&quot;WhitelistPlatforms&quot;: [&quot;Win64&quot;]\n12345678910111213141516171819202122232425&#123;\t&quot;FileVersion&quot;: 3,\t&quot;Version&quot;: 1,\t&quot;VersionName&quot;: &quot;1.0&quot;,\t&quot;FriendlyName&quot;: &quot;FH_MySQL&quot;,\t&quot;Description&quot;: &quot;Using UE4 Connecting MySQL Plugin&quot;,\t&quot;Category&quot;: &quot;FhPlugin&quot;,\t&quot;CreatedBy&quot;: &quot;FangH&quot;,\t&quot;CreatedByURL&quot;: &quot;https://fhangh.gitee.io/&quot;,\t&quot;DocsURL&quot;: &quot;&quot;,\t&quot;MarketplaceURL&quot;: &quot;&quot;,\t&quot;SupportURL&quot;: &quot;&quot;,\t&quot;CanContainContent&quot;: true,\t&quot;IsBetaVersion&quot;: true,\t&quot;IsExperimentalVersion&quot;: false,\t&quot;Installed&quot;: false,\t&quot;Modules&quot;: [\t\t&#123;\t\t\t&quot;Name&quot;: &quot;FH_MySQL&quot;,\t\t\t&quot;Type&quot;: &quot;Runtime&quot;,\t\t\t&quot;LoadingPhase&quot;: &quot;Default&quot;,\t\t\t&quot;WhitelistPlatforms&quot;: [&quot;Win64&quot;]\t\t&#125;\t]&#125;\n\n修改FH_MySQL.Build.cs，文件位置项目文件路径\\FH_TestMySQL\\Plugins\\FH_MySQL\\Source\\FH_MySQL，修改如下内容\n12345678PublicDependencyModuleNames.AddRange(\tnew string[]    &#123;\t\t&quot;Core&quot;,\t\t&quot;ConnectorLibs&quot;,\t\t// ... add other public dependencies that you statically link with here ...\t&#125;);\n\n6. MySQL C++文件6.1 MySQL连接对象\nFH_ConnectionObject.h\n123456789101112131415161718#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;UObject/NoExportTypes.h&quot;#include &quot;mysql.h&quot;#include &quot;FH_ConnectionObject.generated.h&quot;UCLASS(BlueprintType)class FH_MYSQL_API UFH_ConnectionObject : public UObject&#123;\tGENERATED_BODY()private:\tUFH_ConnectionObject();public:\tMYSQL *Fh_ConnMysql;&#125;;\n\nFH_ConnectionObject.cpp\n123456#include &quot;FH_ConnectionObject.h&quot;UFH_ConnectionObject::UFH_ConnectionObject()&#123;\tFh_ConnMysql = nullptr;&#125;\n\n6.2 MySQL函数工具库6.2.1 Version1.0\nBPFuncLib_FHSQL.h\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Kismet/BlueprintFunctionLibrary.h&quot;#include &quot;FH_ConnectionObject.h&quot;#include &quot;BPFuncLib_FHSQL.generated.h&quot;USTRUCT(BlueprintType)struct FQueryResultRow&#123;\tGENERATED_BODY()\tUPROPERTY(BlueprintReadWrite, Category=&quot;MySQL|Result Row Value&quot;)\tTArray&lt;FString&gt; RowValue;&#125;;USTRUCT(BlueprintType)struct FQueryResultRows&#123;\tGENERATED_BODY()\tUPROPERTY(BlueprintReadWrite, Category=&quot;MySQL|Result Rows Value&quot;)\tTArray&lt;FQueryResultRow&gt; RowsValue;&#125;;UCLASS(BlueprintType)class FH_MYSQL_API UBPFuncLib_FHSQL : public UBlueprintFunctionLibrary&#123;\tGENERATED_BODY()public:\t/*\t * Connection == MySQL Object\t * @return *UFH_ConnectionObject == MySQL Connector\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic UFH_ConnectionObject *ConnectToMySQL(FString Host, FString UserName, FString PassWord, FString DBName,\t\t\t\t\t\t\t\t\t\t\t\tint32 Port, FString &amp;ConnectMessage);\t/*\t * ConnectionObject == MySQL Object\t * @return bool == ConnectionState\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool GetConnectionState(UFH_ConnectionObject *ConnectionObject);\t/*\t * ConnectionObject == MySQL Object\t * @return bool == ConnectionState\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool CloseConnection(UFH_ConnectionObject *ConnectionObject);\t/*\t * ConnectionObject == MySQL Object\t * @return bool == Insert, Update, Delete Data Is Succeed Or Failed\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool ActionOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery);\t\t/*\t * TableName = DataBase TableName\t * InsertValues = MySQL Insert Values to Table\t * @return FString = MySQL Insert Query -&gt; Insert\t */\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString InsertFormatSqlQuery(FString TableName, FString InsertValues);\t/*\t * TableName = DataBase TableName\t * RowName = Need Update Row\t * @return FString = MySQL Update Query -&gt; Update\t */\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString UpdateAllFormatSqlQuery(FString TableName, FString RowName, FString UpdateValue);\t/*\t * TableName = DataBase TableName\t * RowName = Need Update Row\t * WhereName = Update Where\t * WhereSymbol = Operator Or Symbol\t * WhereValue = Condition Name\t * UpdateValue = Need Update Date Value\t * @return FString = MySQL Update Query -&gt; Update\t */\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString UpdateByWhereFormatSqlQuery(FString TableName, FString RowName, FString WhereName, FString WhereSymbol, FString WhereValue, FString UpdateValue);\t/*\t * TableName = DataBase TableName\t * @return FString = MySQL Delete Query -&gt; Delete\t */\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString DeleteAllFormatSqlQuery(FString TableName);\t/*\t * TableName = DataBase TableName\t * WhereName = Update Where\t * WhereSymbol = Operator Or Symbol\t * WhereValue = Condition Name\t * @return FString = MySQL Delete Query -&gt; Delete\t */\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString DeleteByWhereFormatSqlQuery(FString TableName, FString WhereName, FString WhereSymbol, FString WhereValue);\t/*\t * ConnectionObject == MySQL Object\t * @return bool == Select Data Is Succeed Or Failed\t */\t\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool SelectOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery, FQueryResultRows &amp;ResultRows);\t\t/*\t * TableName = DataBase TableName\t * @return FString = MySQL Select Query -&gt; Select\t */\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString SelectAllFormatSqlQuery(FString TableName);\t/*\t * TableName = DataBase TableName\t * @return FString = MySQL Select Query -&gt; Select\t */\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString SelectByColumnsFormatSqlQuery(FString TableName, FString Columns);\t/*\t * TableName = DataBase TableName\t * @return TArray&lt;FString&gt; = Get All Rows -&gt; In All Columns Values\t */\t\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FQueryResultRow GetRowByIndex(const FQueryResultRows &amp;ResultRows, int32 RowIndex);&#125;;\n\nBPFuncLib_FHSQL.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include &quot;BPFuncLib_FHSQL.h&quot;#include &quot;mysql.h&quot;#include &lt;string&gt;UFH_ConnectionObject* UBPFuncLib_FHSQL::ConnectToMySQL(FString Host, FString UserName, FString PassWord, FString DBName,\tint32 Port, FString &amp;ConnectMessage)&#123;\tconst std::string m_Host(TCHAR_TO_UTF8(*Host));\tconst std::string m_UserName(TCHAR_TO_UTF8(*UserName));\tconst std::string m_PassWord(TCHAR_TO_UTF8(*PassWord));\tconst std::string m_DBName(TCHAR_TO_UTF8(*DBName));\tconst uint32 m_Port = Port; \t// Create MySQL Connection Object\tUFH_ConnectionObject *ConnectionObject = NewObject&lt;UFH_ConnectionObject&gt;();\t// Init DataBase Connection Object\tConnectionObject-&gt;Fh_ConnMysql = mysql_init(nullptr);\t// Judge Connection Status And Return ConnectMessage\tif (mysql_real_connect(ConnectionObject-&gt;Fh_ConnMysql, m_Host.c_str(), m_UserName.c_str(), m_PassWord.c_str(),\t                       m_DBName.c_str(), m_Port, nullptr, 0))\t&#123;\t\tConnectMessage = TEXT(&quot;Connect Succeed&quot;);\t&#125;\telse\t&#123;\t\tConnectMessage = TEXT(&quot;Connect Failed&quot;);\t&#125;\t// Return MySQL Connection Object\treturn ConnectionObject;&#125;bool UBPFuncLib_FHSQL::GetConnectionState(UFH_ConnectionObject* ConnectionObject)&#123;\t// Judge Current MySQL Connection State\tif (ConnectionObject)\t&#123;\t\tif (ConnectionObject-&gt;Fh_ConnMysql != nullptr)\t\t&#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;\treturn false;&#125;bool UBPFuncLib_FHSQL::CloseConnection(UFH_ConnectionObject* ConnectionObject)&#123;\t// If MySQL Connected -&gt; Close MySQL Connection; Return True\t// Else -&gt; Return True\tif (GetConnectionState(ConnectionObject))\t&#123;\t\tmysql_close(ConnectionObject-&gt;Fh_ConnMysql);\t\tConnectionObject-&gt;Fh_ConnMysql = nullptr;\t\tConnectionObject = nullptr;\t\treturn true;\t&#125;\treturn true;&#125;bool UBPFuncLib_FHSQL::ActionOnTableData(UFH_ConnectionObject* ConnectionObject, FString SqlQuery)&#123;\tconst std::string m_SqlQuery(TCHAR_TO_UTF8(*SqlQuery));\t// Judge MySQL Is Connected\tif (!ConnectionObject)\t&#123;\t\treturn false;\t&#125;\t// Judge SqlQuery Is Apply Succeed\tif (mysql_query(ConnectionObject-&gt;Fh_ConnMysql, m_SqlQuery.c_str()) == 0)\t&#123;\t\treturn true;\t&#125;\treturn true;&#125;FString UBPFuncLib_FHSQL::InsertFormatSqlQuery(FString TableName, FString InsertValues)&#123;\t// INSERT INTO TableName VALUES(InsertValues);\tFString SqlQuery = &quot;INSERT INTO &quot; + TableName + &quot; VALUES(&quot; + InsertValues + &quot;);&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::UpdateAllFormatSqlQuery(FString TableName, FString UpdateRowName, FString UpdateValue)&#123;\t// UPDATE TableName SET RowName=UpdateValue;\tFString SqlQuery = &quot;UPDATE &quot; + TableName + &quot; SET &quot; + UpdateRowName + &quot;=&quot; + UpdateValue + &quot;;&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::UpdateByWhereFormatSqlQuery(FString TableName, FString UpdateRowName, FString WhereName, FString WhereSymbol, FString WhereValue, FString UpdateValue)&#123;\t// UPDATE TableName SET UpdateRowName=UpdateValue WHERE WhereName=WhereValue;\tFString SqlQuery = &quot;UPDATE &quot; + TableName + &quot; SET &quot; + UpdateRowName + &quot;=&quot; + UpdateValue + &quot; WHERE &quot; + WhereName + WhereSymbol + WhereValue + &quot;;&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::DeleteAllFormatSqlQuery(FString TableName)&#123;\t// DELETE FROM TableName;\tFString SqlQuery = &quot;DELETE FROM &quot; + TableName + &quot;;&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::DeleteByWhereFormatSqlQuery(FString TableName, FString WhereName, FString WhereSymbol, FString WhereValue)&#123;\t// DELETE FROM TableName WHERE WhereName=‘WhereValue’;\tFString SqlQuery = &quot;DELETE FROM &quot; + TableName + &quot; WHERE &quot; + WhereName + WhereSymbol + &quot;&#x27;&quot; + WhereValue + &quot;&#x27;;&quot;;\treturn SqlQuery;&#125;bool UBPFuncLib_FHSQL::SelectOnTableData(UFH_ConnectionObject* ConnectionObject, FString SqlQuery, FQueryResultRows &amp;ResultRows)&#123;\tMYSQL_RES *m_Res = nullptr;\tMYSQL_ROW m_Column;\tTArray&lt;FString&gt; m_ColumnNames;\tFQueryResultRows m_Rows;\tconst std::string m_SqlQuery(TCHAR_TO_UTF8(*SqlQuery));\tif (!ConnectionObject)&#123;return false;&#125;\tif (!ConnectionObject-&gt;Fh_ConnMysql)&#123;return false;&#125;\tif (!mysql_query(ConnectionObject-&gt;Fh_ConnMysql, m_SqlQuery.c_str()))\t&#123;\t\tResultRows = &#123;&#125;;\t\tm_Res = mysql_store_result(ConnectionObject-&gt;Fh_ConnMysql);\t\tconst int m_Columns = mysql_num_fields(m_Res);\t\twhile ((m_Column = mysql_fetch_row(m_Res)) != nullptr)\t\t&#123;\t\t\tFQueryResultRow m_Row;\t\t\tfor (int i = 0; i &lt; m_Columns; ++i)\t\t\t&#123;\t\t\t\tm_Row.RowValue.Add(UTF8_TO_TCHAR(m_Column[i]));\t\t\t&#125;\t\t\tResultRows.RowsValue.Add(m_Row);\t\t&#125;\t&#125;\t\tmysql_free_result(m_Res);\treturn true;&#125;FString UBPFuncLib_FHSQL::SelectAllFormatSqlQuery(FString TableName)&#123;\t// SELECT * FROM TableName;\tFString SqlQuery = &quot;SELECT * FROM &quot; + TableName + &quot;;&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::SelectByColumnsFormatSqlQuery(FString TableName, FString Columns)&#123;\t// SELECT Columns1, Columns2, Country FROM TableName;\tFString SqlQuery = &quot;SELECT &quot; + Columns + &quot; FROM &quot; + TableName + &quot;;&quot;;\treturn SqlQuery;&#125;FQueryResultRow UBPFuncLib_FHSQL::GetRowByIndex(const FQueryResultRows &amp;ResultRows, int32 RowIndex)&#123;\tconst FQueryResultRow m_Row = ResultRows.RowsValue[RowIndex];\treturn m_Row;&#125;\n\n6.2.2 Version2.0\nBPFuncLib_FHSQL.h\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Kismet/BlueprintFunctionLibrary.h&quot;#include &quot;FH_ConnectionObject.h&quot;#include &quot;BPFuncLib_FHSQL.generated.h&quot;// 1.0USTRUCT(BlueprintType)struct FQueryResultRow&#123;\tGENERATED_BODY()\tUPROPERTY(BlueprintReadWrite, Category=&quot;MySQL|Result Row Value&quot;)\tTArray&lt;FString&gt; RowValue;&#125;;USTRUCT(BlueprintType)struct FQueryResultRows&#123;\tGENERATED_BODY()\tUPROPERTY(BlueprintReadWrite, Category=&quot;MySQL|Result Rows Value&quot;)\tTArray&lt;FQueryResultRow&gt; RowsValue;&#125;;// 2.0USTRUCT(BlueprintType)struct FRowMap&#123;\tGENERATED_BODY()\tUPROPERTY(BlueprintReadWrite, Category=&quot;MySQL|Utils&quot;)\tTMap&lt;FString, FString&gt; RowMap;&#125;;USTRUCT(BlueprintType)struct FResArray&#123;\tGENERATED_BODY()\tUPROPERTY(BlueprintReadWrite, Category=&quot;MySQL|Utils&quot;)\tTArray&lt;FRowMap&gt; ResArray;&#125;;UCLASS(BlueprintType)class FH_MYSQL_API UBPFuncLib_FHSQL : public UBlueprintFunctionLibrary&#123;\tGENERATED_BODY()public:\t/*\t * 2.0 Select All Results In TArray&lt;TMap&gt; ResArray\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool SelectOnTableToMap(UFH_ConnectionObject* ConnectionObject, FString SqlQuery, FResArray&amp; ResArray);\t\t/*\t * Connection == MySQL Object\t * @return *UFH_ConnectionObject == MySQL Connector\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic UFH_ConnectionObject *ConnectToMySQL(FString Host, FString UserName, FString PassWord, FString DBName,\t\t\t\t\t\t\t\t\t\t\t\tint32 Port, FString &amp;ConnectMessage);\t/*\t * ConnectionObject == MySQL Object\t * @return bool == ConnectionState\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool GetConnectionState(UFH_ConnectionObject *ConnectionObject);\t/*\t * ConnectionObject == MySQL Object\t * @return bool == ConnectionState\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool CloseConnection(UFH_ConnectionObject *ConnectionObject);\t/*\t * ConnectionObject == MySQL Object\t * @return bool == Insert, Update, Delete Data Is Succeed Or Failed\t */\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool ActionOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery);\t\t/*\t * TableName = DataBase TableName\t * InsertValues = MySQL Insert Values to Table\t * @return FString = MySQL Insert Query -&gt; Insert\t */\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString InsertFormatSqlQuery(FString TableName, FString InsertValues);\t/*\t * TableName = DataBase TableName\t * RowName = Need Update Row\t * @return FString = MySQL Update Query -&gt; Update\t */\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString UpdateAllFormatSqlQuery(FString TableName, FString RowName, FString UpdateValue);\t/*\t * TableName = DataBase TableName\t * RowName = Need Update Row\t * WhereName = Update Where\t * WhereSymbol = Operator Or Symbol\t * WhereValue = Condition Name\t * UpdateValue = Need Update Date Value\t * @return FString = MySQL Update Query -&gt; Update\t */\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString UpdateByWhereFormatSqlQuery(FString TableName, FString RowName, FString WhereName, FString WhereSymbol, FString WhereValue, FString UpdateValue);\t/*\t * TableName = DataBase TableName\t * @return FString = MySQL Delete Query -&gt; Delete\t */\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString DeleteAllFormatSqlQuery(FString TableName);\t/*\t * TableName = DataBase TableName\t * WhereName = Update Where\t * WhereSymbol = Operator Or Symbol\t * WhereValue = Condition Name\t * @return FString = MySQL Delete Query -&gt; Delete\t */\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString DeleteByWhereFormatSqlQuery(FString TableName, FString WhereName, FString WhereSymbol, FString WhereValue);\t/*\t * ConnectionObject == MySQL Object\t * @return bool == Select Data Is Succeed Or Failed\t */\t\tUFUNCTION(BlueprintCallable, Category=&quot;MySQL|Utils&quot;)\tstatic bool SelectOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery, FQueryResultRows &amp;ResultRows);\t\t/*\t * TableName = DataBase TableName\t * @return FString = MySQL Select Query -&gt; Select\t */\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString SelectAllFormatSqlQuery(FString TableName);\t/*\t * TableName = DataBase TableName\t * @return FString = MySQL Select Query -&gt; Select\t */\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FString SelectByColumnsFormatSqlQuery(FString TableName, FString Columns);\t/*\t * TableName = DataBase TableName\t * @return TArray&lt;FString&gt; = Get All Rows -&gt; In All Columns Values\t */\t\t\tUFUNCTION(BlueprintPure, Category=&quot;MySQL|Utils&quot;)\tstatic FQueryResultRow SelectGetRowByIndex(const FQueryResultRows &amp;ResultRows, int32 RowIndex);&#125;;\n\n\n\nBPFuncLib_FHSQL.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &quot;BPFuncLib_FHSQL.h&quot;#include &quot;mysql.h&quot;#include &lt;string&gt;UFH_ConnectionObject* UBPFuncLib_FHSQL::ConnectToMySQL(FString Host, FString UserName, FString PassWord, FString DBName,                                                       int32 Port, FString &amp;ConnectMessage)&#123;\tconst std::string m_Host(TCHAR_TO_UTF8(*Host));\tconst std::string m_UserName(TCHAR_TO_UTF8(*UserName));\tconst std::string m_PassWord(TCHAR_TO_UTF8(*PassWord));\tconst std::string m_DBName(TCHAR_TO_UTF8(*DBName));\tconst uint32 m_Port = Port; \t\tUFH_ConnectionObject *ConnectionObject = NewObject&lt;UFH_ConnectionObject&gt;();\tConnectionObject-&gt;Fh_ConnMysql = mysql_init(nullptr);\tconstexpr bool reconnect = 0;\tmysql_options(ConnectionObject-&gt;Fh_ConnMysql, MYSQL_OPT_RECONNECT, &amp;reconnect);\t\t// 判断连接是否成功，失败返回 NULL\tconst auto IsConnected = mysql_real_connect(\t\t\t\tConnectionObject-&gt;Fh_ConnMysql,\t\t\t\tm_Host.c_str(),\t\t\t\tm_UserName.c_str(),\t\t\t\tm_PassWord.c_str(),\t\t\t\tm_DBName.c_str(),\t\t\t\tm_Port,\t\t\t\tnullptr,\t\t\t\t0);\tif (IsConnected == nullptr)\t&#123;\t\tConnectMessage = TEXT(&quot;Connect Failed&quot;);\t\tConnectionObject = nullptr;\t&#125;\telse\t&#123;\t\tConnectMessage = TEXT(&quot;Connect Succeed&quot;);\t&#125;\t\treturn ConnectionObject;&#125;bool UBPFuncLib_FHSQL::GetConnectionState(UFH_ConnectionObject* ConnectionObject)&#123;\t// 判断当前 MySQL 连接状态\tif (ConnectionObject &amp;&amp; ConnectionObject-&gt;Fh_ConnMysql != nullptr)\t&#123;\t\treturn true;\t&#125;\treturn false;&#125;bool UBPFuncLib_FHSQL::CloseConnection(UFH_ConnectionObject* ConnectionObject)&#123;\tif (GetConnectionState(ConnectionObject))\t&#123;\t\tmysql_close(ConnectionObject-&gt;Fh_ConnMysql);\t\tConnectionObject-&gt;Fh_ConnMysql = nullptr;\t\tConnectionObject = nullptr;\t\treturn true;\t&#125;\treturn true;&#125;bool UBPFuncLib_FHSQL::ActionOnTableData(UFH_ConnectionObject* ConnectionObject, FString SqlQuery)&#123;\tconst std::string m_SqlQuery(TCHAR_TO_UTF8(*SqlQuery));\t\tif (!ConnectionObject || !ConnectionObject-&gt;Fh_ConnMysql)&#123;return false;&#125;\tmysql_ping(ConnectionObject-&gt;Fh_ConnMysql);\t\tif (mysql_query(ConnectionObject-&gt;Fh_ConnMysql, m_SqlQuery.c_str()) == 0)\t&#123;\t\treturn true;\t&#125;\treturn false;&#125;FString UBPFuncLib_FHSQL::InsertFormatSqlQuery(FString TableName, FString InsertValues)&#123;\t// INSERT INTO TableName VALUES(InsertValues);\tFString SqlQuery = &quot;INSERT INTO &quot; + TableName + &quot; VALUES(&quot; + InsertValues + &quot;);&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::UpdateAllFormatSqlQuery(FString TableName, FString UpdateRowName, FString UpdateValue)&#123;\t// UPDATE TableName SET RowName=UpdateValue;\tFString SqlQuery = &quot;UPDATE &quot; + TableName + &quot; SET &quot; + UpdateRowName + &quot;=&quot; + UpdateValue + &quot;;&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::UpdateByWhereFormatSqlQuery(FString TableName, FString UpdateRowName, FString WhereName, FString WhereSymbol, FString WhereValue, FString UpdateValue)&#123;\t// UPDATE TableName SET UpdateRowName=UpdateValue WHERE WhereName=WhereValue;\tFString SqlQuery = &quot;UPDATE &quot; + TableName + &quot; SET &quot; + UpdateRowName + &quot;=&quot; + UpdateValue + &quot; WHERE &quot; + WhereName + WhereSymbol + WhereValue + &quot;;&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::DeleteAllFormatSqlQuery(FString TableName)&#123;\t// DELETE FROM TableName;\tFString SqlQuery = &quot;DELETE FROM &quot; + TableName + &quot;;&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::DeleteByWhereFormatSqlQuery(FString TableName, FString WhereName, FString WhereSymbol, FString WhereValue)&#123;\t// DELETE FROM TableName WHERE WhereName=‘WhereValue’;\tFString SqlQuery = &quot;DELETE FROM &quot; + TableName + &quot; WHERE &quot; + WhereName + WhereSymbol + &quot;&#x27;&quot; + WhereValue + &quot;&#x27;;&quot;;\treturn SqlQuery;&#125;/* * version = 1.0 * 不好用，用 version = 2.0 */bool UBPFuncLib_FHSQL::SelectOnTableData(UFH_ConnectionObject* ConnectionObject, FString SqlQuery, FQueryResultRows &amp;ResultRows)&#123;\tMYSQL_RES *m_Res;\tMYSQL_ROW m_Column;\tTArray&lt;FString&gt; m_ColumnNames;\tFQueryResultRows m_Rows;\tconst std::string m_SqlQuery(TCHAR_TO_UTF8(*SqlQuery));\tif (!ConnectionObject)&#123;return false;&#125;\tif (!ConnectionObject-&gt;Fh_ConnMysql)&#123;return false;&#125;\tmysql_ping(ConnectionObject-&gt;Fh_ConnMysql);\tif (!mysql_query(ConnectionObject-&gt;Fh_ConnMysql, m_SqlQuery.c_str()))\t&#123;\t\tResultRows = &#123;&#125;;\t\tm_Res = mysql_store_result(ConnectionObject-&gt;Fh_ConnMysql);\t\tconst int m_Columns = mysql_num_fields(m_Res);\t\twhile ((m_Column = mysql_fetch_row(m_Res)) != nullptr)\t\t&#123;\t\t\tFQueryResultRow m_Row;\t\t\tfor (int i = 0; i &lt; m_Columns; ++i)\t\t\t&#123;\t\t\t\tm_Row.RowValue.Add(UTF8_TO_TCHAR(m_Column[i]));\t\t\t&#125;\t\t\tResultRows.RowsValue.Add(m_Row);\t\t&#125;\t\t\t\tmysql_free_result(m_Res);\t\treturn true;\t&#125;\treturn false;&#125;/* * version = 2.0 * 蓝图里可以得到数据库查询的所有值，存在 TArray&lt;&gt;里 * TArray&lt;&gt;可以但数组用，TArray[0] == 数据表的第一行 == TMap&lt;Key, Value&gt; * TMap&lt;Key, Value&gt; =&gt; Key == 数据表列的名称，Value == 对应列的值 * 用法： *\t1. 先中断 FResArray(Struct) 得到 FRowMap(Struct)[] *\t2. 遍历 FRowMap(Struct)[] 得到 FRowMap(Struct) *\t3. 中断 FRowMap(Struct) 得到 RowMap(Map) *\t4. 获得 RowMap的 Keys, 遍历 keys, 通过key -&gt; find Map 得到 value */bool UBPFuncLib_FHSQL::SelectOnTableToMap(UFH_ConnectionObject* ConnectionObject, FString SqlQuery, FResArray&amp; ResArray)&#123;\tif (!ConnectionObject || !ConnectionObject-&gt;Fh_ConnMysql)&#123;ResArray = &#123;&#125;; return false;&#125;\tmysql_ping(ConnectionObject-&gt;Fh_ConnMysql);\tconst std::string m_SqlQuery(TCHAR_TO_UTF8(*SqlQuery));\tif (!mysql_query(ConnectionObject-&gt;Fh_ConnMysql, m_SqlQuery.c_str()))\t&#123;\t\tMYSQL_RES* Res = mysql_store_result(ConnectionObject-&gt;Fh_ConnMysql);\t\tconst int32 num_rows = mysql_num_rows(Res);\t\tconst int32 num_fields = mysql_num_fields(Res);\t\tMYSQL_FIELD* field = mysql_fetch_field(Res);\t\tMYSQL_ROW row = mysql_fetch_row(Res);\t\tResArray.ResArray.Init(FRowMap&#123;&#125;, num_rows);\t\tfor (int i = 0; i &lt; num_rows; ++i)\t\t&#123;\t\t\tfor (int j = 0; j &lt; num_fields; ++j)\t\t\t&#123;\t\t\t\tResArray.ResArray[i].RowMap.Add(field[j].name, row[j]);\t\t\t&#125;\t\t&#125;\t\tmysql_free_result(Res);\t\treturn true;\t&#125;\treturn false;&#125;FString UBPFuncLib_FHSQL::SelectAllFormatSqlQuery(FString TableName)&#123;\t// SELECT * FROM TableName;\tFString SqlQuery = &quot;SELECT * FROM &quot; + TableName + &quot;;&quot;;\treturn SqlQuery;&#125;FString UBPFuncLib_FHSQL::SelectByColumnsFormatSqlQuery(FString TableName, FString Columns)&#123;\t// SELECT Columns1, Columns2, Country FROM TableName;\tFString SqlQuery = &quot;SELECT &quot; + Columns + &quot; FROM &quot; + TableName + &quot;;&quot;;\treturn SqlQuery;&#125;FQueryResultRow UBPFuncLib_FHSQL::SelectGetRowByIndex(const FQueryResultRows &amp;ResultRows, int32 RowIndex)&#123;\tconst FQueryResultRow m_Row = ResultRows.RowsValue[RowIndex];\treturn m_Row;&#125;\n\n7. 编译项目\n在Rider内进行项目编译\n编译完成，可以在Rider内直接运行启动UE4项目\n\n8. 打包插件8.1 打包前设置编译工具\n前提：如果安装的Visual Studio 2017可能不需要进行这个步骤，直接进入下一步\n\n打包出现RunUAT相关错误信息，再进行此步骤\n\n如果使用的是Visual Studio 2019或Visual Studio 2022或其他版本\n\n找到RunUAT.bat文件，用记事本打开或编辑\n\n文件位置UE4引擎的安装目录\\UE_4.27\\Engine\\Build\\BatchFiles\n\n编辑 -&gt; 查找，%UATExecutable%\n\n%UATExecutable% %* %UATCompileArg%修改为%UATExecutable% %* -VS2019=true %UATCompileArg%\n\n我用的是 VS2022，修改成2022好像不行，但修改成2019就可以正常打包了\n\n\n8.2 打包MySQL插件\n找到Edit或Settings\n选择plugins进入插件界面\n找到插件FH_MySQL\n可选步骤Edit，进行插件的相关信息的编辑，包括插件的图标\n点击Package(打包)，选择打包目录自定义\n等待打包完成即可\n我自己的电脑上的环境打包，完全没有任何Warning和Error，所以理论上打包不存在问题（写这个插件的时候遇到了很多问题，但用我提供的环境库文件和配置步骤，问题都一个个解决了）\n\n","slug":"7_UE4_MySQL插件开发_02","date":"2022-10-06T07:28:25.948Z","categories_index":"UnrealEngine,MySQL","tags_index":"UnrealEngine,MySQL","author_index":"FangH"},{"id":"9bb1210f38db3e1f819e50bcd1059252","title":"Git个人使用","content":"Git个人使用[toc]\n1234// 2021-02-19：苦于还是不记得git bash的使用，每次使用都要到网上找一会，太麻烦了，决定写成博客，记录一下个人的使用总结// 开头从最开始的顺序来记录-----------------------------------------------------------------------------------------------------------------------// 2021-02-20：又添加了 clone 的方法，修改完善了之前的内容\n\n1. 准备工作简单带过：\n\n注册Github账号\n下载Git，并安装\n\n2. 本地账号\n这一步是方便以后使用git时，跳过账号信息验证\n\n123456789101112131415161718192021222324// &quot;&quot; 里填 GitHub 账号的用户名$ git config --global user.name &quot;&quot;// &quot;&quot; 里填 GitHub 账号的邮箱$ git config --global user.email &quot;&quot;// 查看本地的用户信息配置$ git config --list// 结果大概如下PS C:\\Windows\\System32&gt; git config --listdiff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truehttp.sslbackend=opensslhttp.sslcainfo=E:/Git/Git/mingw64/ssl/certs/ca-bundle.crtcore.autocrlf=truecore.fscache=truecore.symlinks=falsepull.rebase=falsecredential.helper=manageruser.email=752972182@qq.comuser.name=FHangH\n\n\n\n3 Public SSH Key\n在 Github 中添加一个 Public SSH key 同时在本地也要有 Public SSH Key 的相关文件\ngit 上传和下载过程中需要密钥的验证，以保证安全性\n\n123456// 首先验证是否本地存在 SSH Key$ ssh -T git@github.com// 如果存在，大概结果如下（可以直接跳过生成本地 SSH Key 的步骤）PS C:\\Windows\\System32&gt; ssh -T git@github.comHi FHangH! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.\n\n12// 查看本地是否已经存在 Public SSH Key$ cd ~/.ssh\n\n12345678910111213// 查看文件列表$ ls// 此时两种情况，一种是什么都没有// 另一种是，差不多是存在以下文件，至少是有 id_rsa , id_rsa.pub 两个文件才行PS C:\\Users\\Admin\\.ssh&gt; ls    Directory: C:\\Users\\Admin\\.sshMode                 LastWriteTime         Length Name----                 -------------         ------ -----a---           2021/2/17     9:18           2610 id_rsa-a---           2021/2/17     9:18            575 id_rsa.pub-a---           2021/2/19    16:05           1385 known_hosts\n\n123456// 如果有，我们需要 id_rsa.pub 的内的key$ cat id_rsa.pub// 出现类似一下内容（全文复制，后面要用）PS C:\\Users\\Admin\\.ssh&gt; cat .\\id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDdrPvLeNqhzEgVU8Ep/9LiDvGpooO6UD8Tq5DM4CJzfiS+I95KjwwhxpQ7Et0pgfMt6ikRBXE1phgxoaK+tArSLcAOr1k8CgHazzB7D2j2X6v4x0Xmescq4dzB+R+6dtYGWhn5qwFjn2KljjYGVwitwdjyuqIqzS3vEpJaIpzI8nOnbGPR42a6t9FmBg3KhYyrcT5Z7DJgQvF1RkXmjeCjtHOOWL7xdDjI8iRwF3Kkiz78ovv2jr8MB2unrgPTNQ56ZPSi34gAGIDgt59VVM14P6GRxvRvtCG644QOEH/4woOmADi28BD3Gkj2+1Z1tXTaj1WPOvyEorHAXVS4L9fDScvaRK3el1LKk1hX1/dq3+ozN+Jpm8KWVtfLGfKxmKgQSJFX6qH49FuCBcD0Rpk3WnJInqz5+HLUlGqQypf0oTjQFpa+vY83/Fa3WKpqAuJM136+3mxeZFv+YCJv7eql2FzNhUAMG6Zur4/Kx5uMP1QFl0y9JYmH7WebS9MMzmE= Admin@DESKTOP-EBFV026\n\n12345// 如果没有，需要生成一个// &quot;&quot; 内填写 Github 账号的注册邮箱$ ssh-keygen -t rsa -C &quot;&quot;// 接下的步骤大概就是确认，填写密码之类的，回车键跳过（简单点）\n\n\n\n4. Github添加Key需要在Github账户内，将本地生成的 SSH key 添加进去，Git上传或下载时，才不会出现错误\n\n进入Github用户主页\n用户头像边上的倒三角\nSettings 进入设置页面\n在侧边栏内找到 SSH and GPG Keys\n在SSH Keys 内找到 New SSH Key\n跳转页面后，在Title页面里填写 Public SSH Key 名称（随意）\n在Key的文本框内，粘贴进之前在 复制的 id_rsa.pub 文件的内容\nAdd SSH Key\n\n5. Git仓库\n创建 Git 仓库 （这个也跳过，简单的创建一个公开的仓库）\n创建后，可以简单记录一下 SSH 的链接，比如：&#x67;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;:FHangH&#x2F;FHangBlogCDN_02.git\n\n6. 上传本地到Git\n首先是进入要上传的项目文件夹内\n\n123456789101112131415161718// 初始化本地仓库$ git init// 将文件全部加入到缓存中$ git add .// 或者在 add 后面跟上指定的文件或某种类型的文件$ git add // 提交操作记录，&quot;&quot; 内随意填$ git commit -m &quot;&quot;// 远程添加到源中，也就是git仓库$ git remote add origin git@github.com:用户名/仓库名.git// 有时候出现失败情况，就用下面这条命令，然后再重复上面的命令$ git remote rm origin// 最后，将本地缓存中的文件上传的远程的git仓库中（有时候网络会抽风）$ git push origin master\n\n\n\n7. 从远程Git仓库拉到本地\n本地创建一个空的项目文件夹，在文件夹内进行\n\n123456789// 多种 clone 的方法$ git clone http[s]://example.com/path/to/repo.git$ git clone http://git.oschina.net/yiibai/sample.git$ git clone ssh://example.com/path/to/repo.git$ git clone git://example.com/path/to/repo.git // 这个速度最快$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git$ git clone rsync://example.com/path/to/repo.git\n\n123456789101112// 此处以 ssh 为例$ git clone git@github.com:FHangH/Cpp-Learn-AddressBook_Clion.git//运行结果（这样就 clone Git仓库到本地了）PS C:\\Users\\Admin\\Desktop\\Test&gt; git clone git@github.com:FHangH/Cpp-Learn-AddressBook_Clion.gitCloning into &#x27;Cpp-Learn-AddressBook_Clion&#x27;...remote: Enumerating objects: 65, done.Receiving objects:  10% (7/65) (65/65), done.remote: Compressing objects: 100% (55/55), done.remote: Total 65 (delta 7), reused 65 (delta 7), pack-reused 0Receiving objects: 100% (65/65), 739.90 KiB | 127.00 KiB/s, done.Resolving deltas: 100% (7/7), done.\n\n\n\n8. gitignore文件\n用来上传本地项目到远程仓库时，过滤掉一些不需要上传的文件\n\n12345// 生成 .gitignore 文件$ touch .gitignore// powershell 里生成 .gitignore 的方法$ new-item .gitignore\n\n\n提供一个现成的 .gitignore 文件的开源库链接\n\n\n使用方法：\n\n确定自己上传的项目类型\n在上述开源链接中找到对应项目类型的 .gitignore 文件\n复制里面的内容\n粘贴到自己项目中创建的 .gitignore 文件中，保存\n\n\n\n8.1 个人常用的 .gitignore 文件8.1.1 UnrealEnigne.gitignore1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Visual Studio 2015 user specific files.vs/# Compiled Object files*.slo*.lo*.o*.obj# Precompiled Headers*.gch*.pch# Compiled Dynamic libraries*.so*.dylib*.dll# Fortran module files*.mod# Compiled Static libraries*.lai*.la*.a*.lib# Executables*.exe*.out*.app*.ipa# These project files can be generated by the engine*.xcodeproj*.xcworkspace*.sln*.suo*.opensdf*.sdf*.VC.db*.VC.opendb# Precompiled AssetsSourceArt/**/*.pngSourceArt/**/*.tga# Binary FilesBinaries/*Plugins/*/Binaries/*# BuildsBuild/*# Whitelist PakBlacklist-&lt;BuildConfiguration&gt;.txt files!Build/*/Build/*/**!Build/*/PakBlacklist*.txt# Don&#x27;t ignore icon files in Build!Build/**/*.ico# Built data for maps*_BuiltData.uasset# Configuration files generated by the EditorSaved/*# Compiled source files for the engine to useIntermediate/*Plugins/*/Intermediate/*# Cache files for the editor to useDerivedDataCache/*\n\n\n\n8.1.2 Unity.gitignore1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# This .gitignore file should be placed at the root of your Unity project directory## Get latest from https://github.com/github/gitignore/blob/master/Unity.gitignore#/[Ll]ibrary//[Tt]emp//[Oo]bj//[Bb]uild//[Bb]uilds//[Ll]ogs//[Uu]ser[Ss]ettings/# MemoryCaptures can get excessive in size.# They also could contain extremely sensitive data/[Mm]emoryCaptures/# Asset meta data should only be ignored when the corresponding asset is also ignored!/[Aa]ssets/**/*.meta# Uncomment this line if you wish to ignore the asset store tools plugin# /[Aa]ssets/AssetStoreTools*# Autogenerated Jetbrains Rider plugin/[Aa]ssets/Plugins/Editor/JetBrains*# Visual Studio cache directory.vs/# Gradle cache directory.gradle/# Autogenerated VS/MD/Consulo solution and project filesExportedObj/.consulo/*.csproj*.unityproj*.sln*.suo*.tmp*.user*.userprefs*.pidb*.booproj*.svd*.pdb*.mdb*.opendb*.VC.db# Unity3D generated meta files*.pidb.meta*.pdb.meta*.mdb.meta# Unity3D generated file on crash reportssysinfo.txt# Builds*.apk*.aab*.unitypackage# Crashlytics generated filecrashlytics-build.properties# Packed Addressables/[Aa]ssets/[Aa]ddressable[Aa]ssets[Dd]ata/*/*.bin*# Temporary auto-generated Android Assets/[Aa]ssets/[Ss]treamingAssets/aa.meta/[Aa]ssets/[Ss]treamingAssets/aa/*\n\n\n\n8.1.3 VisualStudio.gitignore123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360## Ignore Visual Studio temporary files, build results, and## files generated by popular Visual Studio add-ons.#### Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore# User-specific files*.rsuser*.suo*.user*.userosscache*.sln.docstates# User-specific files (MonoDevelop/Xamarin Studio)*.userprefs# Mono auto generated filesmono_crash.*# Build results[Dd]ebug/[Dd]ebugPublic/[Rr]elease/[Rr]eleases/x64/x86/[Ww][Ii][Nn]32/[Aa][Rr][Mm]/[Aa][Rr][Mm]64/bld/[Bb]in/[Oo]bj/[Ll]og/[Ll]ogs/# Visual Studio 2015/2017 cache/options directory.vs/# Uncomment if you have tasks that create the project&#x27;s static files in wwwroot#wwwroot/# Visual Studio 2017 auto generated filesGenerated\\ Files/# MSTest test Results[Tt]est[Rr]esult*/[Bb]uild[Ll]og.*# NUnit*.VisualState.xmlTestResult.xmlnunit-*.xml# Build Results of an ATL Project[Dd]ebugPS/[Rr]eleasePS/dlldata.c# Benchmark ResultsBenchmarkDotNet.Artifacts/# .NET Coreproject.lock.jsonproject.fragment.lock.jsonartifacts/# ASP.NET ScaffoldingScaffoldingReadMe.txt# StyleCopStyleCopReport.xml# Files built by Visual Studio*_i.c*_p.c*_h.h*.ilk*.meta*.obj*.iobj*.pch*.pdb*.ipdb*.pgc*.pgd*.rsp*.sbr*.tlb*.tli*.tlh*.tmp*.tmp_proj*_wpftmp.csproj*.log*.vspscc*.vssscc.builds*.pidb*.svclog*.scc# Chutzpah Test files_Chutzpah*# Visual C++ cache filesipch/*.aps*.ncb*.opendb*.opensdf*.sdf*.cachefile*.VC.db*.VC.VC.opendb# Visual Studio profiler*.psess*.vsp*.vspx*.sap# Visual Studio Trace Files*.e2e# TFS 2012 Local Workspace$tf/# Guidance Automation Toolkit*.gpState# ReSharper is a .NET coding add-in_ReSharper*/*.[Rr]e[Ss]harper*.DotSettings.user# TeamCity is a build add-in_TeamCity*# DotCover is a Code Coverage Tool*.dotCover# AxoCover is a Code Coverage Tool.axoCover/*!.axoCover/settings.json# Coverlet is a free, cross platform Code Coverage Toolcoverage*[.json, .xml, .info]# Visual Studio code coverage results*.coverage*.coveragexml# NCrunch_NCrunch_*.*crunch*.local.xmlnCrunchTemp_*# MightyMoose*.mm.*AutoTest.Net/# Web workbench (sass).sass-cache/# Installshield output folder[Ee]xpress/# DocProject is a documentation generator add-inDocProject/buildhelp/DocProject/Help/*.HxTDocProject/Help/*.HxCDocProject/Help/*.hhcDocProject/Help/*.hhkDocProject/Help/*.hhpDocProject/Help/Html2DocProject/Help/html# Click-Once directorypublish/# Publish Web Output*.[Pp]ublish.xml*.azurePubxml# Note: Comment the next line if you want to checkin your web deploy settings,# but database connection strings (with potential passwords) will be unencrypted*.pubxml*.publishproj# Microsoft Azure Web App publish settings. Comment the next line if you want to# checkin your Azure Web App publish settings, but sensitive information contained# in these scripts will be unencryptedPublishScripts/# NuGet Packages*.nupkg# NuGet Symbol Packages*.snupkg# The packages folder can be ignored because of Package Restore**/[Pp]ackages/*# except build/, which is used as an MSBuild target.!**/[Pp]ackages/build/# Uncomment if necessary however generally it will be regenerated when needed#!**/[Pp]ackages/repositories.config# NuGet v3&#x27;s project.json files produces more ignorable files*.nuget.props*.nuget.targets# Microsoft Azure Build Outputcsx/*.build.csdef# Microsoft Azure Emulatorecf/rcf/# Windows Store app package directories and filesAppPackages/BundleArtifacts/Package.StoreAssociation.xml_pkginfo.txt*.appx*.appxbundle*.appxupload# Visual Studio cache files# files ending in .cache can be ignored*.[Cc]ache# but keep track of directories ending in .cache!?*.[Cc]ache/# OthersClientBin/~$**~*.dbmdl*.dbproj.schemaview*.jfm*.pfx*.publishsettingsorleans.codegen.cs# Including strong name files can present a security risk# (https://github.com/github/gitignore/pull/2483#issue-259490424)#*.snk# Since there are multiple workflows, uncomment next line to ignore bower_components# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)#bower_components/# RIA/Silverlight projectsGenerated_Code/# Backup &amp; report files from converting an old project file# to a newer Visual Studio version. Backup files are not needed,# because we have git ;-)_UpgradeReport_Files/Backup*/UpgradeLog*.XMLUpgradeLog*.htmServiceFabricBackup/*.rptproj.bak# SQL Server files*.mdf*.ldf*.ndf# Business Intelligence projects*.rdl.data*.bim.layout*.bim_*.settings*.rptproj.rsuser*- [Bb]ackup.rdl*- [Bb]ackup ([0-9]).rdl*- [Bb]ackup ([0-9][0-9]).rdl# Microsoft FakesFakesAssemblies/# GhostDoc plugin setting file*.GhostDoc.xml# Node.js Tools for Visual Studio.ntvs_analysis.datnode_modules/# Visual Studio 6 build log*.plg# Visual Studio 6 workspace options file*.opt# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)*.vbw# Visual Studio LightSwitch build output**/*.HTMLClient/GeneratedArtifacts**/*.DesktopClient/GeneratedArtifacts**/*.DesktopClient/ModelManifest.xml**/*.Server/GeneratedArtifacts**/*.Server/ModelManifest.xml_Pvt_Extensions# Paket dependency manager.paket/paket.exepaket-files/# FAKE - F# Make.fake/# CodeRush personal settings.cr/personal# Python Tools for Visual Studio (PTVS)__pycache__/*.pyc# Cake - Uncomment if you are using it# tools/**# !tools/packages.config# Tabs Studio*.tss# Telerik&#x27;s JustMock configuration file*.jmconfig# BizTalk build output*.btp.cs*.btm.cs*.odx.cs*.xsd.cs# OpenCover UI analysis resultsOpenCover/# Azure Stream Analytics local run outputASALocalRun/# MSBuild Binary and Structured Log*.binlog# NVidia Nsight GPU debugger configuration file*.nvuser# MFractors (Xamarin productivity tool) working folder.mfractor/# Local History for Visual Studio.localhistory/# BeatPulse healthcheck temp databasehealthchecksdb# Backup folder for Package Reference Convert tool in Visual Studio 2017MigrationBackup/# Ionide (cross platform F# VS Code tools) working folder.ionide/# Fody - auto-generated XML schemaFodyWeavers.xsd\n\n\n\n8.1.4 C++.gitignore1234567891011121314151617181920212223242526272829303132# Prerequisites*.d# Compiled Object files*.slo*.lo*.o*.obj# Precompiled Headers*.gch*.pch# Compiled Dynamic libraries*.so*.dylib*.dll# Fortran module files*.mod*.smod# Compiled Static libraries*.lai*.la*.a*.lib# Executables*.exe*.out*.app\n\n\n\n8.1.5 C.gitignore12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Prerequisites*.d# Object files*.o*.ko*.obj*.elf# Linker output*.ilk*.map*.exp# Precompiled Headers*.gch*.pch# Libraries*.lib*.a*.la*.lo# Shared objects (inc. Windows DLLs)*.dll*.so*.so.**.dylib# Executables*.exe*.out*.app*.i*86*.x86_64*.hex# Debug files*.dSYM/*.su*.idb*.pdb# Kernel Module Compile Results*.mod**.cmd.tmp_versions/modules.orderModule.symversMkfile.olddkms.conf\n\n\n\n8.1.6 CMake.gitignore1234567891011CMakeLists.txt.userCMakeCache.txtCMakeFilesCMakeScriptsTestingMakefilecmake_install.cmakeinstall_manifest.txtcompile_commands.jsonCTestTestfile.cmake_deps\n\n","slug":"6.Git个人使用","date":"2022-10-06T07:28:25.946Z","categories_index":"编程","tags_index":"Git","author_index":"FangH"},{"id":"fa71f19cd12c01c160b7bc498a3984ba","title":"C语言基础","content":"C语言基础[toc]\n1. 编译预处理命令三种：\n\n宏定义\n文件包含\n条件编译\n\n1.1 宏定义宏是根据一系列定义的规则替换一段文本的一种模式\n\n格式：#define 标识符 字符串\n\n标识符：宏名，大写书写（区别与普通变量名）\n\n字符串：宏体，赋值给标识符（编写时，直接写标识符，编译预处理时替换成字符串的值）\n\n宏展开：宏名置换成宏体\n\n\n定义宏（是否带参数）\n\n无参\n直接用宏名代替字符串，称为 符号常量\n\n有参\n替换宏名时，对参数进行转换\n\n\n1.2 文件包含命令将已有的源文件，通过文件包含引入其他程序中，后续编程直接引用文件包含所有的定义对象，提高代码复用性和编写效率\n2. 编译过程源文件 .c 编译后，得到目标代码文件 .obj （0 和1组成），经过链接（组装）成可执行文件 .exe\n3. 运算量表达式由运算量和运算符，正确使用运算量是正确编写表达式语句的前提\n运算量：\n\n常量\n变量\n函数\n\n3.1 常量分类：值常量，符号常量\n3.1.1 值常量\n整形常量\n\n实型常量\n\n字符常量\n字符型常量和对应的ASCII码通用，可以把A理解成65，参与算术运算\n\n\n3.1.2 符号常量用一个符号代替一个值常量，使用前，先用宏定义（无参宏）\n3.2 变量命名要求：\n\n标识符不能是关键字\n标识符只能是字母、数字、下划线组成\n标识符第一个字符必须是下划线或字母\n标识符区分大小写\n\n3.2.1 类型占内存大小\n整型\n\n\n\n\n数据类型\n占用空间\n取值范围\n\n\n\nshort（短整型）\n2字节\n（-2^15 - 2^15-1）\n\n\nint（整型）\n2字节\n（-2^31 - 2^31-1）\n\n\nlong（长整型）\nwindows为4字节，Linux为4字节（32位），8字节（64位）\n（-2^31 - 2^31-1）\n\n\nlong long（长长整型）\n8字节\n（-2^63 - 2^63-1）\n\n\n\n浮点型\n\n\n\n\n数据类型\n占用空间\n有效数字范围\n\n\n\nfloat\n4字节\n7位有效数字\n\n\ndouble\n8字节\n15 - 16位有效数字\n\n\n\n字符型\n\n作用：显示单个字符\n\n语法：char 变量名 &#x3D; ‘变量值’\n\n注意：char定义的变量只能用单引号；只能有一个字符\n\n占用：char占用1个字节；将字符对应的ASCII码放入存储单元\n\nASCII：\t\n0 - 31 分配个控制字符\n32 - 126 分配个键盘上能找到的字符\n\n\n3.3 函数和数学一样，返回数值的函数可以作为运算量参与表达式的运算\n需要加入头文件 math.h\n\nsqrt(x)：求x的平方根\nfabs(x)：求x的绝对值\nexp(x)：求e的x次方\n\n4. 运算符分类：\n\n算术运算符\n关系运算符\n逻辑运算符\n位运算符\n赋值运算符\n条件运算符\n求字节运算符\n逗号运算符\n指针运算符\n其他\n\n加减乘除运算为：二目运算符（目数取决于参与运算量的个数）\n% ：求余或求模，返回两个整形数的余数\n4.1 算术运算符的结合性当表达式中，所有运算符同级，从左往右算；否则，优先算高级。\n特点表达式，从右往左算\n自增（++），自减（–）：从右往左算 （只对变量做运算，不对表达式）\n++x：先改变量值，再参与表达式运算\nx++：先参与表达式运算，再改变量值\n参数求值顺序位：从右往左\n4.2 关系及逻辑运算符4.2.1 关系运算符实现同类型的运算量之间进行关系比较，用关系运算符连接的式子位关系表达式，值：逻辑真（1），逻辑假（0）\n4.2.2 逻辑运算符和表达式逻辑与（&amp;&amp;），逻辑或（||），逻辑非（！）\n4.3 赋值、逗号、求字节4.3.1 赋值形式：变量 &#x3D; 表达式；\n右结合性（14级）\n4.3.2 逗号形式：表达式1，表达式2，… ，表达式n；\n左结合性（最低优先级，15级）\n4.3.3 求字节形式：sizeof 变量名 或 sizeof(类型名)\n功能：求变量或数据类型内存空间占用的字节数\n运算结果：整型数；\n优先级：单目运算符，2级\n4.4 位运算表达式的值，转二进制，一位一位的逻辑运算\n\n按位与\n按位或\n按位异或（真 异或 ？&#x3D; ！？；假 异或 ？&#x3D; ？）\n按位取反\n\n\n\n\n\n\n\n\n\n5. 数据类型转换转换方式：\n\n赋值转换\n自动转换\n强制转换\n\n5.1 赋值转换赋值时，将右边的值的类型转换成左边变量类型一致的类型\n5.2 自动转换两种类型的数组在表达式中进行算术运算时，低精度会自动转成高精度\nfloat 转成 double\nchar 转成 string\nshort&#x2F;int 转成 long\n5.3 强制转换系统无法自动转换，又必须与另一个类型的数据进行计算，用户需要手动指定转换类型\n形式：（类型名）表达式；\n注意：强制转换是临时转换，变量值不变，只在需要转换的表达式中有效\n6. 算法\n概念\n为解决某一个具体问题采取明确，有限的操作步骤\n\n特性\n\n确定性：每一个步骤语义明确\n有穷性：任务可以复杂，多，但不能无限执行\n可行性：每一步都是C语言能够完成的\n输入：一个算法可以有0个或n个输入\n输出：一个算法至少有一个输出\n\n\n描述工具\n\n伪代码表示法\n传统流程图表示法\nN-S结构化表示法\n\n\n结构化思想\n\n顺序结构\n选择结构\n循环结构\n\n\n语句种类\n\n表达式语句\n空语句\n函数调用语句\n控制语句\n复核语句\n\n\n\n6.1 字符输入输出函数6.1.1 字符输入函数getchar()：从输入设备中，读入1个字符，返回字符的ASCII码，并通过程序流显示在屏幕上\n例：char a；a &#x3D; getchar()；\n注：getch() 后，无需回车键进入下一步\n6.1.2 字符输出函数putchar()：输出一个字符\n例：char ch &#x3D; ‘A’;\nputchar(ch);\nputchar(‘A’);\nputchar(65);\nputchar(‘\\101’);\nputchar(‘\\x41’);\n注：putch()：也只输出一个字符\n6.2 格式输入输出函数6.2.1 格式输出函数例：printf(“格式控制字符串”， 输出字符列表)；\n\n\n\n\n6.2.2 格式输入函数scanf(“格式控制字符”， 字符地址列表)；\n例：scanf(“a&#x3D;%d, b&#x3D;%d”, &amp;a, &amp;b);\n6.3 三目运算\n作用：通过三目运算符实现简单的判断\n语法：表达式a ？表达式b ：表达式c\n解释：\na为真，执行b，并返回b的结果；\na为假，执行c，并返回c的结果；\n\n\n\n123456789101112131415#include &lt;stdio&gt;void main()&#123;\tint a = 10, b = 20;\tint c;\t\tc = (a &gt; b ? a : b);\tcout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\t//三目运算符表达式返回的是 变量，所以可以直接作为左值被赋值；\t(a &lt; b ? a : b) = 100;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; &#125;\n\n\n\n\n\n6.4 switch\n语法：\n\n12345678910111213switch (表达式)&#123;    case 结果1:    执行语句;    break；    case 结果1:    执行语句;    break；    ...    default:    执行语句;    break；&#125;\n\n\n注意：\nswitch语句的表达式类型只能是整型或字符型；\ncase后没有break语句，程序会一直向下执行；\n\n\n123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;void main()&#123;\tint value;\tcout &lt;&lt; &quot;Enter int value : &quot; &lt;&lt; endl;\tcin &gt;&gt; value;\tswitch (value)\t&#123;\tcase 10:\t\tcout &lt;&lt; &quot;Return S&quot; &lt;&lt; endl;\t\tbreak;\tcase 9:\t\tcout &lt;&lt; &quot;Return A&quot; &lt;&lt; endl;\t\tbreak;\tcase 8:\t\tcout &lt;&lt; &quot;Return A&quot; &lt;&lt; endl;\t\tbreak;\tcase 7:\t\tcout &lt;&lt; &quot;Return B&quot; &lt;&lt; endl;\t\tbreak;\tcase 6:\t\tcout &lt;&lt; &quot;Return B&quot; &lt;&lt; endl;\t\tbreak;\tcase 5:\t\tcout &lt;&lt; &quot;Return C&quot; &lt;&lt; endl;\t\tbreak;\tcase 4:\t\tcout &lt;&lt; &quot;Return C&quot; &lt;&lt; endl;\t\tbreak;\tdefault:\t\tcout &lt;&lt; &quot;Return D&quot; &lt;&lt; endl;\t\tbreak;\t&#125;&#125;\n\n\n\n\n\n7. 循环结构程序\nwhile\ndo-while\nfor\n\n7.1 while循环\n作用：满足判断条件，执行循环语句\n\n语法：\n1234while (判断条件)&#123;\t循环语句;&#125;\n\n案列：\n1234567891011121314#include &lt;iostream&gt;using namespace std;void main()&#123;\tint num = 0;\twhile (num &lt; 10)\t&#123;\t\tcout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\t\tnum++;\t&#125;&#125;\n\n7.2 do-while\n作用：先执行循环语句，再满足判断条件，执行循环语句\n\n注意：do…while 与 while的区别在于，do…while 先执行一次循环语句，再判断条件是否满足继续执行\n\n语法：\n1234do&#123;    循环语句;&#125;while (循环条件);\n\n123456789101112131415#include &lt;iostream&gt;using namespace std;void main()&#123;\tint num = 0;\tdo\t&#123;\t\tcout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\t\tnum++;\t&#125; while (num &lt; 10);&#125;\n\n水仙花案列\n\n说明：一个三位的整数满足每一位的三次方的和依旧等于这个三位数 （do … while）\n123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void main()&#123;\tint dNum = 100; //最小的三位数\tdo\t&#123;\t\tdouble a, b, c, d; // a为百位，b为十位，c为个位，d为 a b c三次方的和\t\t//pow(x, y) == x 的 y 次方\t\ta = pow(dNum / 100, 3);\t\tb = pow(dNum / 10 % 10, 3);\t\tc = pow(dNum % 10, 3);\t\td = a + b + c;\t\t//判断当前的三位数是不是水仙花数\t\tif (d == dNum)\t\t&#123;\t\t\t//条件为真时 打印水仙花数\t\t\tcout &lt;&lt; dNum &lt;&lt; endl;\t\t&#125;\t\tdNum++; //每当while条件满足都执行一遍\t&#125; while (dNum &lt; 1000); //判断当前是否是三位数&#125;\n\n7.3 for\n作用：满足条件，执行语句\n\n语法：\n1234for (起始表达式; 循环条件; 循环体)&#123;\t循环语句;&#125;\n\n1234567891011#include &lt;iostream&gt;using namespace std;void main()&#123;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tcout &lt;&lt; i &lt;&lt; endl;\t&#125;&#125;\n\nfor 循环案列-1\n\n说明：1 - 100 的区间数字，满足 各位 或 十位 或 倍数 与 7 有关，打印 yes，其余直接打印数字；\n12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void main()&#123;\tfor (int i = 1; i &lt;= 100; i++) //循环打印 1 - 100 \t&#123;\t\t//判断遍历的数字是否满足条件\t\tif (i % 10 == 7 || i / 10 % 10 == 7 || i % 7 == 0)\t\t&#123;\t\t\tcout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; //满足调件打印 yes\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; i &lt;&lt; endl; //不满足条件打印 原数字\t\t&#125;\t&#125;&#125;\n\nfor 循环案列-2\n\n判断一个整数是否为素数（【2， n-1】内没有n的因子）\n1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#define Log printf#define Enter scanf_sint main()&#123;    int a = 0;  // 素数的个数    int num = 0;  // 输入的整数    Log(&quot;输入一个整数：&quot;);    Enter(&quot;%d&quot;, &amp;num);    for (int i = 2; i &lt; num; i++)    &#123;        if (num % i == 0)        &#123;            a++;  // 素数个数加1        &#125;    &#125;    if (a == 0)    &#123;        Log(&quot;%d是素数。\\n&quot;, num);    &#125;    else    &#123;        Log(&quot;%d不是素数。\\n&quot;, num);    &#125;    return 1;&#125;\n\n7.4 goto\n作用：无条件跳转语句(转向语句)，控制程序流程无条件转移至“语句标号”所指定的语句，开始执行\n语法：goto 标记;\n解释：程序执行到goto时，如果标记存在，怎直接跳转到标记处，并继续执行\n缺点：功能太强，容易破坏程序\n\n123456789101112131415161718#include &lt;iostream&gt;using namespace std;void main()&#123;\tcout &lt;&lt; &quot;S&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;A&quot; &lt;&lt; endl;\tgoto GotoTarget; //此处的 goto 语句标记为 GotoTarget\tcout &lt;&lt; &quot;B&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;C&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;D&quot; &lt;&lt; endl;\tGotoTarget: //程序直接跳转至此处，并继续向下执行\tcout &lt;&lt; &quot;E&quot; &lt;&lt; endl;&#125;\n\n1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123;    int n = 1;    int sum = 0;    NEXT:    sum = sum + n;    n++;    if (sum &lt;= 200)    &#123;        goto NEXT;    &#125;    printf(&quot;sum=%d\\n&quot;, sum);&#125;\n\n1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123;    int n = 1;    int sum = 0;    LOOP:    if (sum &gt;= 200)    &#123;        goto END;    &#125;    else    &#123;        sum += n;        n++;        goto LOOP;    &#125;    END:    printf(&quot;sum=%d\\n&quot;, sum);    return 0;&#125;\n\n\n\n\n\n7.5 break和continue7.5.1 break\n作用：用于跳出选择结构或者循环结构\n使用：\n出现在switch语句中，终止case并跳出switch；\n出现在循环语句中，跳出循环；\n出现在嵌套循环中，跳出内层循环；\n\n\n\n7.5.2 continue只能在循环体中使用\n\n作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一循环\n\n1234567891011121314151617#include &lt;iostream&gt;using namespace std;void main()&#123;\t//从1 -100 遍历100次\tfor (int i = 1; i &lt;= 100; i++)\t&#123;\t\t//如果i 为偶数，则跳过当前循环，执行下一次遍历\t\tif (i % 2 == 0)\t\t&#123;\t\t\tcontinue;\t\t&#125;\t\tcout &lt;&lt; i &lt;&lt; endl;\t&#125;&#125;\n\n\n\n\n\n7.6 循环嵌套\n作用：在循环语句内再添加循环，解决实际问题\n\n注意：一定要确保被嵌套的循环结构完整的包含在外层循环的结构体中\n\n描述：打印 10*10 的矩阵\n123456789101112131415 #include &lt;iostream&gt;using namespace std;void main()&#123;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tfor (int j = 0; j &lt; 10; j++)\t\t&#123;\t\t\tcout &lt;&lt; &quot;* &quot;;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;&#125;\n\n打印乘法表：\n123456789101112131415#include &lt;stdio.h&gt;int main()&#123;    for (int h = 1; h &lt;= 9; h++) //行数    &#123;        for (int v = 1; v &lt;= h; v++) //列数，但不超过行数        &#123;            printf(&quot;%d * %d = %d   &quot;, v, h, v*h);//结果为 列数*行数=        &#125;        printf(&quot;\\n&quot;);    &#125;        return 0;&#125;\n\n\n\n打印菱形：\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#define Log printf#define Enter scanf_sint main()&#123;    int enterNum = 0;    Log(&quot;Enter Num :&quot;);    Enter(&quot;%d&quot;, &amp;enterNum);    Log(&quot;\\n&quot;);    for (int i = 1; i &lt;= enterNum; i++)    &#123;        for (int j = 1; j &lt;= enterNum - i; j++)        &#123;            Log(&quot; &quot;);        &#125;        for (int k = 1; k &lt;= 2 * i - 1; k++)        &#123;            Log(&quot;*&quot;);        &#125;        Log(&quot;\\n&quot;);    &#125;    for (int i = enterNum - 1; i &gt;= 1; i--)    &#123;        for (int j = 1; j &lt;= enterNum - i; j++)        &#123;            Log(&quot; &quot;);        &#125;        for (int k = 1; k &lt;= 2 * i - 1; k++)        &#123;            Log(&quot;*&quot;);        &#125;        Log(&quot;\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n\n\n8. 数组8.1 一维数组8.1.1 一维数组的定义【存储类型】类型说明符 数组名 【常量表达式】\n\n数据类型 数组名[数组长度];\n\n数据类型 数组名[数组长度] &#x3D; {元素1，元素2，…..};\n\n数据类型 数组名[] &#x3D; {元素1，元素2，…..};\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;void main()&#123;\t//1. 数据类型 数组名[数组长度];\tcout &lt;&lt; &quot;数据类型 数组名[数组长度]&quot; &lt;&lt; endl;\tint arr1[3];\tarr1[0] = 1;\tarr1[1] = 2;\tarr1[2] = 3;\t\tfor (int i = 0; i &lt; 3; i++)\t&#123;\t\tcout &lt;&lt; arr1[i] &lt;&lt; &quot;  &quot;;\t&#125;\tcout &lt;&lt; endl;\t//2. 数据类型 数组名[数组长度] = &#123;元素1，元素2，.....&#125;;\tcout &lt;&lt; &quot;数据类型 数组名[数组长度] = &#123;元素1，元素2，.....&#125;&quot; &lt;&lt; endl;\tint arr2[3] = &#123; 1, 2, 4 &#125;;\t\tfor (int j = 0; j &lt; 3; j++)\t&#123;\t\tcout &lt;&lt; arr2[j] &lt;&lt; &quot;  &quot;;\t&#125;\tcout &lt;&lt; endl;\t//3. 数据类型 数组名[] = &#123;元素1，元素2，.....&#125;;\tcout &lt;&lt; &quot;数据类型 数组名[] = &#123;元素1，元素2，.....&#125;&quot; &lt;&lt; endl;\tint arr3[] = &#123;1, 2, 3&#125;;\tfor (int k = 0; k &lt; 3; k++)\t&#123;\t\tcout &lt;&lt; arr1[k] &lt;&lt; &quot;  &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n8.1.2 一维数组名作用内存空间由数组的类型和元素的个数共同决定\nL &#x3D; 元素个数 * sizeof（类型名）\n作用：\n\n可以统计整个数组在内存中的长度\n\n可以获取数组在内存中的首地址\n\n可以获取数组元素的个数\n12345678910111213141516#include &lt;iostream&gt;using namespace std;void main()&#123;\tint arr[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;\tcout &lt;&lt; &quot;arr数组占用的内存空间：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组单个元素占用空间：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组的元素个数：&quot; &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组的首地址：&quot; &lt;&lt; (int)arr &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组第一元素的地址：&quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组第二元素的地址：&quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组最后元素的地址：&quot; &lt;&lt; (int)&amp;arr[sizeof(arr) / sizeof(arr[0])] &lt;&lt; endl;&#125;\n\n8.1.3 输入数字，按顺序输出1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123;    static int a[10];    for (int i = 0; i &lt; 10; ++i)    &#123;        printf(&quot;Enter Num to Array :&quot;);        scanf_s(&quot;%d&quot;, &amp;a[i]);    &#125;    for (int j = 0; j &lt; 10; ++j)    &#123;        printf(&quot;%3d&quot;, a[j]);    &#125;    for (int k = 9; k &gt;= 0; --k)    &#123;        printf(&quot;%3d&quot;, a[k]);    &#125;    return 0;&#125;\n\n\n\n8.1.4 输入数字，输出最大值12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123;    int maxNum = 0;    static int a[10];    for (int i = 0; i &lt; 10; ++i)    &#123;        printf(&quot;Enter Num :&quot;);        scanf_s(&quot;%d&quot;, &amp;a[i]);    &#125;    for (int j = 0; j &lt; 10; ++j)    &#123;        if (a[j] &gt; maxNum)        &#123;            maxNum = a[j];            printf(&quot;\\n&quot;);        &#125;    &#125;    printf(&quot;MaxNum is :%d&quot;, maxNum);    return 0;&#125;\n\n\n\n8.1.5 输入数字，求平均值1234567891011121314151617181920212223242526272829303132333435363738394041使用一维数组循环#include &lt;stdio.h&gt;int main()&#123;    float sumNum = 0, averageNum, enterNum;    static int a[5];    for (int i = 0; i &lt; 5; ++i)    &#123;        printf(&quot;Enter Num :&quot;);        scanf_s(&quot;%f&quot;, &amp;enterNum);        sumNum += enterNum;    &#125;    averageNum = sumNum / 5;    printf(&quot;AverageNum is :%.2f&quot;, averageNum);    return 0;&#125;不使用数组循环#include &lt;stdio.h&gt;int main()&#123;    float enterNum, sumNum = 0, averageNum;    for (int i = 0; i &lt; 5; ++i)    &#123;        printf(&quot;Enter Num :&quot;);        scanf_s(&quot;%f&quot;, &amp;enterNum);        sumNum += enterNum;    &#125;    averageNum = sumNum / 5;    printf(&quot;AverageNum is :%.2f&quot;, averageNum);    return 0;&#125;\n\n\n\n\n\n8.2 二维数组\n形式：【存储类型】类型说明符 数组名 【常量表达式1】【常量表达式2】；\n\n说明：二维数组元素在内存中排列顺序为按行为序排列\n\n初始化：\n\n\n\n\n- \n8.2.1 二维数组的定义四种定义方式：\n\n数据类型 数组名 [行数] [列数]；\n数据类型 数组名 [行数] [列数] &#x3D; ｛｛数据1，数据2｝，｛数据3，数据4｝｝；\n数据类型 数组名 [行数] [列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n数据类型 数组名 [] [列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n\n第二种更直观，可读性更高\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;void main()&#123;\t//1. 数据类型 数组名[行数][列数]；\tint arr1[2][3];\t\tarr1[0][0] = 1;\tarr1[0][1] = 2;\tarr1[0][2] = 3;\tarr1[1][0] = 4;\tarr1[1][1] = 5;\tarr1[1][2] = 6;\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数]------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\tfor (int a = 0; a &lt; 2; a++)\t&#123;\t\tfor (int a1 = 0; a1 &lt; 3; a1++)\t\t&#123;\t\t\tcout &lt;&lt; arr1[a][a1] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\tcout &lt;&lt; endl;\t//2. 数据类型 数组名[行数][列数] = &#123;｛数据1，数据2｝，｛数据3，数据4｝&#125;；\tint arr2[2][3] =\t&#123;\t\t&#123;1, 2, 3&#125;,\t\t&#123;4, 5, 6&#125;\t&#125;;\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数] = &#123;｛数据1，数据2｝，｛数据3，数据4｝&#125;------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\tfor (int b = 0; b &lt; 2; b++)\t&#123;\t\tfor (int b1 = 0; b1 &lt; 3; b1++)\t\t&#123;\t\t\tcout &lt;&lt; arr2[b][b1] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\tcout &lt;&lt; endl;\t//3. 数据类型 数组名[行数][列数] = ｛数据1，数据2，数据3，数据4｝；\tint arr3[2][3] = &#123; 1, 2, 3, 4, 5, 6 &#125;;\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数] = ｛数据1，数据2，数据3，数据4｝------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\tfor (int c = 0; c &lt; 2; c++)\t&#123;\t\tfor (int c1 = 0; c1 &lt; 3; c1++)\t\t&#123;\t\t\tcout &lt;&lt; arr3[c][c1] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\tcout &lt;&lt; endl;\t//4. 数据类型 数组名[][列数] = ｛数据1，数据2，数据3，数据4｝；\tint arr4[][3] = &#123; 1, 2, 3, 4, 5, 6 &#125;;\tcout &lt;&lt; &quot;------数据类型 数组名[][列数] = ｛数据1，数据2，数据3，数据4｝------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\tfor (int d = 0; d &lt; 2; d++)\t&#123;\t\tfor (int d1 = 0; d1 &lt; 3; d1++)\t\t&#123;\t\t\tcout &lt;&lt; arr4[d][d1] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n\n\n8.2.2 二维数组名作用\n查看二维数组所占空间\n\n查看二维数组的首地址\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void main()&#123;\tint arr[2][3] =\t&#123;\t\t&#123;1, 2, 3&#125;,\t\t&#123;4, 5, 6&#125;\t&#125;;\tcout &lt;&lt; &quot;二维数组的大小：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组一行的大小：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组元素的大小：&quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组的行数：&quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组的列数：&quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;*************************&quot; &lt;&lt; endl;\t//地址\tcout &lt;&lt; &quot;二维数组的首地址：&quot; &lt;&lt; (int)arr &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组第一行的地址：&quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组第二行的地址：&quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组第一个元素的地址：&quot; &lt;&lt; (int)&amp;arr[0][0] &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组第二个元素的地址：&quot; &lt;&lt; (int)&amp;arr[0][1] &lt;&lt; endl;&#125;\n\n8.2.3 二维数组输入输出123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main()&#123;    static int a[2][3];    printf(&quot;Enter 6 Num:\\n&quot;);    for (int i = 0; i &lt; 2; ++i)    &#123;        for (int j = 0; j &lt; 3; ++j)        &#123;            printf(&quot;%d Row %d Column:&quot;, i, j);            scanf_s(&quot;%d&quot;, &amp;a[i][j]);        &#125;    &#125;    printf(&quot;Log Array :\\n&quot;);    for (int k = 0; k &lt; 2; ++k)    &#123;        for (int g = 0; g &lt; 3; ++g)        &#123;            printf(&quot;%3d&quot;, a[k][g]);        &#125;        printf(&quot;\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n\n\n8.2.4 二维数组找到最大元素及索引12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int main()&#123;    static int a[3][4];    int max = a[0][0];    int row = 0, column = 0;    printf(&quot;Enter 12 Num To Array\\n&quot;);    for (int i = 0; i &lt; 3; ++i)    &#123;        for (int j = 0; j &lt; 4; ++j)        &#123;            printf(&quot;%d Row %d Column :&quot;, i, j);            scanf_s(&quot;%d&quot;, &amp;a[i][j]);        &#125;    &#125;    printf(&quot;Log Array\\n&quot;);    for (int k = 0; k &lt; 3; ++k)    &#123;        for (int g = 0; g &lt; 4; ++g)        &#123;            if (max &lt; a[k][g])            &#123;                max = a[k][g];                row = k;                column = g;            &#125;            printf(&quot;%3d&quot;, a[k][g]);        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;Max num : %d;\\t Row : %d;\\t Column : %d\\t&quot;, max, row, column);    return 0;&#125;\n\n\n\n8.2.5 3*3二维数组求对角线值和1234567891011121314151617181920212223242526272829303132333435363738394041424344第一种：效率低#include &lt;stdio.h&gt;int main()&#123;    int a[3][3] = &#123;&#123;1, 2, 3&#125;,                   &#123;4, 5, 6&#125;,                   &#123;7, 8, 9&#125;&#125;;    int sum = 0;    for (int i = 0; i &lt; 3; ++i)    &#123;        for (int j = 0; j &lt; 3; ++j)        &#123;            if (i == j)            &#123;                sum += a[i][j];            &#125;        &#125;    &#125;    printf(&quot;3*3的二维数组对角线的值和：%d&quot;, sum);    return 0;&#125;第二种：效率高#include &lt;stdio.h&gt;int main()&#123;    int a[3][3] = &#123;&#123;1, 2, 3&#125;,                   &#123;4, 5, 6&#125;,                   &#123;7, 8, 9&#125;&#125;;    int sum = 0;    for (int i = 0; i &lt; 3; ++i)    &#123;        sum += a[i][i];    &#125;    printf(&quot;3*3的二维数组对角线的值和：%d&quot;, sum);    return 0;&#125;\n\n\n\n\n\n8.3 字符数组\n说明：字符数组相较于普通数组，除了它们的共同特性外，字符数组具有独自的特点\n\n定义：char 数组名 【常量表达式】； —-  char a 【10】；\n定义字符数组a有10个元素，每个元素一个字符变量，占一个字节空间，用于存放一个字符变量\n\n\n8.3.1 字符数组初始化\n逐个元素初始化：char c[3] &#x3D; {‘a’, ‘b’, ‘c’};\t\n （如果初值个数&gt;数组长度，语法错误）\n （如果初值个数&lt;数组长度，则其余元素自动定义为“串结束符”：\\0）\n （如果初值个数&#x3D;数组长度，则定义时，可省略数组长度）\n\n用字符串初始化：char a[11] &#x3D; {“I am a boy”};\n\n\n\n\n\n\n8.3.2 字符数组输入输出char a[20];\n\n用格式符”%c“，逐个字符输入输出\nscanf (“%c”, &amp;a[0]);\nprintf (“%c”, a[0]);\n\n用格式符”%s“，整个字符串输入输出 (字符串输出时，数组长度至少大于初值个数一个单元，即默认的”\\0“，否则输出结果不符合预期)\nscanf (“%s”, &amp;a);\nprintf (“%s”, a);\n\n\n\n\n8.3.3 字符串处理函数\n\n\n\n\n\n\n\n\n\n9. 函数9.1 函数的定义9.1.1 函数的分类\n是否由用户定义\n标准库函数\n用户自定义函数\n\n\n是否返回值\n返回值的函数：sqrt(x) fabs(x)\n不返回值的函数:  clrscr()\n\n\n是否有参数\n有参函数：sqrt(x) fabs(x)\n无参函数:  clrscr()\n\n\n是否在文件内部\n内部函数\n外部函数\n\n\n\n9.1.2 函数的定义\n方式一：\n123456函数返回值类型 函数名(参数列表)\t参数类型说明\t&#123;\t\t变量说明；\t\t语句序列；\t&#125;\n\n方式二：\n12345函数返回值类型 函数名(参数类型说明 参数列表)&#123;\t变量说明；\t语句序列；&#125;\n\n9.1.3 定义不返回值的函数12345678910111213141516#include &lt;stdio.h&gt;void write() //无返回值，无参数的函数&#123;    for (int i = 0; i &lt;= 12; ++i)    &#123;        printf(&quot;%c&quot;, &#x27;*&#x27;);    &#125;    printf(&quot;\\n&quot;);&#125;int main()&#123;    write();    return 0;&#125;\n\n12345678910111213141516#include &lt;stdio.h&gt;void write(int num) //无返回值，有参数的函数&#123;    for (int i = 0; i &lt;= num; ++i)    &#123;        printf(&quot;%c&quot;, &#x27;*&#x27;);    &#125;    printf(&quot;\\n&quot;);&#125;int main()&#123;    write(12);    return 0;&#125;\n\n\n\n9.1.4 定义返回值的函数1234567891011121314151617#include &lt;stdio.h&gt;int sum(int num)&#123;    int sum = 0;    for (int i = 0; i &lt;= num; ++i)    &#123;        sum += i;    &#125;    return sum;&#125;int main()&#123;    printf(&quot;%d&quot;, sum(3));    return 0;&#125;\n\n\n\n9.2 函数的使用9.2.1 函数的执行过程例：求前n个自然数和的平均值\n123456789101112131415161718192021222324#include &lt;stdio.h&gt;float averageNum(float num)&#123;    float sum = 0.0f, average;    int count;    for (int i = 0; i &lt;= (int)num ; ++i)    &#123;        sum += (float)i;        count = i;    &#125;    average = sum / (float)count;    return average;&#125;int main()&#123;    int enterNum;    printf(&quot;enter num:&quot;);    scanf_s(&quot;%d&quot;, &amp;enterNum);    printf(&quot;averageNum=%7.2f&quot;, averageNum((float)enterNum));    return 0;&#125;\n\n\n\n9.3 函数的调用形式\n语句调用\n表达式调用\n\n9.4 函数的声明声明：先定义后调用，声明的函数必须放在main函数之前，否则运行错误\n注：\n\nC++中可以运行，但结果错误\n返回值为int，权限高，可以不声明\n\n1234567891011121314151617#include &lt;stdio.h&gt;int maxNum(int x, int y, int z); // 先声明函数int main()&#123;    printf(&quot;MaxNum:%d&quot;, maxNum(10, 20, 30));    return 0;&#125;int maxNum(int x, int y, int z) // 在mian()函数后面定义函数&#123;    int max = 0;    max = x &gt; y ? x : y;    max = max &gt; z ? max : z;    return max;&#125;\n\n\n\n9.5 带参宏和函数的区别区别：宏中的 sum(x, y)，x和y不存值，而是将函数中出现sum(x, y)类型的表达式用 x+y替代，并返回，再有函数将表达式x+y赋值计算\n\n宏：返回替换的表达式，带入函数中计算\n函数：带入参数计算，返回结果\n\n1234567891011#include &lt;stdio.h&gt;#define sum(x, y) x+y; // 带参宏int main()&#123;    int num = 0;    num = sum(10, 20); // 展开： num = sum(x+y) -&gt; num = x + y    printf(&quot;Sum Num :%d&quot;, num);    return 0;&#125;\n\n\n\n9.6 函数的嵌套和递归调用9.6.1 函数的嵌套调用\n\n\n\n9.6.2 例题\n\n1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int funcSum(int num);float funcCalculate(int m, int n, int p);int main()&#123;    int m, n, p;    printf(&quot;enter num:&quot;);    scanf_s(&quot;%d %d %d&quot;, &amp;m, &amp;n, &amp;p);    float num = funcCalculate(m, n, p);    printf(&quot;Calculate Num :%7.2f&quot;, num);    return 0;&#125;int funcSum(int num)&#123;    int sum;    for (sum = 0; num &gt; 0; --num)    &#123;        sum += num;    &#125;    return sum;&#125;float funcCalculate(int m, int n, int p)&#123;    float y = (float)(funcSum(m) * funcSum(n));    y = y / (float)funcSum(p);    return y;&#125;\n\n\n\n9.6.3 函数的递归调用\n\n\n\n\n\n9.7 变量的作用域9.7.1 定义和区别\n\n\n\n9.7.2 全局变量例子\n\n\n\n9.7.3 全局变量和局部变量同名\n\n\n\n\n\n9.8 变量的存储类型9.8.1 定义和分类\n\n\n\n\n\n9.8.2 例子\n\n\n\n\n\n\n\n\n\n10. 指针10.1 指针的概念\n计算机中为方便地区不同的内存单元，会为每个单元分配内存地址，这个地址称为内存单元地址，简称：内存地址\nC语言中把指针定义为地址，指针是地址的另一种描述，相同的概念：指针&#x3D;&#x3D;地址\n\n10.2 指针的类型\n指针指向的对象类型可能不同\n变量，数组，函数，结构体均是内存中的存储对象，都有这不同的存储类型，不同类型的存储空间大小不同，它们的地址是属于不同类型的指针。\n不同类型的指针之间，不能直接有任何操作\n\n10.3 指针和变量10.3.1 变量的指针\n一个变量通常占用若干个连续的内存单元，把这若干个单元起始单元的地址称为变量的地址\n内存单元本身的地址是0和1组成，不方便使用，C语言用 “&amp;变量名” 表示变量的地址\n不同类型的变量，指针的类型不同\n\n10.3.2 指向变量的指针变量\n指针变量：专门存放地址的变量\n\n指向变量的指针变量：专门存放其他变量地址的指针变量，该指针变量指向对象是一个变量\n\n形式：数据类型名 *变量名；\n\n例：\n1234int x = 5;int *p1; # p1是变量名， *是定义符，向系统说明p1是指针变量（存放地址）p1 = &amp;x; # &amp;x是整形变量的地址，将其赋值个p1保存，此时p1保存了x的地址# x是p1指向的变量，p1是x变量的指针变量\n\n\n指针运算符 “*” 又称间接访问运算符：间址运算符（单目运算符，第二优先级，右结合性）\n\n形式：*地址表达式\n\n先计算表达式的值，再根据表达式的值（地址）及类型，访问内存中相应的对象，分别是两种：从内存中读取，往内存中写入\n\n“*&amp;x”：右结合性 &#x3D;&#x3D; * (&amp;x) &#x3D;&#x3D; x &#x3D;&#x3D; *&amp;x\n1234int a = 5;int *pa; # 此处的*是定义一个pa的指针变量*pa = &amp;a; # 把 a的地址存进去，&amp;（引用）获得变量的地址，此处 *（解析）指向并得到地址内的值printf(&quot;*pa=%d&quot;, *pa); # 打印结果为 *pa=5；\n\n1234567891011121314#include &lt;stdio.h&gt;int main()&#123;    int a = 5, b = 10, *pa = NULL, *pb = NULL;    pa = &amp;a;    pb = &amp;b;    printf(&quot;*pa = %d, *pb = %d&quot;, *pa, *pb);    *pb = *pa + *pb;    printf(&quot;\\n*pb = %d&quot;, *pb);    return 0;&#125;\n\n\n\n10.3.3 指向指针变量的指针\n定义一个指针变量，让它保存其他指针变量的地址，则该指针变量为指向指针的指针变量（多级指针）\n123456int x = 5;int *px;px = &amp;5; # 此时px存储了x的地址int *py;py = &amp;px; # py存储了px的地址（二级指针)\n\n123456789101112131415#include &lt;stdio.h&gt;int main()&#123;    int a = 5;    int *pa;    int **pb; # 定义一个 int * 类型的指针变量（二级指针）    pa = &amp;a; # a的地址赋值该指针变量 pa    pb = &amp;pa; # 指针变量pa的地址赋值 pb    printf(&quot;**pb = %d&quot;, **pb); # **pb == *(*pb): (*pb)解析pb内地址指向的变量pa，*(*pb) == *pa     return 0;&#125;\n\n10.4 指针与数组\n一个数组占用一片连续的内存空间，数组元素的使用可以和同类型的变量相比\n\n10.4.1 一维数组与指针\n一维数组的指针\n1234int arrX[5], i;# w + i == &amp;arrX[i] : 表示第i个元素的地址# w == &amp;arrX[0] : 表示数组的首地址和第0个元素的地址# *(w + i) == arrX[i] : 表示dii个元素 / * （解析）w + i \n\n指向数组元素的指针变量\n12345int arrX[5], i, *p;# p = &amp;i;# p = &amp;arrX[i];# p = w + i;# 当i=0 有 p = w，此时p指向arrX[0]\n\n引用数组元素方法：int a[5], *p &#x3D; a;\n\n下标法：a[i], p[i]\n\n指针法：*(a+i), *(p+i)\n\n例子：\n1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123;    int arr[10], *p = NULL;    p = arr;    int x = 0;    while (p &lt; arr+10)    &#123;        printf(&quot;arr[%d]=&quot;, x);        scanf_s(&quot;%d&quot;, p);        p++;        x++;    &#125;    for (p = arr + 9; p &gt;= arr ; --p)    &#123;        printf(&quot;%3d&quot;, *p);    &#125;    return 0;&#125;\n\n12345678910111213#include &lt;stdio.h&gt;int main()&#123;    int arr[10] = &#123;10, 20, 30, 40, 50, 60, 70, 80, 90, 100&#125;;    int *p = arr + 2;    for (int i = 0; i &lt; 5; ++i)    &#123;        printf(&quot;%5d&quot;, p[i]);    &#125;    return 0;&#125;\n\n\n\n10.4.2 二维数组与指针12int i, j, arr[3][4];w + i # 表示i行的行地址；i = 0，arr表示第0行的行地址\n\n123*(arr + i) # 与arr[i]相同，表示第i行的一维数组名称，也是arr[i][0]的元素地址*(arr + i) + j # 表示&amp;arr[i][j]，表示第i行第j列的元素地址*(*(w + i)+ j) ==== arr[i][j]\n\n12int i, j, k, arr[i][j][k];*(*(*(arr + i) +j) +k) == arr[i][j][k]\n\n\n\n\n\n\n\n\n\n10.5 指针和字符10.5.1 指针变量访问字符数组12345678910#include &lt;stdio.h&gt;int main()&#123;    char *str = &quot;Hello World !&quot;;    printf(&quot;%s\\n&quot;, str);    printf(&quot;%s\\n&quot;, str + 6);    return 0;&#125;\n\n\n\n10.5.2 指向字符的指针变量输入字符串，判断是否是回文符\n1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;    char str[20], *str_Front, *str_Rear;    printf(&quot;Enter String :&quot;);    gets_s(str, 20);    str_Rear = str + strlen(str) - 1;    for (str_Front = str; str_Front &lt; str_Rear; str_Front++, str_Rear--)    &#123;        if (*str_Front != *str_Rear)        &#123;            break;        &#125;    &#125;    printf(&quot;%d %d&quot;, *str_Front, *str_Rear);    if (*str_Front &gt; *str_Rear)    &#123;        printf(&quot; F&quot;);    &#125;    else    &#123;        printf(&quot; T&quot;);    &#125;    return 0;&#125;\n\n\n\n\n\n\n\n10.6 指针和函数10.6.1 指针变量作为函数的参数12345678910111213141516171819#include &lt;stdio.h&gt;void funcSwap(int *x, int *y);int main()&#123;    int x = 2, y = 3;    funcSwap(&amp;x, &amp;y); # &amp; 为引用 得到 x的内存地址    printf(&quot;x = %d, y = %d&quot;, x, y);    return 0;&#125;void funcSwap(int *x, int *y) # 此处是写如 * 为定义 地址变量（指针变量）&#123;    int s = *x; #访问时，* 为解析地址的内存值 == x    *x = *y;    *y = s;&#125;\n\n\n\n10.6.2 指针变量实现字符串复制12345678910111213141516171819202122#include &lt;stdio.h&gt;void funcCopyStr(char *originStr, char *flagStr);int main()&#123;    char str_Origin[100], str_Flag[100];    printf(&quot;Enter String To Copy :&quot;);    gets_s(str_Origin, 100);    funcCopyStr(str_Origin, str_Flag);    printf(&quot;%s\\n&quot;, str_Origin);    printf(&quot;%s\\n&quot;, str_Flag);    return 0;&#125;void funcCopyStr(char *originStr, char *flagStr)&#123;    for (; (*flagStr = *originStr); originStr++, flagStr++);&#125;\n\n\n\n10.6.3 指针数组做函数参数12345678910111213#include &lt;stdio.h&gt;int main(int n, char *args[]) # mian函数内只能定义这样的形参 n == 命令单词的个数；*args[] == 保存命令参数的地址&#123;    printf(&quot;n=%d&quot;, n);    for (int i = 1; i &lt; n; ++i)    &#123;        printf(&quot;%s\\n&quot;, args[i]);    &#125;    return 0;&#125;\n\n\n\n10.6.4 指针函数\n函数也可以返回地址（指针函数）\n\n类型标识符 *函数名(参数表) {}\n123456789101112131415161718192021#include &lt;stdio.h&gt;int *funcJudgeMaxNum(int *p_num1, int *p_num2);int main()&#123;    int num1, num2, *maxNum;    printf(&quot;Enter num1 and num2 :&quot;);    scanf_s(&quot;%d %d&quot;, &amp;num1, &amp;num2);    maxNum = funcJudgeMaxNum(&amp;num1, &amp;num2);    printf(&quot;MaxNum = %d&quot;, *maxNum);    return 0;&#125;int *funcJudgeMaxNum(int *p_num1, int *p_num2)&#123;    return *p_num1 &gt; *p_num2 ? p_num1 : p_num2;&#125;\n\n10.6.5 指针函数动态获取内存空间1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;int main()&#123;    int numCount, *p_TestArr;    printf(&quot;Enter num count=&quot;);    scanf_s(&quot;%d&quot;, &amp;numCount);    p_TestArr = (int *)malloc(numCount * sizeof(int)); # 申请一个numCount*2字节的空间并转换成内存地址赋值个 p_TestArr    for (int i = 0; i &lt; numCount; ++i)    &#123;        printf(&quot;TestArr[%d]=&quot;, i);        scanf_s(&quot;%d&quot;, &amp;p_TestArr[i]);    &#125;    printf(&quot;This Arr=&quot;);    for (int j = 0; j &lt; numCount; ++j)    &#123;        printf(&quot;%4d&quot;, p_TestArr[j]);    &#125;    return 0;&#125;\n\n\n\n10.6.6 指向函数的指针变量\n概念：一个专门保存函数地址的指针变量\n\n定义：\n123int (*f) (int1, int2); # 参数类型可以不带float (*p) ();float *(*f) ();\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;float func_AddNum(float num1, float num2);float func_SubNum(float num1, float num2);float func_MulNum(float num1, float num2);float func_DivNum(float num1, float num2);int main()&#123;    int num1, num2;    char op;    float (*p_Calculate)(float, float);    printf(&quot;Enter num1 num2:&quot;);    scanf_s(&quot;%d %c %d&quot;, &amp;num1, &amp;op, 1, &amp;num2);    switch (op)    &#123;        case &#x27;+&#x27;: p_Calculate = func_AddNum;            break;        case &#x27;-&#x27;: p_Calculate = func_SubNum;            break;        case &#x27;*&#x27;: p_Calculate = func_MulNum;            break;        case &#x27;/&#x27;: p_Calculate = func_DivNum;            break;    &#125;    printf(&quot;CalculateResult Num = %.2f&quot;, (*p_Calculate)(num1, num2));    getchar();    return 0;&#125;float func_AddNum(float num1, float num2)&#123;    return num1 + num2;&#125;float func_SubNum(float num1, float num2)&#123;    return num1 - num2;&#125;float func_MulNum(float num1, float num2)&#123;    return num1 * num2;&#125;float func_DivNum(float num1, float num2)&#123;    return num1 / num2;&#125;\n\n11. 结构体11.1 结构体与变量11.1.1 结构体类型的定义\n是具有不同类型的有序集合\n\n结构体所占空间等于各个数据成员的所需空间之和\n123456789struct 结构体名&#123;    类型表示符 成员名1;    类型表示符 成员名2;    类型表示符 成员名3;&#125;struct 定义结构体类型的关键字域名或成员名：命名规则和变量相同，同一结构体的同层成员不可同名\n\n11.1.2 结构体变量\n先定义结构体类型，再定义变量名\n123456struct s_Student&#123;    int age;&#125;struct s_Student stu1, stu2;\n\n\n\n定义结构体类型和定义变量名写在一起\n1234struct s_Student&#123;    int age;&#125;stu1, stu2;\n\n\n\n若结构体类型名只用一次，则定义可省去\n1234struct&#123;    int age;&#125;stu1, stu2;\n\n11.1.3 结构体类型嵌套\n定义：结构体成员可以是其他结构体类型，但不能在结构体中嵌套其他结构体\n123456789101112struct s_date&#123;    int year, month, day;&#125;struct s_student&#123;    char name[20];    struct birthday;&#125;struct s_student stu1, stu2;\n\n11.1.4 typedef 定义类型\n把一种数据类型名定义成与之等价的另一种类型名\n12345typedef int fh_int;fh_int x, y; # == int x, y;typedef int * fh_pint;fh_pint x, y; # == *x, *y;\n\n利用typedef可以将struct student 定义成一个较为简单的类型名\n12typedef struct student fh_stu;fh_stu stu1, stu2; # == struct student stu1, stu2;\n\n11.1.5 结构体的引用\n结构体是聚合类型的数据，由多种不同的类型的数据成员组成\n\n结构体变量的输入输出，只能对其各个成员分别进行\n123结构体成员的表达式：结构体变量名.成员名&quot;.&quot; 是成员（分量）运算符，具有最高优先级注：同类型的结构体变量之间，可以整体相互赋值\n\n12345678910111213141516171819202122232425#include &lt;stdio.h&gt;struct s_student&#123;    char stu_name[20];    int stu_age;    float stu_percent;&#125;;int main()&#123;    struct s_student stu;    printf(&quot;Enter name:&quot;);    gets_s(stu.stu_name, 20);    printf(&quot;Enter age:&quot;);    scanf_s(&quot;%d&quot;, &amp;stu.stu_age);    printf(&quot;Enter percent:&quot;);    scanf_s(&quot;%f&quot;, &amp;stu.stu_percent);    printf(&quot;Student:\\n&quot;);    printf(&quot;\\t %s\\n \\t %d\\n \\t %.2f\\n&quot;, stu.stu_name, stu.stu_age, stu.stu_percent);    return 0;&#125;\n\n11.1.6 结构体定义时初始化123456789101112131415161718192021#include &lt;stdio.h&gt;struct s1_student&#123;    char stu_name[20];    int stu_age;    float stu_percent;&#125;;int main()&#123;    struct s1_student stu1 = &#123;&quot;fang&quot;, 22, 99&#125;, stu2;    stu2 = stu1;    printf(&quot;Student01:\\n&quot;);    printf(&quot;\\t %s\\n \\t %d\\n \\t %.2f\\n&quot;, stu1.stu_name, stu1.stu_age, stu1.stu_percent);    printf(&quot;Student02:\\n&quot;);    printf(&quot;\\t %s\\n \\t %d\\n \\t %.2f\\n&quot;, stu2.stu_name, stu2.stu_age, stu2.stu_percent);    return 0;&#125;\n\n\n\n\n\n11.2 结构体与数组11.2.1 结构体数组的定义123456struct s_student&#123;    char stu_name[20];    int stu_age;    float stu_percent;&#125;stu[2];\n\n\n\n11.2.2 结构体数组的初始化1234567891011struct s_student&#123;    char stu_name[20];    int stu_age;    float stu_percent;&#125;stu[2] = &#123;    &#123;&quot;fang&quot;, 22, 99&#125;,    &#123;&quot;fang&quot;, 22, 99&#125;,    &#123;&quot;fang&quot;, 22, 99&#125;&#125;;\n\n\n\n\n\n11.3 结构体与指针11.3.1 指向结构体变量的指针变量\n指针变量保存结构体变量地址\n123456789101112131415struct s_student&#123;    char stu_name[20];    int stu_age;    float stu_percent;&#125;stu, *p_stu;p_stu = &amp;stu;stu.stu_age = 20; # == (*p_stu).stu_age = 20;# (*p_stu).stu_age 不可省去（）# (*p_stu).stu_age 书写麻烦，所以C语言提供了 “指向运算符” ：“-&gt;”, 优先级1级，左结合性；# 格式：指针变量-&gt;成员分量名称# (*p_stu).stu_age == p_stu-&gt;stu_age\n\n12345678910111213141516171819202122232425#include &lt;stdio.h&gt;struct s2_student&#123;    char stu_name[20];    int stu_age;    char sex;    float stu_percent;&#125;;int main()&#123;    struct s2_student stu1 = &#123;&quot;fang&quot;, 22, &#x27;T&#x27;, 99&#125;, *p_stu2;    p_stu2 = &amp;stu1;    printf(&quot;Student01:\\n&quot;);    printf(&quot;\\t %s\\n, \\t %d\\n, \\t %s\\n, \\t %.2f\\n&quot;,            stu1.stu_name, stu1.stu_age, (stu1.sex == &#x27;T&#x27;) ? &quot;man&quot; : &quot;women&quot;, stu1.stu_percent);    printf(&quot;Student02:\\n&quot;);    printf(&quot;\\t %s\\n, \\t %d\\n, \\t %s\\n, \\t %.2f\\n&quot;,            p_stu2-&gt;stu_name, p_stu2-&gt;stu_age, (p_stu2-&gt;sex == &#x27;T&#x27;) ? &quot;man&quot; : &quot;women&quot;, p_stu2-&gt;stu_percent);    return 0;&#125;\n\n11.3.2 指向结构体数组的指针变量1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;struct s3_student&#123;    char stu_name[20];    int stu_age;    char sex;    float stu_grade;&#125;;int main()&#123;    struct s3_student stu[3] = &#123;            &#123;&quot;fang01&quot;, 22, &#x27;T&#x27;, 97&#125;,            &#123;&quot;fang02&quot;, 23, &#x27;F&#x27;, 98&#125;,            &#123;&quot;fang03&quot;, 24, &#x27;T&#x27;, 99&#125;    &#125;;    struct s3_student *p_stu;    printf(&quot;%6s %5s %5s %7s\\n&quot;, &quot;Name&quot;, &quot;Age&quot;, &quot;Sex&quot;, &quot;Grade&quot;);    printf(&quot;----------------------------\\n&quot;);    for (p_stu = stu; p_stu &lt; stu + 3; p_stu++)    &#123;        printf(&quot;%7s %4d %4c %8.2f\\n&quot;, p_stu-&gt;stu_name, p_stu-&gt;stu_age, p_stu-&gt;sex, p_stu-&gt;stu_grade);    &#125;    return 0;&#125;\n\n\n\n\n\n11.4 联合体(共用体)123456789union xyz&#123;\tchar x;\tint y;\tdouble z;&#125; t;# t 的内存大小，以union中最大的为标准，也就是double，8个字节# 由于所有成员共用一个空间，在某一时刻，t变量只有其中一个分量的有效值\n\n\n\n11.5 枚举类型\n一种简单的数据类型，把所有的值列举出来，形成该值的取值范围，枚举型变量只能从中取出值，称为枚举元素或枚举常量\n\n枚举类型是一种基本数据类型，不是构造体类型，因此不能 分解成任何基本类型\n123456789enum 枚举名 &#123;枚举值表&#125;;enum weekday &#123;sun, mou, tue, web, thu, fri, sat&#125;;enum weekday a, b, c; # a, b, c 是枚举类型weekday的变量# 也可以定义枚举类型时定义变量enum weekday &#123;sun, mou, tue, web, thu, fri, sat&#125; a, b, c;# 或enum &#123;sun, mou, tue, web, thu, fri, sat&#125; a, b, c;\n\n11.5.1 枚举类型的使用规定\n枚举值是常量，不是变量，不能被赋值\n枚举元素本身由系统定义了一个表示序号的值，序号值可以自定\n只能把枚举值赋值给枚举变量，不能把元素的序号数值赋值给枚举变量\n输出枚举值的格式字符是 “ %d ” ，对应序号，为整数\n\n12. 文件12.1 文件概念和分类12.1.1 文件概念\n\n\n\n\n\n\n\n12.1.2 文件简单分类\n\n\n\n\n\n\n\n12.2 文件基本操作12.2.1 定义文件指针\n\n\n\n\n\n\n\n12.2.2 文件的打开\n\n\n\n\n打开方式\n含义\n说明\n\n\n\nr\n只读\n为输入打开一个已存在的文本文件\n\n\nw\n只写\n为输出打开一个文本文件\n\n\na\n只追加\n为追加打开一个已存在的文本文件\n\n\nrb\n只读\n为输入打开一个已存在的二进制文件\n\n\nwb\n只写\n为输出打开一个二进制文件\n\n\nab\n只追加\n为输入打开一个二进制文件\n\n\nr+\n读写\n为既读又写打开一个已存在的文本文件\n\n\nw+\n读写\n为既读又写新建一个文本文件\n\n\na+\n读写\n为既读又写打开一个已存在的文本文件，文件指针移至为念末尾\n\n\nrb+\n读写\n为既读又写打开一个已存在的二进制文件\n\n\nwb+\n读写\n为既读又写新建一个二进制文件\n\n\nab+\n读写\n为读&#x2F;写打开一个二进制文件进行追加\n\n\n12.2.3 文件的操作\n\n\n\n\n\n\n\n12.2.4 文件的关闭\n\n\n\n\n\n12.2.5 文件操作示例\n在C盘目录下新建一个 “ fh.txt “ 的文件，用来保存键盘输入的字符，直到按回车键为止\n123字符输出函数（fputc）fputc函数使用格式：fputc(ch, fp_fh);将 ch 的值输出到 fp_fh 所指向的文件，并返回该字符，输出失败返回EOF\n\n1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    FILE *fp_fh;    errno_t err_fh; # 新版C语言的要求，老版本的省去    char str_fh;    err_fh = fopen_s(&amp;fp_fh,&quot;C:\\\\Users\\\\FHang\\\\Desktop\\\\fh.txt&quot;, &quot;w&quot;); # 老版本省去    if (err_fh != 0) # 老版本改为 if ((fp_fh = fopen(&quot;C:\\\\Users\\\\FHang\\\\Desktop\\\\fh.txt&quot;, &quot;w&quot;)) == NULL)     &#123;        printf(&quot;Can not find this file\\n&quot;);        exit(0);    &#125;    printf(&quot;Please input a string. Press enter key to end\\n&quot;);    while ((str_fh = getchar()) != &#x27;\\n&#x27;)    &#123;        fputc(str_fh, fp_fh);    &#125;    fclose(fp_fh);    printf(&quot;Create file fh.txt success.&quot;);    return 0;&#125;\n\n13. 链表13.1 链表的概念13.1.1 概念链表的每个节点都有两个部分：\n\n数据区和指针区。前者用来存储数据，后者用来存储指向下一个节点的指针；\n我们使用 malloc() 函数来为每个节点分配内存；\n节点的头部只含有指向第一个节点的指针;\n存储在栈区的 head 指向了存储在堆区的节点;\n堆区的节点又互相连接，形成链状的结构;\n最后一个节点的指针区被赋值为 NULL，标明了链表的结束。\n\n13.1.2 数组相关\n数组的缺点：\n正常情况下，创建的数组为固定大小的静态数组，当数组的数据内容出现增删，需要手动修改大小；\n如果一次性创建足够大的数组，会浪费内存空间；\n动态数组的创建（不会），麻烦；\n数组的内存空间是连续的，当需要添加或删除某一个元素时，其新元素之后的所有数组元素，需要逐一遍历更换内存地址，性能消耗大；\n\n\n数组的优点：\n数组的内存空间是连续的，直接通过数组小标查找数组元素，很高效；\n\n\n\n13.1.3 链表相关\n链表优点：\n链表的内存空间是非连续的，它们通过链表中的指针域，存储了下一个的链表的首地址，以此达到数据表相连；\n插入或删除指定链表时，只需要将新链表，以及前后链表的首地址和指针域进行相关改动即可，不会影响到所有的链表；\n只需要找到第一个链表节点，就能顺着指针域找到所有的链表；\n\n\n链表缺点：\n查找指定链表节点，需要从第一个节点顺着指针域一个个找下去，消耗性能大，远不及数组直接通过下标定位；\n当在整个链表的第一节点前插入新节点，原来找到的链表首节点，就不再是首节点，需要重新找；\n链表的每个节点都需要一块内存空间存储下一个节点的首地址；\n\n\n\n13.1.4 链表分类\n内存类型区分：\n静态链表\n动态链表：使用malloc()\n\n\n功能结构区分：\n单向链表\n双向链表\n循环链表\n单向循环链表\n双向循环链表\n\n\n\n13.2 静态链表13.2.1 静态链表的结构12345678910111213141516171819struct Node&#123;    int data; //数据域    struct Node* next; //指针域，用于存储下一个节点的首地址&#125;;int main()&#123;    // 初始化创建静态链表节点    struct Node Node1 = &#123;1, NULL&#125;;    struct Node Node2 = &#123;2, NULL&#125;;    struct Node Node3 = &#123;3, NULL&#125;;    // 将Node2的首地址存入Node1的next指针地址变量内    Node1.next = &amp;Node2;    Node2.next = &amp;Node3;        return 0;&#125;\n\n\n\n13.2.2 遍历打印静态链表123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123;    int data; //数据域    struct Node* next; //指针域，用于存储下一个节点的首地址&#125;;void printList()&#123;    struct Node node1 = &#123;1, NULL&#125;;    struct Node node2 = &#123;2, NULL&#125;;    struct Node node3 = &#123;3, NULL&#125;;    // 将Node2的首地址存入Node1的next指针地址变量内    node1.next = &amp;node2;    node2.next = &amp;node3;    // 遍历链表    // 先定义一个辅助指针变量    struct Node *pCurrent = &amp;node1;    while (pCurrent != NULL)    &#123;        // 将这个指针指向的内存空间中的节点元素打印        printf(&quot;%d\\n&quot;, pCurrent-&gt;data);        // 打印后，将节点的指针域内存放的下一个节点首地址，赋值给pCurrent，从而找到下一个链表节点        pCurrent = pCurrent-&gt;next;    &#125;&#125;int main()&#123;    printList();    system(&quot;pause&quot;);    return 0;&#125;\n\n\n\n13.3 动态链表(模块化)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//// Created by FHang on 2021/3/29.///* * 动态创建链表 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Node&#123;    int data; //数据域    struct Node *next; //指针域&#125;;// 创建链表struct Node *createList()&#123;    // headNode成为结构体变量    struct Node *headNode = (struct Node*)malloc(sizeof(struct Node));    // 变量使用前，需要初始化    // headNode-&gt;data = 1;    headNode-&gt;next = NULL;    return headNode;&#125;// 创建节点struct Node *createNode(int data)&#123;    struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));    newNode-&gt;data = data;    newNode-&gt;next = NULL;    return newNode;&#125;// 插入节点(表头法插入)void insertNodeByHead(struct Node *headNode, int data)&#123;    // 创建新的插入节点    struct Node *newNode = createNode(data);    newNode-&gt;next = headNode-&gt;next;    headNode-&gt;next = newNode;&#125;// 删除指定链表void deleteNode(struct Node *headNode, int posData)&#123;    struct Node *posNode = headNode-&gt;next;    struct Node *posNodeFront = headNode;    if (posNode == NULL)    &#123;        printf(&quot;Can&#x27;t Delete Null Linklist !\\n&quot;);    &#125;    else    &#123;        while (posNode-&gt;data != posData)        &#123;            posNodeFront = posNode;            posNode = posNodeFront-&gt;next;            if (posNode == NULL)            &#123;                printf(&quot;Can&#x27;t Find This Linklist !\\n&quot;);                return;            &#125;        &#125;        posNodeFront-&gt;next = posNode-&gt;next;        free(posNode);    &#125;&#125;// 打印void printList(struct Node *headNode)&#123;    struct Node *pMove = headNode-&gt;next;    while (pMove != NULL)    &#123;        printf(&quot;Data=%d\\n&quot;, pMove-&gt;data);        pMove = pMove-&gt;next;    &#125;    printf(&quot;\\n&quot;);&#125;int main()&#123;    struct Node *list = createList();    insertNodeByHead(list, 1);    insertNodeByHead(list, 2);    insertNodeByHead(list, 3);    printList(list);    deleteNode(list, 2);    printList(list);    system(&quot;pause&quot;);    return 0;&#125;\n\n\n\n\n\n\n\n例子1.  求百十个位的和1234567891011121314151617181920#include &lt;stdio.h&gt;#define Debug printf#define Enter scanf_sint main()&#123;    int enterNum, sumNum;    int b, s, g;    Debug(&quot;Enter Num : &quot;);    Enter(&quot;%d&quot;, &amp;enterNum);    b = enterNum / 100;    s = enterNum / 10 % 10;    g = enterNum % 10;    sumNum = b + s + g;    Debug(&quot;Sum=%d&quot;, sumNum);&#125;\n\n\n\n2. 求200-300之间素数和1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main()&#123;    int n, i;    int sum = 0;    for (n = 200; n &lt; 300; ++n)    &#123;        for (i = 2; i &lt; n / 2; ++i)        &#123;            if (n % i == 0)            &#123;                break;            &#125;        &#125;        if (i &gt;= n / 2)        &#123;            sum += n;            printf(&quot;%4d&quot;, n);        &#125;    &#125;    printf(&quot;\\n sum = %d&quot;, sum);    return 0;&#125;\n\n\n\n3. 斐波那契123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123;    int f1 = 1, f2 = 1, f3;    printf(&quot;1=%d\\n2=%d\\n&quot;, f1, f2);    for (int k = 3; k &lt;= 20; ++k)    &#123;        f3 = f1 + f2;        printf(&quot;%d=%d\\n&quot;, k, f3);        f1 = f2;        f2 = f3;    &#125;    return 0;&#125;\n\n\n\n4. 递增算法\n\n123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123;    int sum = 1;    for (int i = 9; i &gt;= 1; i--)    &#123;        sum = (sum + 1) * 2;        if (i == 1)        &#123;            printf(&quot;1 day has %d&quot;, sum);            break;        &#125;    &#125;    return 0;&#125;\n\n\n\n\n\n5. 100-999之间水仙花数123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123;    int sum, bw, sw, gw;    for (int i = 100; i &lt;= 999; ++i)    &#123;        bw = i / 100;        sw = i / 10 % 10;        gw = i % 10;        sum = bw * bw * bw + sw * sw * sw + gw * gw * gw;        if (sum == i)        &#123;            printf(&quot;%d\\t&quot;, sum);        &#125;    &#125;    return 0;&#125;\n\n\n\n\n\n6. 求 1!+2!+3!+…+10!123456789101112131415#include &lt;stdio.h&gt;int main()&#123;    long sum = 0, fact = 1;    for (int n = 1; n &lt;= 10 ; ++n)    &#123;        fact *= n;        sum += fact;    &#125;    printf(&quot;sum = %ld&quot;, sum);    return 0;&#125;\n\n\n\n\n\n7. 求多项式的值\n\n1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123;    float x = 0;    float sum = 1, term = 1;    printf(&quot;Enter X Num : &quot;);    scanf_s(&quot;%f&quot;, &amp;x);    for (int n = 1; n &lt;= 20 ; ++n)    &#123;        term = (-term * x) / x;        sum += term;    &#125;    printf(&quot;Calculate Num is %.2f\\n&quot;, sum);    return 0;&#125;\n\n\n\n\n\n8. 将整形一维数组的内容颠倒顺序12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main()&#123;    int sum = 0;    int arr[10] = &#123;11, 22, 33, 44, 55, 66, 77, 88, 99, 100&#125;;    for (int i = 0; i &lt; 10; ++i)    &#123;        printf(&quot;%4d&quot;, arr[i]);    &#125;    for (int i = 0, j = 9; i &lt; j; ++i, --j)    &#123;        sum = arr[i];        arr[i] = arr[j];        arr[j] = sum;    &#125;    printf(&quot;\\n&quot;);    for (int k = 0; k &lt; 10; ++k)    &#123;        printf(&quot;%4d&quot;, arr[k]);    &#125;    return 0;&#125;\n\n\n\n\n\n9. 将3行4列的数组值转置到4行3列123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main()&#123;    int arrA[3][4] = &#123;&#123;1, 2,  3,  4&#125;,                     &#123;5, 6,  7,  8&#125;,                     &#123;9, 10, 11, 12&#125;&#125;;    static int arrB[4][3];    printf(&quot;Before Transpose:\\n&quot;);    for (int i = 0; i &lt; 3; ++i)    &#123;        for (int j = 0; j &lt; 4; ++j)        &#123;            printf(&quot;%4d&quot;, arrA[i][j]);            arrB[j][i] = arrA[i][j];        &#125;        printf(&quot;\\n&quot;);    &#125;        printf(&quot;Later Transpose:\\n&quot;);    for (int i = 0; i &lt; 4; ++i)    &#123;        for (int j = 0; j &lt; 3; ++j)        &#123;            printf(&quot;%4d&quot;, arrB[i][j]);        &#125;        printf(&quot;\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n\n\n10. 将字符串1内容赋值到字符串2中1234567891011121314#include &lt;stdio.h&gt;int main()&#123;    char s2[50];    char s1[50] = &quot;abcdefghjklmn&quot;;    for (int i = 0; (s2[i] = s1[i]); ++i);    puts(s2);    return 0;&#125;\n\n\n\n\n\n11. 打印杨辉三角前10行12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main()&#123;    int arr[10][10];    for (int i = 0; i &lt; 10; ++i)    &#123;        for (int j = 0; j &lt;= i; ++j)        &#123;            if (j==0||i==j)            &#123;                arr[i][j] = 1;            &#125;            else            &#123;                arr[i][j] = arr[i-1][j-1] + arr[i-1][j];            &#125;        &#125;    &#125;    for (int i = 0; i &lt; 10; ++i)    &#123;        for (int j = 0; j &lt;= i; ++j)        &#123;            printf(&quot;%5d&quot;, arr[i][j]);        &#125;        printf(&quot;\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n\n\n12. 判断字符串或数字是否为回文1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string&gt;int main()&#123;    char enterStr[45];    int i, j;    gets(enterStr);    for (i = 0, j = strlen(enterStr) - 1; i &lt; j &amp;&amp; (enterStr[i] == enterStr[j]); ++i, --j);    if (i &lt; j)    &#123;        printf(&quot;No&quot;);    &#125;    else    &#123;        printf(&quot;Yes&quot;);    &#125;    return 0;&#125;\n\n1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main()&#123;    int x, y = 0, z;    printf(&quot;Enter:&quot;);    scanf_s(&quot;%d&quot;, &amp;z);    x = z;    while (x != 0)    &#123;        y = (10*y) + (x%10);        x = x/10;//        printf(&quot;x=%d\\n&quot;, x);//        printf(&quot;y=%d\\n&quot;, y);    &#125;    if (z == y)    &#123;        printf(&quot;Yes&quot;);    &#125;    else    &#123;        printf(&quot;No&quot;);    &#125;    return 0;&#125;\n\n\n\n13. 用递归算法计算n！1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;double funcFact(int n);int main()&#123;    int n = 0;    double factNum;    printf(&quot;Enter Num :&quot;);    scanf_s(&quot;%d&quot;, &amp;n);    factNum = funcFact(n);    printf(&quot;Fact = %.0lf&quot;, factNum);    return 0;&#125;double funcFact(int n)&#123;    double fact;    if (n == 1)    &#123;        fact = 1;    &#125;    else    &#123;        fact = n * funcFact(n - 1);    &#125;    return fact;    // 三目运算来表达    // return n == 1 ? 1 : n * funcFact(n - 1);&#125;\n\n\n\n14. 用递归计算1+2+…+n123456789101112131415161718#include &lt;stdio.h&gt;int funcSum(int n);int main()&#123;    int enterNum;    printf(&quot;Enter Num :&quot;);    scanf_s(&quot;%d&quot;, &amp;enterNum);    printf(&quot;Sum = %d&quot;, funcSum(enterNum));    return 0;&#125;int funcSum(int n)&#123;    return n == 1 ? 1 : n + funcSum(n - 1);&#125;\n\n\n\n15. 用循环和递归计算任意整数个位数之和\n循环\n\n123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123;    int n;    int sum = 0;    printf(&quot;Enter Num :&quot;);    scanf_s(&quot;%d&quot;, &amp;n);    while (n)    &#123;        sum += n % 10;        n = n / 10;    &#125;    printf(&quot;Sum = %d&quot;, sum);    return 0;&#125;\n\n\n递归\n\n123456789101112131415161718192021#include &lt;stdio.h&gt;int funcSum(int n);int main()&#123;    int n;    int sum;    printf(&quot;Enter Num :&quot;);    scanf_s(&quot;%d&quot;, &amp;n);    sum = funcSum(n);    printf(&quot;Sum = %d&quot;, sum);    return 0;&#125;int funcSum(int n)&#123;    return n &lt; 10 ? n : (n % 10) + funcSum(n / 10);&#125;\n\n\n\n16. 通过函数将数组内元素加101234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void funcAdd(int *p_arr, int eleCount, int addNum);int main()&#123;    int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    int eleCount;    eleCount = sizeof(arr) / sizeof(arr[0]);    funcAdd(arr, eleCount, 10);    for (int i = 0; i &lt; eleCount; ++i)    &#123;        printf(&quot;%3d&quot;, arr[i]);    &#125;    return 0;&#125;void funcAdd(int *p_arr, int eleCount, int addNum)&#123;    for (int i = 0; i &lt; eleCount; ++i)    &#123;        p_arr[i] += addNum;    &#125;&#125;\n\n\n\n17. 指针变量为形参，求数组元素和平均值123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;float funcCalculateAverage(const int *p_arr, int eleCount);int main()&#123;    int arr[6] = &#123;10, 20, 30, 40, 50, 11&#125;;    int eleCount;    eleCount = sizeof(arr) / sizeof(arr[0]);    printf(&quot;arr[%d] average = %.2f&quot;, eleCount, funcCalculateAverage(arr, eleCount));    return 0;&#125;float funcCalculateAverage(const int *p_arr, int eleCount)&#123;    int sum = 0;    float average;    for (int i = 0; i &lt; eleCount; ++i)    &#123;        sum += p_arr[i];    &#125;    average = (float)sum / (float)eleCount;    return average;&#125;\n\n\n\n18. 数组元素指针访问数组12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main()&#123;    int *p;    int arr[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;# 两种写法//    for (p = arr[0]; p &lt; arr[0] + 12; p++)//    &#123;//        if ((p - arr[0]) % 4 == 0)//        &#123;//            printf(&quot;\\n&quot;);//        &#125;//        printf(&quot;%3d&quot;, *p);//    &#125;    for (p = *(arr + 0); p &lt; *(arr + 0) + 12; p++)    &#123;        if ((p - *(arr + 0)) % 4 == 0)        &#123;            printf(&quot;\\n&quot;);        &#125;        printf(&quot;%3d&quot;, *p);    &#125;    return 0;&#125;\n\n\n\n19. 一维数组访问二维数组123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123;    int (*p)[4];    int arr[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;    p = arr;    for (int i = 0; i &lt; 3; ++i)    &#123;        for (int j = 0; j &lt; 4; ++j)        &#123;            printf(&quot;%3d&quot;, p[i][j]);//            printf(&quot;%3d&quot;, *(*(p + i) + j));//            printf(&quot;%3d&quot;, *(*(arr + i) + j));        &#125;        printf(&quot;\\n&quot;);    &#125;    return 0;&#125;\n\n1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123;    int (*p)[4], arr[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;    for (p = arr; p &lt; arr + 3; p++)    &#123;        for (int i = 0; i &lt; 4; ++i)        &#123;            printf(&quot;%3d&quot;, *(*p + i));//            printf(&quot;%3d&quot;, *(*(arr + x) + i)); -&gt; x 的取值为 0， 1， 2        &#125;        printf(&quot;\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n20. 指针数组访问另一个一维数组1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123;    int *p_Arr[5]; # == p_Arr0, p_Arr1, ... p_Arr4    int tag_Arr[5] = &#123;1, 2, 3, 4, 5&#125;;    for (int i = 0; i &lt; 5; ++i)    &#123;        p_Arr[i] = tag_Arr + i;    &#125;    for (int j = 0; j &lt; 5; ++j)    &#123;        printf(&quot;%3d&quot;, *p_Arr[j]);    &#125;    printf(&quot;\\n&quot;);    return 0;&#125;\n\n\n\n21. 指针数组的应用12345678910111213#include &lt;stdio.h&gt;int main()&#123;    char *p_StrArr[2] = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;    for (int i = 0; i &lt; 2; ++i)    &#123;        printf(&quot;%s\\n&quot;, p_StrArr[i]);    &#125;    return 0;&#125;\n\n","slug":"5.C语言基础_01","date":"2022-10-06T07:28:25.944Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"e341529351da1e239445a65d65dc3c4f","title":"不同虚拟机的配置方式","content":"[toc]\n不同虚拟机的配置方式虚拟机软件的选择：VirtualBox6.0及以上；VmwareWorkstation\nVirtualBox的配置方法：1. controller的安装过程：1.我们准备好centos7和iaas2.2的iso文件 \n2.在一个磁盘空间充足的磁盘下新建两个文件夹VT-controller; VT-compute, 之后的两个节点分别安装在这两个文件夹下 \n3.打开VirtualBox–新建–名称：Controller\n文件夹：选择之前新建的VT-controller文件夹所在地址\n类型：Linux\n版本：Other Linux（64bit）\n内存：4096MB\n虚拟硬盘：现在创建虚拟硬盘\n4.文件位置：默认\n5.文件大小：40GB\n6.虚拟硬盘类型：VDI\n7.存储在物理硬盘上：动态分配\n此时controller的模板创建好了\n1.管理–主机网络管理器–创建（创建两个虚拟网卡）\n第一块网卡（手动配置）– IPV4：192.168.100.1（内网）\n 子网掩码：255.255.255.0\nDHCP服务器关了\n第二块网卡（手动配置）– IPV4：192.168.200.1（外网）\n  子网掩码：255.255.255.0\n同样关掉DHCP服务\n2.主页面中–设置–系统（主板）–启动顺序：勾上网络，选中光驱，点边上的”向上“箭头移动到最上方\n（处理器）–处理器数量：4\n网络（网卡1）–启用网络连接–界面名称：第一网卡\n  方式：仅主机–高级–混杂：全部允许\n （网卡2）–界面名称为第二款网卡，其它配置同网卡1相同–OK\n3.在主页面中，存储–第二IDE控制器主通道（点击选择centos7.ios）\n4.启动（controller节点已经配置好了）\n2. controller节点的安装过程在centos安装之前，可以在安装界面按“Tab”键\n\n\n \n\n在原有的内容后面–空格–输入：net.ifnames&#x3D;0 biosdevname&#x3D;0\n可以禁用网卡命名规则，是的两块网卡（内网和外网）分别为eth0和eth1，方便后面使用，不过后面的内容里，要自觉将ifcfg-enp0s3和ifcfg-enp0s8换成ifcfg-eth0和ifcfg-eth1，即可\n1.Install Centos7\n2.Continue（默认英文，千万别选中文，搭建过程中会乱码和报错，之后也不会安装图形化界面，因为没必要）–SYSTEM选项中的（installtion  destination）–other storage options选项中：选中I will configure partioning\n3.Done–Click here to create them automatically（若有&#x2F;home目录，选中点击下面的‘—’号，可以删除，因为不需要）\n4.Done–Accept Changes\n5.Begin Installation\n6.此时在安装过程中可以设置Root用户的密码，密码：000000，因为方便；其它的不管\n7.reboot完成controller的安装\n3. compute的安装过程：1.新建–名称：Compute\n文件夹：选择之前新建的VT-controller文件夹所在地址\n类型：Linux\n版本：Other Linux（64bit）\n内存：2048MB\n虚拟硬盘：现在创建虚拟硬盘\n4.文件位置：默认\n5.文件大小：40GB\n6.虚拟硬盘类型：VDI\n7.存储在物理硬盘上：动态分配\n此时compute的模板创建好了\n1.主页面中–设置–系统（主板）–启动顺序：勾上网络，选中光驱，点边上的”向上“箭头移动到最上方\n（处理器）–处理器数量：2\n网络（网卡1）–启用网络连接–界面名称：第一网卡\n  方式：仅主机–高级–混杂：全部允许\n （网卡2）–界面名称为第二款网卡，其它配置同网卡1相同–OK\n2.在主页面中，存储–第二IDE控制器主通道（点击选择centos7.ios）\n3.启动（compute节点已经配置好了）\n4. controller节点的安装过程就照着上面controller节点的安装过程一样的步骤来\n至此两个节点都安装完毕！！！\n接着要对compute节点再照护一下，先将compute节点关机再操作\ncompute节点的磁盘分区（parted和fdisk两种方法，推荐用parted）\n1.在主页面中–（选中）compute节点–设置–存储–（存储介质：控制器IDE）最右边有个鼠标移上去会显示“添加虚拟硬盘”并点击–创建新的虚拟盘–文件大小：20GB–虚拟硬盘文件类型VDI–创建–OK\n2.开启compute节点（要对新添加的虚拟硬盘进行配置）\n5. 在compute中：（parted）123456789\\# fdisk -l可以看到Disk /dev/sdb\\# parted /dev/sdb \\#p\\#h\n\n4.可以看到如图的内容： \n\n\n\n\n6. 我们需要分别进行mklabel和mkpart12345678910111213\\#mklable gpt\\#mkpart cinder\\#xfs\\#0\\#8G\\#I\\#p\n\n6.此时可以看到已经分好了一个8G的分区cinder\n \n\n7.同理\n\n\n1\\#q（退出）\n\n此时swift的盘也分好了\ncinder和swift的盘分别对应这sdb1和sdb2，后面的IaaS搭建里的openrc配置里会用上\n7. fdisk的分区方法：sdb1的创建方式：  \n123\\#fdisk /dev/sdb \\#m\n\n\n\n可以看到帮助文档\n\n\n其中n为添加一个新的分区，w为分好后保存，退出（如果没有w，直接退出，就等于没分区）\n前几个都是默认即可，回车\n一直到 Last sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +8G\n+size{K,M,G} 其中，+size是你要划分的大小数值，{K,M,G}里的三个为可选的单位，我们这里仅为演示所以我是+8G\n#w （保存，退出）\n此时一个分区创建好了（sdb1）\nsdb2的创建方式如下：\n\n\n1\\#fdisk -l\n\n可以看到两个都创建好了 \n这里关于compute节点的磁盘分区就到这了！\n接着在compute节点中：\n123\\#parted /dev/sd*（可以看到其中有sda, sda1, sda2, sdb, sdb1, sdc, sdc1；其中sdb1,sdb2分别为后面要配置的cinder和swift两个云盘）\n\n以上就是VirtualBox的配置方法\n接下来就是VmwareWorkstation的配置方式\n首先在主页面的上菜单栏中–编辑–虚拟网络编辑器–(VmwareWorkstation自己默认有一个VMnet0)–添加网络（添加两个，分别为VM net1，VMnet2）–选中VMnet1–在VMnet信息中选中‘仅主机模式’–选中‘将主机虚拟适配器连接到此网络’，取消使用本地DHCP–子网IP：192.168.100.0–子网掩码：255.255.255.0（内网）\n选中VMnet2–在VMnet信息中选中‘NAT模式’–选中‘将主机虚拟适配器连接到此网络’，取消使用本地DHCP–子网IP：192.168.200.0–子网掩码：255.255.255.0（外网）\n网卡配置好了，接下来是两个控制节点\n8. controller的安装过程：1.我们准备好centos7和iaas2.2的iso文件 \n2.在一个磁盘空间充足的磁盘下新建两个文件夹VM-controller; VM-compute, 之后的两个节点分别安装在这两个文件夹下\n3.在主页面中–创建新的虚拟机–典型–下一步–稍后安装操作系统–下一步：客户机操作系统：Linux–下一步\n 版本：centos7 64位\n4.虚拟机名称：Controller\n 位置：你所创建的VM-controller文件夹的地址–下一步\n 最大磁盘大小：40GB\n 选中：将虚拟磁盘拆分成多个文件–下一步–自定义硬件：内存：4GB\n  处理器数量和内核都选：2；虚拟化引擎：选中‘虚拟化 InterVT-x&#x2F;EPT或AMD-V&#x2F;RVI ’\n  选中‘新CD&#x2F;DVD（IDE）’：添加一个新的‘新CD&#x2F;DVD（IDE）’\n  （两个IDE的设备状态选中启动时连接，连接选中使用ISO映像文件）\n  浏览：centos7.iso文件的地址，第二个IDE选中iaas2.2.iso文件地址\n   选中‘网络适配器’：添加一个新的‘网络适配器2’\n（两个网络适配器，第一个：仅主机模式；第二个：默认NAT模式）–关闭–完成\n5.鼠标移到创建好的controller节点上–右击–管理–克隆–下一步–下一步–创建方法：链接克隆–下一步–虚拟机名称：Compute\n位置–浏览：VM-compute文件夹位置\n–完成–关闭\n6.编辑虚拟机–内存：2\n处理器数量和内核都选：1；虚拟化引擎：选中‘虚拟化 InterVT-x&#x2F;EPT或AMD-V&#x2F;RVI ’\n（其它不用动）\n两个节点的配置完成，安装过程和VirtualBox的安装过程一样\n接下来就是VmwareWorkstation中compute节点的添加磁盘了\n选中compute节点–编辑虚拟机设置–硬盘–添加（硬盘，添加两个）–下一步–默认推荐–创建新虚拟硬盘–磁盘大小：20GB–将虚拟硬盘拆分成多个文件–下一步–完成\n（第二块硬盘的文件名不可与第一块硬盘文件名相同，随别改一个）\n现在启动compute节点，接下来的步骤和VirtualBox的磁盘配置方法相同\n至此，两个不同虚拟机软件对两个不同节点的配置和磁盘划分的方法介绍完毕！！！\n请看下一篇secureCRTP连接虚拟机！！！\n","slug":"3.不同虚拟机的配置方式_01","date":"2022-10-06T07:28:25.941Z","categories_index":"云计算","tags_index":"IaaS","author_index":"FangH"},{"id":"60a02aae4ddcc163be15d5053e1b9c2a","title":"secureCRT上传镜像","content":"[toc]\nsecureCRT上传镜像本文为如何在secureCRT中往虚拟机中上传镜像文件\n打开secureCRT后\n1.\n\n将鼠标移到192.168.100.10的标签，右击–打开secureFX\n2.\n\n选中本地里的XianDian-Iaas-v2.2.iso和CentOS-7-x86_64-DVD-1511.iso文件，右击–上传（直接确定默认的选项即可）\n本人这里已经上传好了（上传到root目录下，如上图所示）\n注：此处还可以额外从本地上传如上图中的  cirros-0.3.4-x86_64-disk.img ,因为XianDian和CentOS的镜像较大，后期建立云主机电脑内存不够可能会创建失败，该额外提供的镜像非常小，后期创建云主机时如果电脑内存足够大，可以用CentOS的镜像，如果不够，就用这个小镜像\n至此，secureCRT上传镜像文件的方法介绍完了，搭建IAAS时会用上这个！！！\n请看下一篇IAAS搭建！！！\n","slug":"3.secureCRT上传镜像_03","date":"2022-10-06T07:28:25.939Z","categories_index":"云计算","tags_index":"IaaS","author_index":"FangH"},{"id":"356a9c77ef7da7d0d7efea2dfccf8eb9","title":"secureCRT连接虚拟机","content":"[toc]\nsecureCRT连接虚拟机本文介绍使用secureCRTP连接虚拟机，因为secureCRTP使用方便，观感也很好，还可以定制字体和字号，支持复制粘贴功能和上传镜像功能，这些功能在后面IAAS搭建里十分好用\n虚拟机要想能通过CRT连接，就必须要将虚拟机的网络环境配置好，也是IAAS搭建的基本要求条件\ncentos7的网络配置文件在 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;下\ncontroller和compute两个节点的配置方法基本相同，首先介绍controller的配置方式\n[root@controller ~]#\ncontroller的网络配置\n\n\n1.#cd  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;\n（将工作台切换到该目录下）\n\n\n\n2.#ls  ifcfg-enp*\n（查看所有以ifcfg-enp*  开头的文件）\n\n\n此时应该可以看到两个文件，如果不是两个，说明你之前的虚拟机网卡配置错了\n以本人的为例，出现了ifcfg-enp0s3和ifcfg-enp0s8两个文件，也就是两个网卡配置文件\n此处，我们以ifcfg-enp0s3为内网，ifcfg-enp0s8为外网，进行配置，至于为什么，上一篇有提示过\n3.#vi ifcfg-enp0s3\n按照我这样配置：（按‘i’进行修改，按‘Esc’退出修改，按‘shift’加‘x’保存退出，后面经常用，不过多阐述；如果后面如果输错文件名，退出修改后按‘shift’+‘q！’，不保存退出文件）\nTYPE&#x3D;Ethernet\n\n\n\nBOOTPROTO&#x3D;static\n（此处修改）\n\n\n\n\n\n\n\nDEFROUTE&#x3D;yes\nPEERDNS&#x3D;yes\nPEERROUTES&#x3D;yes\nIPV4_FAILURE_FATAL&#x3D;no\nIPV6INIT&#x3D;yes\nIPV6_AUTOCONF&#x3D;yes\nIPV6_DEFROUTE&#x3D;yes\nIPV6_PEERDNS&#x3D;yes\nIPV6_PEERROUTES&#x3D;yes\nIPV6_FAILURE_FATAL&#x3D;no\nNAME&#x3D;enp0s3\nUUID&#x3D;e0c0cc4d-0233-4f43-b71e-8b18920330cb\nDEVICE&#x3D;enp0s3\n\n\n\nONBOOT&#x3D;yes\n（此处修改）\n\n\n\nIPADDR&#x3D;192.168.100.10\n（此处为添加）\n\n\nGATEWAY&#x3D;192.168.100.1\n（此处为添加）\n\n\nNETMASK&#x3D;255.255.255.0\n（此处为添加）\n\n\n保存，退出\n4.#vi ifcfg-enp0s8\n分别将：\n\n\n\nBOOTPROTO&#x3D;static\n（此处修改）\n\n\n\nONBOOT&#x3D;yes\n（此处修改）\n\n\nIPADDR&#x3D;192.168.200.10\n（此处为添加）\n\n\nNETMASK&#x3D;255.255.255.0\n（此处为添加）\n\n\n注意：外网不添加GATEWAY这一项\n保存，退出\n\n\n\n5.#cd\n（将工作台切换到根目录下）\n\n\n\n6.#service  network restart\n（重新启动网卡，如果出现：Restarting network (via systemctl): [   OK ]，说明配置完成）\n\n\ncompute的网络配置[root@compute ~]#\n方法同controller一样，此处只提出不同的地方\n1.#vi ifcfg-enp0s3\n\n\n\nBOOTPROTO&#x3D;static\n（此处修改）\n\n\n\nONBOOT&#x3D;yes\n（此处修改）\n\n\nIPADDR&#x3D;192.168.100.20\n（此处为添加）\n\n\nNETMASK&#x3D;255.255.255.0\n（此处为添加）\n\n\nGATEWAY&#x3D;192.168.100.1\n（此处为添加）\n\n\n保存，退出\n2.#vi ifcfg-enp0s8\n\n\n\nBOOTPROTO&#x3D;static\n（此处修改）\n\n\n\nONBOOT&#x3D;yes\n（此处修改）\n\n\nIPADDR&#x3D;192.168.200.20\n（此处为添加）\n\n\nNETMASK&#x3D;255.255.255.0\n（此处为添加）\n\n\n保存，退出\n3.#cd\n4.#service network restart\n至此controller和compute的两个节点的网络配置完毕，此时可以使用CRT进行连接使用了\nsecureCRTP的连接：\n1.首先打开CRT，进行controller的连接\n2.文件–快速连接（出现如下窗口）\n\n\n3.主机名：192.168.100.10\n  用户名：root\n  连接–输入密码：000000–保存密码–确定\n  （此时已经连上controller的虚拟机）\n4.鼠标右击192.168.100.10的标签–会话选项\n本人的配置方法如下（个人觉的比较好看）\n\n\ncompute的连接过程和controller相同\n主机名：192.168.100.20\n（其他都一样好了）\n至此用secureCRTP连接虚拟机的内容介绍完毕，接下来就是进入正题了\n请看下一篇secureCRTP上传镜像！！！\n","slug":"3.secureCRT连接虚拟机_02","date":"2022-10-06T07:28:25.936Z","categories_index":"云计算","tags_index":"IaaS","author_index":"FangH"},{"id":"6a417038b30356b420810aef9fa30ba4","title":"Iaas搭建","content":"Iaas搭建[toc]\n\n\n以上是IAAS平台的基本环境配置，这些服务配置将在接下来的内容了呈现\ncontroller和compute两节点都要打开\n1.主机名的配置12345678910111213controller：\\#hostnamectl set-hostname controller\\#bash compute：\\#hostnamectl set-hostname compute\\#bash\n\n2.配置映射文件controller和compute都要配置\n1\\#vi /etc/hosts\n\n进行如下配置：\n保存退出\n3.配置controller的yum源首先配置controller的yum源\n12345678[root@controller ~]#\\#cd /etc/yum.repos.d/ \\#rm -rvf *\\#vi [ftp.repo](http://ftp.repo) | 创建源文件\n\n\n\n配置内容如下：\n\n\ncompute的yum源先不急着配\n4.挂载iso文件（上一篇上传镜像后，才能继续进行接下来的IAAS搭建）在上一篇中提到一个小镜像cirros-0.3.4-x86_64-disk.img，此时也可以进行下一步，对电脑配置自信的可以忽略，\n1234567891011121314151617[root@controller ~]# \\#cd\\#cd /opt/ \\#mkdir  &#123;centos，iaas&#125;   | （在/opt 目录下建立两个文件夹，用来挂载接下来的两个镜像文件）  \\#mkdir  cirros  |  （此处选做）  \\#cd\\#mount -o loop CentOS-7-x86_64-DVD-1511.iso /opt/centos/  |  （上传Centos的镜像到centos文件夹下）    \\#mount -o loop XianDian-IaaS-v2.2.iso /opt/iaas/  |  （此处和上面同理）      \\#mount -o  loop cirros-0.3.4-x86_64-disk.img  /opt/cirros/  \n\n挂载成功会出现read-only等字样\n123#yum clean  all      （清除缓存）  #yum list      （验证yum源）  \n\n5.搭建ftp服务器，开启并设置自启12345[root@controller ~]##yum install  -y vsftpd    （搭建ftp服务器）    #vi /etc/vsftpd/vsftpd.conf    （修改ftp的配置文件）  \n\n\n\n\n\n如上图所示，在原文本中添加\n1anon_root=/opt/\n\n保存退出\n123#systemctl  restart vsftpd      （重启ftp服务）  #systemctl enable vsftpd      （设置开机自启）  \n\n6.关闭防火墙并设置开机不自启controller和compute都要做：\n123#setenforce 0#getenforce      （出现Permissive则表示防火墙的安全级别已经降低了）  \n\n这种方式时临时的，如果重启了虚拟机，需要再执行一次\n123#systemctl  stop firewalld    （关闭防火墙）    #systemctl  disable firewalld    （设置防火墙开机不自启）  \n\n7.配置compute的yum源先前已经配好了controller的yum源，这里只要用scp传过来，进行一些修改即可\n12345678910111213[root@compute ~]#\\#cd /etc/yum.reops.d/\\#rm -rvf *\\#scp 192.168.100.10://etc/yum.repos.d/* .出现（yes/no）和password就依次填写yes和000000，后面还会遇到几次，也是同样的方法\\#cd /etc/yum.repos.d/\\#vi [ftp.repo\n\n\n\n照着上图进行修改从controller传来的ftp.repo文件内容即可\n接着顺便清除缓存和验证compute的yum源\n12345\\#cd\\#yum clean all\\#yum list\n\n这些都做好后进行下一步操作\n8.编辑controller和compute的环境变量1\\#yum install -y iaas-xiandian\n\n接下来是编辑文件&#x2F;etc&#x2F;xiandian&#x2F;openrc.sh,此文件是安装过程中的各项参数，根据每项参数上一行的说明及服务器实际情况进行配置。\n首先编辑controller的openrc.sh脚本文件\n123[root@controller ~]# \\#vi /etc/xiandian/openrc.sh\n\n出现如下图的文件内容：\n\n\n上图是我已经修改过的（注意：该脚本文件配置每一个环节都不能有错，不然后面有些脚本会执行失败！！！）\n配置内容：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667HOST_IP=192.168.100.10HOST_NAME=controllerHOST_IP_NODE=192.168.100.20HOST_NAME_NODE=computeRABBIT_USER=openstackRABBIT_PASS=000000DB_PASS=000000DOMAIN_NAME=demo（自定义）ADMIN_PASS=000000DEMO_PASS=000000KEYSTONE_DBPASS=000000GLANCE_DBPASS=000000GLANCE_PASS=000000NOVA_DBPASS=000000NOVA_PASS=000000NEUTRON_DBPASS=000000NEUTRON_PASS=000000METADATA_SECRET=000000INTERFACE_NAME=enp0s8（外网网卡名，第一篇文章有提到）CINDER_DBPASS=000000CINDER_PASS=000000TROVE_DBPASS=000000TROVE_PASS=000000BLOCK_DISK=sdb1（空白分区名，第一篇文章里有提到）SWIFT_PASS=000000OBJECT_DISK=sdc1（空白分区名）STORAGE_LOCAL_NET_IP=192.168.100.20HEAT_DBPASS=000000HEAT_PASS=000000CEILOMETER_DBPASS=000000CEILOMETER_PASS=000000AODH_DBPASS=000000AODH_PASS=000000（注意要去掉前面的‘#’）\n\n保存，退出\n至此，controller的openrc.sh配置好了，接下来传给compute的就可以了\n12345[root@controller ~]#\\#scp /etc/xiandian/openrc.sh 192.168.100.20://etc/xiandian/openrc.sh输入：yes--输入：000000\n\n此时两个节点的openrc.sh都配好了，建议都进行一下接下来的命令：\ncontroller和compute\n1\\#source /etc/xiandian/openrc.sh\n\n\n\n接下来就是进入脚本跑酷环节！！！\n9.通过脚本安装服务（内容包括：安装Openstack包，配置域名解析，配置防火墙和Selinux，安装ntp服务）\ncontroller和compute：\n1\\#iaas-pre-host.sh\n\n安装完成后会提示重启。因为我们在本篇内容第一步修改了主机名，所以不需要重启\n10.通过脚本安装服务（内容包括：安装Mysql数据库服务，安装Mongo数据库服务，安装RabbitMQ服务，安装memcahce）\n123[root@controller ~]#\\#iaas-install-mysql.sh\n\n11.通过脚本安装keystone认证服务（内容包括：安装keystone服务软件包，创建Keystone数据库，配置数据库连接，为keystone服务创建数据库表，创建令牌，创建签名密钥和证书，定义用户、租户和角色，创建admin-openrc.sh）\n123[root@controller ~]#\\#iaas-install-keystone.sh\n\n12.通过脚本安装glance服务（内容包括：安装Glance镜像服务软件包，创建Glance数据库，配置文件创建数据库连接，为镜像服务创建数据库表，创建用户，配置镜像服务，创建Endpoint和API端点，启动服务，上传镜像）\n123[root@controller ~]#\\#iaas-install-glance.sh\n\n\n\n13.通过脚本Nova计算服务（内容包括：安装Nova 计算服务软件包，创建Nova数据库，创建计算服务表，创建用户，配置计算服务，创建Endpoint和API端点 ，启动服务，验证Nova，安装Nova计算服务软件包，配置Nova服务，检查系统处理器是否支持虚拟机的硬件加速，启动，清除防火墙）\ncontroller和compute同时：\n1234567[root@controller ~]#\\#iaas-install-nova-controller.sh[root@compute ~]#\\#iaas-install-nova-compute.sh\n\n14.通过脚本安装neutron服务（内容包括：创建Neutron数据库，创建用户，创建Endpoint和API端点 ，安装neutron网络服务软件包，配置Neutron服务，编辑内核，创建数据库，启动服务和创建网桥，安装软件包，配置Neutron服务，编辑内核，启动服务进而创建网桥）\ncontroller和compute同时：\n1234567[root@controller ~]#\\#iaas-install-neutron-controller.sh[root@compute ~]#\\#iaas-install-neutron-compute.sh\n\n\n\n接下来就是网络模式的选择\n123[root@controller ~]##iaas-install-neutron-controller-      （按两次‘Tab’）   \n\n可以看见：\n12345iaas-install-neutron-controller-flat.sh iaas-install-neutron-controller-gre.sh  iaas-install-neutron-controller-vlan.sh\n\n我们选择安装gre.sh\n15.选择Neutron网络模式controller和compute同时：\n1234567[root@controller ~]#iaas-install-neutron-controller-gre.sh[root@compute ~]#iaas-install-neutron-compute-gre.sh\n\n16.通过脚本安装dashboard服务（内容包括：安装Dashboard服务软件包，配置，启动服务）\n123[root@controller ~]#\\#iaas-install-dashboard.sh\n\n此时可以通过浏览器网址栏输入http://192.168.100.10/dashboard进入先电云计算平台\n域：demo\n用户名：admin\n密码：000000\n17.网络–网络–创建网络点击创建网络，我这里已经创建好了\n\n\n\n\n\n\n点击已创建\n18.管理员–网络–创建网络\n\n提交\n创建好后–点击网络名称中的ext\n子网–创建子网\n\n\n下一步\n\n\n已创建\n19.网络–路由–新建路由\n\n点路由名称route–接口–增加\n\n\n\n\n20.安装cinder之前做个准备工作1234567[root@controller ~]# \\#source /etc/keystone/admin-openrc.sh\\# glance image-create --name centos7 --disk-format qcow2 --container-format bare --progress &lt; /opt/iaas/images/CentOS_7.2_x86_64_XD.qcow2 （此处将CentOS的镜像上传，下一步可以一次在平台上建立一个虚拟机，做测试）\n\n上一篇文章介绍了如何用secureCRTP上传镜像，其中补充了一个小镜像也可以用上面一样的命令上传到先电平台\n1\\# glance image-create --name cirros --disk-format qcow2 --container-format bare --progress &lt; /opt/iaas/images/cirros-0.3.4-x86_64-disk.img\n\n21.在云平台中–计算–云主机–创建云主机\n启动实例\n绑定浮动IP–‘+’–分配IP–关联\n\n\n\n\n\n\n22.计算–访问&amp;安全–（defult）管理规则–删除原有的规则–添加规则\n\n\n\n分别添加–所有ICMP，所有TCP，所有UDP–并且各自添加 出口 和 入口\n如上图所示\n此时可以访问之前创建好的云主机123了，启动云主机后，可以直接在CRT上连接\n好，继续脚本跑酷！！！\n23.通过脚本安装Cinder服务（内容包括：安装Cinder块存储服务软件包，创建数据库，创建用户，创建Endpoint和API端点 ，配置Cinder服务，创建数据库，启动服务，安装块存储软件，创建LVM物理和逻辑卷，修改Cinder配置文件，重启服务，验证）\ncontroller和compute同时：\n1234567[root@controller ~]#\\#iaas-install-cinder-controller.sh[root@compute ~]# \\#iaas-install-cinder-compute.sh\n\n完成后接着还有一步：\n123[root@controller ~]#\\#source /etc/keystone/admin-openrc.sh\n\n24.通过脚本安装Swift服务（内容包括：创建用户，创建Endpoint和API端点 ，编辑&#x2F;etc&#x2F;swift&#x2F;proxy-server.conf，创建账号、容器、对象，编辑&#x2F;etc&#x2F;swift&#x2F;swift.conf，启动服务和赋予权限，安装软件包，配置rsync，配置账号、容器和对象，修改Swift配置文件，重启服务和赋予权限）\ncontroller和compute同时：\n1234567[root@controller ~]#\\#iaas-install-swift-controller.sh[root@compute ~]# \\#iaas-install-swift-compute.sh\n\n25.通过脚本安装Trove服务（内容包括：安装Trove数据库服务的软件包，创建数据库，创建用户，创建Endpoint和API端点 ，配置trove.conf文件，配置trove-taskmanager.conf，配置trove-conductor.conf文件，配置trove-guestagent.conf，同步数据库，启动服务）\n需注意安装Trove服务之前需要配置好网络（flat或gre）,创建好子网，并确认系统已经安装swift和cinder两个服务，否则安装会失败。\n123[root@controller ~]#\\#iaas-install-trove.sh\n\n26.查看上传的镜像123[root@controller ~]#\\#cat /usr/local/bin/iaas-install-trove.sh\n\n（查看上传的镜像）\n\n\n\n\n27.上传镜像将提供的MySQL_5.6_xiandian.qcow2 上传到系统内\n123[root@controller ~]#\\#glance image-create --name &quot;mysql-5.6&quot; --disk-format qcow2 --container-format bare --progress &lt; MySQL_5.6_XD.qcow2\n\n\n\n\n\n1\\# ls /opt/iaas/images\n\n如上图可以查看到 MySQL_5.6_XD.qcow2 已经成功上传\n28.创建数据库存储123[root@controller ~]#\\# trove-manage datastore_update mysql &#x27;&#x27;\n\n29.使用上传的镜像更新数据库123[root@controller ~]#\\# trove-manage datastore_version_update mysql mysql-5.6 mysql $&#123;Glance_Image_ID&#125; &#x27;&#x27; 1\n\n将其中${Glance_Image_ID} 改为26节第一张图里面的ID后面的字符串\n123\\# trove create mysql-1 $&#123;FLAVOR_ID&#125; --size 5 --databases myDB --users user:r00tme --datastore_version mysql-5.6 --datastore mysql\n\n将其中${FLAVOR_ID}改为2\n创建完成后查询trove列表\n123[root@controller ~]#\\#trove list\n\n\n\n30.通过脚本安装heat服务（内容包括：安装heat编配服务软件包，创建数据库，创建用户，创建Endpoint和API端点 ，配置Heat服务，创建数据库，启动服务）\n123[root@controller ~]#\\#iaas-install-heat.sh\n\n\n\n31.nginx模板nginx模板文件存放在&#x2F;etc&#x2F;xiandian&#x2F;目录下，在使用模板之前需成功安装，ceilometer监控服务以及alarm监控服务。\n123[root@controller ~]#\\#ls /etc/xiandian/\n\n可以查看nginx模板\n构建一台http服务器，将lb-server.yaml模板文件上传至http服务器中。\n32.通过脚本安装Ceilometer服务（内容包括：安装Ceilometer监控服务软件包，创建数据库，创建用户，创建Endpoint和API端点 ，配置Ceilometer，启动服务，监控组件，安装软件包，配置Ceilometer）\ncontroller和compute同时：\n1234567[root@controller ~]#\\#iaas-install-ceilometer-controller.sh[root@compute ~]# \\#iaas-install-ceilometer-compute.sh\n\n33.通过脚本安装alarm服务（内容包括：创建数据库，创建keystone用户，创建Endpoint和API，安装软件包，配置aodh，同步数据库，启动服务）\n123[root@controller ~]#\\#iaas-install-alarm.sh\n\n\n\n34.添加控制节点资源到云平台修改openrc.sh，把compute节点的IP和主机名改为controller节点的IP和主机名\n123[root@compute ~]# \\#vi /etc/xiandian/openrc.sh\n\n修改以下参数为：\n123HOST_IP_NODE=192.168.100.10HOST_NAME_NODE=controller\n\n保存退出\n修改结果如上图所示\n123[root@controller ~]#\\#iaas-install-nova-compute.sh\n\n将compute的资源添加到controller中\n最后提供一个卸载脚本命令\n35.系统卸载系统提供一键卸载脚本，节点运行iaas-uninstall-all.sh脚本，脚本卸载当前节点的所有云平台数据，如果卸载节点为controller节点则会清除所有的数据（此时云平台也被清空），如果卸载节点为compute节点则会删除compute节点的数据。\ncontroller和compute同时：\n1234567[root@controller ~]#\\#iaas-uninstall-all.sh[root@compute ~]# \\#iaas-uninstall-all.sh\n\n至此，IAAS平台搭建完成！！！\n请看下一篇PAAS的平台搭建！！！\n","slug":"3.Iaas搭建_04","date":"2022-10-06T07:28:25.933Z","categories_index":"云计算","tags_index":"IaaS","author_index":"FangH"},{"id":"d96e73c46a21215b2a6710733d95f450","title":"HTML","content":"HTML[toc]\n1.HTML的基本格式12345678&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;title&gt;…&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n​\t\n​\t\n123456789101112131415161718192021222324252627282930313233标签：&lt;title&gt;…&lt;/title&gt; 位于&lt;head&gt;…&lt;/head&gt;之间，用于浏览器标题。&lt;p&gt;…&lt;/p&gt;位于&lt;body&gt;…&lt;/body&gt;\t用于段落位置\t\t居中：&lt;p align=&quot;center&quot;&gt;…&lt;/p&gt;\t\t左对齐：&lt;p align=&quot;left&quot;&gt;…&lt;/p&gt;\t\t右对齐：&lt;p align=&quot;right&quot;&gt;…&lt;/p&gt;\t\t不产生段落间距换行：&lt;br&gt;\t预格式标记：&lt;pre&gt;…&lt;/pre&gt;\t\t文本标题：Dreamweaver 提供6种标准的标题样式\t\t&lt;h1&gt;…&lt;/h1&gt;\t\t&lt;h2&gt;…&lt;/h2&gt;\t\t&lt;h3&gt;…&lt;/h3&gt;\t\t&lt;h4&gt;…&lt;/h4&gt;\t\t&lt;h5&gt;…&lt;/h5&gt;\t\t&lt;h6&gt;…&lt;/h6&gt;\t\t(从上到下依次由大变小)\t\t设置文本格式\t\t可以设置字体：&lt;font face=&quot;字体&quot;&gt;…&lt;/font&gt;\t\t字号：&lt;font size=&quot;字体字号&quot;&gt;…&lt;/font&gt;\t\t\t1~7号字体为绝对大小；-4~+4为相对3号的缩小与放大。\t\t颜色：&lt;font color=&quot;字体颜色&quot;&gt;…&lt;/font&gt;\t\t\t设置文本样式\t\t常用的格式化标记：\t\t\t加粗：&lt;b&gt;…&lt;/b&gt;\t\t&lt;strong&gt;…&lt;/strong&gt;\t\t\t斜体:&lt;i&gt;…&lt;i&gt;\t\t&lt;em&gt;…&lt;/em&gt;    &lt;cite&gt;…&lt;/cite&gt;\t\t\t上标：&lt;sup&gt;…&lt;/sup&gt;\t\t下标：&lt;sub&gt;…&lt;/sub&gt;\t\t\t下划线：&lt;u&gt;…&lt;/u&gt;\t\t中划线：&lt;s&gt;…&lt;/s&gt;\t\t\t闪烁：&lt;blink&gt;…/blink&lt;&gt;\t\t\n\n2.列表​\t无序列表：位于…之间。\n123&lt;ul&gt;\t&lt;li&gt;…&lt;/li&gt;&lt;/ul&gt;\n\n\n\n1234567891011121314151617181920type值：&lt;ul type=&quot;disc&quot;&gt;\t\t\t   \t&lt;li&gt;…&lt;/li&gt;\t\t\t   &lt;/ul&gt;\t\tdisc(默认值)：实心圆\t\tcircle：空心圆\t\tsquare:实心正方形\t\t有序列表：\t&lt;ol&gt;…&lt;/ol&gt;\t\ttype:&lt;ol type=&quot;l&quot;&gt;\t\t   &lt;li&gt;…&lt;/li&gt;\t\t   &lt;/ol&gt;\t\t\ttype:\t\tl（默认）：1，2，3，4…\t\ta: a, b, c, d…\t\tA: A, B, C, D…\t\ti: i, ii, iii, iv…\t\tI: I, II, III, IV…\n\n3.列表嵌套12345678910无序中嵌入有序\t&lt;body&gt;\t\t&lt;ul&gt;\t\t\t&lt;li&gt;…\t\t\t\t&lt;ol&gt;\t\t\t\t\t&lt;li&gt;…&lt;/li&gt;\t\t\t\t&lt;/ol&gt;\t\t\t&lt;/li&gt;\t\t&lt;/ul&gt;\t&lt;/body&gt;\n\n1234567插入符号：\t&amp;nbsp:空格\t&amp;copy:版权\t&amp;lt:小于号“&lt;”\t&amp;gt:大于号“&gt;”\t&amp;quot:双引号“&quot;&quot;”水平线：&lt;hr&gt;\t&lt;hr align=&quot;center&quot; width=&quot;200&quot; size=&quot;5&quot; noshade=&quot;noshade&quot; color=&quot;#FF0000&quot; id=&quot;line&quot;&gt;\t\t\talign:对齐方式\twidth:宽度（长度）\tsize:高度\tcolor:颜色\tnoshade:阴影\n\n4.文件头标签12345678910插入关键字&lt;meta&gt;位于&lt;head&gt;…&lt;/head&gt;&lt;meta name=&quot;keywords&quot; content=&quot;…&quot;&gt;插入说明：对网页内容的详细说明&lt;meta name=&quot;description&quot; content=&quot;…,…&quot;&gt;刷新：指网页的刷新时间或跳转至其他页面的功能&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10&quot;&gt;\t一定时间后跳转至其他页面\t&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10;url=…网页地址…&quot;&gt;\n\n5.使用图像12345678910111213141516插入图像：&lt;img src=&quot;图片地址/图片名.jpg&quot; width=&quot;600&quot; height=&quot;404&quot;/&gt;地址：\t绝对地址：文件所在具体位置\t相对地址：与网页同一级目录\t\t例子：C &gt;&gt; user &gt;&gt; html &gt;&gt; photo &gt;&gt; p1.jpg\t\t\t\t\t\t\t   p1.jpg                     p2.jpg\t\t\t绝对地址：/photos/p1.jpg\t\t\t相对地址：p1.jpg\t\t\t图像属性\talt:&lt;img src=&quot; &quot; alt=&quot;…&quot;/&gt; 图像无法显示时，显示alt内容。\tborder:&lt;img src=&quot; &quot; border=&quot;…/&quot;&gt; 给图像加边。\talign:&lt;img src=&quot; &quot; align=&quot;…/&quot;&gt; 给图像对齐。\t\talign=&quot;right, left, top, bottom&quot;\n\n6.vspace与hspace：设置水平，垂直边距。​\t\n7.网页背景图像​\t\n12插入背景图像，位于&lt;body&gt;…&lt;/body&gt;中&lt;body backgroup=&quot;图片地址&quot;&gt;&lt;/body&gt;\n\n\n\n8.网页背景音乐12&lt;embed src=&quot;音乐地址&quot; hidden=&quot;true&quot; autostart=&quot;true&quot; loop=&quot;-1&quot;&gt;当loop为-1或infinite时，播放次数为无限次。\n\n\n\n9.设置背景图像不随页面滚动123&lt;body style=&quot;backgroup-attachment=fixed&quot;; backgroup=&quot;地址&quot;&gt;&lt;/body&gt;backgroup-attachment=fixed为背景附加属性“固定”backgroup-position=center为背景位置设置为“中心”\n\n​\t\n10.滚动标签：marquee123456789101112131415161718192021222324252627282930313233marquee可以移动文字，图片，表格&lt;marquee&gt;…&lt;/marquee&gt;(默认向左滚动)滚动方向：direction&lt;marquee direction=&quot;滚动方向&quot;&gt;…&lt;/marquee&gt;\t滚动方向:up, down, left, right\t滚动方式：behavior&lt;marquee behavior=&quot;方式&quot;&gt;…&lt;/marquee&gt;\t方式：scroll 循环（默认）\t\t\tslide 滚动一次\t\t\talternate 交替滚动\t\t\t滚动次数：loop&lt;marquee loop=&quot;次数&quot;&gt;…&lt;/marquee&gt;滚动速度：scrollamount&lt;marquee scrollamount=&quot;速度&quot;&gt;…&lt;/marquee&gt;\t实际为每次滚动的移动长度，以像素为单位。滚动延迟：scrolldelay&lt;marquee scrolldelay=&quot;时间间隔&quot;&gt;…&lt;/marquee&gt;\t“时间间隔”以毫秒为单位\t滚动区域背景颜色:bgcolor&lt;marquee bgcolor=&quot;颜色&quot;&gt;…&lt;/marquee&gt;\t&quot;颜色&quot;为十六进制码滚动背景宽度：width和高度：height&lt;marquee width=&quot;宽度&quot; height=&quot;高度&quot;&gt;…&lt;/marquee&gt;设置空白空间hspace, vspace&lt;marquee hspace=&quot;水平范围&quot; vspace=&quot;垂直范围&quot;&gt;…&lt;/marquee&gt;\n\n\n\n11.多媒体标签embed12embed可以插入各种多媒体&lt;embed src=&quot;地址&quot; loop=&quot;true&quot; autostart=&quot;true&quot; width=&quot;宽度&quot; height=&quot;&quot;&gt;\n\n​\t\n12.超链接的建立​\t\t基础：每个网页都有唯一的地址，统称为资源定位符（URL）​\t\t\n12345678910111213链接元素&lt;a&gt;…&lt;/a&gt;\t指定路径属性href\t\t&lt;a href=&quot;链接地址&quot;&gt;…&lt;/a&gt;\t\t&lt;a name=&quot;链接命名&quot;&gt;…&lt;/a&gt; \t\t\ttitle=&quot;给链接添加提示文字&quot;\t\t\ttarget=&quot;指定链目标窗口&quot;\t\t\t显示链接目标属性\t&lt;a href=&quot;链接地址&quot; target=&quot;目标窗口的打开方式&quot;&gt;\t\t方式：_blank打开一个新的窗口\t\t\t\t_self在本窗口打开\t\t\t\t_top在整个窗口中打开\t\t\t\t_parent在父框架集中打开文档\n\n13.设置不同的链接目标1234567锚链接：&lt;a href=&quot;#锚点名称&quot;&gt;…&lt;/a&gt;&lt;a href=&quot;命名&quot; id=&quot;锚点名称&quot;&gt;…&lt;/a&gt;设置图片超链接：&lt;a href=&quot;地址&quot; target=&quot;方式&quot;&gt;…&lt;img src=&quot;地址&quot;&gt;…&lt;/a&gt;设置电子邮件链接：&lt;a href=&quot;mailto=邮箱地址&quot;&gt;…&lt;/a&gt;\n\n\n\n14.表格元素结构​\t由行，列，单元格组成，表格标记table，行标记tr，单元格标记td​\t\t\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586结构：表格&lt;table&gt;\t\t\t&lt;table&gt;表格内容&lt;/table&gt;\t\t行&lt;tr&gt;\t\t\t&lt;tr&gt;行内容&lt;/tr&gt;\t\t单元格&lt;td&gt;\t\t\t&lt;td&gt;单元格内容&lt;/td&gt;:内容可为文字，图像，表单，甚至另一个表格\t\t\t&lt;table&gt;元素属性:\t边框属性border(外边框)\t\t&lt;table border=&quot;边框宽度&quot;&gt;\t水平对齐属性align(用于表格在页面中的位置)\t\t&lt;table align=&quot;对齐方式&quot;&gt;\t\t\t参数：left\t左对齐\t\t\t      center\t居中\t\t\t      right\t右对齐\t高度属性height\t\t&lt;table height=&quot;表格高度&quot;&gt;\t\t\t高度可为像素，也可为百分比\t\t\t\t宽度属性width\t\t&lt;table width=&quot;表格宽度&quot;&gt;\t\t宽度可为像素，百分比\t\t\t边框颜色属性bordercolor(边框宽度不为零)\t\t&lt;table border=&quot;边框宽度&quot; bordercolor=&quot;边框颜色&quot;&gt;\t\t颜色为十六进制或英文名称\t\t\t边框亮边线属性\t\t&lt;table bordercolorlight=&quot;亮边框的颜色&quot;&gt;\t\t&lt;table bordercolorlight=&quot;暗边框的颜色&quot;&gt;\t\t\t背景颜色属性bgcolor\t\t&lt;table bgcolor=&quot;颜色&quot;&gt;\t\t\t背景图片属性background(表格背景)\t\t&lt;table background=&quot;图片地址&quot;&gt;\t\t单元格间距属性cellspacing\t\t&lt;table cellspacing=&quot;单元格&quot;&gt;\t单元格补白属性cellspadding\t\t规定单元格边沿与其内容之间的空白\t\t&lt;table cellspadding=&quot;单元补白属性&quot;&gt;\t\t\t&lt;tr&gt;元素的属性（行）\t\t水平对齐属性align\t\t\t&lt;table align=&quot;水平对齐方式&quot;&gt;\t\t\t方式：left(默认), center, right\t\t\t\t\t垂直对齐属性valign\t\t\t&lt;tr valign=&quot;垂直对齐方式&quot;&gt;\t\t\t方式：top, middle, bottom\t\t\t\t\t行的背景颜色bgcolor\t\t\t&lt;tr bgcolor=&quot;行的背景颜色&quot;&gt;\t\t\t只对行起作用，会覆盖表格背景\t\t\t\t行边框颜色\t\t\t&lt;tr bordercolor=&quot;行边框颜色&quot;&gt;\t\t\t\t&lt;td&gt;元素的属性\t\t宽度：&lt;td width=&quot;单元格宽度&quot;&gt;\t\t高度：&lt;td height=&quot;单元格高度&quot;&gt;\t\t指定单元格背景色：&lt;td bgcolor=&quot;颜色&quot;&gt;\t\t指定单元格背景图：&lt;td background=&quot;图片地址&quot;&gt;\t\t指定水平对齐：&lt;td align=&quot;水平对齐&quot;&gt;    方式：left, center, right\t\t指定垂直对齐：&lt;td valign=&quot;垂直对齐&quot;&gt;    方式：top, middle, bottom\t\t指定单元格边框颜色：&lt;td border=&quot;颜色&quot;&gt;\t\t\t合并列表属性colspan(跨列)    rowspan(跨行)\t\t&lt;td colspan=&quot;跨列数&quot;&gt;\t\t&lt;td rowspan=&quot;跨行数&quot;&gt;\t\t\t表格标题：位于&lt;table&gt;…&lt;/table&gt;\t\t&lt;caption&gt;标题&lt;/caption&gt;\t\t\t表格框架简例：\t\t&lt;table border=&quot;&quot; width=&quot;&quot; cellspacing=&quot;&quot; cellsapdding=&quot;&quot;&gt;\t\t\t&lt;tr&gt;\t\t\t\t&lt;td&gt;…&lt;/td&gt;\t\t\t&lt;/tr&gt;\t\t&lt;/table&gt;\t\t\t内联框架：\t\t&lt;iframe src=&quot;地址&quot; width=&quot;&quot; height=&quot;&quot;&gt;&lt;/iframe&gt;\n\n15.多媒体​\t\t\t\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778Flash 是矢量的Web交互动画制作工具，Dreamweaver提供了使用Flash对象的功能。Flash动画\tDreamweaver &gt;&gt; 插入 &gt;&gt; 媒体 &gt;&gt; SWF命令\t选择要插入的&quot;.swf&quot;的动画文件，得到Flash占位符。可在 属性面板中进行属性设置。\t透明Flash动画\t新建一个“网页”，在“外观CSS分类”中添加“背景图像”\t插入“.swf”后，在属性中Wmode中选择“透明”FlashPaper\t原理是FlashPaper虚拟机打印可打印的文档转换为SWF或PDF。\tFlash视频\tFlash视频即为FLV流媒体格式的视频\t选择“插入” &gt;&gt; “媒体” &gt;&gt; “FLV”\t“视频类型”：累进式下载视频，先将FLV文件下载到访问者的硬盘，然后再播放。\t流视频：进行一段缓冲时间后才在网页上播放视频内容。插入shockwave影片\t插入 &gt;&gt; 媒体 &gt;&gt; shockwave\t打开“选择文件”，选择&quot;.dcr&quot;, &quot;.dir&quot;, &quot;.dxr&quot;插入Applet\tApplet用Java编程语言开发的，可嵌入Web页中的小型应用程序\t插入 &gt;&gt; 媒体 &gt;&gt; Applet命令 &gt;&gt;  &quot;.class&quot;\t插入ActiveX控件\tActiveX是可以在浏览器中充当插入，可重复使用：插入 &gt;&gt; 媒体 &gt;&gt; ActiveX\t在属性面板中“class ID”插入视频，参数内可控制播放参数。\t&lt;param name=&quot;AutoRewind&quot; value=&quot;true&quot;&gt;    播放完回到开始\t&quot;FileName&quot;\t设置视频文件\t&quot;ShowControls&quot;\t控制条\t&quot;ShowPositionControls&quot;\t快进/快退\t&quot;ShowAudioControls&quot;\t音频调节\t&quot;ShowTracker&quot;\t播放条\t&quot;ShowDisplay&quot;\t播放列表\t&quot;ShowStatusBar&quot;\t状态栏\t&quot;ShowCaptioning&quot;\t字幕\t&quot;AutoStart&quot;\t自动播放\t&quot;Volume&quot;\t音量\t&quot;AllowChangeDisplaySize&quot;\t允许改变显示尺寸\t&quot;EnableContextMenu&quot;\t显示右键菜单\t&quot;Windowless Video&quot;\t双击鼠标切换全屏插入音频\t\t通过&lt;bgsound&gt;标签添加背景音乐\t&lt;embed&gt;添加音乐播放器\t\t\t\t设置背景音乐，用于&lt;body&gt;…&lt;/body&gt;之间\t\t&quot;&lt;bgsound&quot;后按空格出现属性：\t\t\tbalance\t设置左右对齐\t\t\tdelay\t设置播放延时\t\t\tloop\t设置循环次数，当loop=-1，表示无限循环\t\t\tvolume\t设置音乐音量\t\t\tsrc\t文件地址\t\t设置音乐播放器\t\t&lt;embed src=&quot;地址&quot; …&gt;滚动字幕\t&lt;marquee&gt;…&lt;/marquee&gt;\t&quot;&lt;marquee&quot;后空格可以选择属性：\t\tbehavior\t滚动方式 ：\t\t\talternate 文本左右滚动\t\t\tscroll 循环滚动\t\t\tslide 滚动后固定\t\tbgcolor\t背景色\t\tdirection\t滚动方向：\t\t\tup \t\t\tdown \t\t\tleft \t\t\tright\t\theight 滚动效果的高度\twidth 宽度\t\tloop\t循环次数\t\tscrollamount\t滚动延迟时间\t\thspace 水平范围\tvspace 垂直范围\n\n16.使用框架​\t概述：可以在同一浏览器窗口中显示多个不同的文件，常用于左侧和上侧的区域设置为目录区和导航条，内部有超链，用于方便浏览其他的网页。​\t\n1234567891011121314151617181920212223创建框架\t&lt;frameset&gt;和&lt;frame&gt;\t\t&lt;frameset cols=&quot;96,*&quot;&gt;\t\t\t&lt;frame src=&quot;left.html&quot;/&gt;\t\t\t&lt;frame rows=&quot;59,572&quot;&gt;\t\t\t\t&lt;frame src=&quot;top.html&quot;&gt;\t\t\t\t&lt;frame src=&quot;main.html&quot;/&gt;\t\t\t&lt;/frameset&gt;\t\t&lt;/frameset&gt;\t\t\t&lt;frame&gt;只存在于&lt;frameset&gt;中，用于链接URL\t\t以像素为单位，也可取百分比：cols:框架的列数 rows:框架的行数\t\t“*”：表示框架占剩余未被定义的空间浮动框架\t&lt;iframe src=&quot;地址&quot; name=&quot;…&quot; width=&quot;…&quot; height=&quot;… align=&quot;…&quot; scrolling=&quot;yes/no&quot; frameborder=&quot;…&quot;&gt;&lt;/frame&gt;\t\tname:框架标识名\tscrolling:是否出现滚动条\tframeborder:边框\t\t&lt;a href=&quot;地址&quot; target=&quot;…&quot;&gt;…&lt;/a&gt;\ttarget结合name使用\n\n\n​\t\t​\t​\t\n","slug":"2_HTML_01","date":"2022-10-06T07:28:25.931Z","categories_index":"编程","tags_index":"HTML/CSS","author_index":"FangH"},{"id":"a7d67895004888252f8010c8618442cf","title":"CSS","content":"CSS[toc]\n1.类型属性用于定义网页中文本的字体、大小、颜色、样式及文本链接的修饰效果\n123456789101112131415161718192021.cs2&#123;font-family:&quot;黑体&quot;; (字体)font-size:14px; (字号大小)font-style:italic; (文字样式：normal, italic(斜体), oblique(偏斜)font-weight:bold; (字体粗细:normal, bold(粗), bolder, lighter)font-variant:small-caps; (字体变体)font-height:20px (行高，行间距)text-transform:capitalize; (大小写) uppercase, lowercase, nonecolor:#F00; (颜色)text-decoration:underline(下划线)，overline(上划线)，（文字修饰）&#125;\n\nline-through(删除线)，blink(闪烁线)，none\n2.背景属性12345678910111213.cs3&#123;background-attachment:fixed;background-image:url(bg.gif)background-repeat:repeat-x;background-position:right bottom;background-color:#F00; (背景颜色)&#125;\n\nbackground-image:url(地址); 背景图像\nbackground-repeat:用来设置图像重复显示的形式\nno-repeat(不重复)，repeat，repeat-x(横向重复)，repeat-y(纵向重复)\nbackground-attachment:用来设置背景是否随着页面滚动而滚动\nscroll(滚动)，fixed(固定)\nbackground-position:用于设置背景图片在网页中的位置\nleft(左对齐)，right, center, top, bottom, 也可输入数字\n3.区域属性1234567891011121314151617.cs4&#123;center-spacing:2px; （字符间距，优先级高于单词，可选normal）text-align:center; (文本对齐，left, right, center, justify(绝对居中))text-indent:10; (文本缩进，设置第一行缩进距离，可取长度或百分比)vertical-align:middle;word-spacing:2px; (单词间距，可取长度或normal)while-space:nowrap;display:none;&#125;\n\nwhile-spacing(空格):\nnormal:使多重空格合并成一个\npre:保留元素中的空格原始形象，不允许多重空格合并成一个\nnowrap:（不换行）长文本不自动换行\n4.方框属性css可以控制框大小，外观，位置，将每个文档的元素存入其中\n12345678910111213141516171819.cs5&#123;content:  （div的内容）border:2px （div的边框粗细）margin:30px （div之间的间距）padding:20px(填充) （content与div边框的间距）clear:right(清除浮动效果)float:right(浮动) 设置快元素的浮动效果height:400pxwidth:400px&#125;\n\nfloat:选择left(左对齐)元素放置在左页面空白处；right\npadding:定义应用样式的元素内容和元素边界之间的空白大小\nmargin:定义样式元素与其他之间的空白大小\nmargin-top right bottom left\n top 左右 bottom\n上下 左右\n四边\n5.边框属性可以设置元素边框的宽度、样式、颜色\n12345.cs6&#123;border-top-width:2px;&#125;\n\nborder-方向-（宽度）颜色：…；\nborder 宽度 solid 颜色\nstyle(样式)：设定边框线的样式\nnone，dotted（点线），dashed（虚线），solid（实线），double（双实线）\ngroove（沟槽），ridge（脊形），inset（凹陷），outset（凸起）\n6.列表属性控制列表内容的各项元素\nList-style-type(列表类型)\ntype:disc(默认实心圆),  circle(实心圆),  none, square(实心方块), decimal(数字), lower-roman(小写罗马数字)\n upper-roman, lower-alpha(小写英文数字), upper–alpha\nList-style-image(项目符号图像)\n以图片做为无序列表的符号：outside（在方框外显示） inside（在方框内显示） \n7.定位属性position(位置)：可以设置浏览器放置AP Div 的方式\nstatic(静态)：由浏览器决定元素的左边缘和上边缘\nabsolute(绝对)：以top、bottom、left、right,坐标为页面左上角\nfixed(固定)：将元素相对其显示的页面或窗口进行定位\nrelative(相对)：坐标原点为当前位置\nvisibility(显示)：设置的初始化显示属性\ninherit(继承)：继承分层父级元素的可见性属性\nvisible(可见)：层显示可见\nhidden(隐藏)：层隐藏\nwidth&#x2F;height：设置元素宽，高的值\nz-index(z轴)：定义层的顺序；可以用auto（自动）或相应数\noverflow(溢出)：定义层中，内容超出层的边界后发生的情况\nvisible(可见)，hidden, scroll, auto\nplacement(放置)：设置层的大小和位置\nclip(剪辑区域)：定义可见层的局部区域的位置和大小，可以把元素区域剪切成各种形状\n8.扩展属性分页：通过样式来为网页添加分页符号。允许用户在指定元素前后进行分页，分页是指打印网页内容时在某一位置停止，后续内容在另一页上打印。\n1page-break-before ; page-break-after\n\n视觉效果：cursor(光标) fillter(过滤器)\n在CSS中有一个Alpha滤镜，这个滤镜可以设置目标元素的透明度。还可以通过指定坐标，从而实现各种不同范围的透明度。\n具体语法如下：\n12345678910111213&#123;filter:alpha(opacity=opacity,finishopacity=finishopacity,style=style,startx=startx,starty=starty,finishx=finishx,finishy=finishy)&#125;\n\n具体参数含义如下：\nopacity 透明度。默认的范围是从0 到 100，他们其实是百分比的形式。也就是说，0代表完全透明，100代表完全不透明。 \nfinishopacity 是一个可选参数，如果想要设置渐变的透明效果，就可以使用他们来指定结束时的透明度。范围也是0 到 100。 \nstyle  指定透明区域的形状特征：0 代表统一形状，1 代表线形，2 代表放射状，3 代表矩形 \nstartx  渐变透明效果开始处的 X坐标。 只能style &#x3D; 1才有效\nstarty  渐变透明效果开始处的 Y坐标。 只能style &#x3D; 1才有效 \nfinishx 渐变透明效果结束处的 X坐标。 只能style &#x3D; 1才有效\nfinishy 渐变透明效果结束处的 Y坐标。 只能style &#x3D; 1才有效 \n以上的参数可以选用，可以只设置一个opacity\n实例： \n123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;head&gt; &lt;title&gt;alpha效果展示：&lt;/title&gt; &lt;style type=&quot;text/Css&quot;&gt;                //*定义CSS样式*//    .half&#123;filter:alpha(opacity=50)&#125;    //*透明度50，默认形状*//  .s0&#123;filter:alpha(opacity=30,style=0)&#125; //*透明度30，统一形状*//  .s1&#123;filter:alpha(opacity=80,style=1)&#125; //*透明度80，线性透明*//  .s2&#123;filter:alpha(opacity=80,style=2)&#125; //*透明度80，放射性*//  .s3&#123;filter:alpha(opacity=80,style=3)&#125; //*透明度80，长方形*//  &lt;/style&gt;  &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;Sunset.jpg&quot;&gt;  &lt;img class=half src=&quot;Sunset.jpg&quot;&gt;   &lt;img class=s0 src=&quot;Sunset.jpg&quot;&gt;     &lt;img class=s1 src=&quot;Sunset.jpg&quot;&gt;      &lt;img class=s2 src=&quot;Sunset.jpg&quot;&gt;        &lt;img class=s3 src=&quot;Sunset.jpg&quot;&gt;       &lt;/body&gt; &lt;/html&gt;\n\n9.标准文档流组成&amp;display属性块级元素（block level）1&lt;h1&gt;~&lt;h6&gt;,&lt;p&gt;,&lt;div&gt;,&lt;hr&gt;,列表\n\n列表：123&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;\n\n1234567&lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;\n\n内联元素（inline）1&lt;span&gt;,&lt;a&gt;,&lt;img/&gt;,&lt;strong&gt;\n\n内联标签可以包含于块级标签中，成为它的子元素\ndisplay属性：控制元素的显示与隐藏；\n块级元素和行级元素之间的转换；\n\n\n\nblock\n块级元素的默认值，元素会被显示为块级元素，该元素前后会带有换行符\n\n\n\ninline\n内联元素的默认值，元素会被显示为内联元素，该元素前后不会带有换行符\n\n\nnone\n设置元素不会被显示\n\n\n10.float浮动属性\n\n\nleft\n元素向左浮动\n\n\n\nright\n元素向右浮动\n\n\nnone\n默认值，元素不浮动，并会显示在其文本中的位置\n\n\nclear属性\n\n\nleft\n在左侧不允许浮动元素\n\n\n\nright\n在右侧不允许浮动元素\n\n\nboth\n在左右两侧不允许浮动元素\n\n\nnone\n默认值，允许浮动元素出现在两侧\n\n\n11.overflow属性（溢出处理）\n\n\nvisible\n默认值，内容不会被修剪，会呈现在盒子之外\n\n\n\nhidden\n内容会被修剪，并且其余内容比可见\n\n\nscroll\n内容会被修剪，但浏览器会显示滚动条，以显示其余内容\n\n\nauto\n如果内容会被修剪，但浏览器会显示滚动条，以显示其余内容\n\n\n12.position属性（元素定位）\n\n\nstatic\n默认值，没有定位\n\n\n\nrelative\n相对定位\n\n\nabsolute\n绝对定位\n\n\nfixed\n固定定位（在一些浏览器中不支持，使用较少）\n\n\nrelative:相对自身原来的位置进行偏移\n12345678910111213&#123;position:relative;top: px;bottom: px;left: px;right: px;&#125;\n\n(px值可为负数，以浏览器为参照进行偏移，正值为偏离参照物，负值为接近参照物)\n设置相对定位的盒子会相对它原来的位置，通过指定偏移，到达新的位置。\n设置相对定位的盒子仍在标准流中，它对父级盒子和相邻的盒子都没有任何影响。\n设置了position属性值为relative的网页元素，无论是在标准流中还是在浮动流中，都不会对它的父级元素和相邻元素有任何影响，它只针对自身原来的位置进行偏移。\nabsolute：绝对定位，以某个参照物进行位置偏移\n12345678910111213&#123;position:absolute;top: px;bottom: px;left: px;right: px;&#125;\n\n（px值可为负数，以浏览器为参照进行偏移，px为正值时，效果为距离浏览器边框距离，负值为远离浏览器边框的距离）\n使用了绝对定位的元素以它最近的一个：“已经定位”的“祖先元素”为基准进行偏移。如果没有已经定位的祖先元素，那么会以浏览器窗口为基准进行定位。\n绝对定位的元素从标准文档流中脱离，这意味着它们对其他元素的定位不会造成影响。\n13.z-index属性（调整元素定位时重叠层的上下位置）z-index属性值：整数，默认值为0；\n设置了position属性时，z-index属性可以设置各元素之间的重叠高低关系；\nz-index值大的层位于其值小的层上方；\n14.网页元素透明度&amp;CSS元素透明度\n\n\nopacity:x 属性\nx值为0~1，值越小越透明\nopacity:0.4;\n\n\n\nfilter:alpha(opacity&#x3D;x)\nx值为0~100,值越小越透明\nfilter:alpha(opacity&#x3D;40);\n\n\n","slug":"2_CSS_02","date":"2022-10-06T07:28:25.928Z","categories_index":"编程","tags_index":"HTML/CSS","author_index":"FangH"},{"id":"fdd7c70afe97f7b4969565b83472fc45","title":"C++_职工管理系统","content":"C++_职工管理系统[toc]\n1. 管理系统需求系统需求：\n\n职工管理系统可以用来管理公司内所有员工的信息\n公司职工分三类：普通员工，经理，老板；\n显示员工信息：显示职工编号，职工姓名，职工岗位\n职责：\n普通员工职责：完成经理的任务\n经理职责：完成老板的任务\n老板：管理所有事务\n\n\n\n管理系统需要的功能：\n\n退出管理程序：退出当前管理系统\n增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号，姓名，部门编号\n显示职工信息：显示公司内部所有职工的信息\n删除离职职工：按照编号删除指定的职工\n修改职工信息：按照编号修改职工个人信息\n查找职工信息：按照职工的编号或者职工的姓名进行查找相关人员信息\n按照编号排序：按照职工编号，进行排序，排序规则由用户指定\n清空所有文档：清空文件中记录的所有职工信息（清空前需要确认，防止误删）\n\n2. 创建管理类\n管理类的内容：\n用户的沟通菜单界面\n对职工增删改查的操作\n与文件的读写交互\n\n\n\n2.1 创建文件\nClion中创建\n头文件：workerManager.h\n源文件：workerManager.cpp\n主文件：StaffManagerSystem_Main.cpp\nCMakeList.txt\n\n\n\n2.2 创建管理类文件\nCMakeList.txt\n123456cmake_minimum_required(VERSION 3.19)project(StaffManagementSystem)set(CMAKE_CXX_STANDARD 14)add_executable(StaffManagementSystem StaffManagerSystem_Main.cpp workerManager.h workerManager.cpp)\n\nworkerManager.h\n12345678910111213141516171819//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H#define STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H#include &lt;iostream&gt;using namespace std;class WorkerManager&#123;public:    WorkerManager();    ~WorkerManager();&#125;;#endif //STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n\nworkerManager.cpp\n1234567891011121314//// Created by Admin on 2021/6/26.//#include &quot;workerManager.h&quot;WorkerManager::WorkerManager()&#123;&#125;WorkerManager::~WorkerManager()&#123;&#125;\n\nStaffManagerSystem_Main.cpp\n12345678#include &lt;iostream&gt;#include &quot;workerManager.h&quot;int main()&#123;    cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;    return 0;&#125;\n\n3. 菜单功能\n功能描述：与用户沟通的界面\n\n3.1 添加成员函数\n在workerManager.h中的WorkerManager类中添加成员函数：void Show_Menu();\n12345678910111213141516171819202122//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H#define STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H#define wm workerManager#include &lt;iostream&gt;using namespace std;class WorkerManager&#123;public:    WorkerManager();    ~WorkerManager();    // 显示菜单    void Show_Menu();&#125;;#endif //STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n\n3.2 菜单功能实现\n在管理类 workerManager.cpp 中实现具体 Show_Menu() 函数\n123456789101112131415void WorkerManager::Show_Menu()&#123;    cout &lt;&lt; &quot;======================&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;====员工管理系统主菜单====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====0.退出管理系统=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====1.增加职工信息=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====2.显示职工信息=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====3.删除离职职工=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====4.修改职工信息=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====5.查找职工信息=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====6.按照编号排序=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====7.清空所有文档=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;======================&quot; &lt;&lt; endl;    cout &lt;&lt; endl;&#125;\n\n3.3 测试菜单功能\n在StaffManagerSystem_Main.cpp中进行测试\n123456789#include &lt;iostream&gt;#include &quot;workerManager.h&quot;int main()&#123;    WorkerManager workerManager;    wm.Show_Menu();    return 0;&#125;\n\n4. 退出功能4.1 提供菜单功能接口\n在main函数中提供分支选择，提供菜单界面每个功能的接口\n\n先创建一个StaffManagerSystem_Main.cpp中的函数showMenu()&#123;&#125;;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &quot;workerManager.h&quot;void showMenu()&#123;        // 初始选择    int choice = 0;    // 生成 管理界面 对象    WorkerManager workerManager;    // 调用 菜单界面    ReShowMenu:    wm.Show_Menu();    cout &lt;&lt; &quot;功能选择 &gt;&gt; &quot;;    cin &gt;&gt; choice;    // 菜单界面的功能选择分支    switch (choice)    &#123;        case 0: // 0.退出管理系统            wm.exitSystem();            break;        case 1: // 1.增加职工信息            break;        case 2: // 2.显示职工信息            break;        case 3: // 3.删除离职职工            break;        case 4: // 4.修改职工信息            break;        case 5: // 5.查找职工信息            break;        case 6: // 6.按照编号排序            break;        case 7: // 7.清空所有文档            break;        default: // 0 ~ 7 之外任意值，清空，重来菜单界面            system(&quot;cls&quot;);            goto ReShowMenu;    &#125;&#125;int main()&#123;    showMenu();    return 0;&#125;\n\n4.2 实现退出功能\n在workerManager.h中提供退出系统的成员函数 void exitSystem();\n\n在workerManager.cpp中具体实现功能\n123456// 0.退出管理系统void WorkerManager::exitSystem()&#123;    cout &lt;&lt; &quot;员工管理系统-退出&quot; &lt;&lt; endl;    exit(0);&#125;\n\n5. 创建职工类5.1 创建职工抽象类\n职工分类：\n\n普通员工\n经理\n老板\n\n\n将三种职工抽象到一个类Worker中，利用多态管理不同职工类\n\n职工的属性：\n\n职工编号\n职工姓名\n职工部门编号\n\n\n职工行为：\n\n岗位职责信息描述\n获取岗位名称\n\n\n创建头文件 worker.h\n123456789101112131415161718192021222324252627//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_WORKER_H#define STAFFMANAGEMENTSYSTEM_WORKER_H#include &lt;iostream&gt;using namespace std;// 职工抽象类class Worker&#123;public:    int worker_ID; // 职工ID    string worker_Name; // 职工姓名    int worker_DepartID; // 职工部门编号    // 获得 职工的信息    virtual void getWorkerInfo() = 0;    // 获得 职工部门的岗位名称    virtual void getWorkerDepartName() = 0;&#125;;#endif //STAFFMANAGEMENTSYSTEM_WORKER_H\n\n5.2 创建普通员工类\n普通员工继承职工抽象类，并重写父类中的纯虚函数\n\n在头文件和源文件的文件夹中创建employee.h和employee.cpp\n\nemployee.h\n1234567891011121314151617181920212223242526//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_EMPLOYEE_H#define STAFFMANAGEMENTSYSTEM_EMPLOYEE_H#include &quot;worker.h&quot;#include &lt;iostream&gt;using namespace std;class Employee : public Worker&#123;public:    // 初始化 员工 构造函数    Employee(int w_Id, string w_Name, int w_DepartId);    // 获得员工个人信息    void getWorkerInfo() override;    // 获得员工部门岗位名称    void getWorkerDepartName() override;&#125;;#endif //STAFFMANAGEMENTSYSTEM_EMPLOYEE_H\n\nemployee.cpp\n123456789101112131415161718192021222324//// Created by Admin on 2021/6/26.//#include &quot;../Header/employee.h&quot;Employee::Employee(int w_Id, string w_Name, int w_DepartId)&#123;    this-&gt;worker_ID = w_Id;    this-&gt;worker_Name = w_Name;    this-&gt;worker_DepartID = w_DepartId;&#125;void Employee::getWorkerInfo()&#123;    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;worker_ID         &lt;&lt; &quot;\\t职工姓名：&quot; &lt;&lt; this-&gt;worker_Name         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()         &lt;&lt; &quot;\\t岗位职责：完成经理的任务&quot; &lt;&lt; endl;&#125;string Employee::getWorkerDepartName()&#123;    return string(&quot;普通员工&quot;);&#125;\n\n5.3 创建经理类\n经理类继承职工抽象类，并重写父类中虚函数\n\n在头文件和源文件文件夹内，创建manager.h和manager.cpp\n\nmanager.h\n123456789101112131415161718192021222324252627//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_MANAGER_H#define STAFFMANAGEMENTSYSTEM_MANAGER_H#include &quot;worker.h&quot;#include &lt;iostream&gt;using namespace std;// 经理类class Manager : public Worker&#123;public:    // 初始化 经理 构造函数    Manager(int w_Id, string w_Name, int w_DepartId);    // 获得经理个人信息    void getWorkerInfo() override;    // 获得经理部门岗位名称    string getWorkerDepartName() override;&#125;;#endif //STAFFMANAGEMENTSYSTEM_MANAGER_H\n\nmanager.cpp\n12345678910111213141516171819202122232425262728//// Created by Admin on 2021/6/26.//#include &quot;../Header/manager.h&quot;// 构造函数 初始化 经理 信息Manager::Manager(int w_Id, string w_Name, int w_DepartId)&#123;    this-&gt;worker_ID = w_Id;    this-&gt;worker_Name = w_Name;    this-&gt;worker_DepartID = w_DepartId;&#125;// 获得 职工信息void Manager::getWorkerInfo()&#123;    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;worker_ID         &lt;&lt; &quot;\\t职工姓名：&quot; &lt;&lt; this-&gt;worker_Name         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()         &lt;&lt; &quot;\\t岗位职责：完成老板的任务&quot; &lt;&lt; endl;&#125;// 获得 职工 岗位信息string Manager::getWorkerDepartName()&#123;    return string(&quot;经理&quot;);&#125;\n\n5.4 创建老板类\n老板类继承职工抽象类，并重写父类中虚函数\n\n在头文件和源文件文件夹内，创建boss.h和boss.cpp\n\nboss.h\n123456789101112131415161718192021222324252627//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_BOSS_H#define STAFFMANAGEMENTSYSTEM_BOSS_H#include &quot;worker.h&quot;#include &lt;iostream&gt;using namespace std;// 老板类class Boss : public Worker&#123;public:    // 初始化 老板 构造函数    Boss(int w_Id, string w_Name, int w_DepartId);    // 获得老板个人信息    void getWorkerInfo() override;    // 获得老板部门岗位名称    string getWorkerDepartName() override;&#125;;#endif //STAFFMANAGEMENTSYSTEM_BOSS_H\n\nboss.cpp\n12345678910111213141516171819202122232425262728//// Created by Admin on 2021/6/26.//#include &quot;../Header/boss.h&quot;// 构造函数 初始化 老板 信息Boss::Boss(int w_Id, string w_Name, int w_DepartId)&#123;    this-&gt;worker_ID = w_Id;    this-&gt;worker_Name = w_Name;    this-&gt;worker_DepartID = w_DepartId;&#125;// 获得 职工信息void Boss::getWorkerInfo()&#123;    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;worker_ID         &lt;&lt; &quot;\\t职工姓名：&quot; &lt;&lt; this-&gt;worker_Name         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()         &lt;&lt; &quot;\\t岗位职责：管理所有事务&quot; &lt;&lt; endl;&#125;// 获得 职工 岗位信息string Boss::getWorkerDepartName()&#123;    return string(&quot;老板&quot;);&#125;\n\n5.5 测试多态\n在StaffManagerSystem_Main.cpp中添加测试函数void demo()&#123;&#125;;\n\n测试代码：\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &quot;../Header/workerManager.h&quot;#include &quot;../Header/worker.h&quot;#include &quot;../Header/employee.h&quot;#include &quot;../Header/manager.h&quot;#include &quot;../Header/boss.h&quot;void demo()&#123;    Worker *worker = nullptr;        worker = new Employee(1, &quot;Normal_A&quot;, 1);    worker-&gt;getWorkerInfo();        worker = new Manager(2, &quot;Manager_A&quot;, 2);    worker-&gt;getWorkerInfo();        worker = new Boss(3, &quot;Boss_A&quot;, 3);    worker-&gt;getWorkerInfo();&#125;int main()&#123;    demo();    return 0;&#125;\n\n6. 添加职工\n功能描述：批次添加职工，并保存到文件中\n\n6.1 功能分析\n分析：\n用户在批量创建时，可能创建不同种类的职工\n如果想将所有不同种类的职工都放在一个数组中，可以将所有员工的指针维护到一个数租里\n如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker **维护\n\n\n堆区开辟以Worker类型的数组：Worker ** = new Worker*[];\n\n6.2 功能实现\n在WorkerManager.h添加成员属性\n12345// 记录文件中的人数int worker_EmpNum;    // 员工数组指针    Worker ** worker_EmpArray;\n\n\n\n在WorkerManager.cpp中构造函数初始化属性\n12345678WorkerManager::WorkerManager()&#123;    // 初始化人数    this-&gt;worker_EmpNum = 0;    // 初始化数组指针    this-&gt;worker_EmpArray = nullptr;&#125;\n\n\n\n在WorkerManager.h添加成员函数\n12// 1.增加职工信息 void addEmployee();\n\n\n\n在WorkerManager.cpp中实现void addEmployee()&#123;&#125;\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 1.增加职工信息void WorkerManager::addEmployee()&#123;    cout &lt;&lt; &quot;输入增加职工数量：&gt;&gt;&quot;;    int addNum = 0;    cin &gt;&gt; addNum;    if (addNum &gt; 0)    &#123;        // 计算需要的空间大小 = 已用的空间 + 新需要的空间        int newSize = this-&gt;worker_EmpNum + addNum;        // 在 堆区中开辟 计算好大小的内存空间        Worker **newSpace = new Worker *[newSize];        // 将已有空间的内容存在新的内村空间中        if (this-&gt;worker_EmpArray != nullptr)        &#123;            for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)            &#123;                newSpace[i] = this-&gt;worker_EmpArray[i];            &#125;        &#125;        // 再将 需要添加的新内容加入        for (int j = 0; j &lt; addNum; j++)        &#123;            int worker_ID; // 职工ID            string worker_Name; // 职工姓名            int worker_DepartID; // 职工部门编号            cout &lt;&lt; &quot;输入第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;位员工信息:&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;职工编号&gt;&gt;&quot;;            cin &gt;&gt; worker_ID;            cout &lt;&lt; &quot;职工姓名&gt;&gt;&quot;;            cin &gt;&gt; worker_Name;            cout &lt;&lt; &quot;职工岗位_ 1.员工_2.经理_3.老板&gt;&gt;&quot;;            cin &gt;&gt; worker_DepartID;            Worker *worker = nullptr;            switch (worker_DepartID)            &#123;                case 1:                    worker = new Employee(worker_ID, worker_Name, 1);                    break;                case 2:                    worker = new Manager(worker_ID, worker_Name, 2);                    break;                case 3:                    worker = new Boss(worker_ID, worker_Name, 3);                    break;                default:                    break;            &#125;            newSpace[this-&gt;worker_EmpNum + j] = worker;        &#125;        // 释放原本的空间        delete[] this-&gt;worker_EmpArray;        // 更改新空间的指向        this-&gt;worker_EmpArray = newSpace;        // 更新 新的个数        this-&gt;worker_EmpNum = newSize;        // 提示信息        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;需输入正确的数字&quot; &lt;&lt; endl;    &#125;    system(&quot;cls&quot;);&#125;\n\n6.3 测试添加\n部分修改：\n\nworkerManager.h\n12345#include &lt;iostream&gt;#include &quot;worker.h&quot;#include &quot;employee.h&quot;#include &quot;manager.h&quot;#include &quot;boss.h&quot;\n\nStaffManagerSystem_Main.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &quot;../Header/workerManager.h&quot;void showMenu()&#123;    // 初始选择    int choice = 0;    // 生成 管理界面 对象    WorkerManager workerManager;    // 调用 菜单界面    while (true)    &#123;        wm.Show_Menu();        cout &lt;&lt; &quot;功能选择 &gt;&gt; &quot;;        cin &gt;&gt; choice;        // 菜单界面的功能选择分支        switch (choice)        &#123;            case 0: // 0.退出管理系统                wm.exitSystem();                break;            case 1: // 1.增加职工信息                wm.addEmployee();                break;            case 2: // 2.显示职工信息                break;            case 3: // 3.删除离职职工                break;            case 4: // 4.修改职工信息                break;            case 5: // 5.查找职工信息                break;            case 6: // 6.按照编号排序                break;            case 7: // 7.清空所有文档                break;            default: // 0 ~ 7 之外任意值，清空，重来菜单界面                system(&quot;cls&quot;);                break;        &#125;    &#125;&#125;int main()&#123;    showMenu();    return 0;&#125;\n\nworkerManager.cpp\n12345678WorkerManager::~WorkerManager()&#123;    if (this-&gt;worker_EmpArray != nullptr)    &#123;        delete[] this-&gt;worker_EmpArray;        this-&gt;worker_EmpArray = nullptr;    &#125;&#125;\n\n\n\n6.4 补充：职工ID唯一性\n确保职工文件内，每个职工的worker_ID是唯一的\n\n在workerManager.h中添加成员函数bool isEmployeeIDExist(int workerID);\n12// 排查添加的新职工的编号在文件中是否存在bool isEmployeeIDExist(int workerID);\n\n在workerManager.cpp中实现成员函数bool isEmployeeIDExist(int workerID)&#123;&#125;\n123456789101112131415161718// 排查添加的新职工的编号在文件中是否存在bool WorkerManager::isEmployeeIDExist(int workerID)&#123;    bool isIDExist = true;    for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)    &#123;        if (this-&gt;worker_EmpArray[i]-&gt;worker_ID == workerID)        &#123;            isIDExist = true;            break;        &#125;        else        &#123;            isIDExist = false;        &#125;    &#125;    return isIDExist;&#125;\n\n修改workerManager.cpp中的成员函数void addEmployee()&#123;&#125;\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 1.增加职工信息void WorkerManager::addEmployee()&#123;    cout &lt;&lt; &quot;&lt;-- 已录入职工数量：&quot; &lt;&lt; worker_EmpNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;输入增加职工数量：&gt;&gt; &quot;;    int addNum = 0;    cin &gt;&gt; addNum;    if (addNum &gt; 0)    &#123;        // 计算需要的空间大小 = 已用的空间 + 新需要的空间        int newSize = this-&gt;worker_EmpNum + addNum;        // 在 堆区中开辟 计算好大小的内存空间        Worker **newSpace = new Worker *[newSize];        // 将已有空间的内容存在新的内村空间中        if (this-&gt;worker_EmpArray != nullptr)        &#123;            for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)            &#123;                newSpace[i] = this-&gt;worker_EmpArray[i];            &#125;        &#125;        // 再将 需要添加的新内容加入        for (int j = 0; j &lt; addNum; j++)        &#123;            int worker_ID; // 职工ID            string worker_Name; // 职工姓名            int worker_DepartID; // 职工部门编号            bool isExistID = true; // 新增的变量，用于判断文件中是否已存在某个ID            // 在输入职工ID的地方，进行了修改            // 每次输入ID，都要判断一次，输入的ID在职工文件中是否已经存在            // 存在就继续循环该语句，不存在再继续执行            while (true)            &#123;                cout &lt;&lt; &quot;输入第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;位员工信息:&quot; &lt;&lt; endl;                cout &lt;&lt; &quot;职工编号&gt;&gt; &quot;;                cin &gt;&gt; worker_ID;                isExistID = isEmployeeIDExist(worker_ID);                if (isExistID)                &#123;                    cout &lt;&lt; &quot;编号已经存在&quot; &lt;&lt; endl;                    system(&quot;pause&quot;);                    system(&quot;cls&quot;);                &#125;                else                &#123;                    break;                &#125;            &#125;            cout &lt;&lt; &quot;职工姓名&gt;&gt; &quot;;            cin &gt;&gt; worker_Name;            cout &lt;&lt; &quot;职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;            cin &gt;&gt; worker_DepartID;            cout &lt;&lt; endl;            Worker *worker = nullptr;            switch (worker_DepartID)            &#123;                case 1:                    worker = new Employee(worker_ID, worker_Name, 1);                    break;                case 2:                    worker = new Manager(worker_ID, worker_Name, 2);                    break;                case 3:                    worker = new Boss(worker_ID, worker_Name, 3);                    break;                default:                    break;            &#125;            newSpace[this-&gt;worker_EmpNum + j] = worker;        &#125;        // 释放原本的空间        delete[] this-&gt;worker_EmpArray;        // 更改新空间的指向        this-&gt;worker_EmpArray = newSpace;        // 更新 新的个数        this-&gt;worker_EmpNum = newSize;        // 更新 文件不在为假        this-&gt;isFileEmpty = false;        // 提示信息        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;        // 保存录入的职工信息到文本文件中        this-&gt;saveNewToFile();    &#125;    else    &#123;        cout &lt;&lt; &quot;需输入正确的数字&quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;\n\n7. 文件交互7.1 写文件\n功能描述：对文件进行读写\n在上一个添加功能中，只完成了将数据添加到内存中，程序结束数据将被回收\n需求给项目的文件管理类添加一个文件交互功能，将数据保存到文本中，进行写操作\n\n\n\n7.1.1 设定文件路径\n首先是设定文件路径\n\n路径的选择最好是项目内，采用相对路径，在项目目录下创建文件夹 File\n\n在workerManager.h中添加宏常量，并包含头文件fstream.h\n12#define WORKER_FILENAME &quot;../File/workerFile.txt&quot;#include &lt;fstream&gt;\n\n7.1.2 成员函数声明\n在workerManager.h中添加成员函数void saveNewToFile();\n12// 保持录入职工的信息到文件void saveNewToFile();\n\n7.1.3 保存文件实现workerManager.cpp\n123456789101112131415// 保持录入职工的信息到文件void WorkerManager::saveNewToFile()&#123;    ofstream ofs;    ofs.open(WORKER_FILENAME, ios::out);    for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)    &#123;        ofs &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_ID &lt;&lt; &quot; &quot;            &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_Name &lt;&lt; &quot; &quot;            &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_DepartID &lt;&lt; endl;    &#125;    ofs.close();&#125;\n\n\n\n\n\n7.1.4 保存文件测速\n在workerManager.cpp实现的添加职工功能打印成功后面，添加保存文件的函数void saveNewToFile();\n12345 // 提示信息cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;/ 保存录入的职工信息到文本文件中 this-&gt;saveNewToFile();\n\n7.2 读文件\n功能描述：将文件中的内容读取到程序中\n\n上一个功能完成了在程序中将堆中的数据保存到文本文件中，但还需要一个程序启动时，读取文本文件数据到堆中的功能\n\n同时需要完成清空文本文件的功能\n\n构造函数初始化数据的情况分三种：\n\n第一次使用，文件未创建\n文件存在，数据被清空\n文件存在，数据也存在\n\n\n\n7.2.1 文件未创建\n在workerManager.h中添加成员变量，bool isFileEmpty; 来标记文件是否为空\n12// 判断文件是否为空bool isFileEmpty;\n\n\n\n\n修改workerManager.cpp中的构造函数\n123456789101112131415161718192021222324252627WorkerManager::WorkerManager()&#123;    // 初始化 读文件对象    ifstream ifs;    ifs.open(WORKER_FILENAME, ios::in);    // 文件不存在的情况    if (!ifs.is_open())    &#123;        cout &lt;&lt; &quot;文件不存在&quot; &lt;&lt; endl;        this-&gt;worker_EmpNum = 0;        this-&gt;worker_EmpArray = nullptr;        // 初始化 文件 是空        this-&gt;isFileEmpty = true;        ifs.close();        return;    &#125;        // 初始化人数    this-&gt;worker_EmpNum = 0;    // 初始化数组指针    this-&gt;worker_EmpArray = nullptr;    // 判断文件是否为空    this-&gt;isFileEmpty = false;&#125;\n\n确保项目中，没有workerFile.txt文件存在，运行时，可以看到打印结果，同时完成初始化\n\n\n7.2.2 文件存在且数据为空\nworkerManager.cpp中，在构造函数中加入代码\n12345678910111213141516171819202122232425262728293031WorkerManager::WorkerManager()&#123;    // 初始化 读文件对象    ifstream ifs;    ifs.open(WORKER_FILENAME, ios::in);    // 文件不存在的情况    if (!ifs.is_open())    &#123;        cout &lt;&lt; &quot;&lt;-- 提示：职工文件不存在 --&gt;&quot; &lt;&lt; endl;        this-&gt;worker_EmpNum = 0;        this-&gt;worker_EmpArray = nullptr;        // 初始化 文件 是空        this-&gt;isFileEmpty = true;        ifs.close();        return;    &#125;    // 文件存在 数据为空    string str;    ifs &gt;&gt; str;    if (ifs.eof())    &#123;        cout &lt;&lt; &quot;&lt;-- 提示：职工文件为空 --&gt;&quot; &lt;&lt; endl;        this-&gt;worker_EmpNum = 0;        this-&gt;worker_EmpArray = nullptr;        this-&gt;isFileEmpty = true;        ifs.close();        return;    &#125;&#125;\n\n同时，在文件存在时，文件判空变量isFileEmpty需要修改为false；\n\n在workerManager.cpp中的void WorkerManager::addEmployee()中，进行更改\n1234567891011// 更改新空间的指向this-&gt;worker_EmpArray = newSpace;// 更新 新的个数this-&gt;worker_EmpNum = newSize;// 更新 文件不在为空this-&gt;isFileEmpty = false;// 提示信息cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;\n\n此时先创建项目文件，可以手动在File文件夹内直接新建workerFile.txt；\n\n也可以先运行项目，添加职工信息后，手动删除文件内的内容，再进行测速上面的代码\n\n\n7.2.3 文件存在且有数据7.2.3.1 获取记录的职工人数\n在workerManager.h中添加成员函数int getEmpNum();\n12// 获得记录职工人数int getEmpNum();\n\n在workerMananger.cpp中实现功能\n1234567891011121314151617181920212223// 获得记录职工人数int WorkerManager::getEmpNum()&#123;    ifstream ifs;    ifs.open(WORKER_FILENAME, ios::in);    // 存入 读到的数据    int worker_ID;    string worker_Name;    int worker_DepartID;    // 初始化 记录人数    int empNum = 0;    // 当 读文件操作对象 返回为真    while (ifs &gt;&gt; worker_ID &amp;&amp; ifs &gt;&gt; worker_Name &amp;&amp; ifs &gt;&gt; worker_DepartID)    &#123;        // 记录人数 +1        empNum++;    &#125;    ifs.close();        return empNum;&#125;\n\n在workerManager.cpp的构造函数中继续添加测试代码\n123456// 文件存在 有数据// 获得文件已记录人数int empNum = this-&gt;getEmpNum();// 更新 记录人数this-&gt;worker_EmpNum = empNum;cout &lt;&lt; &quot;&lt;-- 职工数量: &quot; &lt;&lt; empNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;\n\n此时可以运行项目，添加数个职工信息后，再重新启动项目，即可看到测试数据\n\n\n7.2.3.2 初始化职工信息数组\n根据职工的数据以及职工数据，初始化workerManager.h中的Worker ** worker_EmpArray;指针\n\n在workerManager.h中添加成员函数void initEmployee();\n12 // 初始化职工void initEmployee();\n\n在workerManager.cpp中实现void initEmployee()&#123;&#125;\n12345678910111213141516171819202122232425262728293031323334353637// 初始化职工void WorkerManager::initEmployee()&#123;    ifstream ifs;    ifs.open(WORKER_FILENAME, ios::in);    // 存入 读到的数据    int worker_ID;    string worker_Name;    int worker_DepartID;    // 初始化 记录人数    int index = 0;    // 当 读文件操作对象 返回为真    while (ifs &gt;&gt; worker_ID &amp;&amp; ifs &gt;&gt; worker_Name &amp;&amp; ifs &gt;&gt; worker_DepartID)    &#123;        Worker *worker = nullptr;        // 根据 DepartID，创建不同职工对象        if (worker_DepartID == 1)        &#123;            worker = new Employee(worker_ID, worker_Name, worker_DepartID);        &#125;        else if (worker_DepartID == 2)        &#123;            worker = new Manager(worker_ID, worker_Name, worker_DepartID);        &#125;        else        &#123;            worker = new Boss(worker_ID, worker_Name, worker_DepartID);        &#125;        // 生成职工对象后，存入职工数组中        this-&gt;worker_EmpArray[index] = worker;        index++;    &#125;    ifs.close();&#125;\n\n在workerManager.cpp的构造函数中继续添加代码\n1234567891011// 根据职工数量创建数组this-&gt;worker_EmpArray = new Worker *[this-&gt;worker_EmpNum];this-&gt;initEmployee();// 测试代码for (int i = 0; i &lt;worker_EmpNum; i++)&#123;\tcout &lt;&lt; &quot;&lt;-- 职工编号：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_ID\t\t&lt;&lt; &quot;职工姓名：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_Name\t\t&lt;&lt; &quot;职工部门：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_DepartID\t\t&lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;&#125;\n\n8. 显示职工\n功能描述：显示已录入职工文件内所有的职工信息\n\n8.1 显示职工函数声明\n在workerManager.h中添加成员函数void showEmployeeInfo();\n12// 2.显示职工信息void showEmployeeInfo();\n\n8.2 显示职工函数实现\n在workerManager.cpp中实现函数void showEmployeeInfo()&#123;&#125;\n1234567891011121314151617// 2.显示职工信息void WorkerManager::showEmployeeInfo()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        for (int i = 0; i &lt; worker_EmpNum; i++)        &#123;            // 利用多态调用接口            this-&gt;worker_EmpArray[i]-&gt;getWorkerInfo();        &#125;    &#125;    system(&quot;cls&quot;);&#125;\n\n在StaffManagerSystem_Main.cpp中的void showMenu()&#123;&#125;中补充调用showEmployeeInfo()的代码\n123case 2: // 2.显示职工信息    wm.showEmployeeInfo();    break;\n\n9. 删除职工\n功能描述：按照职工的编号进行删除职工操作\n\n9.1 职工是否存在函数声明\n删除，修改，查找职工功能都需要先检查文件中是否存在职工\n\n在workerManager.h中添加成员函数int IsEmployeeExist(int workerID);\n12// 职工是否存在int isEmployeeExist(int workerID);\n\n9.2 职工是否存在函数实现\n在workerManager.cpp中实现成员函数int isEmployeeExist()&#123;&#125;\n12345678910111213141516// 职工是否存在int WorkerManager::isEmployeeExist(int workerID)&#123;    // 默认index为职工的编号，-1是不存在    int index = -1;    for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)    &#123;        if (this-&gt;worker_EmpArray[i]-&gt;worker_ID == workerID)        &#123;            index = i;            break;        &#125;    &#125;    // 返回 -1 表示不存在这个职工，其他表示找到了对应职工的ID编号    return index;&#125;\n\n9.3 删除职工函数声明\n在workerManager.h中添加成员函数void deletEmployee();\n12// 3.删除离职职工void deletEmployee();\n\n9.4 删除职工函数实现\n在workerManager.cpp中实现成员函数void deletEmployee()&#123;&#125;\n123456789101112131415161718192021222324252627282930313233343536// 3.删除离职职工void WorkerManager::deletEmployee()&#123;    // 先判断是否存在职工文件    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        int workerID = 0;        cout &lt;&lt; &quot;输入需要删除的职工编号&gt;&gt; &quot;;        cin &gt;&gt; workerID;        // 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号        int workerIndex = isEmployeeExist(workerID);        if (workerIndex != -1)        &#123;            // 删掉指定数据后，数组数据需要数据前移            for (int i = workerIndex; i &lt; this-&gt;worker_EmpNum -1; i++)            &#123;                this-&gt;worker_EmpArray[i] = this-&gt;worker_EmpArray[i + 1];            &#125;            // 没移动一个数据，数组后面需要移动的数据就少一个            this-&gt;worker_EmpNum--;            // 修改数据后，将更新的数据保存到文件中            this-&gt;saveNewToFile();            cout &lt;&lt; &quot;编号:&quot; &lt;&lt; workerIndex + 1 &lt;&lt; &quot; 职工已删除&quot; &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;删除失败，职工编号错误&quot; &lt;&lt; endl;        &#125;    &#125;    system(&quot;cls&quot;);&#125;\n\n\n\n在StaffManagerSystem_Main.cpp中添加删除职工的接口\n123case 3: // 3.删除离职职工    wm.deletEmployee();    break;\n\n10. 修改职工\n功能描述：输入职工编号，删除文件中对应的职工信息\n\n10.1 修改职工函数声明\n在workerManager.h中添加成员函数void modifyEmployeeInfo();\n12// 4.修改职工信息void modifyEmployeeInfo();\n\n10.2 修改职工函数实现\n在workerManager.cpp中实现成员函数void modifyEmployeeInfo()&#123;&#125;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 4.修改职工信息void WorkerManager::modifyEmployeeInfo()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        int workerID = 0;        cout &lt;&lt; &quot;输入需要修改的职工编号&gt;&gt; &quot;;        cin &gt;&gt; workerID;        // 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号        int workerIndex = isEmployeeExit(workerID);        if (workerIndex != -1)        &#123;            // 找到存在且有效的职工编号后，删除数组中对应的信息            delete this-&gt;worker_EmpArray[workerIndex];            int newWorker_ID; // 职工ID            string newWorker_Name; // 职工姓名            int newWorker_DepartID; // 职工部门编号            cout &lt;&lt; &quot;查的编号:&quot; &lt;&lt; workerID &lt;&lt; &quot; 的职工&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;新的职工编号&gt;&gt; &quot;;            cin &gt;&gt; newWorker_ID;            cout &lt;&lt; &quot;新的职工姓名&gt;&gt; &quot;;            cin &gt;&gt; newWorker_Name;            cout &lt;&lt; &quot;新的职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;            cin &gt;&gt; newWorker_DepartID;            cout &lt;&lt; endl;            Worker *worker = nullptr;            switch (newWorker_DepartID)            &#123;                case 1:                    worker = new Employee(newWorker_ID, newWorker_Name, 1);                    break;                case 2:                    worker = new Manager(newWorker_ID, newWorker_Name, 2);                    break;                case 3:                    worker = new Boss(newWorker_ID, newWorker_Name, 3);                    break;                default:                    break;            &#125;            // 更新数据到数组中对应的编号            this-&gt;worker_EmpArray[workerIndex] = worker;            cout &lt;&lt; &quot;新编号:&quot; &lt;&lt; newWorker_ID &lt;&lt; &quot; 职工的信息，修改完成&quot;                 &lt;&lt; &quot; 新部门编号:&quot; &lt;&lt; this-&gt;worker_EmpArray[workerIndex]-&gt;worker_DepartID &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;修改失败，职工编号错误或不存在&quot; &lt;&lt; endl;        &#125;    &#125;    system(&quot;cls&quot;);&#125;\n\n在StaffManagerSystem_Main.cpp中添加修改职工的接口\n123case 4: // 4.修改职工信息    wm.modifyEmployeeInfo();    break;\n\n11. 查找职工\n功能描述：提供两种查找方式\n按职工编号查找\n按职工姓名查找\n\n\n\n11.1 查找职工函数声明\n在workerManager.h中添加成员函数void findEmployee();\n12// 5.查找职工信息void findEmployee();\n\n11.2 查找职工函数实现\n在workerManager.cpp中实现成员函数void findEmployee()&#123;&#125;;\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 5.查找职工信息void WorkerManager::findEmployee()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        int findSwitch = 0;        cout &lt;&lt; &quot;查找选择_1.编号_2.姓名&gt;&gt; &quot;;        cin &gt;&gt; findSwitch;        if (findSwitch == 1)        &#123;            int findWorkerID;            cout &lt;&lt; &quot;查找的职工编号&gt;&gt; &quot;;            cin &gt;&gt; findWorkerID;            // 判断输入的编号有效性            int workerIndex = isEmployeeExist(findWorkerID);            if (workerIndex != -1)            &#123;                cout &lt;&lt; &quot;查找成功&quot; &lt;&lt; endl;                cout &lt;&lt; &quot;职工信息: &quot;;                this-&gt;worker_EmpArray[workerIndex]-&gt;getWorkerInfo();            &#125;            else            &#123;                cout &lt;&lt; &quot;查找失败，职工编号错误或不存在&quot; &lt;&lt; endl;            &#125;        &#125;        else if (findSwitch == 2)        &#123;            string findWorkerName;            cout &lt;&lt; &quot;查找的职工姓名&gt;&gt; &quot;;            cin &gt;&gt; findWorkerName;            bool isFindByName = false;            for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)            &#123;                if (this-&gt;worker_EmpArray[i]-&gt;worker_Name == findWorkerName)                &#123;                    isFindByName = true;                    cout &lt;&lt; &quot;查到职工: &quot; &lt;&lt; findWorkerName &lt;&lt; &quot; 职工编号: &quot; &lt;&lt; worker_EmpArray[i]-&gt;worker_ID &lt;&lt; endl;                    cout &lt;&lt; &quot;职工信息: &quot;;                    worker_EmpArray[i]-&gt;getWorkerInfo();                &#125;            &#125;            if (!isFindByName)            &#123;                cout &lt;&lt; &quot;查找失败，职工编号、姓名错误或不存在&quot; &lt;&lt; endl;            &#125;        &#125;        else        &#123;            cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;        &#125;    &#125;    system(&quot;cls&quot;);&#125;\n\n在StaffManagerSystem_Main.cpp中添加查找职工的接口\n123case 5: // 5.查找职工信息    wm.findEmployee();    break;\n\n12. 排序职工\n功能描述：按照职工编号排序，可以依据用户选择进行升序排列和降序排列\n\n12.1 排序函数声明\n在workerManager.h 中添加成员函数void sortEmployeeByID();\n12// 6.按照编号排序void sortEmployeeByID();\n\n12.2 排序函数实现\n在workerManager.cpp中实现成员函数void sortEmployeeByID()&#123;&#125;\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 6.按照编号排序void WorkerManager::sortEmployeeByID()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;    else    &#123;        int switchSort = 0;        cout &lt;&lt; &quot;依据编号，选择排序方式_1.升序排列_2.降序排列&gt;&gt; &quot;;        cin &gt;&gt; switchSort;        for (int i = 0; i &lt; this-&gt;worker_EmpNum; ++i)        &#123;            int maxOrmin = i;            for (int j = i + 1; j &lt; this-&gt;worker_EmpNum; ++j)            &#123;                // 升序排列                if (switchSort == 1)                &#123;                    // 升序排列，如是指定下标的值 大于 遍历出的最小值，说明指定的不是最小的，把遍历的下标赋值给变量                    if (worker_EmpArray[maxOrmin]-&gt;worker_ID &gt; worker_EmpArray[j]-&gt;worker_ID)                    &#123;                        maxOrmin = j;                    &#125;                &#125;                    // 降序排列                else if (switchSort == 2)                &#123;                    // 降序排列，如是指定下标的值 小于 遍历出的最大值，说明指定的不是最大的，把遍历的下标赋值给变量                    if (worker_EmpArray[maxOrmin]-&gt;worker_ID &lt; worker_EmpArray[j]-&gt;worker_ID)                    &#123;                        maxOrmin = j;                    &#125;                &#125;                else                &#123;                    cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;                &#125;            &#125;            // 交换数据            if (maxOrmin != i)            &#123;                Worker *temp = worker_EmpArray[i];                worker_EmpArray[i] = worker_EmpArray[maxOrmin];                worker_EmpArray[maxOrmin] = temp;            &#125;        &#125;        cout &lt;&lt; &quot;排序成功&quot; &lt;&lt; endl;        this-&gt;saveNewToFile();        this-&gt;showEmployeeInfo();    &#125;&#125;\n\n在StaffManagerSystem_Main.cpp这补充接口调用\n123case 6: // 6.按照编号排序    wm.sortEmployeeByID();    break;\n\n13. 清空文件\n功能描述：将文件记录数据清空\n\n13.1 清空文件函数声明\n在workerManager.h中添加成员函数void toEmptyFile();\n12// 7.清空所有文档void toEmptyFile();\n\n13.2 清空文件函数实现\n在workerManager.h中实现成员函数void toEmptyFile()&#123;&#125;\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 7.清空所有文档void WorkerManager::toEmptyFile()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;    else    &#123;        int switchNum = 0;        cout &lt;&lt; &quot;确认清空文件_1.确认_2.取消&gt;&gt; &quot;;        cin &gt;&gt; switchNum;        if (switchNum == 1)        &#123;            // 打开模式 ios::trunc 如果存在文件 删除后 重新生成            ofstream ofs(WORKER_FILENAME, ios::trunc);            ofs.close();            // 判断内存中堆区的是否存在 存在需要释放            if (this-&gt;worker_EmpArray != nullptr)            &#123;                for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)                &#123;                    if (this-&gt;worker_EmpArray[i] != nullptr)                    &#123;                        delete this-&gt;worker_EmpArray[i];                    &#125;                &#125;                this-&gt;worker_EmpNum = 0;                delete[] worker_EmpArray;                this-&gt;worker_EmpArray = nullptr;                this-&gt;isFileEmpty = true;            &#125;            cout &lt;&lt; &quot;职工文件清空完成&quot; &lt;&lt; endl;        &#125;        else if (switchNum == 2)        &#123;            cout &lt;&lt; &quot;已取消清空职工文件&quot; &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;        &#125;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;\n\n13.3 析构函数修改完善\n析构函数内，先判断数组属性是否存在，存在改为NULL，之后删除对象\n123456789101112131415WorkerManager::~WorkerManager()&#123;    if (this-&gt;worker_EmpArray != nullptr)    &#123;        for (int i= 0; i &lt; this-&gt;worker_EmpNum; i++)        &#123;            if (this-&gt;worker_EmpArray[i] != nullptr)            &#123;                delete this-&gt;worker_EmpArray[i];            &#125;        &#125;        delete[] this-&gt;worker_EmpArray;        this-&gt;worker_EmpArray = nullptr;    &#125;&#125;\n\n13.4 清空文件函数测试\n在StaffManagerSystem_Main.cpp这补充接口调用\n123case 7: // 7.清空所有文档    wm.toEmptyFile();    break;\n\n14. 后期bug修复14.1 职工编号存在判断失误\nbug描述：\n\n清空文件后，重新添加职工，输入任意编号，都会判断职工编号已经存在\n\n\nbug修复：\n\n在workerManager.h这添加成员变量\n12// 判断文件是否存在某个编号bool isIDExist;\n\n在workerManager.cpp中修改bool WorkerManager::isEmployeeIDExist(int workerID)&#123;&#125;\n123456789101112131415161718192021222324// 排查添加的新职工的编号在文件中是否存在bool WorkerManager::isEmployeeIDExist(int workerID)&#123;    if (this-&gt;isFileEmpty)    &#123;        this-&gt;isIDExist = false;    &#125;    else    &#123;        for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)        &#123;            if (this-&gt;worker_EmpArray[i]-&gt;worker_ID == workerID)            &#123;                this-&gt;isIDExist = true;                break;            &#125;            else            &#123;                this-&gt;isIDExist = false;            &#125;        &#125;    &#125;    return this-&gt;isIDExist;&#125;\n\n在workerManager.cpp中修改void WorkerManager::addEmployee()&#123;&#125;\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 1.增加职工信息void WorkerManager::addEmployee()&#123;    cout &lt;&lt; &quot;&lt;-- 已录入职工数量：&quot; &lt;&lt; worker_EmpNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;输入增加职工数量：&gt;&gt; &quot;;    int addNum = 0;    cin &gt;&gt; addNum;    if (addNum &gt; 0)    &#123;        // 计算需要的空间大小 = 已用的空间 + 新需要的空间        int newSize = this-&gt;worker_EmpNum + addNum;        // 在 堆区中开辟 计算好大小的内存空间        Worker **newSpace = new Worker *[newSize];        // 将已有空间的内容存在新的内村空间中        if (this-&gt;worker_EmpArray != nullptr)        &#123;            for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)            &#123;                newSpace[i] = this-&gt;worker_EmpArray[i];            &#125;        &#125;        // 再将 需要添加的新内容加入        for (int j = 0; j &lt; addNum; j++)        &#123;            int worker_ID; // 职工ID            string worker_Name; // 职工姓名            int worker_DepartID; // 职工部门编号            bool isExistID = true; // 新增的变量，用于判断文件中是否已存在某个ID            // 在输入职工ID的地方，进行了修改            // 每次输入ID，都要判断一次，输入的ID在职工文件中是否已经存在            // 存在就继续循环该语句，不存在再继续执行之后的语句            while (true)            &#123;                cout &lt;&lt; &quot;输入第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;位员工信息:&quot; &lt;&lt; endl;                cout &lt;&lt; &quot;职工编号&gt;&gt; &quot;;                cin &gt;&gt; worker_ID;                this-&gt;isIDExist = isEmployeeIDExist(worker_ID);                if (this-&gt;isIDExist)                &#123;                    cout &lt;&lt; &quot;编号已经存在&quot; &lt;&lt; endl;                    system(&quot;pause&quot;);                    system(&quot;cls&quot;);                &#125;                else                &#123;                    break;                &#125;            &#125;            cout &lt;&lt; &quot;职工姓名&gt;&gt; &quot;;            cin &gt;&gt; worker_Name;            cout &lt;&lt; &quot;职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;            cin &gt;&gt; worker_DepartID;            cout &lt;&lt; endl;            Worker *worker = nullptr;            switch (worker_DepartID)            &#123;                case 1:                    worker = new Employee(worker_ID, worker_Name, 1);                    break;                case 2:                    worker = new Manager(worker_ID, worker_Name, 2);                    break;                case 3:                    worker = new Boss(worker_ID, worker_Name, 3);                    break;                default:                    break;            &#125;            newSpace[this-&gt;worker_EmpNum + j] = worker;        &#125;        // 释放原本的空间        delete[] this-&gt;worker_EmpArray;        // 更改新空间的指向        this-&gt;worker_EmpArray = newSpace;        // 更新 新的个数        this-&gt;worker_EmpNum = newSize;        // 更新 文件不在为假        this-&gt;isFileEmpty = false;        // 提示信息        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;        // 保存录入的职工信息到文本文件中        this-&gt;saveNewToFile();    &#125;    else    &#123;        cout &lt;&lt; &quot;需输入正确的数字&quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;\n\n在workerManager.cpp中的void WorkerManager::toEmptyFile()&#123;&#125;修改\n12cout &lt;&lt; &quot;职工文件清空完成&quot; &lt;&lt; endl;this-&gt;isIDExist = false;\n\n\n\n15. 源码整理-Clion项目结构：\n\nStaffManagerSystem\nFile\nHeader\nboss.h\nemployee.h\nmanager.h\nworker.h\nworkerManager.h\n\n\nMain\nStaffManagerSystem_Main.cpp\n\n\nSource\nboss.cpp\nemployee.cpp\nmanager.cpp\nworkerManager.cpp\n\n\nCMakeList.txt\n\n\n\n对应源码：\n\nStaffManagerSystem\nFile\n\nHeader\n\nboss.h\n123456789101112131415161718192021222324252627//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_BOSS_H#define STAFFMANAGEMENTSYSTEM_BOSS_H#include &quot;worker.h&quot;#include &lt;iostream&gt;using namespace std;// 老板类class Boss : public Worker&#123;public:    // 初始化 老板 构造函数    Boss(int w_Id, string w_Name, int w_DepartId);    // 获得老板个人信息    void getWorkerInfo() override;    // 获得老板部门岗位名称    string getWorkerDepartName() override;&#125;;#endif //STAFFMANAGEMENTSYSTEM_BOSS_H\n\n\n\nemployee.h\n123456789101112131415161718192021222324252627//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_EMPLOYEE_H#define STAFFMANAGEMENTSYSTEM_EMPLOYEE_H#include &quot;worker.h&quot;#include &lt;iostream&gt;using namespace std;// 普通员工 类class Employee : public Worker&#123;public:    // 初始化 员工 构造函数    Employee(int w_Id, string w_Name, int w_DepartId);    // 获得员工个人信息    void getWorkerInfo() override;    // 获得员工部门岗位名称    string getWorkerDepartName() override;&#125;;#endif //STAFFMANAGEMENTSYSTEM_EMPLOYEE_H\n\n\n\nmanager.h\n123456789101112131415161718192021222324252627//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_MANAGER_H#define STAFFMANAGEMENTSYSTEM_MANAGER_H#include &quot;worker.h&quot;#include &lt;iostream&gt;using namespace std;// 经理类class Manager : public Worker&#123;public:    // 初始化 经理 构造函数    Manager(int w_Id, string w_Name, int w_DepartId);    // 获得经理个人信息    void getWorkerInfo() override;    // 获得经理部门岗位名称    string getWorkerDepartName() override;&#125;;#endif //STAFFMANAGEMENTSYSTEM_MANAGER_H\n\n\n\nworker.h\n123456789101112131415161718192021222324252627//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_WORKER_H#define STAFFMANAGEMENTSYSTEM_WORKER_H#include &lt;iostream&gt;using namespace std;// 职工抽象类class Worker&#123;public:    int worker_ID; // 职工ID    string worker_Name; // 职工姓名    int worker_DepartID; // 职工部门编号    // 获得 职工的信息    virtual void getWorkerInfo() = 0;    // 获得 职工部门的岗位名称    virtual string getWorkerDepartName() = 0;&#125;;#endif //STAFFMANAGEMENTSYSTEM_WORKER_H\n\n\n\nworkerManager.h\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//// Created by Admin on 2021/6/26.//#ifndef STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H#define STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H#define wm workerManager#define WORKER_FILENAME &quot;../File/workerFile.txt&quot;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &quot;worker.h&quot;#include &quot;employee.h&quot;#include &quot;manager.h&quot;#include &quot;boss.h&quot;using namespace std;class WorkerManager&#123;public:    // 记录文件中的人数    int worker_EmpNum;    // 判断文件是否为空    bool isFileEmpty;    // 判断文件是否存在某个编号    bool isIDExist;    // 员工数组指针    Worker ** worker_EmpArray;    WorkerManager();    ~WorkerManager();    // 显示员工管理系统主菜单    void Show_Menu();    // 保持录入职工的信息到文件    void saveNewToFile();    // 获得记录职工人数    int getEmpNum();    // 初始化职工    void initEmployee();    // 职工是否存在    int isEmployeeExist(int workerID);    // 排查添加的新职工的编号在文件中是否存在    bool isEmployeeIDExist(int workerID);    // 0.退出管理系统    void exitSystem();    // 1.增加职工信息    void addEmployee();    // 2.显示职工信息    void showEmployeeInfo();    // 3.删除离职职工    void deletEmployee();    // 4.修改职工信息    void modifyEmployeeInfo();    // 5.查找职工信息    void findEmployee();    // 6.按照编号排序    void sortEmployeeByID();    // 7.清空所有文档    void toEmptyFile();&#125;;#endif //STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n\n\nMain\n\nStaffManagerSystem_Main.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &quot;../Header/workerManager.h&quot;// 早期测试代码void demo()&#123;    Worker *worker;    worker = new Employee(1, &quot;Normal_A&quot;, 1);    worker-&gt;getWorkerInfo();    delete worker;    worker = new Manager(2, &quot;Manager_A&quot;, 2);    worker-&gt;getWorkerInfo();    delete worker;    worker = new Boss(3, &quot;Boss_A&quot;, 3);    worker-&gt;getWorkerInfo();    delete worker;&#125;// 显示职工管理系统的主界面void showMenu()&#123;    // 初始选择    int choice = 0;    // 生成 管理界面 对象    WorkerManager workerManager;    // 调用 菜单界面    while (true)    &#123;        wm.Show_Menu();        cout &lt;&lt; &quot;功能选择 &gt;&gt; &quot;;        cin &gt;&gt; choice;        // 菜单界面的功能选择分支        switch (choice)        &#123;            case 0: // 0.退出管理系统                wm.exitSystem();                break;            case 1: // 1.增加职工信息                wm.addEmployee();                break;            case 2: // 2.显示职工信息                wm.showEmployeeInfo();                break;            case 3: // 3.删除离职职工                wm.deletEmployee();                break;            case 4: // 4.修改职工信息                wm.modifyEmployeeInfo();                break;            case 5: // 5.查找职工信息                wm.findEmployee();                break;            case 6: // 6.按照编号排序                wm.sortEmployeeByID();                break;            case 7: // 7.清空所有文档                wm.toEmptyFile();                break;            default: // 0 ~ 7 之外任意值，清空，重来菜单界面                system(&quot;pause&quot;);                system(&quot;cls&quot;);                break;        &#125;    &#125;&#125;int main()&#123;//    demo();    showMenu();    return 0;&#125;\n\n\nSource\n\nboss.cpp\n1234567891011121314151617181920212223242526272829//// Created by Admin on 2021/6/26.//#include &quot;../Header/boss.h&quot;// 构造函数 初始化 老板 信息Boss::Boss(int w_Id, string w_Name, int w_DepartId)&#123;    this-&gt;worker_ID = w_Id;    this-&gt;worker_Name = w_Name;    this-&gt;worker_DepartID = w_DepartId;&#125;// 获得 职工信息void Boss::getWorkerInfo()&#123;    cout &lt;&lt; &quot;编号：&quot; &lt;&lt; this-&gt;worker_ID         &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; this-&gt;worker_Name         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()         &lt;&lt; &quot;\\t职责：管理所有的事务&quot; &lt;&lt; endl;&#125;// 获得 职工 岗位信息string Boss::getWorkerDepartName()&#123;    return string(&quot;老板&quot;);&#125;\n\n\n\nemployee.cpp\n123456789101112131415161718192021222324252627//// Created by Admin on 2021/6/26.//#include &quot;../Header/employee.h&quot;// 构造函数 初始化 普通员工 信息Employee::Employee(int w_Id, string w_Name, int w_DepartId)&#123;    this-&gt;worker_ID = w_Id;    this-&gt;worker_Name = w_Name;    this-&gt;worker_DepartID = w_DepartId;&#125;// 获得 职工信息void Employee::getWorkerInfo()&#123;    cout &lt;&lt; &quot;编号：&quot; &lt;&lt; this-&gt;worker_ID         &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; this-&gt;worker_Name         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()         &lt;&lt; &quot;\\t职责：完成经理的任务&quot; &lt;&lt; endl;&#125;// 获得 职工 岗位信息string Employee::getWorkerDepartName()&#123;    return string(&quot;员工&quot;);&#125;\n\n\n\nmanager.cpp\n12345678910111213141516171819202122232425262728//// Created by Admin on 2021/6/26.//#include &quot;../Header/manager.h&quot;// 构造函数 初始化 经理 信息Manager::Manager(int w_Id, string w_Name, int w_DepartId)&#123;    this-&gt;worker_ID = w_Id;    this-&gt;worker_Name = w_Name;    this-&gt;worker_DepartID = w_DepartId;&#125;// 获得 职工信息void Manager::getWorkerInfo()&#123;    cout &lt;&lt; &quot;编号：&quot; &lt;&lt; this-&gt;worker_ID         &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; this-&gt;worker_Name         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()         &lt;&lt; &quot;\\t职责：执行老板的任务&quot; &lt;&lt; endl;&#125;// 获得 职工 岗位信息string Manager::getWorkerDepartName()&#123;    return string(&quot;经理&quot;);&#125;\n\n\n\nworkerManager.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628//// Created by Admin on 2021/6/26.//#include &quot;../Header/workerManager.h&quot;WorkerManager::WorkerManager()&#123;    // 1. 初始化 读文件对象    ifstream ifs;    ifs.open(WORKER_FILENAME, ios::in);    // 2. 文件不存在的情况    if (!ifs.is_open())    &#123;        cout &lt;&lt; &quot;&lt;-- 提示：职工文件不存在 --&gt;&quot; &lt;&lt; endl;        this-&gt;worker_EmpNum = 0;        this-&gt;worker_EmpArray = nullptr;        // 初始化 文件 是空        this-&gt;isFileEmpty = true;        ifs.close();        return;    &#125;    // 3. 文件存在 数据为空    string str;    ifs &gt;&gt; str;    if (ifs.eof())    &#123;        cout &lt;&lt; &quot;&lt;-- 提示：职工文件为空 --&gt;&quot; &lt;&lt; endl;        this-&gt;worker_EmpNum = 0;        this-&gt;worker_EmpArray = nullptr;        this-&gt;isFileEmpty = true;        ifs.close();        return;    &#125;    // 4. 文件存在 有数据    // 获得文件已记录人数    int empNum = this-&gt;getEmpNum();    // 更新 记录人数    this-&gt;worker_EmpNum = empNum;    cout &lt;&lt; &quot;&lt;-- 职工数量: &quot; &lt;&lt; empNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;    // 根据职工数量创建数组    this-&gt;worker_EmpArray = new Worker *[this-&gt;worker_EmpNum];    this-&gt;initEmployee();    // 测试代码//    for (int i = 0; i &lt;worker_EmpNum; i++)//    &#123;//        cout &lt;&lt; &quot;&lt;-- 职工编号：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_ID//             &lt;&lt; &quot;   职工姓名：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_Name//             &lt;&lt; &quot;   职工部门：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_DepartID//             &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;//    &#125;&#125;WorkerManager::~WorkerManager()&#123;    if (this-&gt;worker_EmpArray != nullptr)    &#123;        for (int i= 0; i &lt; this-&gt;worker_EmpNum; i++)        &#123;            if (this-&gt;worker_EmpArray[i] != nullptr)            &#123;                delete this-&gt;worker_EmpArray[i];            &#125;        &#125;        delete[] this-&gt;worker_EmpArray;        this-&gt;worker_EmpArray = nullptr;    &#125;&#125;// 显示员工管理系统主菜单void WorkerManager::Show_Menu()&#123;    cout &lt;&lt; &quot;======================&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;====员工管理系统主菜单====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====0.退出管理系统=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====1.增加职工信息=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====2.显示职工信息=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====3.删除离职职工=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====4.修改职工信息=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====5.查找职工信息=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====6.按照编号排序=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;=====7.清空所有文档=====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;======================&quot; &lt;&lt; endl;&#125;// 保持录入职工的信息到文件void WorkerManager::saveNewToFile()&#123;    // 初始化 写文件对象    ofstream ofs;    ofs.open(WORKER_FILENAME, ios::out);    for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)    &#123;        ofs &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_ID &lt;&lt; &quot; &quot;            &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_Name &lt;&lt; &quot; &quot;            &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_DepartID &lt;&lt; endl;    &#125;    ofs.close();&#125;// 获得记录职工人数int WorkerManager::getEmpNum()&#123;    ifstream ifs;    ifs.open(WORKER_FILENAME, ios::in);    // 存入 读到的数据    int worker_ID;    string worker_Name;    int worker_DepartID;    // 初始化 记录人数    int empNum = 0;    // 当 读文件操作对象 返回为真    while (ifs &gt;&gt; worker_ID &amp;&amp; ifs &gt;&gt; worker_Name &amp;&amp; ifs &gt;&gt; worker_DepartID)    &#123;        // 记录人数 +1        empNum++;    &#125;    ifs.close();    return empNum;&#125;// 初始化职工void WorkerManager::initEmployee()&#123;    ifstream ifs;    ifs.open(WORKER_FILENAME, ios::in);    // 存入 读到的数据    int worker_ID;    string worker_Name;    int worker_DepartID;    // 初始化 记录人数    int index = 0;    // 当 读文件操作对象 返回为真    while (ifs &gt;&gt; worker_ID &amp;&amp; ifs &gt;&gt; worker_Name &amp;&amp; ifs &gt;&gt; worker_DepartID)    &#123;        Worker *worker = nullptr;        // 根据 DepartID，创建不同职工对象        if (worker_DepartID == 1)        &#123;            worker = new Employee(worker_ID, worker_Name, worker_DepartID);        &#125;        else if (worker_DepartID == 2)        &#123;            worker = new Manager(worker_ID, worker_Name, worker_DepartID);        &#125;        else        &#123;            worker = new Boss(worker_ID, worker_Name, worker_DepartID);        &#125;        // 生成职工对象后，存入职工数组中        this-&gt;worker_EmpArray[index] = worker;        index++;    &#125;    ifs.close();&#125;// 职工是否存在int WorkerManager::isEmployeeExist(int workerID)&#123;    // 默认index为职工的编号，-1是不存在    int index = -1;    for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)    &#123;        if (this-&gt;worker_EmpArray[i]-&gt;worker_ID == workerID)        &#123;            index = i;            break;        &#125;    &#125;    // 返回 -1 表示不存在这个职工，其他表示找到了对应职工的ID编号    return index;&#125;// 排查添加的新职工的编号在文件中是否存在bool WorkerManager::isEmployeeIDExist(int workerID)&#123;    if (this-&gt;isFileEmpty)    &#123;        this-&gt;isIDExist = false;    &#125;    else    &#123;        for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)        &#123;            if (this-&gt;worker_EmpArray[i]-&gt;worker_ID == workerID)            &#123;                this-&gt;isIDExist = true;                break;            &#125;            else            &#123;                this-&gt;isIDExist = false;            &#125;        &#125;    &#125;    return this-&gt;isIDExist;&#125;// 0.退出管理系统void WorkerManager::exitSystem()&#123;    cout &lt;&lt; &quot;=====员工管理系统-退出=====&quot; &lt;&lt; endl;    exit(0);&#125;// 1.增加职工信息void WorkerManager::addEmployee()&#123;    cout &lt;&lt; &quot;&lt;-- 已录入职工数量：&quot; &lt;&lt; worker_EmpNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;输入增加职工数量：&gt;&gt; &quot;;    int addNum = 0;    cin &gt;&gt; addNum;    if (addNum &gt; 0)    &#123;        // 计算需要的空间大小 = 已用的空间 + 新需要的空间        int newSize = this-&gt;worker_EmpNum + addNum;        // 在 堆区中开辟 计算好大小的内存空间        Worker **newSpace = new Worker *[newSize];        // 将已有空间的内容存在新的内村空间中        if (this-&gt;worker_EmpArray != nullptr)        &#123;            for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)            &#123;                newSpace[i] = this-&gt;worker_EmpArray[i];            &#125;        &#125;        // 再将 需要添加的新内容加入        for (int j = 0; j &lt; addNum; j++)        &#123;            int worker_ID; // 职工ID            string worker_Name; // 职工姓名            int worker_DepartID; // 职工部门编号            bool isExistID = true; // 新增的变量，用于判断文件中是否已存在某个ID            // 在输入职工ID的地方，进行了修改            // 每次输入ID，都要判断一次，输入的ID在职工文件中是否已经存在            // 存在就继续循环该语句，不存在再继续执行之后的语句            while (true)            &#123;                cout &lt;&lt; &quot;输入第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;位员工信息:&quot; &lt;&lt; endl;                cout &lt;&lt; &quot;职工编号&gt;&gt; &quot;;                cin &gt;&gt; worker_ID;                this-&gt;isIDExist = isEmployeeIDExist(worker_ID);                if (this-&gt;isIDExist)                &#123;                    cout &lt;&lt; &quot;编号已经存在&quot; &lt;&lt; endl;                    system(&quot;pause&quot;);                    system(&quot;cls&quot;);                &#125;                else                &#123;                    break;                &#125;            &#125;            cout &lt;&lt; &quot;职工姓名&gt;&gt; &quot;;            cin &gt;&gt; worker_Name;            cout &lt;&lt; &quot;职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;            cin &gt;&gt; worker_DepartID;            cout &lt;&lt; endl;            Worker *worker = nullptr;            switch (worker_DepartID)            &#123;                case 1:                    worker = new Employee(worker_ID, worker_Name, 1);                    break;                case 2:                    worker = new Manager(worker_ID, worker_Name, 2);                    break;                case 3:                    worker = new Boss(worker_ID, worker_Name, 3);                    break;                default:                    break;            &#125;            newSpace[this-&gt;worker_EmpNum + j] = worker;        &#125;        // 释放原本的空间        delete[] this-&gt;worker_EmpArray;        // 更改新空间的指向        this-&gt;worker_EmpArray = newSpace;        // 更新 新的个数        this-&gt;worker_EmpNum = newSize;        // 更新 文件不在为假        this-&gt;isFileEmpty = false;        // 提示信息        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;        // 保存录入的职工信息到文本文件中        this-&gt;saveNewToFile();    &#125;    else    &#123;        cout &lt;&lt; &quot;需输入正确的数字&quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;// 2.显示职工信息void WorkerManager::showEmployeeInfo()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;    else    &#123;        for (int i = 0; i &lt; worker_EmpNum; i++)        &#123;            // 利用多态调用接口            this-&gt;worker_EmpArray[i]-&gt;getWorkerInfo();        &#125;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;// 3.删除离职职工void WorkerManager::deletEmployee()&#123;    // 先判断是否存在职工文件    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;    else    &#123;        int workerID = 0;        cout &lt;&lt; &quot;输入需要删除的职工编号&gt;&gt; &quot;;        cin &gt;&gt; workerID;        // 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号        int workerIndex = isEmployeeExist(workerID);        if (workerIndex != -1)        &#123;            // 删掉指定数据后，数组数据需要数据前移            for (int i = workerIndex; i &lt; this-&gt;worker_EmpNum - 1; i++)            &#123;                this-&gt;worker_EmpArray[i] = this-&gt;worker_EmpArray[i + 1];            &#125;            // 没移动一个数据，数组后面需要移动的数据就少一个            this-&gt;worker_EmpNum--;            // 修改数据后，将更新的数据保存到文件中            this-&gt;saveNewToFile();            cout &lt;&lt; &quot;编号:&quot; &lt;&lt; workerIndex + 1 &lt;&lt; &quot; 职工已删除&quot; &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;删除失败，职工编号错误或不存在&quot; &lt;&lt; endl;        &#125;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;// 4.修改职工信息void WorkerManager::modifyEmployeeInfo()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;    else    &#123;        int workerID = 0;        cout &lt;&lt; &quot;输入需要修改的职工编号&gt;&gt; &quot;;        cin &gt;&gt; workerID;        // 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号        int workerIndex = isEmployeeExist(workerID);        if (workerIndex != -1)        &#123;            // 找到存在且有效的职工编号后，删除数组中对应的信息            delete this-&gt;worker_EmpArray[workerIndex];            int newWorker_ID; // 职工ID            string newWorker_Name; // 职工姓名            int newWorker_DepartID; // 职工部门编号            cout &lt;&lt; &quot;查的编号:&quot; &lt;&lt; workerID &lt;&lt; &quot; 的职工&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;新的职工编号&gt;&gt; &quot;;            cin &gt;&gt; newWorker_ID;            cout &lt;&lt; &quot;新的职工姓名&gt;&gt; &quot;;            cin &gt;&gt; newWorker_Name;            cout &lt;&lt; &quot;新的职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;            cin &gt;&gt; newWorker_DepartID;            cout &lt;&lt; endl;            Worker *worker = nullptr;            switch (newWorker_DepartID)            &#123;                case 1:                    worker = new Employee(newWorker_ID, newWorker_Name, 1);                    break;                case 2:                    worker = new Manager(newWorker_ID, newWorker_Name, 2);                    break;                case 3:                    worker = new Boss(newWorker_ID, newWorker_Name, 3);                    break;                default:                    break;            &#125;            // 更新数据到数组中对应的编号            this-&gt;worker_EmpArray[workerIndex] = worker;            cout &lt;&lt; &quot;新编号:&quot; &lt;&lt; newWorker_ID &lt;&lt; &quot; 职工的信息，修改完成&quot;                 &lt;&lt; &quot; 新部门编号:&quot; &lt;&lt; this-&gt;worker_EmpArray[workerIndex]-&gt;worker_DepartID &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;修改失败，职工编号错误或不存在&quot; &lt;&lt; endl;        &#125;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;// 5.查找职工信息void WorkerManager::findEmployee()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;    else    &#123;        int findSwitch = 0;        cout &lt;&lt; &quot;查找选择_1.编号_2.姓名&gt;&gt; &quot;;        cin &gt;&gt; findSwitch;        if (findSwitch == 1)        &#123;            int findWorkerID;            cout &lt;&lt; &quot;查找的职工编号&gt;&gt; &quot;;            cin &gt;&gt; findWorkerID;            // 判断输入的编号有效性            int workerIndex = isEmployeeExist(findWorkerID);            if (workerIndex != -1)            &#123;                cout &lt;&lt; &quot;查找成功&quot; &lt;&lt; endl;                cout &lt;&lt; &quot;职工信息: &quot;;                this-&gt;worker_EmpArray[workerIndex]-&gt;getWorkerInfo();            &#125;            else            &#123;                cout &lt;&lt; &quot;查找失败，职工编号错误或不存在&quot; &lt;&lt; endl;            &#125;        &#125;        else if (findSwitch == 2)        &#123;            string findWorkerName;            cout &lt;&lt; &quot;查找的职工姓名&gt;&gt; &quot;;            cin &gt;&gt; findWorkerName;            bool isFindByName = false;            for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)            &#123;                if (this-&gt;worker_EmpArray[i]-&gt;worker_Name == findWorkerName)                &#123;                    isFindByName = true;                    cout &lt;&lt; &quot;查到职工: &quot; &lt;&lt; findWorkerName &lt;&lt; &quot; 职工编号: &quot; &lt;&lt; worker_EmpArray[i]-&gt;worker_ID &lt;&lt; endl;                    cout &lt;&lt; &quot;职工信息: &quot;;                    worker_EmpArray[i]-&gt;getWorkerInfo();                &#125;            &#125;            if (!isFindByName)            &#123;                cout &lt;&lt; &quot;查找失败，职工编号、姓名错误或不存在&quot; &lt;&lt; endl;            &#125;        &#125;        else        &#123;            cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;        &#125;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;// 6.按照编号排序void WorkerManager::sortEmployeeByID()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;    else    &#123;        int switchSort = 0;        cout &lt;&lt; &quot;依据编号，选择排序方式_1.升序排列_2.降序排列&gt;&gt; &quot;;        cin &gt;&gt; switchSort;        for (int i = 0; i &lt; this-&gt;worker_EmpNum; ++i)        &#123;            int maxOrmin = i;            for (int j = i + 1; j &lt; this-&gt;worker_EmpNum; ++j)            &#123;                // 升序排列                if (switchSort == 1)                &#123;                    // 升序排列，如是指定下标的值 大于 遍历出的最小值，说明指定的不是最小的，把遍历的下标赋值给变量                    if (worker_EmpArray[maxOrmin]-&gt;worker_ID &gt; worker_EmpArray[j]-&gt;worker_ID)                    &#123;                        maxOrmin = j;                    &#125;                &#125;                    // 降序排列                else if (switchSort == 2)                &#123;                    // 降序排列，如是指定下标的值 小于 遍历出的最大值，说明指定的不是最大的，把遍历的下标赋值给变量                    if (worker_EmpArray[maxOrmin]-&gt;worker_ID &lt; worker_EmpArray[j]-&gt;worker_ID)                    &#123;                        maxOrmin = j;                    &#125;                &#125;                else                &#123;                    cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;                &#125;            &#125;            // 交换数据            if (maxOrmin != i)            &#123;                Worker *temp = worker_EmpArray[i];                worker_EmpArray[i] = worker_EmpArray[maxOrmin];                worker_EmpArray[maxOrmin] = temp;            &#125;        &#125;        cout &lt;&lt; &quot;排序成功&quot; &lt;&lt; endl;        this-&gt;saveNewToFile();        this-&gt;showEmployeeInfo();    &#125;&#125;// 7.清空所有文档void WorkerManager::toEmptyFile()&#123;    if (this-&gt;isFileEmpty)    &#123;        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;    else    &#123;        int switchNum = 0;        cout &lt;&lt; &quot;确认清空文件_1.确认_2.取消&gt;&gt; &quot;;        cin &gt;&gt; switchNum;        if (switchNum == 1)        &#123;            // 打开模式 ios::trunc 如果存在文件 删除后 重新生成            ofstream ofs(WORKER_FILENAME, ios::trunc);            ofs.close();            // 判断内存中堆区的是否存在 存在需要释放            if (this-&gt;worker_EmpArray != nullptr)            &#123;                for (int i = 0; i &lt; this-&gt;worker_EmpNum; i++)                &#123;                    if (this-&gt;worker_EmpArray[i] != nullptr)                    &#123;                        delete this-&gt;worker_EmpArray[i];                    &#125;                &#125;                this-&gt;worker_EmpNum = 0;                delete[] worker_EmpArray;                this-&gt;worker_EmpArray = nullptr;                this-&gt;isFileEmpty = true;            &#125;            cout &lt;&lt; &quot;职工文件清空完成&quot; &lt;&lt; endl;            this-&gt;isIDExist = false;        &#125;        else if (switchNum == 2)        &#123;            cout &lt;&lt; &quot;已取消清空职工文件&quot; &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;        &#125;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;\n\n\nCMakeList.txt\n12345678910cmake_minimum_required(VERSION 3.19)project(StaffManagementSystem)set(CMAKE_CXX_STANDARD 14)add_executable(StaffManagementSystem        Main/StaffManagerSystem_Main.cpp        Header/workerManager.h Header/worker.h Header/employee.h Header/manager.h Header/boss.h        Source/workerManager.cpp Source/employee.cpp Source/manager.cpp Source/boss.cpp        )\n\n\n\n","slug":"1_C++_职工管理系统_04","date":"2022-10-06T07:28:25.925Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"ece0e381639ba808e0c15b18566061ec","title":"C++_通讯录管理系统","content":"C++_通讯录管理系统[toc]\n1. 系统需求\n添加联系人：向通讯录中添加联系人，联系人信息（姓名，性别，年龄，联系电话，家庭住址），最多记录1000人\n显示联系人：显示通讯录中所有联系人信息\n删除联系人：按照姓名进行删除指定联系人\n查找联系人：按照姓名查找指定联系人信息\n修改联系人：按照姓名重新修改联系人信息\n清空联系人：清空通讯录中所有联系人信息\n退出通讯录：退出当前正在使用的通讯录\n\n2. 创建项目1. 创建项目\nVS中创建新项目 AddressBook\n选择空项目\n\n2. 创建文件\n在新的项目中找到源文件\n在源文件中创建空的 AddressBook.cpp文件\n\n3. 菜单功能\n描述：用户选择功能界面\n\n步骤：\n\n分装函数显示该界面 void showAddressBookMenu()\n在main中调用封装好的函数\n创建头文件 AddressBook.h\n创建源文件 Features.cpp\n\n\n代码：\nAddressBook.h\n12345#include &lt;iostream&gt;using namespace std;void showAddressBookMenu();\n\nFeatures.cpp\n12345678910111213#include &quot;AddressBook.h&quot;void showAddressBookMenu()&#123;\tcout &lt;&lt; &quot;-------- Address Book --------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t1. 添加联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t2. 显示联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t3. 删除联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t4. 查找联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t5. 修改联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t6. 清空联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t0. 退出通讯录&quot; &lt;&lt; endl;&#125;\n\nAddressBook.cpp\n123456789#include &lt;iostream&gt;#include &quot;AddressBook.h&quot;using namespace std;void main()&#123;\tshowAddressBookMenu();&#125;\n\n4. 退出功能\n描述：退出通讯录\n\n思路：通过switch语句判断用户的输入，执行退出功能\n\n代码：\nmain.cpp\n123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &quot;AddressBook.h&quot;using namespace std;int main()&#123;\tint userSelect;\twhile (true)\t&#123;\t\tshowAddressBookMenu();\t\t\t\tcout &lt;&lt; &quot;Select : &quot;;\t\tcin &gt;&gt; userSelect;\t\tswitch (userSelect)\t\t&#123;\t\tcase 1: //1. 添加联系人\t\t\tbreak;\t\tcase 2: //2. 显示联系人\t\t\tbreak;\t\tcase 3: //3. 删除联系人\t\t\tbreak;\t\tcase 4: //4. 查找联系人\t\t\tbreak;\t\tcase 5: //5. 修改联系人\t\t\tbreak;\t\tcase 6: //6. 清空联系人\t\t\tbreak;\t\tcase 0: //0. 退出通讯录\t\t\texitAddressBook();\t\t\treturn 0;\t\t\tbreak;\t\tdefault:\t\t\tbreak;\t\t&#125;\t&#125;&#125;\n\n.h\n123456#include &lt;iostream&gt;using namespace std;void showAddressBookMenu();void exitAddressBook();\n\n源.cpp\n12345678910111213141516171819#include &quot;AddressBook.h&quot;void showAddressBookMenu()&#123;\tcout &lt;&lt; &quot;-------- Address Book --------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t1. 添加联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t2. 显示联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t3. 删除联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t4. 查找联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t5. 修改联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t6. 清空联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t0. 退出通讯录&quot; &lt;&lt; endl;&#125;void exitAddressBook()&#123;\tcout &lt;&lt; &quot;已退出通讯录&quot; &lt;&lt; endl;\tsystem(&quot;pause&quot;);&#125;\n\n5. 添加联系人\n描述：实现添加联系人功能，上限1000人，联系人信息（姓名，性别，年龄，联系电话，住址）\n步骤：\n设计联系人结构体\n设计通讯录结构体\nmain中创建通讯录\n分装添加联系人函数\n\n\n\n1. 设计联系人结构体\n联系人信息（姓名，性别，年龄，联系电话，住址）\nmain\n1234567struct s_ContactPerson&#123;\tstring m_Name;\tint m_Sex;\tint m_Age;\tstring m_Address;&#125;;\n\n2. 设计通讯录结构体main\n1234567#define MAX 1000 //限定通讯录的最大人数struct s_AddressBook&#123;\ts_ContactPerson personArr[MAX];\tint m_Size; //通讯录的联系人数&#125;;\n\n\n\n3. main中创建通讯录12s_AddressBook s_ABS; //创建通讯录s_ABS.m_Size = 0;\n\n\n\n4. 添加联系人12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void addPerson(s_AddressBook* s_ABS)&#123;\tif (s_ABS-&gt;m_Size == MAX)\t&#123;\t\tcout &lt;&lt; &quot;Address Book is Full !&quot;;\t\treturn;\t&#125;\telse\t&#123;\t\t//Enter address book contactperson info : name\t\tstring enterName;\t\tcout &lt;&lt; &quot;Enter name: &quot;;\t\tcin &gt;&gt; enterName;\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Name = enterName;\t\t//Enter address book contactperson info : sex\t\tint enterSex = 0;\t\twhile (true)\t\t&#123;\t\t\tcout &lt;&lt; &quot;Enter sex(1-Man;2-Women;default 0): &quot;;\t\t\tcin &gt;&gt; enterSex;\t\t\tif (enterSex == 1 || enterSex == 2)\t\t\t&#123;\t\t\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Sex = enterSex;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;Enter 1 or 2&quot; &lt;&lt; endl;\t\t\t&#125;\t\t&#125;\t\t//Enter address book contactperson info : age\t\tint enterAge = 0;\t\tcout &lt;&lt; &quot;Enter age: &quot;;\t\tcin &gt;&gt; enterAge;\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Age = enterAge;\t\t//Enter address book contactperson info : phone\t\tstring enterPhone;\t\tcout &lt;&lt; &quot;Enter phone: &quot;;\t\tcin &gt;&gt; enterPhone;\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_phone = enterPhone;\t\t//Enter address book contactperson info : address\t\tstring enterAddress;\t\tcout &lt;&lt; &quot;Enter address: &quot;;\t\tcin &gt;&gt; enterAddress;\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Address = enterAddress;\t\t//tip info\t\tcout &lt;&lt; s_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Name &lt;&lt; &quot; Add Succeeded !&quot; &lt;&lt; endl;\t\t//update address book m_size \t\ts_ABS-&gt;m_Size++;\t\t//clear console show info\t\tsystem(&quot;pause&quot;); //请按任意键\t\tsystem(&quot;cls&quot;); //clear console show info\t&#125;&#125;\n\n1234main中case 1: //1. 添加联系人\t\t\taddPerson(&amp;s_ABS); //通过地址传递结构体实参，可以在函数中修改本地的结构体内实参值\t\t\tbreak;\n\n\n\n5. 显示联系人\n描述：显示通讯录中已有的联系人信息\n\n步骤：\n\n封装显示联系人函数\n测速显示联系人函数\n\n代码添加：\n123456789101112131415161718192021void showPerson(s_AddressBook* s_ABS)&#123;\tif (s_ABS-&gt;m_Size == 0)\t&#123;\t\tcout &lt;&lt; &quot;-------- Address Book No Contact ! --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tfor (int i = 0; i &lt; s_ABS-&gt;m_Size; i++)\t\t&#123;\t\t\tcout &lt;&lt; &quot; &quot; &lt;&lt; s_ABS-&gt;m_Size &lt;&lt; &quot;. &quot;\t\t\t\t&lt;&lt; &quot;Name: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Name \t\t\t\t&lt;&lt; &quot; / Sex: &quot; &lt;&lt; (s_ABS-&gt;personArr[i].m_Sex == 1 ? &quot;男&quot;:&quot;女&quot;)\t\t\t\t&lt;&lt; &quot; / Age: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Age \t\t\t\t&lt;&lt; &quot; / Phone: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_phone \t\t\t\t&lt;&lt; &quot; / Address: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Address &lt;&lt; endl;\t\t&#125;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;\n\n1234main中case 2: //2. 显示联系人\t\t\tshowPerson(&amp;s_ABS);\t\t\tbreak;\n\n6. 删除联系人\n描述：按照姓名删除指定联系人\n\n步骤：\n\n封装检测联系人是否存在函数\n封装删除联系人函数\n测速删除联系人函数\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//查找联系人(服务与删除联系人功能)int findPerson(s_AddressBook* s_ABS, string enterName)&#123;\tfor (int i = 0; i &lt; s_ABS-&gt;m_Size; i++)\t&#123;\t\tif (s_ABS-&gt;personArr[i].m_Name == enterName)\t\t&#123;\t\t\treturn i; //若找到\t\t&#125;\t&#125;\treturn -1; //若没找到&#125;//删除联系人void deletPerson(s_AddressBook* s_ABS, int personIndex, string enterName)&#123;\tif (personIndex == -1)\t&#123;\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;-------- &quot; &lt;&lt; enterName &lt;&lt; &quot; Delet Succeeded ! --------&quot; &lt;&lt; endl;\t\tfor (int i = personIndex; i &lt; s_ABS-&gt;m_Size; i++)\t\t&#123;\t\t\ts_ABS-&gt;personArr[i] = s_ABS-&gt;personArr[i + 1];\t\t&#125;\t\ts_ABS-&gt;m_Size--;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;//提示输入信息string tipEnterInfo(string enterName)&#123;\tcout &lt;&lt; &quot;Enter Name for Delet: &quot;;\tcin &gt;&gt; enterName;\treturn enterName;&#125;//提示返回信息void tipReturnInfo(int returnNum)&#123;\tif (returnNum == -1)\t&#123;\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;-------- Have Contact --------&quot; &lt;&lt; endl;\t&#125;&#125;\n\n12345678910111213main中case 3: //3. 删除联系人\t\t&#123;\t\t\tstring enterName;\t\t\tint personIndex;\t\t\t\t\t\tenterName = tipEnterInfo(enterName);\t\t\tfindPerson(&amp;s_ABS, enterName);\t\t\t\t\t\tpersonIndex = findPerson(&amp;s_ABS, enterName);\t\t\t//tipReturnInfo(findPerson(&amp;s_ABS, enterName));\t\t\tdeletPerson(&amp;s_ABS, personIndex, enterName); \t\t&#125;\n\n7. 查找联系人\n描述：按照指定的姓名查找联系人是否存在\n\n步骤：\n\n封装查找联系人函数\n测速查找联系人函数\n\n12345678910111213141516171819202122232425//查找联系人void findPerson(s_AddressBook* s_ABS)&#123;\tcout &lt;&lt; &quot;Enter name: &quot;;\tstring findName;\tcin &gt;&gt; findName;\tint nameIndex = findPersonByDelet(s_ABS, findName);\t\tif (nameIndex == -1)\t&#123;\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot; &quot; &lt;&lt; nameIndex &lt;&lt; &quot;. &quot;\t\t\t&lt;&lt; &quot;Name: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Name\t\t\t&lt;&lt; &quot; / Sex: &quot; &lt;&lt; (s_ABS-&gt;personArr[nameIndex].m_Sex == 1 ? &quot;男&quot; : &quot;女&quot;)\t\t\t&lt;&lt; &quot; / Age: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Age\t\t\t&lt;&lt; &quot; / Phone: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_phone\t\t\t&lt;&lt; &quot; / Address: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Address &lt;&lt; endl;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;\n\n1234main中case 4: //4. 查找联系人\t\t\tfindPerson(&amp;s_ABS);\t\t\tbreak;\n\n8. 修改联系人\n描述：修改指定姓名的联系人的信息\n\n步骤：\n\n封装修改联系人函数\n测速修改联系人函数\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127 //修改联系人菜单 void showModifyContactMenu() &#123; \tcout &lt;&lt; endl; \tcout &lt;&lt; &quot;-------- Modify Contact --------&quot; &lt;&lt; endl; \tcout &lt;&lt; &quot;\\t1. Modify Name&quot; &lt;&lt; endl;cout &lt;&lt; &quot;\\t2. Modify Sex&quot; &lt;&lt; endl; \tcout &lt;&lt; &quot;\\t3. Modify Age&quot; &lt;&lt; endl; \tcout &lt;&lt; &quot;\\t4. Modify Phone&quot; &lt;&lt; endl; \tcout &lt;&lt; &quot;\\t5. Modify Address&quot; &lt;&lt; endl; \tcout &lt;&lt; &quot;\\t0. Exit Modify&quot; &lt;&lt; endl; &#125;  //修改联系人 int modifyPerson(s_AddressBook* s_ABS) &#123; \tcout &lt;&lt; &quot;Enter name: &quot;; \tstring modifyName; \tcin &gt;&gt; modifyName;  \tint nameIndex = findPersonByDeletOrModify(s_ABS, modifyName);  \tif (nameIndex == -1) \t&#123; \t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl; \t&#125; \telse \t&#123; \t\tint userSelect; \t\t \t\twhile (true) \t\t&#123; \t\t\tshowModifyContactMenu();  \t\t\tcout &lt;&lt; &quot;Select : &quot;; \t\t\tcin &gt;&gt; userSelect; \t\t\t \t\t\tswitch (userSelect) \t\t\t&#123; \t\t\tcase 1 : //Modify Name \t\t\t&#123; \t\t\t\tcout &lt;&lt; &quot;Enter name: &quot; &lt;&lt; endl; \t\t\t\tstring newName; \t\t\t\tcin &gt;&gt; newName; \t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Name = newName; \t\t\t\tcout &lt;&lt; &quot;-------- Modify Name Succeeded ! --------&quot; &lt;&lt; endl; \t\t\t\t \t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tsystem(&quot;cls&quot;); \t\t\t&#125; \t\t\t\tbreak; \t\t\tcase 2: //Modify Sex \t\t\t&#123; \t\t\t\tcout &lt;&lt; &quot;Enter sex(1-Man / 2-Women / default 1): &quot;; \t\t\t\tint newSex; \t\t\t\twhile (true) \t\t\t\t&#123; \t\t\t\t\tcin &gt;&gt; newSex; \t\t\t\t\tif (newSex == 1 || newSex == 2) \t\t\t\t\t&#123; \t\t\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Sex = newSex; \t\t\t\t\t\tbreak; \t\t\t\t\t&#125; \t\t\t\t\telse \t\t\t\t\t&#123; \t\t\t\t\t\tcout &lt;&lt; &quot;Enter 1 or 2&quot; &lt;&lt; endl; \t\t\t\t\t&#125; \t\t\t\t&#125; \t\t\t\tcout &lt;&lt; &quot;-------- Modify Sex Succeeded ! --------&quot; &lt;&lt; endl;  \t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tsystem(&quot;cls&quot;); \t\t\t&#125; \t\t\t\tbreak; \t\t\tcase 3: //Modify Age \t\t\t&#123; \t\t\t\tcout &lt;&lt; &quot;Enter Age: &quot;; \t\t\t\tint newAge; \t\t\t\tcin &gt;&gt; newAge; \t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Age = newAge; \t\t\t\tcout &lt;&lt; &quot;-------- Modify Age Succeeded ! --------&quot; &lt;&lt; endl;  \t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tsystem(&quot;cls&quot;); \t\t\t&#125; \t\t\t\tbreak; \t\t\tcase 4: //Modify Phone \t\t\t&#123; \t\t\t\tcout &lt;&lt; &quot;Enter Phone: &quot;; \t\t\t\tstring newPhone; \t\t\t\tcin &gt;&gt; newPhone; \t\t\t\ts_ABS-&gt;personArr[nameIndex].m_phone = newPhone; \t\t\t\tcout &lt;&lt; &quot;-------- Modify Phone Succeeded ! --------&quot; &lt;&lt; endl;  \t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tsystem(&quot;cls&quot;); \t\t\t&#125; \t\t\t\tbreak; \t\t\tcase 5: //Modify Address \t\t\t&#123; \t\t\t\tcout &lt;&lt; &quot;Enter Address: &quot;; \t\t\t\tstring newAddress; \t\t\t\tcin &gt;&gt; newAddress; \t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Address = newAddress; \t\t\t\tcout &lt;&lt; &quot;-------- Modify Address Succeeded ! --------&quot; &lt;&lt; endl;  \t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tsystem(&quot;cls&quot;); \t\t\t&#125; \t\t\t\tbreak; \t\t\tcase 0: \t\t\t&#123; \t\t\t\tcout &lt;&lt; &quot;已退出修改联系人&quot; &lt;&lt; endl; \t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tsystem(&quot;cls&quot;); \t\t\t&#125; \t\t\treturn 0; \t\t\t\tbreak; \t\t\tdefault: \t\t\t\tbreak; \t\t\t&#125; \t\t&#125; \t&#125;  \tsystem(&quot;pause&quot;); \tsystem(&quot;cls&quot;); &#125;\n\n1234maincase 5: //5. 修改联系人\t\t\tmodifyPerson(&amp;s_ABS);\t\t\tbreak;\n\n9. 清空联系人\n描述：清空通讯录中所有联系人的信息\n\n步骤：\n\n封装清空联系人函数\n测速清空联系人函数\n\n1234567891011121314151617181920212223242526272829303132//清空联系人void cleanPerson(s_AddressBook* s_ABS)&#123;\tstring enterYN;\tstring selectYN;\twhile (true)\t&#123;\t\tcout &lt;&lt; &quot;Clean All Contact ( y / n ): &quot;;\t\tcin &gt;&gt; enterYN;\t\tif (enterYN == &quot;y&quot; || enterYN == &quot;n&quot;)\t\t&#123;\t\t\tselectYN = enterYN;\t\t\tbreak;\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;Enter y or n&quot; &lt;&lt; endl;\t\t&#125;\t&#125;\tif (selectYN == &quot;y&quot;)\t&#123;\t\ts_ABS-&gt;m_Size = 0;\t\tcout &lt;&lt; &quot;-------- Address Book Clean Succeeded ! --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;-------- Address Book Clean Exit ! --------&quot; &lt;&lt; endl;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;\n\n1234maincase 6: //6. 清空联系人\t\t\tcleanPerson(&amp;s_ABS);\t\t\tbreak;\n\n6. 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421#include &lt;iostream&gt;#define MAX 1000 //限定通讯录的最大人数using namespace std;struct s_ContactPerson&#123;\tstring m_Name;\tint m_Sex = 1;\tint m_Age = 0;\tstring m_phone;\tstring m_Address;&#125;;struct s_AddressBook&#123;\ts_ContactPerson personArr[MAX];\tint m_Size = 0; //通讯录的联系人数&#125;;//显示通讯录菜单void showAddressBookMenu()&#123;\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;-------- Address Book --------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t1. 添加联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t2. 显示联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t3. 删除联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t4. 查找联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t5. 修改联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t6. 清空联系人&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t0. 退出通讯录&quot; &lt;&lt; endl;&#125;//添加联系人void addPerson(s_AddressBook* s_ABS)&#123;\tif (s_ABS-&gt;m_Size == MAX)\t&#123;\t\tcout &lt;&lt; &quot;Address Book is Full !&quot;;\t\treturn;\t&#125;\telse\t&#123;\t\t//Enter address book contactperson info : name\t\tstring enterName;\t\tcout &lt;&lt; &quot;Enter name: &quot;;\t\tcin &gt;&gt; enterName;\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Name = enterName;\t\t//Enter address book contactperson info : sex\t\tint enterSex = 0;\t\twhile (true)\t\t&#123;\t\t\tcout &lt;&lt; &quot;Enter sex(1-Man / 2-Women / default 1): &quot;;\t\t\tcin &gt;&gt; enterSex;\t\t\tif (enterSex == 1 || enterSex == 2)\t\t\t&#123;\t\t\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Sex = enterSex;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;Enter 1 or 2&quot; &lt;&lt; endl;\t\t\t&#125;\t\t&#125;\t\t//Enter address book contactperson info : age\t\tint enterAge = 0;\t\tcout &lt;&lt; &quot;Enter age: &quot;;\t\tcin &gt;&gt; enterAge;\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Age = enterAge;\t\t//Enter address book contactperson info : phone\t\tstring enterPhone;\t\tcout &lt;&lt; &quot;Enter phone: &quot;;\t\tcin &gt;&gt; enterPhone;\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_phone = enterPhone;\t\t//Enter address book contactperson info : address\t\tstring enterAddress;\t\tcout &lt;&lt; &quot;Enter address: &quot;;\t\tcin &gt;&gt; enterAddress;\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Address = enterAddress;\t\t//tip info\t\tcout &lt;&lt; &quot;-------- &quot; &lt;&lt; s_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Name &lt;&lt; &quot; Add Succeeded ! --------&quot; &lt;&lt; endl;\t\t//update address book m_size \t\ts_ABS-&gt;m_Size++;\t\t//clear console show info\t\tsystem(&quot;pause&quot;); //请按任意键\t\tsystem(&quot;cls&quot;); //clear console show info\t&#125;&#125;//显示联系人void showPerson(s_AddressBook* s_ABS)&#123;\tif (s_ABS-&gt;m_Size == 0)\t&#123;\t\tcout &lt;&lt; &quot;-------- Address Book No Contact ! --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tfor (int i = 0; i &lt; s_ABS-&gt;m_Size; i++)\t\t&#123;\t\t\tcout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot;. &quot;\t\t\t\t&lt;&lt; &quot;Name: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Name \t\t\t\t&lt;&lt; &quot; / Sex: &quot; &lt;&lt; (s_ABS-&gt;personArr[i].m_Sex == 1 ? &quot;男&quot;:&quot;女&quot;)\t\t\t\t&lt;&lt; &quot; / Age: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Age \t\t\t\t&lt;&lt; &quot; / Phone: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_phone \t\t\t\t&lt;&lt; &quot; / Address: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Address &lt;&lt; endl;\t\t&#125;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;//查找联系人(服务与删除联系人功能)int findPersonByDeletOrModify (s_AddressBook* s_ABS, string enterName)&#123;\tfor (int i = 0; i &lt; s_ABS-&gt;m_Size; i++)\t&#123;\t\tif (s_ABS-&gt;personArr[i].m_Name == enterName)\t\t&#123;\t\t\treturn i; //若找到\t\t&#125;\t&#125;\treturn -1; //若没找到&#125;//删除联系人void deletPerson(s_AddressBook* s_ABS, int personIndex, string enterName)&#123;\tif (personIndex == -1)\t&#123;\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;-------- &quot; &lt;&lt; enterName &lt;&lt; &quot; Delet Succeeded ! --------&quot; &lt;&lt; endl;\t\tfor (int i = personIndex; i &lt; s_ABS-&gt;m_Size; i++)\t\t&#123;\t\t\ts_ABS-&gt;personArr[i] = s_ABS-&gt;personArr[i + 1];\t\t&#125;\t\ts_ABS-&gt;m_Size--;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;//提示输入信息string tipEnterInfo(string enterName)&#123;\tcout &lt;&lt; &quot;Enter Name for Delet: &quot;;\tcin &gt;&gt; enterName;\treturn enterName;&#125;//提示返回信息void tipReturnInfo(int returnNum)&#123;\tif (returnNum == -1)\t&#123;\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;-------- Have Contact --------&quot; &lt;&lt; endl;\t&#125;&#125;//查找联系人void findPerson(s_AddressBook* s_ABS)&#123;\tcout &lt;&lt; &quot;Enter name: &quot;;\tstring findName;\tcin &gt;&gt; findName;\tint nameIndex = findPersonByDeletOrModify(s_ABS, findName);\t\tif (nameIndex == -1)\t&#123;\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot; &quot; &lt;&lt; nameIndex &lt;&lt; &quot;. &quot;\t\t\t&lt;&lt; &quot;Name: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Name\t\t\t&lt;&lt; &quot; / Sex: &quot; &lt;&lt; (s_ABS-&gt;personArr[nameIndex].m_Sex == 1 ? &quot;男&quot; : &quot;女&quot;)\t\t\t&lt;&lt; &quot; / Age: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Age\t\t\t&lt;&lt; &quot; / Phone: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_phone\t\t\t&lt;&lt; &quot; / Address: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Address &lt;&lt; endl;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;//修改联系人菜单void showModifyContactMenu()&#123;\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;-------- Modify Contact --------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t1. Modify Name&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t2. Modify Sex&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t3. Modify Age&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t4. Modify Phone&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t5. Modify Address&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;\\t0. Exit Modify&quot; &lt;&lt; endl;&#125;//修改联系人int modifyPerson(s_AddressBook* s_ABS)&#123;\tcout &lt;&lt; &quot;Enter name: &quot;;\tstring modifyName;\tcin &gt;&gt; modifyName;\tint nameIndex = findPersonByDeletOrModify(s_ABS, modifyName);\tif (nameIndex == -1)\t&#123;\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tint userSelect;\t\t\t\twhile (true)\t\t&#123;\t\t\tshowModifyContactMenu();\t\t\tcout &lt;&lt; &quot;Select : &quot;;\t\t\tcin &gt;&gt; userSelect;\t\t\t\t\t\tswitch (userSelect)\t\t\t&#123;\t\t\tcase 1 : //Modify Name\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;Enter name: &quot; &lt;&lt; endl;\t\t\t\tstring newName;\t\t\t\tcin &gt;&gt; newName;\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Name = newName;\t\t\t\tcout &lt;&lt; &quot;-------- Modify Name Succeeded ! --------&quot; &lt;&lt; endl;\t\t\t\t\t\t\t\tsystem(&quot;pause&quot;);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase 2: //Modify Sex\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;Enter sex(1-Man / 2-Women / default 1): &quot;;\t\t\t\tint newSex;\t\t\t\twhile (true)\t\t\t\t&#123;\t\t\t\t\tcin &gt;&gt; newSex;\t\t\t\t\tif (newSex == 1 || newSex == 2)\t\t\t\t\t&#123;\t\t\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Sex = newSex;\t\t\t\t\t\tbreak;\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\tcout &lt;&lt; &quot;Enter 1 or 2&quot; &lt;&lt; endl;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tcout &lt;&lt; &quot;-------- Modify Sex Succeeded ! --------&quot; &lt;&lt; endl;\t\t\t\tsystem(&quot;pause&quot;);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase 3: //Modify Age\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;Enter Age: &quot;;\t\t\t\tint newAge;\t\t\t\tcin &gt;&gt; newAge;\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Age = newAge;\t\t\t\tcout &lt;&lt; &quot;-------- Modify Age Succeeded ! --------&quot; &lt;&lt; endl;\t\t\t\tsystem(&quot;pause&quot;);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase 4: //Modify Phone\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;Enter Phone: &quot;;\t\t\t\tstring newPhone;\t\t\t\tcin &gt;&gt; newPhone;\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_phone = newPhone;\t\t\t\tcout &lt;&lt; &quot;-------- Modify Phone Succeeded ! --------&quot; &lt;&lt; endl;\t\t\t\tsystem(&quot;pause&quot;);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase 5: //Modify Address\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;Enter Address: &quot;;\t\t\t\tstring newAddress;\t\t\t\tcin &gt;&gt; newAddress;\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Address = newAddress;\t\t\t\tcout &lt;&lt; &quot;-------- Modify Address Succeeded ! --------&quot; &lt;&lt; endl;\t\t\t\tsystem(&quot;pause&quot;);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase 0:\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;已退出修改联系人&quot; &lt;&lt; endl;\t\t\t\tsystem(&quot;pause&quot;);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t&#125;\t\t\treturn 0;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;//清空联系人void cleanPerson(s_AddressBook* s_ABS)&#123;\tstring enterYN;\tstring selectYN;\twhile (true)\t&#123;\t\tcout &lt;&lt; &quot;Clean All Contact ( y / n ): &quot;;\t\tcin &gt;&gt; enterYN;\t\tif (enterYN == &quot;y&quot; || enterYN == &quot;n&quot;)\t\t&#123;\t\t\tselectYN = enterYN;\t\t\tbreak;\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;Enter y or n&quot; &lt;&lt; endl;\t\t&#125;\t&#125;\tif (selectYN == &quot;y&quot;)\t&#123;\t\ts_ABS-&gt;m_Size = 0;\t\tcout &lt;&lt; &quot;-------- Address Book Clean Succeeded ! --------&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;-------- Address Book Clean Exit ! --------&quot; &lt;&lt; endl;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);&#125;//退出通讯录void exitAddressBook()&#123;\tcout &lt;&lt; &quot;已退出通讯录&quot; &lt;&lt; endl;\tsystem(&quot;pause&quot;);&#125;int main()&#123;\tint userSelect;\ts_AddressBook s_ABS; //创建通讯录\ts_ABS.m_Size = 0;\twhile (true)\t&#123;\t\tshowAddressBookMenu();\t\t\t\tcout &lt;&lt; &quot;Select : &quot;;\t\tcin &gt;&gt; userSelect;\t\tswitch (userSelect)\t\t&#123;\t\tcase 1: //1. 添加联系人\t\t\taddPerson(&amp;s_ABS); //通过地址传递结构体实参，可以在函数中修改本地的结构体内实参值\t\t\tbreak;\t\tcase 2: //2. 显示联系人\t\t\tshowPerson(&amp;s_ABS);\t\t\tbreak;\t\tcase 3: //3. 删除联系人\t\t&#123;\t\t\tstring enterName;\t\t\tint personIndex;\t\t\t\t\t\tenterName = tipEnterInfo(enterName);\t\t\tfindPersonByDeletOrModify(&amp;s_ABS, enterName);\t\t\t\t\t\tpersonIndex = findPersonByDeletOrModify(&amp;s_ABS, enterName);\t\t\t//tipReturnInfo(findPersonByDeletOrModify(&amp;s_ABS, enterName));\t\t\tdeletPerson(&amp;s_ABS, personIndex, enterName); \t\t&#125;\t\t\tbreak;\t\tcase 4: //4. 查找联系人\t\t\tfindPerson(&amp;s_ABS);\t\t\tbreak;\t\tcase 5: //5. 修改联系人\t\t\tmodifyPerson(&amp;s_ABS);\t\t\tbreak;\t\tcase 6: //6. 清空联系人\t\t\tcleanPerson(&amp;s_ABS);\t\t\tbreak;\t\tcase 0: //0. 退出通讯录\t\t\texitAddressBook();\t\t\treturn 0;\t\t\tbreak;\t\tdefault:\t\t\tbreak;\t\t&#125;\t&#125;&#125;\n\n","slug":"1_C++_通讯录管理系统_02","date":"2022-10-06T07:28:25.923Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"85a2acfa491d3e6f2208fd787a774695","title":"C++_模板和STL","content":"C++_模板和STL[toc]\n\n记录C++泛型编程和STL的使用和原理\n\n1. 模板-Template1.1 模板概念\n作用：建立通用的模具，提高编程的复用性\n特点：\n模板在实际项目中不可直接使用，它只是一个框架，需根据实际情况进行使用\n模板的通用不是万能的\n\n\n\n1.2 函数模板\nC++提供了另一种编程思想，泛型编程，主要利用的技术就是模板template\nC++提供了两种模板机制：函数模板和类模板\n\n1.2.1 函数模板语法\n函数模板的作用：\n\n建立一个通用函数，其函数返回值类型和形参类型可以不确定，是一个虚拟的类型\n\n当需要使用时，再根据实际情况进行声明或由编译器自行判断数据类型\n\n\n\n语法：\n12template &lt;typename T&gt;函数的声明或定义\n\n\n\n解释：\n\ntemplate：声明创建模板\ntypename：表面后面的符号，代表着是一种数据类型，但不确定是哪种，也可以用class来代替\nT：通用数据类型，是一个符号，可以换成别的代替，通常大写，并习惯写成T\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637//// Created by FHang on 2021/7/9 13:35//#include &lt;iostream&gt;using namespace std;// 函数模板// 声明一个模板，通用数据符号 T， 防止编译器报错template &lt;typename T&gt;void swap_T(T &amp;num1, T &amp;num2)&#123;    T tempNum = num1;    num1 = num2;    num2 = tempNum;&#125;void demo1()&#123;    int num1 = 10;    int num2 = 20;    // 自动类型推导    swap_T(num1, num2);    cout &lt;&lt; &quot;自动类型: &quot; ;    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;    // 指定类型    swap_T&lt;int&gt;(num1, num2);    cout &lt;&lt; &quot;指定类型: &quot; ;    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;&#125;int main()&#123;    demo1();    return 0;&#125;\n\n\n\n总结：\n\n函数模板的创建利用关键字template\n使用函数模板有两种方式：自动类型推导和显示指定类型\n模板的目的是提高复用性，将类型参数化\n\n\n\n1.2.2 函数模板注意事项注意事项：\n\n自动类型推导：通用数据类型 T 必须推导出一致的类型，才能使用\n模板函数在使用时，无论哪种方式，必须确定了使用的数据类型，才能使用\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435//// Created by FHang on 2021/7/9 13:55//#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void swap_T(T &amp;num1, T &amp;num2)&#123;    T tempNum = num1;    num1 = num2;    num2 = tempNum;&#125;void demo1()&#123;    int num1 = 10;    int num2 = 20;    char c1 = &#x27;A&#x27;;    // 自动类型推导    // num1 和 num2 都是 int 类型，可以自动推导出是一致类型    swap_T(num1, num2);    // c1是char类型，是错误的使用方式    // swap_T(c1, num2);    cout &lt;&lt; &quot;自动类型: &quot; ;    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;&#125;int main()&#123;    demo1();    return 0;&#125;\n\n\n\n\n\n1.2.3 函数模板案例\n案例描述：\n\n利用函数模板封装一个排序函数，可以对不同类型数据进行排序\n排序规则：从大到小，排序算法为选择排序\n分别利用char数组和int数组进行测试\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//// Created by FHang on 2021/7/9 14:01//#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;template &lt;class T&gt;void swap_T(T &amp;a, T &amp;b)&#123;    T temp = a;    a = b;    b = temp;&#125;template &lt;class T&gt;void sort_T(T arr[], int length)&#123;    for (int i = 0; i &lt; length; ++i)    &#123;        // 假设最大值的下标，后面进行比较        int max = i;        for (int j = i + 1; j &lt; length; ++j)        &#123;            // 将假设的下标对应的值和后面的值，比较            if (arr[max] &lt; arr[j])            &#123;                max = j;            &#125;        &#125;        // 上面的循环结束后，检查一开始假设的下标，是否是循环检查出的最大值下标        if (max != i)        &#123;            swap_T(arr[max], arr[i]);        &#125;    &#125;&#125;template &lt;class T&gt;void print_T(T arr, int length)&#123;    cout &lt;&lt; &quot;从大到小排序后：&quot;;    for (int i = 0; i &lt; length; ++i)    &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void sortCharDemo()&#123;    char c_Array[26];    int c_Length;    cout &lt;&lt; &quot;输入字符(a - z) &gt;&gt; &quot;;    cin &gt;&gt; c_Array;    // 实际的字符后面有一个 `\\0`收尾,这获取长度方法不好    //c_Length = (sizeof(c_Array) / sizeof(char));    // strlen() 获取长度，读到`\\0`，就不读，适合这个项目的需求    // 需要包含 &lt;cstring&gt;    c_Length = strlen(c_Array);    sort_T(c_Array, c_Length);    print_T(c_Array, c_Length);&#125;void sortIntDemo()&#123;    int i_Array[10];    int i = 0;    int i_Length;    cout &lt;&lt; &quot;输入数字(0 - 9) &gt;&gt; &quot;;    while (cin.peek() != &#x27;\\n&#x27;)    &#123;        cin &gt;&gt; i_Array[i++];        i_Length = i;    &#125;    sort_T(i_Array, i_Length);    print_T(i_Array, i_Length);&#125;int main()&#123;    // sortCharDemo();    sortIntDemo();    return 0;&#125;\n\n1.2.4 普通和模板函区别\n区别：\n\n普通函数调用时，可以发生自动类型转换 (隐式类型转换)\n函数模板调用时，利用自动类型转换，不会发生(隐式类型转换)\n如果利用显示指定类型的方式，可以发生(隐式类型转换)\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334//// Created by FHang on 2021/7/9 15:54//#include &lt;iostream&gt;using namespace std;int add(int a,  int b)&#123;    return a + b;&#125;template &lt;class T&gt;T add_T(T a, T b)&#123;    return a + b;&#125;int main()&#123;    int a = 10;    // c -&gt; ASCII = 97    char c = &#x27;a&#x27;;    // 普通函数 可以隐式类型转换    cout &lt;&lt; add(a, c) &lt;&lt; endl;    // 模板函数 自动类型转换 无法隐式类型转换    // cout &lt;&lt; add_T(a, c) &lt;&lt; endl;    // 指定类型转换 可以隐式类型转换    cout &lt;&lt; add_T&lt;int&gt;(a, c) &lt;&lt; endl;    return 0;&#125;\n\n总结：建议使用显示指定类型的方式调用函数模板，可以自己确定通用类型T\n\n\n1.2.5 普通和模板函数调用\n调用规则：\n\n如果函数模板和普通函数都能实现，优先调用普通函数\n可以通过空模板参数列表来，强制调用函数模板\n函数模板可以发生重载\n如果函数模板可以产生更好的匹配，优先调用函数模板\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041//// Created by FHang on 2021/7/9 16:18//#include &lt;iostream&gt;using namespace std;void print(int a, int b)&#123;    cout &lt;&lt; &quot;普通函数调用&quot; &lt;&lt; endl;&#125;template &lt;class T&gt;T print(T a, T b)&#123;    cout &lt;&lt; &quot;模板函数调用&quot; &lt;&lt; endl;&#125;template &lt;class T&gt;T print(T a, T b, T c)&#123;    cout &lt;&lt; &quot;模板函数重载调用&quot; &lt;&lt; endl;&#125;int main()&#123;    // 1. 如果函数模板和普通函数都能实现，优先调用普通函数    print(1, 2);    // 2. 可以通过空模板参数列表来，强制调用函数模板    print&lt;&gt;(1, 2);    // 3. 函数模板可以发生重载    print(1, 2, 3);    // 4. 如果函数模板可以产生更好的匹配，优先调用函数模板    // 因为 a， b为char，隐式类型转换调用普通函数，不如直接自动类型转换调用模板函数调用来的方便    print(&#x27;a&#x27;, &#x27;b&#x27;);    return 0;&#125;\n\n总结：如果需要使用模板函数，就不用提供声明普通函数，以免产生二义性\n\n\n1.2.6 模板的局限性\n局限性：模板的通用性，并非万能\n\n代码示例_1：如果传入的 a 和 b是数组，该模板函数无法实现\n12345template &lt;class T&gt;void func(T a, T b)&#123;    a = b;&#125;\n\n代码示例_2：传入的是自定义类型数据，同样无法实现\n123456template &lt;class T&gt;void func(T a, T b)&#123;    if (a &gt; b)    &#123;......&#125;&#125;\n\n\n\n解决方法：C++为了解决这个问题，提供模板的重载，可以为特定的类型提供具体化的模板\n\n代码示例_3：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// Created by FHang on 2021/7/9 16:44//#include &lt;iostream&gt;using namespace std;// 自定义的结构体数据类型struct Person&#123;    Person(int age, string name)    &#123;        this-&gt;age = age;        this-&gt;name = name;    &#125;    int age;    string name;&#125;;template &lt;class T&gt;bool compare_T(T &amp;a, T &amp;b)&#123;    return a == b;&#125;// 具体化模板函数的实现，当传入参数类型为 Person，优先调用这个模板函数template&lt;&gt; bool compare_T(Person &amp;p1, Person &amp;p2)&#123;    return p1.age == p2.age &amp;&amp; p1.name == p2.name;&#125;void demo1()&#123;    int a = 10;    int b = 20;    bool rel = compare_T(a, b);    string printInfo = rel ? &quot;a = b&quot; : &quot;a != b&quot;;    cout &lt;&lt; printInfo &lt;&lt; endl;&#125;void demo2()&#123;    Person p1(10, &quot;fh&quot;);    Person p2(10, &quot;fh&quot;);    bool rel = compare_T(p1, p2);    string printInfo = rel ? &quot;p1 = p2&quot; : &quot;p1 != p2&quot;;    cout &lt;&lt; printInfo &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n总结：\n\n利用具体化模板函数，可以解决自定义类型的通用化\n学习模板并非是为了写模板，而是能够在STL中使用系统提供的模板\n\n\n\n1.3 类模板1.3.1 类模板语法\n类模板作用：建立一个通用类，类的成员数据类型可以不具体声明，用虚拟类型代替\n\n类模板语法：\n1234567template &lt;class name_T, class age_T&gt;class 类名&#123;public:    name_T name;    age_T age;&#125;;\n\n代码示例：类和结构体都可以\n1234567891011121314151617181920212223242526272829303132333435//// Created by FHang on 2021/7/9 17:17//#include &lt;iostream&gt;using namespace std;// 类和结构体都可以这么用template &lt;class name_T, class age_T&gt;struct Person&#123;    name_T name;    age_T age;    Person(name_T name, age_T age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    ~Person()    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;    &#125;&#125;;void demo()&#123;    Person&lt;string, int&gt;(&quot;fh&quot;, 24);&#125;int main()&#123;    demo();    return 0;&#125;\n\n1.3.2 类和模板区别\n区别：\n\n类模板没有自动类型推导的使用方式\n类模板在模板参数列表中，可以有默认参数\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Created by FHang on 2021/7/11 7:40//#include &lt;iostream&gt;using namespace std;template &lt;class name_T, class age_T&gt;struct Person01&#123;    name_T name;    age_T age;    Person01(name_T name, age_T age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    ~Person01()    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;    &#125;&#125;;// 用结构体来代替类了// 类模板中，可以在参数列表中，指明默认参数类型，生成对象时，不需要再显示指定类型template &lt;class name_T = string, class age_T = int&gt;struct Person02&#123;    name_T name;    age_T age;    Person02(name_T name, age_T age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    ~Person02()    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;    &#125;&#125;;void demo_P1()&#123;    // 类模板没有自动类型推导，所以这个写法是错误的    // Person01&lt;&gt; person01(&quot;FH&quot;, 24);    // 需要显示指定类型    Person01&lt;string, int&gt; person01(&quot;FH&quot;, 24);&#125;void demo_P2()&#123;    Person02&lt;&gt; person02(&quot;XX&quot;, 24);&#125;int main()&#123;    demo_P1();    demo_P2();    return 0;&#125;\n\n1.3.3 类模板中成员函数创建时机\n类模板中和普通类中的成员函数创建时机存在区别\n\n普通类中的成员函数一开始就可以创建\n类模板中的成员函数在调用时才会创建\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// Created by FHang on 2021/7/12 13:51//#include &lt;iostream&gt;using namespace std;class Person1&#123;public:    void showPerson1()    &#123;        cout &lt;&lt; &quot;Show Person 1&quot; &lt;&lt; endl;    &#125;&#125;;class Person2&#123;public:    void showPerson2()    &#123;        cout &lt;&lt; &quot;Show Person 2&quot; &lt;&lt; endl;    &#125;&#125;;template &lt;class class_T&gt;class Person_T&#123;public:    class_T person;    // 传入的类型不确定，所以默认情况下，编译器不会保错    // 此时，类模板中的函数不会被创建，当正确调用类模板时，才会创建    void showFunc1()    &#123;        person.showPerson1();    &#125;    void showFunc2()    &#123;        person.showPerson2();    &#125;&#125;;void demo()&#123;    Person_T&lt;Person1&gt; p1;    p1.showFunc1();    // 传入的是Person1，所以编译时，编译器创建类模板内的成员函数时，找不到可以调用的showPerson2()    // p1.showFunc2();        // 传入Person2，才能调用showPerson2()，但同样也找不到showPerson1()    Person_T&lt;Person2&gt; p2;    p2.showFunc2();&#125;int main()&#123;    demo();    return 0;&#125;\n\n1.3.4 类模板对象做函数参数\n说明：类模板实例化出对象，向函数传参的方式\n\n三种传入方式：\n\n指定传入类型：直接显示对象的数据类型\n参数模板化：将对象中的参数变为模板进行传递\n整个类模板化：将对象类型模板化进行传递\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//// Created by FHang on 2021/7/12 14:08//#include &lt;iostream&gt;using namespace std;template &lt;class name_T, class age_T&gt;class Person&#123;public:    name_T name;    age_T age;    Person(name_T name, age_T age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    void showPerson()    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;    &#125;&#125;;// 1. 指定传入类型：直接显示对象的数据类型void print1(Person&lt;string, int&gt; &amp;person)&#123;    person.showPerson();&#125;void demo1()&#123;    Person&lt;string, int&gt; person(&quot;FH&quot;, 24);    print1(person);&#125;// 2. 参数模板化：将对象中的参数变为模板进行传递template &lt;class string_T, class int_T&gt;void print2(Person&lt;string_T, int_T&gt; &amp;person)&#123;    person.showPerson();&#125;void demo2()&#123;    Person&lt;string, int&gt; person(&quot;FF&quot;, 22);    print2(person);&#125;// 3. 整个类模板化：将对象类型模板化进行传递template &lt;class person_T&gt;void print3(person_T &amp;person)&#123;    person.showPerson();&#125;void demo3()&#123;    Person&lt;string, int&gt; person(&quot;HH&quot;, 20);    print3(person);&#125;int main()&#123;    demo1();    demo2();    demo3();    return 0;&#125;\n\n1.3.5 类模板与继承\n当类模板遇到需要继承时，需注意：\n\n当子类继承的父类是模板时，子类在声明时，需要指出父类中 T 的类型\n如果不指定，编译器无法给子类分配内存\n如果要灵活指定父类中的 T 类型，子类也需变成类模板\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839//// Created by FHang on 2021/7/12 14:34//#include &lt;iostream&gt;using namespace std;template &lt;class class_T&gt;class Base&#123;public:    class_T base_Info;&#125;;class Derived_1 : Base&lt;int&gt; &#123;&#125;;template &lt;class deClass_T, class baseClass_T&gt;class Derived_2 : Base&lt;baseClass_T&gt;&#123;public:    deClass_T derived_Info;    Derived_2()    &#123;        cout &lt;&lt; &quot;deClass_T: &quot; &lt;&lt; typeid(deClass_T).name() &lt;&lt; endl;        cout &lt;&lt; &quot;baseClass_T: &quot; &lt;&lt; typeid(baseClass_T).name() &lt;&lt; endl;    &#125;&#125;;void demo()&#123;    Derived_2&lt;int, char&gt; derived2;&#125;int main()&#123;    demo();    return 0;&#125;\n\n1.3.6 类模板成员函数类外实现\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344//// Created by FHang on 2021/7/12 15:04//#include &lt;iostream&gt;using namespace std;template &lt;class name_T, class age_T&gt;class Person&#123;public:    name_T name;    age_T age;    // 类模板 内 声明    Person(name_T name, age_T age);    void showPerson();&#125;;// 类模板 外 实现template &lt;class name_T, class age_T&gt;Person&lt;name_T, age_T&gt;::Person(name_T name, age_T age)&#123;    this-&gt;name = name;    this-&gt;age = age;&#125;template &lt;class name_T, class age_T&gt;void Person&lt;name_T, age_T&gt;::showPerson()&#123;    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;&#125;void demo()&#123;    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);    person.showPerson();&#125;int main()&#123;    demo();    return 0;&#125;\n\n1.3.7 类模板分文件编写\n说明：掌握类模板成员函数分文件编写产生的问题及解决方式\n\n问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到\n\n解决：\n\n直接包含 .cpp文件\n将声明和实现写在同一个文件中，并改名为.hpp，是约定的标准名称，并非强制要求\n\n\n代码示例：\n\n第一种：直接包含 .cpp文件\nperson.h\n1234567891011121314151617181920212223//// Created by Admin on 2021/7/12.//#ifndef TEMPLATE_STL_PERSON_H#define TEMPLATE_STL_PERSON_H#include &lt;iostream&gt;using namespace std;template &lt;class name_T, class age_T&gt;class Person&#123;public:    name_T name;    age_T age;    Person(name_T name, age_T age);    void showPerson();&#125;;#endif //TEMPLATE_STL_PERSON_H\n\nperson.cpp\n123456789101112131415161718//// Created by Admin on 2021/7/12.//#include &quot;person.h&quot;template &lt;class name_T, class age_T&gt;Person&lt;name_T, age_T&gt;::Person(name_T name, age_T age)&#123;    this-&gt;name = name;    this-&gt;age = age;&#125;template &lt;class name_T, class age_T&gt;void Person&lt;name_T, age_T&gt;::showPerson()&#123;    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;&#125;\n\nperson_Main.cpp\n12345678910111213141516171819202122//// Created by FHang on 2021/7/12 15:30//// 包含头文件 不管用 因为类模板的成员函数 只在调用时创建 所以编译时无法链接到外部文件// #include &quot;person.h&quot;// 第一种：直接包含 .cpp 文件// 直接包含 源文件 源文件中包含头文件 同时实现了 类模板的成员函数#include &quot;person.cpp&quot;void demo()&#123;    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);    person.showPerson();&#125;int main()&#123;    demo();    return 0;&#125;\n\n第二种：将声明和实现写在同一个文件中，并改名为.hpp\nperson.hpp\n123456789101112131415161718192021222324252627282930313233343536//// Created by Admin on 2021/7/12.//#ifndef TEMPLATE_STL_PERSON_H#define TEMPLATE_STL_PERSON_H#include &lt;iostream&gt;using namespace std;template &lt;class name_T, class age_T&gt;class Person&#123;public:    name_T name;    age_T age;    Person(name_T name, age_T age);    void showPerson();&#125;;template &lt;class name_T, class age_T&gt;Person&lt;name_T, age_T&gt;::Person(name_T name, age_T age)&#123;    this-&gt;name = name;    this-&gt;age = age;&#125;template &lt;class name_T, class age_T&gt;void Person&lt;name_T, age_T&gt;::showPerson()&#123;    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;&#125;#endif //TEMPLATE_STL_PERSON_H\n\nperson_Main.cpp\n12345678910111213141516//// Created by FHang on 2021/7/12 15:47//#include &quot;person.hpp&quot;void demo()&#123;    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);    person.showPerson();&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n\n1.3.8 类模板与友元\n说明：类模板配合友元函数的类内和类外实现\n\n实现：\n\n全局函数类内实现：直接在类内声明友元\n全局函数类外实现：需要让编译器提前知道全局函数的存在\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// Created by FHang on 2021/7/12 15:57//#include &lt;iostream&gt;using namespace std;// 全局函数 类外实现template &lt;class name_T, class age_T&gt;class Person;template &lt;class name_T, class age_T&gt;void showPerson_2(Person&lt;name_T, age_T&gt; &amp;person)&#123;    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt;person.age &lt;&lt; endl;&#125;template &lt;class name_T, class age_T&gt;class Person&#123;    // 全局函数 类内实现    friend void showPerson_1(Person&lt;name_T, age_T&gt; &amp;person)    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt;person.age &lt;&lt; endl;    &#125;    // 全局函数 类外实现    friend void showPerson_2&lt;&gt;(Person&lt;name_T, age_T&gt; &amp;person);private:    name_T name;    age_T age;public:    Person(name_T name, age_T age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;&#125;;void demo1()&#123;    cout &lt;&lt; &quot;全局函数，类内实现: &quot;;    Person&lt;string, int&gt; person(&quot;FH&quot;, 24);    showPerson_1(person);&#125;void demo2()&#123;    cout &lt;&lt; &quot;全局函数，类外实现: &quot;;    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);    showPerson_2(person);&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n1.3.9 类模板案例\n案例要求：实现一个通用的数组类\n\n案例功能：\n\n可以对内置类型和自定义类型进行存储\n将数组的数据存储到堆区\n构造函数可以传入数组的容量\n提供拷贝函数及operator=防止浅拷贝问题\n提供尾差法和尾删法对数组中的数据进行增删\n通过下标访问数组中的元素\n获取数组中的元素个数和数组容量\n\n\n代码示例：(初期)\nfArray.hpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//// Created by Admin on 2021/7/13.//#ifndef TEMPLATE_STL_FARRAY_HPP#define TEMPLATE_STL_FARRAY_HPP#include &lt;iostream&gt;using namespace std;template &lt;class array_T&gt;class FArray&#123;private:    array_T *arrayAddress; // 指针指向堆区开辟的数组首地址    int arrayCapacity; // 数组容量    int arraySize; // 数组大小public:    // 初始化 数组的容量 大小 和 在堆区创建    FArray(int capacity)    &#123;        this-&gt;arrayCapacity = capacity;        this-&gt;arraySize = 0;        this-&gt;arrayAddress = new array_T[this-&gt;arrayCapacity];        cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;    &#125;    // 释放堆区的数组    ~FArray()    &#123;        if (this-&gt;arrayAddress != nullptr)        &#123;            delete[] this-&gt;arrayAddress;            this-&gt;arrayAddress = nullptr;            cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;        &#125;    &#125;    // 拷贝构造函数，解决浅拷贝问题    FArray(const FArray &amp;fArray)    &#123;        this-&gt;arrayCapacity = fArray.arrayCapacity;        this-&gt;arraySize = fArray.arraySize;        // 这是编译器默认的浅拷贝，在析构函数执行后，因为地址始终不为null，所以会重复释放        // this-&gt;arrayAddress = fArray.arrayAddress;        // 重新开辟空间，解决浅拷贝问题        this-&gt;arrayAddress = new array_T[this-&gt;arrayCapacity];        // 将 fArray的数据拷贝进新的空间中        for (int i = 0; i &lt; this-&gt;arraySize; ++i)        &#123;            this-&gt;arrayAddress[i] = fArray.arrayAddress[i];        &#125;        cout &lt;&lt; &quot;拷贝函数调用&quot; &lt;&lt; endl;    &#125;    // operator= 解决浅拷贝问题    FArray &amp;operator=(const FArray &amp;fArray)    &#123;        // 先判断堆区是否存在，存在就先释放        if (this-&gt;arrayAddress != nullptr)        &#123;            delete[] this-&gt;arrayAddress;            this-&gt;arrayAddress = nullptr;            this-&gt;arrayCapacity = 0;            this-&gt;arraySize = 0;        &#125;        // 深拷贝        this-&gt;arrayCapacity = fArray.arrayCapacity;        this-&gt;arraySize = fArray.arraySize;        this-&gt;arrayAddress = new array_T[this-&gt;arrayCapacity];        for (int i = 0; i &lt; this-&gt;arraySize; ++i)        &#123;            this-&gt;arrayAddress[i] = fArray.arrayAddress[i];        &#125;        cout &lt;&lt; &quot;operator=函数调用&quot; &lt;&lt; endl;        return *this;    &#125;&#125;;#endif //TEMPLATE_STL_FARRAY_HPP\n\nfArray_Main.cpp\n123456789101112131415161718192021222324//// Created by FHang on 2021/7/13 14:36//#include &quot;fArray.hpp&quot;void demo()&#123;    // 测试 初期，创建一个容量5的int类型数组    // 测试 构造函数和析构函数    FArray&lt;int&gt; fArray1(5);    // 测试 拷贝构造函数    FArray&lt;int&gt; fArray2(fArray1);    // 测试 operator= 函数    FArray&lt;int&gt; fArray3(10);    fArray3 = fArray1;&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n\n代码示例：（后期）\nfArray.hpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//// Created by Admin on 2021/7/13.//#ifndef TEMPLATE_STL_FARRAY_HPP#define TEMPLATE_STL_FARRAY_HPP#include &lt;iostream&gt;using namespace std;template &lt;class array_T&gt;class FArray&#123;private:    array_T *arrayAddress; // 指针指向堆区开辟的数组首地址    int arrayCapacity; // 数组容量    int arraySize; // 数组大小public:    // 初始化 数组的容量 大小 和 在堆区创建    FArray(int capacity)    &#123;        this-&gt;arrayCapacity = capacity;        this-&gt;arraySize = 0;        this-&gt;arrayAddress = new array_T[this-&gt;arrayCapacity];        // cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;    &#125;    // 释放堆区的数组    ~FArray()    &#123;        if (this-&gt;arrayAddress != nullptr)        &#123;            delete[] this-&gt;arrayAddress;            this-&gt;arrayAddress = nullptr;            // cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;        &#125;    &#125;    // 拷贝构造函数，解决浅拷贝问题    FArray(const FArray &amp;fArray)    &#123;        this-&gt;arrayCapacity = fArray.arrayCapacity;        this-&gt;arraySize = fArray.arraySize;        // 这是编译器默认的浅拷贝，在析构函数执行后，因为地址始终不为null，所以会重复释放        // this-&gt;arrayAddress = fArray.arrayAddress;        // 重新开辟空间，解决浅拷贝问题        this-&gt;arrayAddress = new array_T[this-&gt;arrayCapacity];        // 将 fArray的数据拷贝进新的空间中        for (int i = 0; i &lt; this-&gt;arraySize; ++i)        &#123;            this-&gt;arrayAddress[i] = fArray.arrayAddress[i];        &#125;        // cout &lt;&lt; &quot;拷贝函数调用&quot; &lt;&lt; endl;    &#125;    // operator= 解决浅拷贝问题    FArray &amp;operator=(const FArray &amp;fArray)    &#123;        // 先判断堆区是否存在，存在就先释放        if (this-&gt;arrayAddress != nullptr)        &#123;            delete[] this-&gt;arrayAddress;            this-&gt;arrayAddress = nullptr;            this-&gt;arrayCapacity = 0;            this-&gt;arraySize = 0;        &#125;        // 深拷贝        this-&gt;arrayCapacity = fArray.arrayCapacity;        this-&gt;arraySize = fArray.arraySize;        this-&gt;arrayAddress = new array_T[this-&gt;arrayCapacity];        for (int i = 0; i &lt; this-&gt;arraySize; ++i)        &#123;            this-&gt;arrayAddress[i] = fArray.arrayAddress[i];        &#125;        // cout &lt;&lt; &quot;operator=函数调用&quot; &lt;&lt; endl;        return *this;    &#125;    // 返回数组大小    int getArraySize()    &#123;        return this-&gt;arraySize;    &#125;    // 返回数组容量    int getArrayCapacity()    &#123;        return this-&gt;arrayCapacity;    &#125;    // 尾插法    void tail_Insertion(const array_T &amp;arrayValue)    &#123;        // 先判断数组容量是否够        if (this-&gt;arrayCapacity == this-&gt;arraySize)        &#123;            return;        &#125;        this-&gt;arrayAddress[this-&gt;arraySize] = arrayValue; // 将数据插入到数组的尾部        this-&gt;arraySize++; // 更新数组的大小    &#125;    // 尾删法    void tail_Deletion()    &#123;        // 让用户无法访问最后一个元素，逻辑删除        if (this-&gt;arraySize == 0)        &#123;            return;        &#125;        this-&gt;arraySize--;    &#125;    // 通过小标访问数组元素 自定义的数据类型，内置的[]不能用，需要重载[]    array_T &amp;operator[](int fArray_Index)    &#123;        return this-&gt;arrayAddress[fArray_Index];    &#125;&#125;;#endif //TEMPLATE_STL_FARRAY_HPP\n\nfArray.cpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//// Created by FHang on 2021/7/13 14:36//#include &quot;fArray.hpp&quot;int arrayIntCount = 0;int arrayPersonCount = 0;// 打印int类型数组void printIntArray(FArray&lt;int&gt; &amp;fArray)&#123;    arrayIntCount++;    cout &lt;&lt; &quot;数组&quot; &lt;&lt; arrayIntCount &lt;&lt; &quot;：[ &quot;;    for (int i = 0; i &lt; fArray.getArraySize(); ++i)    &#123;        cout &lt;&lt; fArray[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;&#125;// 前期测试：创建到堆区，拷贝构造函数，operator= 函数void test1()&#123;    // 测试 初期，创建一个容量5的int类型数组    // 测试 构造函数和析构函数    FArray&lt;int&gt; fArray1(5);    // 测试 拷贝构造函数    FArray&lt;int&gt; fArray2(fArray1);    // 测试 operator= 函数    FArray&lt;int&gt; fArray3(10);    fArray3 = fArray1;&#125;// 后期测试：尾插法，容量，大小void test2()&#123;    // 创建数组 和 容量    FArray&lt;int&gt; fArray1(10);    // 用尾插法插入数据    for (int i = 0; i &lt; 5; ++i)    &#123;        fArray1.tail_Insertion(i);    &#125;    // 打印数组    printIntArray(fArray1);    // 查看数组 容量 大小    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray1.getArrayCapacity() &lt;&lt; endl;    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray1.getArraySize() &lt;&lt; endl;    // 尾删法 测试    FArray&lt;int&gt; fArray2(fArray1);    printIntArray(fArray2);    fArray2.tail_Deletion();    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray2.getArrayCapacity() &lt;&lt; endl;    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray2.getArraySize() &lt;&lt; endl;&#125;// 后期测试 自定义数据类型class Person&#123;public:    string name;    int age;    Person()&#123;&#125;;    Person(string name, int age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;&#125;;// 打印Person类型数组void printPersonArray(FArray&lt;Person&gt; &amp;fArray)&#123;    arrayPersonCount++;    cout &lt;&lt; &quot;数组&quot; &lt;&lt; arrayPersonCount &lt;&lt; &quot;：[ &quot;;    for (int i = 0; i &lt; fArray.getArraySize(); ++i)    &#123;        cout &lt;&lt; fArray[i].name &lt;&lt; &quot; &quot; &lt;&lt; fArray[i].age &lt;&lt; &quot; - &quot;;    &#125;    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;&#125;void test3()&#123;    FArray&lt;Person&gt; fArray(3);    Person person1(&quot;FH&quot;, 24);    Person person2(&quot;HH&quot;, 22);    fArray.tail_Insertion(person1);    fArray.tail_Insertion(person2);    printPersonArray(fArray);    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray.getArrayCapacity() &lt;&lt; endl;    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray.getArraySize() &lt;&lt; endl;&#125;int main()&#123;    // test1();    // test2();    test3();    return 0;&#125;\n\n2. STL基础2.1 STL的诞生\nC++的面向对象和泛型编程思想，目的是复用性\n大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作\n为了建立数据结构和算法的标准，诞生了STL\n\n2.2 STL基本概念\nSTL(Standard Template Library，标准模板库)\nSTL广义上分为：容器(container)，算法(algorithm)，迭代器(iterator)\n容器和算法之间通过迭代器进行连接\nSTL激活所有的代码都采用了模板类或模板函数\n\n2.3 STL六大组件\nSTL大体分为六个组件：\n容器\n算法\n迭代器\n仿函数\n适配器(配接器)\n空间配置器\n\n\n组件介绍：\n容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据\n算法：各种常用的算法，如sort、find、copy、for_each等\n迭代器：扮演了容器和算法之间的胶合剂\n仿函数：行为类似函数，可作为算法的某种策略\n适配器：一种修饰容器或仿函数或迭代器接口\n空间配置器：负责空间的配置和管理\n\n\n\n2.4 STL容器\\算法\\迭代器\n容器：存放数据，将运用最广泛的一些数据结构实现出来\n\n常用数据结构：数组，链表，树，栈，队列，集合，映射表 等\n容器分为：序列式容器和关联式容器\n序列式容器：强调值的排序，序列容器中的每个元素均有固定的位置\n关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系\n\n\n\n\n算法：解决问题，有限的步骤，解决逻辑或数学上的问题\n\n算法分为：质变算法和非质变算法\n质变算法：值运算过程中会更改区间内的元素的内容，例如：拷贝，替换，删除等\n非质变算法：值运算过程中不会更改区间内的元素内容，例如：查找，计数，遍历，寻找极值等\n\n\n\n\n迭代器：容器和算法之间胶合剂\n\n提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表示方式\n\n每个容器都有自己的专属迭代器\n\n迭代器使用类似指针\n\n迭代器的种类：\n\n\n\n种类\n功能\n支持算法\n\n\n\n输入迭代器\n对数据只读访问\n只读，支持 ++，&#x3D;&#x3D;，!&#x3D;\n\n\n输出迭代器\n对数据只写访问\n只写，支持 ++\n\n\n前向迭代器\n读写操作，并能向前推进迭代器\n读写，支持 ++，&#x3D;&#x3D;，!&#x3D;\n\n\n双向迭代器\n读写操作，并能向前和向后操作\n读写，支持 ++，–\n\n\n随机访问迭代器\n读写操作，可以跳跃访问任意数据\n读写，支持 ++，–，[n]，-n，&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D;\n\n\n\n常用的容器这迭代器种类为双向迭代器和随机访问迭代器\n\n\n\n\n2.5 容器\\算法\\迭代器基础2.5.1 vector存放内置数据类型\n容器：vector\n\n算法：for_each\n\n迭代器：vector&lt;int&gt;::iterator\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// Created by FHang on 2021/7/19 14:23//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void fPrint(int value)&#123;    cout &lt;&lt; value &lt;&lt; endl;&#125;void demo()&#123;    // 创建一个vector容器    vector&lt;int&gt; v;    // 插入数据    v.push_back(10);    v.push_back(11);    v.push_back(12);    v.push_back(13);    // 通过创建迭代器访问容器中的数据    vector&lt;int&gt;::iterator iBegin = v.begin(); // 起始地迭代器 指向容器中的第一个元素    vector&lt;int&gt;::iterator iEnd = v.end(); // 指向容器最后一个元素 之后的地址    // 第一种遍历方式//    while (iBegin != iEnd)//    &#123;//        cout &lt;&lt; *iBegin &lt;&lt; endl;//        iBegin++;//    &#125;    // 第二种遍历方式//    for (vector&lt;int&gt;::iterator i = v.begin(); i != v.end(); ++i)//    &#123;//        cout &lt;&lt; *i &lt;&lt; endl;//    &#125;    // 第三种遍历方式    for_each(v.begin(), v.end(), fPrint);&#125;int main()&#123;    demo();    return 0;&#125;\n\n2.5.2 vector存放自定义数据类型\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// Created by FHang on 2021/7/19 14:49//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Person&#123;public:    string name;    int age;    Person(string name, int age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;&#125;;void demo1()&#123;    cout &lt;&lt; &quot;&lt; --demo1-- &gt;&quot; &lt;&lt; endl;    vector&lt;Person&gt; v_P;    Person p1(&quot;fh&quot;, 24);    Person p2(&quot;ff&quot;, 22);    Person p3(&quot;hh&quot;, 20);    v_P.push_back(p1);    v_P.push_back(p2);    v_P.push_back(p3);    for (vector&lt;Person&gt;::iterator it_P = v_P.begin(); it_P != v_P.end(); ++it_P)    &#123;        cout &lt;&lt; it_P-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; it_P-&gt;age &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void demo2()&#123;    cout &lt;&lt; &quot;&lt; --demo2-- &gt;&quot; &lt;&lt; endl;    vector&lt;Person *&gt; v_P;    Person p1(&quot;fh&quot;, 24);    Person p2(&quot;ff&quot;, 22);    Person p3(&quot;hh&quot;, 20);    v_P.push_back(&amp;p1);    v_P.push_back(&amp;p2);    v_P.push_back(&amp;p3);    for (vector&lt;Person *&gt;::iterator it_P = v_P.begin(); it_P != v_P.end(); ++it_P)    &#123;        cout &lt;&lt; (*it_P)-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; (*it_P)-&gt;age &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n2.5.3 vector容器嵌套容器\n容器中嵌套容器，将数据进行遍历打印\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by FHang on 2021/7/19 15:07//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void demo()&#123;    // 创建大容器    vector&lt;vector&lt;int&gt;&gt; v_Big;    // 创建小容器    vector&lt;int&gt; v_S1;    vector&lt;int&gt; v_S2;    vector&lt;int&gt; v_S3;    vector&lt;int&gt; v_S4;    // 向小容器中添加数据    for (int i = 0; i &lt; 4; ++i)    &#123;        v_S1.push_back(i + 1);        v_S2.push_back(i + 2);        v_S3.push_back(i + 3);        v_S4.push_back(i + 4);    &#125;    // 将小容器插入大容器    v_Big.push_back(v_S1);    v_Big.push_back(v_S2);    v_Big.push_back(v_S3);    v_Big.push_back(v_S4);    // 遍历大容器    for (vector&lt;vector&lt;int&gt;&gt;::iterator it_Big = v_Big.begin(); it_Big != v_Big.end(); ++it_Big)    &#123;        // (*it_Big)是小容器 vector&lt;int&gt;        // 遍历小容器        for (vector&lt;int&gt;::iterator it_Small = (*it_Big).begin(); it_Small != (*it_Big).end(); ++it_Small)        &#123;            cout &lt;&lt; *it_Small &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3. STL常用容器3.1 string容器3.1.1 string基本概念\n本质：string是C++的风格字符串，而string本质是一个类\nstring和char * 区别：\nchar * 是指针\nstring 是指针，内部封装了 char * ，管理这个字符串，是一个 char * 的容器\n\n\n特点：\nstring内部封装了很多的成员方法\n查找 find，拷贝 copy，删除 delete，替换 replace，插入 insert\nstring管理 char * 所分配的内存，不用担心复制越界和取值越界，由类内部进行负责\n\n\n\n3.1.2 string构造函数\n构造函数原型：\n\n\n\nstring();\n创建一个空的字符串\n\n\n\nstring(const char *s);\n使字符串初始化\n\n\nstring(const string &amp;s);\n用一个string对象初始化另一个string对象\n\n\nstring(int n, char c);\n使用n个字符c，初始化\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031//// Created by FHang on 2021/7/20 9:43//#include &lt;iostream&gt;using namespace std;void demo()&#123;    // 创建一个空的字符串    string string1;    // 使字符串初始化    const char *str = &quot;HelloWorld&quot;;    string string2(str);    cout &lt;&lt; &quot;string2 = &quot; &lt;&lt; string2 &lt;&lt; endl;    // 用一个string对象初始化另一个string对象    string string3(string2);    cout &lt;&lt; &quot;string3 = &quot; &lt;&lt; string3 &lt;&lt; endl;    // 使用n个字符c，初始化    string string4(10, &#x27;a&#x27;);    cout &lt;&lt; &quot;string4 = &quot; &lt;&lt; string4 &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.1.3 string赋值操作\n功能描述：给string字符串赋值\n\n\n\n赋值的函数原型\n\n\n\n\nstring &amp;operator=(const char *s);\nchar *类型字符串，赋值给当前的字符串\n\n\nstring &amp;operator=(const string &amp;s);\n字符串s，赋值给当前的字符串\n\n\nstring &amp;operator=(char c);\n字符，赋值给当前字符串\n\n\nstring &amp;assign(const char *s);\n字符串s，赋值给当前的字符串\n\n\nstring &amp;assign(const char *s, int n);\n字符串s的前n个字符，赋值给当前的字符串\n\n\nstring &amp;assign(const string &amp;s);\n字符串s，赋值给当前的字符串\n\n\nstring &amp;assign(int n, char c);\n用n个字符c，赋值给当前字符串\n\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839//// Created by FHang on 2021/9/21 14:56//#include &lt;iostream&gt;using namespace std;void demo()&#123;    string string1;    string1 = &quot;hello world&quot;;    cout &lt;&lt; &quot;string1 = &quot; &lt;&lt; string1 &lt;&lt; endl;    string string2;    string2 = string1;    cout &lt;&lt; &quot;string2 = &quot; &lt;&lt; string2 &lt;&lt; endl;    string string3;    string3 = &quot;A&quot;;    cout &lt;&lt; &quot;string3 = &quot; &lt;&lt; string3 &lt;&lt; endl;    string string4;    string4.assign(&quot;hello world&quot;);    cout &lt;&lt; &quot;string4 = &quot; &lt;&lt; string4 &lt;&lt; endl;    string string5;    string5.assign(&quot;hello world&quot;, 3);    cout &lt;&lt; &quot;string5 = &quot; &lt;&lt; string5 &lt;&lt; endl;    string string6;    string6.assign(6, &#x27;a&#x27;);    cout &lt;&lt; &quot;string6 = &quot; &lt;&lt; string6 &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.1.4 string字符拼接\n功能描述：实现字符串末尾拼接字符串\n\n\n\n函数原型\n\n\n\n\nstring &amp;operator+=(const char *str);\n重载+&#x3D;操作符\n\n\nstring &amp;operator+=(const char c);\n重载+&#x3D;操作符\n\n\nstring &amp;operator+=(const string &amp;str);\n重载+&#x3D;操作符\n\n\nstring &amp;append(const char *s);\n字符串s，连接到当前字符串的末尾\n\n\nstring &amp;append(const char *s, int n);\n字符串s的前n个字符，连接到当前字符串的末尾\n\n\nstring &amp;append(const string &amp;s);\n等同于，string &amp;operator+=(const string &amp;str);\n\n\nstring &amp;append(const string &amp;s, int pos, int n);\n字符串s中从pos开始取n个字符，连接到当前字符串的末尾\n\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243//// Created by FHang on 2021/9/21 15:12//#include &lt;iostream&gt;using namespace std;void demo()&#123;    string string1 = &quot;Hello &quot;;    string1 += &quot;World&quot;;    cout &lt;&lt; &quot;String1 = &quot; &lt;&lt; string1 &lt;&lt; endl;    string string2 = &quot;Hi &quot;;    string2 += string1;    cout &lt;&lt; &quot;String2 = &quot; &lt;&lt; string2 &lt;&lt; endl;    string string3 = &quot;Age &quot;;    string3 += &#x27;8&#x27;;    cout &lt;&lt; &quot;String3 = &quot; &lt;&lt; string3 &lt;&lt; endl;    string string4 = &quot;Hello &quot;;    string4.append(&quot;World&quot;);    cout &lt;&lt; &quot;String4 = &quot; &lt;&lt; string4 &lt;&lt; endl;    string string5 = &quot;Hi &quot;;    string5.append(string4);    cout &lt;&lt; &quot;String5 = &quot; &lt;&lt; string5 &lt;&lt; endl;    string string6;    string6.append(&quot;Hello World&quot;, 4);    cout &lt;&lt; &quot;String6 = &quot; &lt;&lt; string6 &lt;&lt; endl;    string string7 = string5;    string7.append(&quot;Hello World&quot;, 5, 6);    cout &lt;&lt; &quot;String7 = &quot; &lt;&lt; string7 &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.1.5 string查找替换\n功能描述：\n\n查找：查找指定字符串是否存在\n\n替换：在指定的位置替换字符串\n\n\n\n函数原型\n\n\n\n\nint find(const string &amp;str, int pos = 0) const;\n查找str第一次出现的位置，默认pos从头开始\n\n\nint find(const char *s, int pos = 0) const;\n查找s第一次出现的位置，默认pos从头开始\n\n\nint find(const char *s, int pos, int n) const;\n从pos查找s的前n个字符第一次位置\n\n\nint find(const char *c, int pos = 0) const;\n查找字符c第一次出现位置\n\n\nint rfind(const string &amp;str, int pos = npos) const;\n查找str最后一次位置，从pos开始找\n\n\nint rfind(const char *s, int pos = npos) const;\n查找s最后一次位置，从pos开始找\n\n\nint rfind(const char *s, int pos, int n) const;\n从pos查找s的前n个字符最后一次位置\n\n\nint rfind(const char *c, int pos = 0) const;\n查找字符c最后一次出现位置\n\n\nstring &amp;replace(int pos, int n, const string &amp;str) const;\n替换从pos开始n个字符为字符串str\n\n\nstring &amp;replace(int pos, int n, const char *s) const;\n替换从pos开始n个字符为字符串s\n\n\n\n\n\n示例：\n123456789101112131415161718192021222324252627282930//// Created by FHang on 2021/9/21 15:46//#include &lt;iostream&gt;using namespace std;void findString()&#123;    string string1 = &quot;AABBCCBBAA&quot;;    int pos1 = string1.find(&quot;BB&quot;);    cout &lt;&lt; &quot;BB pos1 = &quot; &lt;&lt; pos1 &lt;&lt; endl;    int pos2 = string1.rfind(&quot;BB&quot;);    cout &lt;&lt; &quot;BB pos2 = &quot; &lt;&lt; pos2 &lt;&lt; endl;&#125;void replaceString()&#123;    string string1 = &quot;ABCDE&quot;;    string1.replace(2, 3, &quot;123&quot;);    cout &lt;&lt; &quot;String1 = &quot; &lt;&lt; string1 &lt;&lt; endl;&#125;int main()&#123;    findString();    replaceString();    return 0;&#125;\n\n\n\n总结：\n\nfind是从左往右查，rfind是从右往左查\nfind查到字符后，返回字符的位置，找不到返回-1\nreplace在替换时，需指定起始位置，替换字符数，替换字符\n\n\n\n3.1.6 string字符比较\n功能描述：字符串之间比较\n\n比较方式：按照字符编码ACSII进行比较\n\n= 返回 0\n&gt; 返回 1\n&lt; 返回 -1\n\n\n\n\n函数原型\n\n\n\n\nint compare(const string &amp;str) const;\n与字符串str比较\n\n\nint compare(const char *s) const;\n与字符串s比较\n\n\n\n示例：\n123456789101112131415161718192021222324252627//// Created by FHang on 2021/9/21 16:12//#include &lt;iostream&gt;using namespace std;void demo()&#123;    string string1 = &quot;Hello&quot;;    string string2 = &quot;World&quot;;    if (string1.compare(string2) == 0)    &#123;        cout &lt;&lt; &quot;string1 string2&quot; &lt;&lt; &quot; = &quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;string1 string2&quot; &lt;&lt; &quot; != &quot; &lt;&lt; endl;    &#125;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.1.7 string字符存取\nstring中单个字符串存取方式有两种：\n\n\n\n方式\n\n\n\n\nchar &amp;operator[](int n);\n通过[]方式取字符\n\n\nchar &amp;at(int n);\n通过at取字符\n\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233//// Created by FHang on 2021/9/21 16:23//#include &lt;iostream&gt;using namespace std;string string1 = &quot;ABCDEFG&quot;;void demo1()&#123;    for (int i = 0; i &lt; string1.size(); ++i)    &#123;        cout &lt;&lt; string1[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo2()&#123;    for (int i = 0; i &lt; string1.size(); ++i)    &#123;        cout &lt;&lt; string1.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n3.1.8 string插入删除\n功能描述：对string字符串进行插入和删除字符操作\n\n\n\n函数原型\n\n\n\n\nstring &amp;insert(int pos, const char *s);\n插入字符串\n\n\nstring &amp;insert(int pos, const string &amp;str);\n插入字符串\n\n\nstring &amp;insert(int pos, int n, char c);\n在指定位置插入n个字符c\n\n\nstring &amp;erase(int pos, int n = npos);\n删除从pos开始的n个字符\n\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435//// Created by FHang on 2021/9/21 16:35//#include &lt;iostream&gt;using namespace std;void demoInsert()&#123;    string str1 = &quot;Hello &quot;;    string str2 = &quot;world &quot;;    str1.insert(6, &quot;world &quot;);    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;    str1.insert(12, str2);    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;    str1.insert(18, 6, &#x27;!&#x27;);    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;&#125;void demoDelete()&#123;    string str3 = &quot;Hello World&quot;;    str3.erase(5, 6);    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;&#125;int main()&#123;    demoInsert();    demoDelete();    return 0;&#125;\n\n总结：插入insert()和删除erase()都是从下标0开始的\n\n\n3.1.9 string获取字串\n功能描述：从字符串中获得想要的一段子字符串\n\n\n\n函数原型\n\n\n\n\nstring substr(int pos = 0, int n = npos) const;\n返回由pos开始的n个字符组成的字符串\n\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233//// Created by FHang on 2021/10/5 14:59//#include &lt;iostream&gt;using namespace std;void subStringDemo()&#123;    string str1 = &quot;Hello World&quot;;    str1 = str1.substr(0, 5);    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;&#125;void getEmailTypeInfo()&#123;    string str2 = &quot;752972182@qq.com&quot;;    int pos = str2.find(&quot;@&quot;);    string str3 = str2.substr(pos + 1, 2);    str2 = str2.substr(0, pos);    cout &lt;&lt; &quot;str2 email user = &quot; &lt;&lt; str2 &lt;&lt; endl;    cout &lt;&lt; &quot;str3 email type = &quot; &lt;&lt; str3 &lt;&lt; endl;&#125;int main()&#123;    subStringDemo();    getEmailTypeInfo();    return 0;&#125;\n\n3.2 vector容器3.2.1 vector基本概念\n功能：vector数据结构和数组非常相似，也称为单端数组\n\n与数组的区别：数组是静态空间，vector可以动态扩展\n\n动态扩展：并非是在原有的空间后面，连续开辟新空间；而是在另一个更大的内存空间中重新开辟，并拷贝原来的容器数据，同时释放原容器\n\nvector容器的迭代器是支持随机访问的迭代器\n\n\n\nvector迭代器方法介绍 vector&lt;T&gt; v;\n\n\n\n\nv.rend();\n容器第一个元素之前的地址\n\n\nv.end();\n容器最后一个元素之后的地址\n\n\nv.begin();\n容器第一个元素自身的地址\n\n\nv.rbegin();\n容器最后一个元素之前的地址\n\n\nv.insert();\n容器中插入一个元素\n\n\n\n\n3.2.2 vector构造函数\n功能描述：创建vector容器\n\n\n\n函数原型 vector&lt;T&gt; v;\n\n\n\n\nvector&lt;T&gt; v;\n采用模板类实现，默认构造函数\n\n\nvector(v.begin(), v.end());\n将 [ v.begin(), v.end() ) 之间的元素拷贝给自身 [闭 开)区间\n\n\nvector(n, elem);\n构造函数将 n个 元素拷贝给自身\n\n\nvector(const vector &amp;vec);\n拷贝构造函数\n\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by FHang on 2021/10/5 15:37//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printVector(vector&lt;int&gt; &amp;v)&#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo1()&#123;    // 默认构造（无参）    vector&lt;int&gt; v1;    for (int i = 0; i &lt; 10; ++i)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    // 通过 [ ) 构造    vector&lt;int&gt; v2(v1.begin(), v1.end());    printVector(v2);    // n个 elem构造    vector&lt;int&gt; v3(10, 1);    printVector(v3);    // 拷贝构造    vector&lt;int&gt; v4(v1);    printVector(v4);&#125;int main()&#123;    demo1();    return 0;&#125;\n\n3.2.3 vector赋值操作\n功能描述：给容器赋值\n\n\n\n函数原型 vector&lt;T&gt; v;\n\n\n\n\nvetor &amp;operator=(const vector &amp;vec);\n重载= 操作符\n\n\nv.assign(v.begin, v.end);\n将 [begin, end)区间中的数据拷贝到自身\n\n\nv.assign(n, elem);\n将 n个 elem拷贝赋值给自身\n\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041//// Created by FHang on 2021/10/5 16:08//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printVector(vector&lt;int&gt; &amp;v)&#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v1;    for (int i = 0; i &lt; 10; ++i)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt; v2 = v1;    printVector(v2);    vector&lt;int&gt; v3(v1.begin(), v1.end());    printVector(v3);    vector&lt;int&gt; v4(10, 1);    printVector(v4);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.2.4 vector容量大小\n功能描述：对vector容器的容量和大小进行操作\n\n\n\n函数原型\n\n\n\n\nempty();\n判断容器是否为空\n\n\ncapacity();\n获取容器的容量\n\n\nsize();\n获取容器中的元素个数\n\n\nresize(int num);\n重新指定容器长度，若变长，默认填充；若变短，删除末尾超出容器长度的元素\n\n\nresize(int num, elem);\n重新指定容器长度，若变长，elem填充；若变短，删除末尾超出容器长度的元素\n\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by FHang on 2021/10/5 16:18//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printVector(vector&lt;int&gt; &amp;v)&#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v1;    for (int i = 0; i &lt; 5; ++i)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    if (v1.empty())    &#123;        cout &lt;&lt; &quot;v1 is empty&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;v1 not empty&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;v1 size = &quot; &lt;&lt; v1.size() &lt;&lt; endl;        cout &lt;&lt; &quot;v1 capacity = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;    &#125;    v1.resize(10);    printVector(v1);    v1.resize(15, 1);    printVector(v1);    v1.resize(2);    printVector(v1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.2.5 vector插入删除\n功能描述：对vector容器进行插入、删除操作\n\n\n\n函数原型\n\n\n\n\npush_back(elem);\n尾部插入元素 elem\n\n\npop_back();\n删除最后一个元素\n\n\ninsert(const_iterator pos, elem);\n迭代器指向位置pos，插入元素elem\n\n\ninsert(const_iterator pos, int count, elem);\n迭代器指向位置pos，插入count个元素elem\n\n\nerase(const_iterator pos);\n删除迭代器指向位置pos的元素\n\n\nerase(const_iterator start, const_iterator end);\n删除迭代器选择的start到end之间的元素\n\n\nclear();\n清空容器\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//// Created by FHang on 2021/10/10 15:56//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printVector(vector&lt;int&gt; &amp;v)&#123;    for (vector&lt;int&gt;::iterator iterator = v.begin(); iterator != v.end(); ++iterator)    &#123;        cout &lt;&lt; *iterator &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo1()&#123;    // 尾插入    vector&lt;int&gt; v1;    v1.push_back(1);    v1.push_back(2);    v1.push_back(3);    v1.push_back(4);    v1.push_back(5);    printVector(v1);    // 尾删除    v1.pop_back();    printVector(v1);    // 迭代器指定位置插入    v1.insert(v1.begin(), 0);    printVector(v1);    // 迭代器指定位置插入 指定数量 元素    v1.insert(v1.end(), 3, 5);    printVector(v1);    // 删除迭代器指向位置的元素    v1.erase(v1.end() - 1);    printVector(v1);    // 删除迭代器选择的start到end之间的元素    v1.erase(v1.begin() + 1, v1.end() - 2);    printVector(v1);    // clear    v1.clear();    printVector(v1);&#125;int main()&#123;    demo1();    return 0;&#125;\n\n3.2.6 vector数据存取\n功能描述：vector中的数据存取操作\n\n\n\n函数原型\n\n\n\n\nat(int index);\n返回索引index所指的数据\n\n\noperator[];\n返回索引index所指的数据\n\n\nfront();\n返回容器中第一个数据元素\n\n\nback();\n返回容器中最后一个数据元素\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839//// Created by FHang on 2021/10/10 16:20//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt; 5; ++i)    &#123;        v.push_back(i);    &#125;    for (int i = 0; i &lt; v.size(); ++i)    &#123;        cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0; i &lt; v.size(); ++i)    &#123;        cout &lt;&lt; v.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;Vector Front Elem: &quot; &lt;&lt; v.front() &lt;&lt; endl;    cout &lt;&lt; &quot;Vector Back Elem: &quot; &lt;&lt; v.back() &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.2.7 vector互换容器\n功能描述：实现两个容器内元素的互换\n\n\n\n函数原型\n\n\n\n\nswap(otherVector);\n将otherVector与本身的元素互换\n\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//// Created by FHang on 2021/10/10 16:30//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void debugVector(vector&lt;int&gt; &amp;v)&#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void debugVectorInfo(vector&lt;int&gt; &amp;v)&#123;    cout &lt;&lt; &quot;Vector Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;Vector Size: &quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;void demo1()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0; i &lt; 5; ++i)    &#123;        v1.push_back(i);    &#125;    for (int i = 5; i &gt; 0; --i)    &#123;        v2.push_back(i);    &#125;    v1.swap(v2);    debugVector(v1);    debugVector(v2);&#125;void demo2()&#123;    vector&lt;int&gt; v3;    for (int i = 0; i &lt; 1000000; ++i)    &#123;        v3.push_back(i);    &#125;    debugVectorInfo(v3);    // 巧用 swap() 收缩容器的容量大小0    v3.resize(10);    vector&lt;int&gt;(v3).swap(v3);    debugVectorInfo(v3);&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n总结：swap还可以收缩容器的容量大小\n\n\n3.2.8 vector预留空间\n功能描述：减少vector在动态扩展容器时的扩展次数\n\n\n\n函数原型\n\n\n\n\nreserve(int length);\n容器预留length个元素长度，预留位置不初始化，元素不可访问\n\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// Created by FHang on 2021/10/10 16:54//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void demo1()&#123;    int count = 0;    int *p = nullptr;    vector&lt;int&gt; v;    for (int i = 0; i &lt; 10000000; ++i)    &#123;        v.push_back(i);        if (p != &amp;v[0])        &#123;            p = &amp;v[0];            ++count;        &#125;    &#125;    cout &lt;&lt; &quot;Number Of Extensions: &quot; &lt;&lt; count &lt;&lt; endl;&#125;void demo2()&#123;    int count = 0;    int *p = nullptr;    vector&lt;int&gt; v;    v.reserve(10000001);    for (int i = 0; i &lt; 10000000; ++i)    &#123;        v.push_back(i);        if (p != &amp;v[0])        &#123;            p = &amp;v[0];            ++count;        &#125;    &#125;    cout &lt;&lt; &quot;Reserve Number Of Extensions: &quot; &lt;&lt; count &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n总结：如果一开始容器需要插入足够大的数据时，可以通过reserve的方式提前预留，已减少容器扩展的次数\n\n\n3.3 deque容器3.3.1 deque基本概念\n功能：双端数组，可以对容器头端进行插入、删除操作\n\ndeque与vector的区别：\n\nvector头部插入、删除效率低，数据量越大，效率越低\nvector访问元素比deque快，源于内部实现的区别\n\n\ndeque功能介绍：\n\n\n\n函数原型\n\n\n\n\npush_front();\n头部插入\n\n\npop_front();\n头部删除\n\n\n\ndeque内部工作原理：\n\ndeque内部有一个中控器，维护每段缓冲区的内容，缓冲区存放真实数据\n中控器维护的是缓冲区的地址，使得deque在使用时，像是连续的内存空间\ndeque容器的迭代器支持随机访问\n\n\n\n3.3.2 deque构造函数\n功能描述：deque容器构造\n\n\n\n函数原型\n\n\n\n\ndeque&lt;T&gt; dequeT;\n默认构造形式\n\n\ndeque(begin, end);\n构造函数将 [begin, end)区间中的元素拷贝给自身\n\n\ndeque(n, elem);\n构造函数将n个elem拷贝给自身\n\n\ndeque(const deque &amp;deque);\n拷贝构造函数\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by FHang on 2021/10/14 12:27//#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;// const 修饰 该容器为只可 读void printDeque(const deque&lt;int&gt; &amp;otherDeque)&#123;    for (deque&lt;int&gt;::const_iterator it = otherDeque.begin(); it != otherDeque.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo1()&#123;    // 无参构造    deque&lt;int&gt; d1;    for (int i = 0; i &lt; 10; ++i)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    // 区间构造    deque&lt;int&gt; d2(d1.begin(), d1.end());    printDeque(d2);    // n个元素构造    deque&lt;int&gt; d3(10, 1);    printDeque(d3);    // 拷贝构造    deque&lt;int&gt; d4(d3);    printDeque(d4);&#125;int main()&#123;    demo1();    return 0;&#125;\n\n总结：deque与vector相似，灵活使用即可\n\n\n3.3.3 deque赋值操作\n功能描述：给deque容器赋值\n\n\n\n函数原型\n\n\n\n\ndeque &amp;operator=(const deque &amp;deque);\n重载等号操作\n\n\nassign(begin, end);\n将 [begin, end)区间中的数据拷贝赋值给本身\n\n\nassign(n, elem);\n将n个elem拷贝赋值给本身\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by FHang on 2021/10/14 13:13//#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;void printDeque(deque&lt;int&gt; &amp;otherDeque)&#123;    for (deque&lt;int&gt;::iterator it = otherDeque.begin(); it != otherDeque.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    deque&lt;int&gt; deque1;    for (int i = 0; i &lt; 10; ++i)    &#123;        deque1.push_back(i);    &#125;    printDeque(deque1);    // operator=    deque&lt;int&gt; deque2 = deque1;    printDeque(deque2);    // assign(begin, end)    deque&lt;int&gt; deque3;    deque3.assign(deque1.begin(), deque1.end());    printDeque(deque3);    // assign(n, elem)    deque&lt;int&gt; deque4;    deque4.assign(10, 1);    printDeque(deque4);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.3.4 deque大小操作\n功能描述：对deque容器的大小进行操作\n\n\n\n函数原型\n\n\n\n\ndeque.empty();\n判断容器是否为空\n\n\ndeque.size();\n获取容器中元素个数\n\n\ndeque.resize(num);\n重新指定容器长度为num，容器过长以默认值填充，容器过短，删除末尾多余元素\n\n\ndeque.resize(num, elem)\n重新指定容器长度为num，容器过长以elem填充，容器过短，删除末尾多余元素\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by FHang on 2021/10/17 15:17//#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;void printDeque(const deque&lt;int&gt; &amp;otherDeque)&#123;    for (deque&lt;int&gt;::const_iterator it = otherDeque.begin(); it != otherDeque.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt;&quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    // 初始化 deque1    deque&lt;int&gt; deque1;    for (int i = 0; i &lt; 10; ++i)    &#123;        deque1.push_back(i);    &#125;    printDeque(deque1);    // 判断deque1是否为空，不为空，打印出容器大小    if (deque1.empty())    &#123;        cout &lt;&lt; &quot;deque1 is empty&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;deque1 size: &quot; &lt;&lt; deque1.size() &lt;&lt; endl;        // deque 没有容量的概念(capacity)    &#125;    // deque1 大小重置    deque1.resize(12);    printDeque(deque1);    deque1.resize(15, 1);    printDeque(deque1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n总结：\n\ndeque没有容量的概念\nempty判断是否为空\nsize获取容器的大小\nresize重置容器大小\n\n\n\n3.3.5 deque插入删除\n功能描述：向deque容器插入和删除数据\n\n函数原型：\n\n\n\n两端插入caoz\n\n\n\n\npush_back(elem);\n容器尾部添加一个数据\n\n\npush_front(elem);\n容器头部插入一个数据\n\n\npop_back();\n删除容器最后一个数据\n\n\npop_front();\n删除容器开头一个数据\n\n\n\n\n\n指定位置操作\n\n\n\n\ninsert(pos, elem);\n在pos位置插入一个elem元素的拷贝，返回新数据的位置\n\n\ninsert(pos, n, elem);\n在pos位置插入n个elem元素的拷贝，无返回值\n\n\ninsert(pos, begin, end);\n在pos位置插入[begin, end)区间的数据，无返回值\n\n\nclear();\n清空容器所有数据\n\n\nerase(begin, end);\n删除[begin, end)区间的数据，返回下一个数据的位置\n\n\nerase(pos);\n删除pos位置的数据，返回下一个数据的位置\n\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// Created by FHang on 2021/10/17 15:38//#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;void printDeque(const deque&lt;int&gt; &amp;otherDeque)&#123;    for (deque&lt;int&gt;::const_iterator it = otherDeque.begin(); it != otherDeque.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    deque&lt;int&gt; deque1;    // push_back()    deque1.push_back(1);    deque1.push_back(2);    // push_front()    deque1.push_front(0);    deque1.push_front(0);    printDeque(deque1);    // pop_back()    deque1.pop_back();    // pop_front()    deque1.pop_front();    printDeque(deque1);    // insert(pos, elem)    deque1.insert(deque1.begin(), 0);    // insert(pos, n, elem)    deque1.insert(deque1.end(), 2, 2);    printDeque(deque1);    // clear()    deque1.clear();    printDeque(deque1);    for (int i = 0; i &lt; 10; ++i)    &#123;        deque1.push_back(i);    &#125;    printDeque(deque1);    // erase(begin, end)    deque1.erase(deque1.begin(), deque1.end() - 7);    printDeque(deque1);    // erase(pos)    deque1.erase(deque1.begin() + 1);    printDeque(deque1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.3.6 deque数据存取\n功能描述：的deque中的数据的存取操作\n\n\n\n函数原型\n\n\n\n\nat(int index);\n返回索引index所指的数据\n\n\noperator[index];\n返回索引index所指的数据\n\n\nfront();\n返回容器中第一个数据\n\n\nback();\n返回容器这最后一个数据\n\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344//// Created by FHang on 2021/10/17 15:57//#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;void printDeque(const deque&lt;int&gt; &amp;otherDeque)&#123;    for (deque&lt;int&gt;::const_iterator it = otherDeque.begin(); it != otherDeque.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    deque&lt;int&gt; deque1;    for (int i = 0; i &lt; 10; ++i)    &#123;        deque1.push_back(i);    &#125;    printDeque(deque1);    // at(int index)    cout &lt;&lt; deque1.at(1) &lt;&lt; endl;    // operator[]    cout &lt;&lt; deque1[1] &lt;&lt; endl;    // front()    cout &lt;&lt; deque1.front() &lt;&lt; endl;    // back()    cout &lt;&lt; deque1.back() &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.3.7 deque容器排序\n功能描述：利用算法实现deque容器进行排序\n\n\n\n函数原型\n\n\n\n\nsort(iterator begin, iterator end);\n对begin, end区间的数据进行排序\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536//// Created by FHang on 2021/10/17 16:05//#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;using namespace std;void printDeque(const deque&lt;int&gt; &amp;otherDeque)&#123;    for (deque&lt;int&gt;::const_iterator it = otherDeque.begin(); it != otherDeque.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    deque&lt;int&gt; deque1;    for (int i = 20; i &gt; 0; i -= 2)    &#123;        deque1.push_back(i);    &#125;    printDeque(deque1);    std::sort(deque1.begin(), deque1.end());    printDeque(deque1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n总结：使用sort排序，需引入头文件algorithm\n\n\n3.4 案例-评委打分3.4.1 案例描述\n5名选上ABCDE，10名评委分别对每一名选手打分，去除最高分和最低分，取平均分\n\n3.4.2 实现步骤\n创建5名选手，存入vector容器中\n遍历vector容器，获取每一名选手，使用for循环，把10名评委的打分存入deque容器中\nsort算法对deque容器中分数排序，去除最高和最低分\ndeque容器遍历一遍，累加总分\n获取平均分\n\n3.4.3 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//// Created by FHang on 2021/10/20 14:26//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;class Player&#123;public:    string playerName;    int playerScore;    Player(string name, int score)    &#123;        this-&gt;playerName = name;        this-&gt;playerScore = score;    &#125;&#125;;/*Test Code*//*void printVector(vector&lt;Player&gt; &amp;v_Player)&#123;    for (vector&lt;Player&gt;::iterator it = v_Player.begin(); it != v_Player.end(); ++it)    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; (*it).playerName &lt;&lt; &quot; Score: &quot; &lt;&lt; (*it).playerScore &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void printPlayerScores(vector&lt;Player&gt; &amp;v_Player, deque&lt;int&gt; &amp;d_Scores)&#123;    for (vector&lt;Player&gt;::iterator v_it = v_Player.begin(); v_it != v_Player.end(); ++v_it)    &#123;        cout &lt;&lt; v_it-&gt;playerName &lt;&lt; endl;        for (deque&lt;int&gt;::iterator d_it = d_Scores.begin(); d_it != d_Scores.end(); ++d_it)        &#123;            cout &lt;&lt; *d_it &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;*//*Program Code*/vector&lt;Player&gt; createPlayers()&#123;    int score = 0;    string nameSeed = &quot;ABCDE&quot;;    vector&lt;Player&gt; v_Player;    for (int i = 0; i &lt; 5; ++i)    &#123;        string name = &quot;player&quot;;        name += nameSeed[i];        Player player(name, score);        v_Player.push_back(player);    &#125;    // printVector(v_Player);    return v_Player;&#125;int playerScoreSortAndDeal(deque&lt;int&gt; &amp;d_Scores)&#123;    float averageScore;    int allScore = 0;    std::sort(d_Scores.begin(), d_Scores.end());    d_Scores.pop_front();    d_Scores.pop_back();    for (deque&lt;int&gt;::iterator it = d_Scores.begin(); it != d_Scores.end(); ++it)    &#123;        allScore += (*it);    &#125;    averageScore = allScore / d_Scores.size();    return averageScore;&#125;void setPlayerScore(vector&lt;Player&gt; &amp;v_Player)&#123;    for (vector&lt;Player&gt;::iterator it = v_Player.begin(); it != v_Player.end(); ++it)    &#123;        deque&lt;int&gt; d_Scores;        for (int i = 0; i &lt; 10; ++i)        &#123;            int score = (rand() % 71) + 30;            d_Scores.push_back(score);        &#125;        it-&gt;playerScore = playerScoreSortAndDeal(d_Scores);        // printPlayerScores(v_Player, d_Scores);    &#125;&#125;void showPlayerAverageScore(vector&lt;Player&gt; &amp;v_Player)&#123;    for (vector&lt;Player&gt;::iterator it = v_Player.begin(); it != v_Player.end(); ++it)    &#123;        cout &lt;&lt; &quot;Name: &quot; + it-&gt;playerName &lt;&lt; &quot; AverageScore: &quot; &lt;&lt; it-&gt;playerScore &lt;&lt; endl;    &#125;&#125;int main()&#123;    srand((unsigned int) time(NULL));    vector&lt;Player&gt; v_Player = createPlayers();    setPlayerScore(v_Player);    showPlayerAverageScore(v_Player);    return 0;&#125;\n\n\n\n\n\n3.5 stack容器3.5.1 stack基本概念\n概念：stack是一种先进后出(First In Last out : FILO)的数据结构，它只有一个出口\n栈底存放首个元素，后续其它元素都在栈顶依次加入\n栈中的元素，只有栈顶的元素可以被外界使用，也因此不支持遍历的行为\npush()入栈，pop()出栈，empty()判断栈是否为空，size()获取栈大小\n\n3.5.2 stack常用接口\n功能描述：栈容器常用的对外口\n\n构造函数：\n\nstack&lt;T&gt; stk; 采用模板类实现，stack对象的默认构造形式\nstack(const stack &amp;stk); 拷贝构造函数\n\n\n赋值操作：\n\nstack &amp;operator=(const stack &amp;stk); 重载等号操作\n\n\n数据存取：\n\npush(elem); 向栈顶添加元素\npop(); 移除栈顶的元素\ntop(); 返回栈顶的元素\n\n\n大小操作：\n\nempty(); 判断栈是否为空\nsize() 获取栈大小\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031//// Created by FHang on 2021/10/20 16:13//#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void demo()&#123;    stack&lt;int&gt; stk;    stk.push(10);    stk.push(20);    stk.push(30);    while (!stk.empty())    &#123;        cout &lt;&lt; &quot;Stack Size: &quot; &lt;&lt; stk.size() &lt;&lt; endl;        cout &lt;&lt; &quot;Stack Top Element: &quot; &lt;&lt; stk.top() &lt;&lt; endl;        stk.pop();    &#125;    cout &lt;&lt; &quot;Stack Size: &quot; &lt;&lt; stk.size() &lt;&lt; endl;    cout &lt;&lt; &quot;Stack Top Element: &quot; &lt;&lt; stk.top() &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.6 queue容器3.6.1 queue基本概念\n概念：queue是先进先出(First In Frist Out : FIFO)的数据结构，它有两个出口\n队列容器只能队尾加入元素，对头删除元素\n队列容器只有头和尾可被外界使用，因此不支持遍历行为\n队列中进数据：入队push\n队列中出数据：出队pop\n\n3.6.2 queue常用接口\n功能描述：栈容器常用的对外接口\n\n构造函数：\n\nqueue&lt;T&gt; que; 采用模板类实现，queue对象的默认构造形式\nqueue(const queue &amp;que); 拷贝构造函数\n\n\n赋值操作：\n\nqueue&amp;operator=(const queue &amp;que); 重载等号操作\n\n\n数据存取：\n\npush(elem); 向队尾添加元素\npop(); 移除队头元素\nback(); 返回最后一个元素\nfront(); 返回第一个元素\n\n\n大小操作：\n\nempty(); 判断栈是否为空\nsize() 获取栈大小\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// Created by FHang on 2021/10/20 16:37//#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;class Person&#123;public:    string name;    int age;    Person(string name, int age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;&#125;;void demo()&#123;    queue&lt;Person&gt; q;    Person p1(&quot;QQ&quot;, 10);    Person p2(&quot;WW&quot;, 20);    Person p3(&quot;EE&quot;, 30);    Person p4(&quot;RR&quot;, 40);    q.push(p1);    q.push(p2);    q.push(p3);    q.push(p4);    cout &lt;&lt; &quot;Queue Size: &quot; &lt;&lt; q.size() &lt;&lt; endl;    while (!q.empty())    &#123;        cout &lt;&lt; &quot;Front Name: &quot; + q.front().name + &quot; Front Age: &quot; &lt;&lt; q.front().age &lt;&lt; endl;        cout &lt;&lt; &quot;Back Name: &quot; + q.back().name + &quot; Back Age: &quot; &lt;&lt; q.back().age &lt;&lt; endl;        q.pop();    &#125;    cout &lt;&lt; &quot;Queue Size: &quot; &lt;&lt; q.size() &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.7 list容器3.7.1 list基本概念\n功能：将数据进行链式存储\n\n链表：是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链实现的\n\n链表的组成：链表由一系列结点组成\n\n结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\n\nSTL中的链表是一个双向循环链表\n\n优点：可以对任意位置进行快速插入或删除元素\n\n缺点：\n\n链表容器遍历元素比数组慢\n占用空间比数组大\n\n\nSTL链表的结构：双向循环链表\n\n结点：\n\ndata区：存储数据\npionter区：(默认指向null，则是不循环双向链表)\nprev：指向上一个结点的首地址(第一个结点默认指向最后一个结点的首地址)\nnext：指向下一个结点的首地址(最后一个结点默认指向第一个结点的首地址)\n\n\n\n\n方法：\n\npush_front()：添加一个新结点做为首结点\npop_front()：删除首结点\npush_back()：添加一个新结点做为尾结点\npop_back()：删除尾结点\n\n\n迭代器：\n\nbegin()：获得首结点的地址\ninsert()：获得指定的结点的地址\nend()：获得尾结点的地址\n\n\n补充：由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器\n\nlist的优点：\n\n采用动态存储分配，不会造成内存浪费和溢出\n链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素\n\n\nlist的缺点：\n\n链表的灵活带来的是空间(指针域)和时间(遍历)的额外消费较大\n\n\nlist的重要性质：插入和删除操作都不会造成原有list容器迭代器的失效(vector中会失效)\n\n总结：STL中的lsit和vector是两个常用的容器，各有优缺点\n\n\n3.7.2 list构造函数\n功能描述：创建list容器\n\n\n\n函数原型\n\n\n\n\nlist&lt;T&gt; list;\nlist采用模板类实现，对象的默认构造函数形式\n\n\nlist(begin, end);\n构造函数将[begin, end)区间中的元素拷贝给自身\n\n\nlist(n, elem);\n构造函数将n个elem拷贝给自身\n\n\nlist(const list &amp;list);\n拷贝构造函数\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by FHang on 2021/10/27 14:37//#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;void printList(const list&lt;int&gt; &amp;otherList)&#123;    for (list&lt;int&gt;::const_iterator it = otherList.begin(); it != otherList.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    list&lt;int&gt; list1;    list1.push_back(1);    list1.push_back(2);    list1.push_back(3);    list1.push_back(4);    printList(list1);    // 区间构造    list&lt;int&gt; list2(list1.begin(), list1.end());    printList(list2);    // 拷贝构造    list&lt;int&gt; list3(list2);    printList(list3);    // n 个 elem    list&lt;int&gt; list4(4, 0);    printList(list4);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.7.3 list赋值交换\n功能描述：给list容器进行赋值，以及容器list交换\n\n\n\n函数原型\n\n\n\n\nassign(begin, end);\n将[begin, end)区间中的数据拷贝赋值给自身\n\n\nassign(n, elem);\nn个elem拷贝赋值给自身\n\n\nlist &amp;operator=(const list &amp;list);\n重载=操作符\n\n\nswap(list);\n将list与自身的元素互换\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// Created by FHang on 2021/10/27 14:49//#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;void printList(const list&lt;int&gt; &amp;other)&#123;    for (list&lt;int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo1()&#123;    cout &lt;&lt; &quot;Demo1 &gt;&gt;&quot; &lt;&lt; endl;    list&lt;int&gt; l1(4, 1);    printList(l1);    // operator=    list&lt;int&gt; l2 = l1;    printList(l2);    // assign(begin, end)    list&lt;int&gt; l3;    l3.assign(l1.begin(), l1.end());    printList(l3);    // assign(n, elem)    list&lt;int&gt; l4;    l4.assign(4, 0);    printList(l4);&#125;void demo2()&#123;    cout &lt;&lt; &quot;Demo2 &gt;&gt;&quot; &lt;&lt; endl;    list&lt;int&gt; list1(4, 0);    list&lt;int&gt; list2(4, 9);    cout &lt;&lt; &quot;Swap List Before &gt;&gt;&quot; &lt;&lt; endl;    printList(list1);    printList(list2);    cout &lt;&lt; &quot;Swap List Last &gt;&gt;&quot; &lt;&lt; endl;    list1.swap(list2);    printList(list1);    printList(list2);&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n3.7.4 list大小操作\n功能描述：对list容器的大小进行操作\n\n\n\n函数原型\n\n\n\n\nsize();\n返回容器中元素个数\n\n\nempty();\n判断容器是否为空\n\n\nresize();\n重新指定容器长度为num，容器过长以默认值填充，容器过短，删除末尾多余元素\n\n\nresize(num, elem);\n重新指定容器长度为num，容器过长以elem填充，容器过短，删除末尾多余元素\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142//// Created by FHang on 2021/10/27 15:06//#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;void printList(const list&lt;int&gt; &amp;other)&#123;    for (list&lt;int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    list&lt;int&gt; list1(5, 1);    if (list1.empty())    &#123;        cout &lt;&lt; &quot;List1 Is Empty&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;List1 Size: &quot; &lt;&lt; list1.size() &lt;&lt; endl;    &#125;    list1.resize(10, 2);    printList(list1);    list1.resize(5);    printList(list1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.7.5 list插入删除\n功能描述：对list容器进行数据的插入和删除\n\n\n\n函数原型\n\n\n\n\npush_back(elem);\n在容器尾部加入一个元素\n\n\npop_back();\n删除容器中最后一个元素\n\n\npush_front(elem);\n在容器开头加入一个元素\n\n\npop_front();\n删除容器开头的一个元素\n\n\ninsert(pos, elem);\n在pos的位置插入elem元素的拷贝，返回新数据的位置\n\n\ninsert(pos, n, elem);\n在pos位置插入n个elem元素，无返回值\n\n\ninsert(pos, begin, end);\n在pos位置插入[begin, end)区间的数据，无返回值\n\n\nclear();\n移除容器中所有的元素\n\n\nerase(begin, end);\n删除[begin, end)区间的数据，返回下一个数据的位置\n\n\nerase(pos);\n删除pos位置的数据，返回下一个数据的位置\n\n\nremove(elem);\n删除容器中所有与elem元素匹配的元素\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//// Created by FHang on 2021/10/29 14:54//#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;void printList(const list&lt;int&gt; &amp;other)&#123;    for (list&lt;int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    list&lt;int&gt; l1;    // push_back()    for (int i = 0; i &lt; 5; ++i)    &#123;        l1.push_back(i);    &#125;    printList(l1);    // push_front()    for (int i = 1; i &lt;5; ++i)    &#123;        l1.push_front(1);    &#125;    printList(l1);    // pop_back()    l1.pop_back();    printList(l1);    // pop_front()    l1.pop_front();    printList(l1);    // insert(pos, elem)    l1.insert(l1.begin(), 0);    printList(l1);    // insert(pos, n, elem)    l1.insert(l1.end(), 3, 5);    printList(l1);    // insert(pos, begin, end);    list&lt;int&gt; l2(3, 9);    l1.insert(l1.end(), l2.begin(), l2.end());    printList(l1);    // erase(pos)    l1.erase(++l1.begin());    printList(l1);    // remove(elem)    l1.remove(5);    printList(l1);    // clear()    l1.clear();    l1.push_front(9);    printList(l1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.7.6 list数据存取\n功能描述：对list容器数据进行存取\n\n\n\n函数原型\n\n\n\n\nfront();\n返回第一个元素\n\n\nback();\n返回最后一个元素\n\n\n\n补充：list&lt;int&gt; l1;\n\nl1[0];\nl1.at(0);\n原因：list容器本质是链表，空间不连续，无法使用数组下标的方式获得数值，迭代器也不支持随机访问\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142//// Created by FHang on 2021/10/29 15:33//#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;void printList(const list&lt;int&gt; &amp;other)&#123;    for (list&lt;int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    list&lt;int&gt; l1;    for (int i = 0; i &lt; 5; ++i)    &#123;        l1.push_back(i);    &#125;    printList(l1);    cout &lt;&lt; &quot;l1 first&gt;&gt; &quot; &lt;&lt; l1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;l1 back&gt;&gt; &quot; &lt;&lt; l1.back() &lt;&lt; endl;    // 双向访问    list&lt;int&gt;::iterator it1 = ++l1.begin();    list&lt;int&gt;::iterator it2 = --l1.end();    l1.erase(it1, it2);    printList(l1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.7.7 list容器排序\n功能描述：将容器中的元素反转，以及元素排序\n\n\n\n函数原型\n\n\n\n\nreverse();\n反转链表\n\n\nsort();\n链表排序\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// Created by FHang on 2021/10/29 15:54//#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;void printList(const list&lt;int&gt; &amp;other)&#123;    for (list&lt;int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;bool upSort(int &amp;list1, int &amp;list2)&#123;    return list1 &gt; list2;&#125;void demo()&#123;    list&lt;int&gt; list1;    for (int i = 0; i &lt; 10; ++i)    &#123;        list1.push_back(i);    &#125;    printList(list1);    // reverse()    list1.reverse();    printList(list1);    // sort() -- 默认从小到大    list1.sort();    printList(list1);    // sort() -- 改为从大到小    list1.sort(upSort);    printList(list1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.8 案例-自定义数据排序\n案例描述：将Person自定义数据类型进行排序，Person中属性有：姓名，年龄，身高\n\n排序规则：按照年龄进行升序(年龄小的放在前面)，如果年龄相同，按照身高进行降序(身高低的放在前面)\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//// Created by FHang on 2021/10/29 16:15//#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;class Person&#123;public:    string name;    int age;    int height;    Person(const string &amp;name, int age, int height)    &#123;        this-&gt;name = name;        this-&gt;age = age;        this-&gt;height = height;    &#125;&#125;;// Debugvoid printPersonList(const list&lt;Person&gt; &amp;other)&#123;    for (list&lt;Person&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot; Height:&quot; &lt;&lt; it-&gt;height &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;bool sortRule(Person &amp;person1, Person &amp;person2)&#123;    if (person1.age == person2.age)    &#123;        return person1.height &lt; person2.height;    &#125;    else    &#123;        return person1.age &lt; person2.age;    &#125;&#125;list&lt;Person&gt; createPersonList()&#123;    list&lt;Person&gt; l1;    Person person1(&quot;QQ&quot;, 10, 160);    Person person2(&quot;WW&quot;, 20, 150);    Person person3(&quot;EE&quot;, 20, 170);    Person person4(&quot;RR&quot;, 70, 175);    Person person5(&quot;TT&quot;, 30, 180);    l1.push_back(person1);    l1.push_back(person2);    l1.push_back(person3);    l1.push_back(person4);    l1.push_back(person5);    printPersonList(l1);    return l1;&#125;void upSort(list&lt;Person&gt; &amp;other)&#123;    cout &lt;&lt; &quot;UpSort&gt;&gt; By Age And Height&quot; &lt;&lt; endl;    other.sort(sortRule);    printPersonList(other);&#125;int main()&#123;    list&lt;Person&gt; l1 = createPersonList();    upSort(l1);    return 0;&#125;\n\n3.9 set&#x2F;multiset容器3.9.1 set基本概念\n简介：所有元素被插入时，容器都会进行一次自动排序\n本质：set/multiset属于关联容器，底层结构是二叉树实现\nset和multiset的区别：\nset不允许容器中有重复的元素\nmultiset允许容器中有重复的元素\n\n\n\n3.9.2 set构造赋值\n功能描述：创建set容器并赋值\n\n\n\n构造\n\n\n\n\nset&lt;T&gt; st;\n默认构造函数\n\n\nset(const set &amp;st);\n拷贝构造函数\n\n\n\n\n\n赋值\n\n\n\n\nset &amp;operator=(const set &amp;st);\n重载等号操作符\n\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344//// Created by FHang on 2021/10/30 14:49//#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;void printSet(const set&lt;int&gt; &amp;st)&#123;    for (set&lt;int&gt;::const_iterator it = st.begin(); it != st.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    set&lt;int&gt; st1;    // set 只能用 insert插入数据，且不插入重复数据    // set 会自动排序插入的数据    st1.insert(1);    st1.insert(1);    st1.insert(1);    st1.insert(4);    st1.insert(3);    st1.insert(2);    printSet(st1);    // 默认构造    set&lt;int&gt; st2(st1);    printSet(st2);    // 赋值拷贝构造    set&lt;int&gt; st3 = st1;    printSet(st3);&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n\n总结：set 只能用 insert插入数据，且不插入重复数据\n\n\n3.9.3 set大小交换\n功能描述：统计set容器大小，以及交换set容器\n\n\n\n函数原型\n\n\n\n\nsize();\n返回容器中元素个数\n\n\nempty();\n判断容器是否为空\n\n\nswap(st);\n交换两个容器的元素\n\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//// Created by FHang on 2021/10/30 15:00//#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;void printSet(const set&lt;int&gt; &amp;st)&#123;    for (set&lt;int&gt;::const_iterator it = st.begin(); it != st.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    set&lt;int&gt; st1;    for (int i = 0; i &lt; 5; ++i)    &#123;        st1.insert(i);    &#125;    if (st1.empty())    &#123;        cout &lt;&lt; &quot;Set1 Is Empty&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;        printSet(st1);        cout &lt;&lt; &quot;Set1 Size&gt;&gt;&quot; &lt;&lt; st1.size() &lt;&lt; endl;    &#125;&#125;void demo2()&#123;    set&lt;int&gt; st1;    for (int i = 0; i &lt; 5; ++i)    &#123;        st1.insert(i);    &#125;    set&lt;int&gt; st2;    for (int i = 9; i &gt;= 5 ; --i)    &#123;        st2.insert(i);    &#125;    cout &lt;&lt; &quot;Swap Before&gt;&gt;&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;    printSet(st1);    cout &lt;&lt; &quot;Set2&gt;&gt;&quot;;    printSet(st2);    cout &lt;&lt; &quot;Swap Last&gt;&gt;&quot; &lt;&lt; endl;    st1.swap(st2);    cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;    printSet(st1);    cout &lt;&lt; &quot;Set2&gt;&gt;&quot;;    printSet(st2);&#125;int main()&#123;    demo();    demo2();    return 0;&#125;\n\n3.9.4 set插入删除\n功能描述：set容器进行插入和删除数据\n\n\n\n函数原型\n\n\n\n\ninsert(elem);\n在容器中插入元素\n\n\nclear();\n清除所有元素\n\n\nerase(pos);\n删除迭代器pos所指的元素，返回下一个元素的迭代器\n\n\nerase(begin, end);\n删除[begin, end)区间内的元素，返回下一个元素的迭代器\n\n\nerase(elem);\n删除容器中的所有elem元素\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// Created by FHang on 2021/10/30 15:14//#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;void printSet(const set&lt;int&gt; &amp;st)&#123;    for (set&lt;int&gt;::const_iterator it = st.begin(); it != st.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    set&lt;int&gt; st1;    for (int i = 0; i &lt;= 9; ++i)    &#123;        st1.insert(i);    &#125;    printSet(st1);    // erase(pos)    st1.erase(st1.begin());    printSet(st1);    // erase(elem)    st1.erase(9);    printSet(st1);    // erase(begin, end);    st1.erase(++st1.begin(), --st1.end());    printSet(st1);    // clear()    st1.clear();    st1.insert(0);    printSet(st1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.9.5 set查找统计\n功能描述：对容器内的元素进行查找和统计\n\n\n\n函数原型\n\n\n\n\nfind(key);\n查找key是否存在，存在则返回该元素的迭代器，不存在则返回set.end();\n\n\ncount(key);\n统计key的个数\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by FHang on 2021/10/30 15:25//#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;void printSet(const set&lt;int&gt; &amp;st)&#123;    for (set&lt;int&gt;::const_iterator it = st.begin(); it != st.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    set&lt;int&gt; st1;    for (int i = 0; i &lt;= 9; ++i)    &#123;        st1.insert(i);    &#125;    printSet(st1);    // find(key)    set&lt;int&gt;::const_iterator it = st1.find(3);    if (it != st1.end())    &#123;        cout &lt;&lt; &quot;Set1 Find&gt;&gt;&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Set1 Not Find&quot; &lt;&lt; endl;    &#125;    // count(key)    set&lt;int&gt; st2;    for (int i = 0; i &lt;= 9; ++i)    &#123;        st2.insert(0);    &#125;    printSet(st2);    cout &lt;&lt; &quot;Set2 Count 0&gt;&gt;&quot; &lt;&lt; st2.count(0) &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.9.6 set&#x2F;multiset区别\n区别：\n\nset不可以插入重复的元素，multiset可以\nset插入数据同时返回插入结果，表示插入成功\nmultiset不会检查插入数据，所以可以重复插入\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// Created by FHang on 2021/10/30 15:58//#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;void printMultiSet(const multiset&lt;int&gt; &amp;multiset1)&#123;    for (multiset&lt;int&gt;::const_iterator it = multiset1.begin(); it != multiset1.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    set&lt;int&gt; set1;    pair&lt;set&lt;int&gt;::iterator, bool&gt; pairResult;    pairResult = set1.insert(1);    cout &lt;&lt; &quot;First&gt;&gt; &quot; &lt;&lt; endl;    if (pairResult.second)    &#123;        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Succeed&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Error&quot; &lt;&lt; endl;    &#125;    pairResult = set1.insert(1);    cout &lt;&lt; &quot;Second&gt;&gt; &quot; &lt;&lt; endl;    if (pairResult.second)    &#123;        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Succeed&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Error&quot; &lt;&lt; endl;    &#125;&#125;void demo2()&#123;    multiset&lt;int&gt; multiset1;    for (int i = 0; i &lt;= 9; ++i)    &#123;        multiset1.insert(9);    &#125;    printMultiSet(multiset1);&#125;int main()&#123;    demo();    demo2();    return 0;&#125;\n\n3.9.7 pair对组创建\n功能描述：成对出现的数据组，利用对组可以返回两个数据\n\n创建方式：\n\npair&lt;type1, type2&gt; p(value1, value2);\npair&lt;type1, type2&gt; p = make_pair(value1, value2);\n\n\n代码示例：\n1234567891011121314151617181920212223242526//// Created by FHang on 2021/10/30 16:18//#include &lt;iostream&gt;using namespace std;void printPair(const pair&lt;string, int&gt; &amp;other)&#123;    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; other.first &lt;&lt; &quot; Age: &quot; &lt;&lt; other.second &lt;&lt; endl;&#125;void demo()&#123;    pair&lt;string, int&gt; pair1(&quot;FF&quot;, 22);    printPair(pair1);    pair&lt;string, int&gt; pair2 = make_pair(&quot;QQ&quot;, 20);    printPair(pair2);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.9.8 set容器排序\n默认排序：set容器默认排序是从小到大\n\n排序目标：掌握自定义排序规则\n\n使用方法：利用仿函数，改变排序规则\n\n代码示例一：set存放内置数据类型，从大到小排序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Created by FHang on 2021/10/30 16:30//#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;class DownSort&#123;public:    bool operator()(int value1, int value2)    &#123;        return value1 &gt; value2;    &#125;&#125;;void printSet(const set&lt;int&gt; &amp;other)&#123;    for (set&lt;int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void printSet(const set&lt;int, DownSort&gt; &amp;other)&#123;    for (set&lt;int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    set&lt;int&gt; set1;    for (int i = 0; i &lt;= 9; ++i)    &#123;        set1.insert(i);    &#125;    printSet(set1);    set&lt;int, DownSort&gt; set2;    for (int i = 0; i &lt;= 9; ++i)    &#123;        set2.insert(i);    &#125;    printSet(set2);&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n\n代码示例二：自定义数据类型，从大到小排序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// Created by FHang on 2021/10/30 16:42//#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;class Person&#123;public:    string name;    int age;    Person(string name, int age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;&#125;;class DownSort&#123;public:    bool operator()(const Person &amp;p1, const Person &amp;p2)    &#123;        return p1.age &gt; p2.age;    &#125;&#125;;void printSet(const set&lt;Person, DownSort&gt; &amp;other)&#123;    for (set&lt;Person, DownSort&gt;::iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; Age: &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    Person p1(&quot;QQ&quot;, 10);    Person p2(&quot;WW&quot;, 40);    Person p3(&quot;EE&quot;, 20);    Person p4(&quot;RR&quot;, 30);    set&lt;Person, DownSort&gt; set1;    set1.insert(p1);    set1.insert(p2);    set1.insert(p3);    set1.insert(p4);    printSet(set1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.10 map&#x2F;multimap容器3.10.1 map基本概念\n简介：\nmap中所有的元素都是pair\npair中第一个元素为key(键值)，起到索引作用，第二元素为value(实值)\n所有元素都会根据元素的键值自动排序\n\n\n本质：\nmap/multimap属于关联式容器，底层结构是用二叉树实现\n\n\n优点：\n可以根据key值快速找到value值\n\n\nmap/multimap的区别：\nmap不允许有重复的元素\nmultimap允许重复的元素\n\n\n\n3.10.2 map构造赋值\n功能描述：对map容器进行构造和赋值操作\n\n\n\n构造\n\n\n\n\nmap&lt;T1, T2&gt; mp;\nmap默认构造函数\n\n\nmap(const map &amp;mp);\n拷贝构造函数\n\n\n\n\n\n赋值\n\n\n\n\nmap &amp;operator=(const map &amp;mp);\n重载等号操作符\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243//// Created by FHang on 2021/10/31 16:34//#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;void printMap(const map&lt;int, string&gt; &amp;other)&#123;    for (map&lt;int, string&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; &quot;ID: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Name: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    map&lt;int, string&gt; map1;    map1.insert(pair&lt;int, string&gt;(1, &quot;QQ&quot;));    map1.insert(pair&lt;int, string&gt;(4, &quot;WW&quot;));    map1.insert(pair&lt;int, string&gt;(2, &quot;EE&quot;));    map1.insert(pair&lt;int, string&gt;(5, &quot;RR&quot;));    map1.insert(pair&lt;int, string&gt;(3, &quot;TT&quot;));    printMap(map1);    // 拷贝构造    map&lt;int, string&gt; map2(map1);    printMap(map2);    // 赋值    map&lt;int, string&gt; map3 = map1;    printMap(map3);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.10.3 map大小交换\n功能描述：统计map容器大小以及交换map容器\n\n\n\n函数原型\n\n\n\n\nsize();\n返回容器中的元素的数目\n\n\nempty();\n判断容器是否为空\n\n\nswap(st);\n交换两个集合容器\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// Created by FHang on 2021/11/13 15:12//#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;void printMap(const map&lt;int, int&gt; &amp;other)&#123;    for (map&lt;int, int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    map&lt;int, int&gt; map1;    map1.insert(pair&lt;int, int&gt;(1, 10));    map1.insert(pair&lt;int, int&gt;(2, 20));    map1.insert(pair&lt;int, int&gt;(3, 30));    if (map1.empty())    &#123;        cout &lt;&lt; &quot;Map1 Is Empty&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Map1 Size &quot; &lt;&lt; map1.size() &lt;&lt; endl;    &#125;    map&lt;int, int&gt; map2;    map2.insert(pair&lt;int, int&gt;(4, 40));    map2.insert(pair&lt;int, int&gt;(5, 50));    map2.insert(pair&lt;int, int&gt;(6, 60));    map1.swap(map2);    printMap(map1);    printMap(map2);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.10.4 map插入删除\n功能描述：map容器进行插入和删除操作\n\n\n\n函数原型\n\n\n\n\ninsert(pair&lt;type1, type2&gt;(key, value));\n在容器中插入元素\n\n\nclear();\n清空容器\n\n\nerase(pos);\n删除pos迭代器所指位置的元素，返回下一个元素的迭代器\n\n\nerase(begin, end);\n删除[begin, end]之间的元素，返回下一个元素的迭代器\n\n\nerase(key);\n删除key指定索引位置的元素\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//// Created by FHang on 2021/11/13 15:31//#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;void printMap(const map&lt;int, int&gt; &amp;other)&#123;    for (map&lt;int, int&gt;::const_iterator it = other.begin(); it != other.end(); ++it)    &#123;        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    map&lt;int, int&gt; map1;    map1.insert(pair&lt;int, int&gt;(1, 10));    map1.insert(make_pair(2, 20));    map1.insert(map&lt;int, int&gt;::value_type(3, 30));    // 不建议使用该方法插入，但可以通过这个方法利用 key 访问 value    map1[4] = 40;    map1.insert(pair&lt;int, int&gt;(5, 50));    map1.insert(pair&lt;int, int&gt;(6, 60));    map1.insert(pair&lt;int, int&gt;(7, 70));    // map[5]在容器中不存在，所以默认直接在容器中添加了一个，默认value为0    cout &lt;&lt; map1[8] &lt;&lt; endl;    printMap(map1);    map1.erase(map1.begin());    printMap(map1);    map1.erase(8);    printMap(map1);    map1.erase(++map1.begin(), --map1.end());    printMap(map1);    map1.clear();    printMap(map1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.10.5 map查找统计\n功能描述：对map容器进行查找数据以及数据统计\n\n\n\n函数原型\n\n\n\n\nfind(key);\n查找key是否存在，若存在返回key键的元素迭代器；不存在，返回set.end();\n\n\ncount(key);\n统计key的元素的个数\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// Created by FHang on 2021/11/13 16:34//#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;void printMap(const map&lt;int, int&gt; &amp;other)&#123;    for (map&lt;int, int&gt;::const_iterator it = other.cbegin(); it != other.cend(); ++it)    &#123;        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    map&lt;int, int&gt; map1;    map1.insert(pair&lt;int, int&gt;(1, 10));    map1.insert(pair&lt;int, int&gt;(2, 20));    map1.insert(pair&lt;int, int&gt;(3, 30));    map&lt;int, int&gt;::const_iterator itPos = map1.find(3);    // map.end() 返回的是迭代器所指位置的 “下一个”迭代器的位置    if (itPos != map1.cend())    &#123;        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; itPos-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; itPos-&gt;second &lt;&lt; endl;        cout &lt;&lt; &quot;End Key: &quot; &lt;&lt; map1.cend()-&gt;first &lt;&lt; &quot; End Value: &quot; &lt;&lt; map1.cend()-&gt;second &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Can Find Key&quot; &lt;&lt; endl;    &#125;    map1.insert(pair&lt;int, int&gt;(3, 90));    int count = map1.count(3);    cout &lt;&lt; &quot;End Key: &quot; &lt;&lt; map1.cend()-&gt;first &lt;&lt; &quot; End Value: &quot; &lt;&lt; map1.cend()-&gt;second &lt;&lt; endl;    cout &lt;&lt; count &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.10.6 map容器排序\n目标：\n\nmap容器默认排序规则，按照key值进行，从小到大的排序\n掌握自定义排序规则\n\n\n主要技术点：利用仿函数，改变排序规则\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243//// Created by FHang on 2021/11/13 18:08//#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;class DownSort&#123;public:    bool operator()(int value1, int value2)    &#123;        return value1 &gt; value2;    &#125;&#125;;void printMap(const map&lt;int, int, DownSort&gt; &amp;other)&#123;    for (map&lt;int, int&gt;::const_iterator it = other.cbegin(); it != other.cend(); ++it)    &#123;        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    map&lt;int, int, DownSort&gt; map1;    map1.insert(pair&lt;int, int&gt;(1, 10));    map1.insert(pair&lt;int, int&gt;(2, 20));    map1.insert(pair&lt;int, int&gt;(3, 30));    map1.insert(pair&lt;int, int&gt;(4, 40));    map1.insert(pair&lt;int, int&gt;(5, 50));    printMap(map1);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.11 案例-员工分组3.11.1 案例描述\n10名员工（ABCDEFGHIJ），需要分配部门\n员工信息：姓名，工资\n部门：策划，美术，研发\n随机给10名员工分配工资和部门\n通过multimap进行信息插入：key部门编号，value员工\n分部门显示员工信息\n\n3.11.2 实现步骤\n创建10个员工对象，存入vector容器中\n遍历vector，取出每个员工，进行随机分组\n分组后，将key部门编号，value员工，存放到multimap\n分部门显示员工信息\n\n3.11.3 案例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//// Created by FHang on 2021/11/13 19:05//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;ctime&gt;using namespace std;#define PLAN 0#define ART 1#define RD 2class Staff&#123;public:    string staff_Name;    int staff_Salary;&#125;;void printVector(const vector&lt;Staff&gt; &amp;other)&#123;    for (vector&lt;Staff&gt;::const_iterator it = other.cbegin(); it != other.cend(); ++it)    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; it-&gt;staff_Name &lt;&lt; &quot; Salary: &quot; &lt;&lt; it-&gt;staff_Salary &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void creatStaff(vector&lt;Staff&gt; &amp;v_Staff)&#123;    string staffNameSeed = &quot;ABCDEFGHIJ&quot;;    for (int i = 0; i &lt; 10; ++i)    &#123;        Staff staff;        staff.staff_Name = &quot;Staff_&quot;;        staff.staff_Name += staffNameSeed[i];        staff.staff_Salary = rand() % 10000 + 10000;        v_Staff.push_back(staff);    &#125;&#125;void setStaffGroup(vector&lt;Staff&gt; &amp;v_Staff, multimap&lt;int, Staff&gt; &amp;map_Depart)&#123;    for (vector&lt;Staff&gt;::iterator it = v_Staff.begin(); it != v_Staff.end(); ++it)    &#123;        int depart_ID = rand() % 3;        map_Depart.insert(pair&lt;int, Staff&gt;(depart_ID, *it));    &#125;&#125;void checkStaffByGroup(multimap&lt;int, Staff&gt;::const_iterator &amp;itPos, const multimap&lt;int, Staff&gt; &amp;map_Depart, const int count)&#123;    for (int index = 0; itPos != map_Depart.cend() &amp;&amp; index &lt; count; ++itPos, ++index)    &#123;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; itPos-&gt;second.staff_Name &lt;&lt; &quot; Salary: &quot; &lt;&lt; itPos-&gt;second.staff_Salary &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void showStaffInfoByGroup(multimap&lt;int, Staff&gt; &amp;map_Depart)&#123;    int countStaff_PLAN = map_Depart.count(PLAN);    int countStaff_ART = map_Depart.count(ART);    int countStaff_RD = map_Depart.count(RD);    multimap&lt;int, Staff&gt;::const_iterator itPos_Plan = map_Depart.find(PLAN);    multimap&lt;int, Staff&gt;::const_iterator itPos_Art = map_Depart.find(ART);    multimap&lt;int, Staff&gt;::const_iterator itPos_RD = map_Depart.find(RD);    cout &lt;&lt; &quot;Plan Department&gt;&gt;&quot; &lt;&lt; endl;    checkStaffByGroup(itPos_Plan, map_Depart, countStaff_PLAN);    cout &lt;&lt; &quot;Art Department&gt;&gt;&quot; &lt;&lt; endl;    checkStaffByGroup(itPos_Art, map_Depart, countStaff_ART);    cout &lt;&lt; &quot;R&amp;D Department&gt;&gt;&quot; &lt;&lt; endl;    checkStaffByGroup(itPos_RD, map_Depart, countStaff_RD);&#125;int main()&#123;    srand((unsigned int)time(NULL));    vector&lt;Staff&gt; v_Staff;    creatStaff(v_Staff);    printVector(v_Staff);    multimap&lt;int, Staff&gt; map_Depart;    setStaffGroup(v_Staff, map_Depart);    showStaffInfoByGroup(map_Depart);    return 0;&#125;\n\n\n\n","slug":"1_C++_模板和STL_05","date":"2022-10-06T07:28:25.920Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"e614b361765c5cfea11849494ca08809","title":"C++_面向对象反汇编补充","content":"C++_面向对象反汇编补充[toc]\n1. 类1.1 类的定义\nC++中可以使用 struct，class来定义类\n\n1.2 struct和class区别\nstruct默认成员权限是public\nclass默认成员权限是private\n\n1.2.1 定义和访问\n代码示例：\n123456789101112131415161718192021222324252627282930struct Person&#123;    int m_Age;        void run()    &#123;        cout &lt;&lt; &quot;m_Age: &quot; &lt;&lt; m_Age &lt;&lt; endl;    &#125;&#125;;class Person&#123;public:        int m_Age;        void run()    &#123;        cout &lt;&lt; &quot;m_Age: &quot; &lt;&lt; m_Age &lt;&lt; endl;    &#125;&#125;;Person person;// 通过对象访问person.m_Age = 20;person.run();// 通过指针访问Person *ptr_Person = &amp;person;ptr_Person -&gt;m_Age = 20;ptr_Person -&gt;run();\n\n对象person 和 指针ptr_Person的内存都是在函数的栈空间中，自动分配和回收\n\n对象person只有一个int类型的成员变量，所以是4字节\n\n指针ptr_Person在 32位占用4字节，64位占用8字节\n\n\n1.2.2 反汇编查看区别\n代码示例1：\n1234567891011121314151617181920212223class Car&#123;public:    int m_price;        void run()    &#123;        cout &lt;&lt; &quot;Car::run() &quot; &lt;&lt; m_price &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Car car1;    car1.m_price = 10;    car1.run();        Car car2;    car2.m_price = 20;    car2.run();        return 0;&#125;\n\n1234567891011121314151617181920// 查看核心部分汇编代码mov dword ptr[car1], 0Ah // 由此可得，对象占用4字节，成员变量占用4字节，所以第一个成员变量的内存地址就是对象的地址// Car car1;// car1.m_price = 10;lea ecx, [car1]call 0086141A // 此处 call run()// car1.run();    mov dword ptr[car2], 14h// Car car2;lea ecx, [car2]call 0086141A // 此处 call run()// car2.m_price = 20;// car2.run();// 由上可以等到，两个对象 car1 和 car2 的成员变量是不同的// 但它们调用的函数的地址是同一个\n\n对象内的函数不占用对象的内存大小：\n\n类中的函数在编译阶段，会将函数的地址存放到单独的一段内存中\n当两个函数完全相同时，会去重，仅保留一个函数地址\n一个类生成的多个对象中，只有成员变量是每个对象各自拥有的，而成员方法则是统一去重存储在方法列表中\n\n\n补充：\n\n无论函数和变量存在于什么地方，如果没有在其它地方使用或调用\n该函数和变量，在编译阶段会被优化，也就是根本不存在\n\n\n\n1.3 对象的内存布局\n代码示例：\n1234567891011121314151617struct Person&#123;  int m_age;  int m_id;&#125;;int main()&#123;    Person person;    person.m_age = 10;    person.m_id = 100;        cout &lt;&lt; &quot;&amp;person = &quot; &lt;&lt; &amp;person &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;person.m_age = &quot; &lt;&lt; &amp;person.m_age &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;person.m_id = &quot; &lt;&lt; &amp;person.m_id &lt;&lt; endl;    return 0;&#125;\n\n运行结果：\n123&amp;person = 0x7bfe18&amp;person.m_age = 0x7bfe18   &amp;person.m_id = 0x7bfe1c  \n\n2. this\n隐式参数\n\n存储着函数调用者的地址\n\n代码示例1：\n1234567891011121314151617181920struct Person&#123;  int m_age;    void run()  &#123;    // 编译器会隐式传参    // this = &amp;person1      this-&gt;m_age = 3;  &#125;&#125;;int main()&#123;    Person person1;    person1.m_age = 10;    person1.run();        return 0;&#125;\n\n反汇编分析：\n123456789101112131415// ebp-8 是 this 的地址// eax 是 person1 的地址// Person person1;// person1.m_age = 10;mov dword ptr [ebp-0Ch], 0Ah// person.run();lea ecx, [ebp-0Ch]call 00181366\tmov dword ptr [ebp-8], ecx\t\t// this-&gt;m_age = 3;\tmov eax. dword ptr [ebp-8]\tmov dword ptr [eax], 3\n\n\n\n\n\n代码示例2：\n123456789101112131415161718192021struct Person&#123;  int m_age;  int m_id;    void run()&#123;&#125;&#125;;int main()&#123;    Person person1;    person1.m_age = 10;    person1.m_id = 20;    person1.run();\t    Person *person2 = &amp;person1;    person2-&gt;m_age = 10;    person2-&gt;m_id = 10;    person2-&gt;run();    return 0;&#125;\n\n反汇编分析：\n1234567891011121314151617181920212223242526// Person person1;// person1.m_age = 10;mov dword ptr [ebp-14h], 0Ah// person1.m_id = 20;mov dword ptr [ebp-10h], 14h// person1.run();lea ecx, [ebp-14h]call 00FA141F\t// Person *person2 = &amp;person1;lea eax, [ebp-14h] // [ebp-14h]是person1的地址mov dword ptr [ebp-20h], eax // [ebp-20h]是指针变量person2的地址// person2-&gt;m_age = 10;mov eax, dword ptr [ebp-20h] // eax存储的是person1的地址值mov dword ptr [eax], 0Ah // person2-&gt;m_id = 10;mov eax, dword ptr [ebp-20h]mov dword ptr [eax+4], 0Ah // person2-&gt;run();mov ecx, dword ptr [ebp-20h] // 将person1地址隐式传给thiscall 003B141F\n\n\n\n代码示例3：\n123456789101112131415161718192021222324252627282930struct Person&#123;  int m_age;  int m_id;  int m_height;      void run()  &#123;      cout &lt;&lt; m_age &lt;&lt; &quot;+&quot; &lt;&lt; m_id &lt;&lt; &quot;+&quot; &lt;&lt; m_height &lt;&lt; endl;  &#125;&#125;;int main()&#123;    Person person;    person.m_age = 10;    person.m_id = 20;    person.m_height = 30;\t    Person *p = (Person *) &amp;person.m_age;    p-&gt;m_age = 0;    p-&gt;m_id = 0;        // 注意：这里用的 person，不是 p    person.run();    return 0;&#125;# 打印结果：# 10+0+0\n\n反汇编分析：\n12345678910111213141516// Person *p = (Person *) &amp;person.m_id;// eax == &amp;person.m_id == person+4// p-&gt;m_age = 0;mov eax, dword ptr [p]mov dword ptr [eax + 0], 0h// p-&gt;m_id = 0;mov eax, dword ptr [p]mov dword ptr [eax + 4], 0h// 在栈空间中&gt;&gt; &amp;person == &amp;person.m_age// 改程序中 eax 的存储的地址是 &amp;person.m_id == &amp;person+4// 所以&gt;&gt; // p-&gt;m_age = 0; 修改的是 m_id// p-&gt;m_id = 0; 修改的是 m_height\n\n思考：\n12345678910111213Person *p = (Person *) &amp;person.m_age;p-&gt;m_age = 0;p-&gt;m_id = 0;// person 对象的地址传递给 run 的thisperson.run();// 改为// 将指针 p 里存储的地址值传给 run 的this == &amp;person.m_id 传递给 thisp-&gt;run();# 打印结果# 40+50+-858993460# -858993460 == Oxcccccccc\n\n补充：\n\n上面的程序打印结果：Oxcccccccc\n\n由来：函数调用是，开辟栈空间，调用结束，用cccccccc来填充内存空间\n\n原因：\n\ncc的汇编是int3：断点\nint是硬件中断\n\n\n作用：防止指针或jump之类的指令，指向错误的内存地址，可能造成系统安全问题，所以用硬件中断指令填充被释放的栈空间\n1234// p-&gt;run();// 汇编中有一条指令mov eax, 0cccccccchrep stos dword ptr es:[edi]\n\n3. 内存空间的布局\n每个应用都有自己独立的内存空间：\n代码区(代码段)：用于存放代码\n全局区(数据段)：用于存放全局变量等\n栈空间：\n每调用一个函数就会给它分配一个连续的栈空间，等函数调用完毕后会自动回收这段栈空间\n自动分配和回收\n\n\n堆空间：需要主动去申请和释放\n\n\n\n3.1 代码区\n只读\n存放CPU指令(机器码)\n\n3.2 全局区\n程序结束，全局区的数据才会清空\n\n3.3 堆空间\n在程序运行过程中，为了能自由控制内存的生命周期，大小，会经常使用堆空间的内存\n\n3.3.1 堆空间申请和释放\n堆空间的申请和释放：(C/C++语言 =&gt; malloc() / free())\n1234567891011121314151617181920212223void demo()&#123;    // malloc(4) 申请4字节堆空间，返回 void *，强转成 int *    int *p = (int *)malloc(4);    // int * 占用4个字节，所以 10 赋值给4个字节空间    *p = 10;    // 释放 p 申请的所有空间    free(p);        char *p = (char *)malloc(4);    // char * 占用1个字节空间，所以 10 赋值给 p地址的第一个字节，另外3个字节是空的    *p = 10;    *(p + 1) = 11;    *(p + 2) = 12;    *(p + 3) = 13;    // 等价于    p[0] = 10;    p[1] = 11;    p[2] = 12;    p[3] = 13;        free(p);&#125;\n\n分析上面代码的内存分布：\n12345678910111213int *p = (int *)malloc(4);*p = 10;// X86 -- 32bit ，int 指针占用 4 字节，64bit 占用 8字节// 栈空间# 地址：0x111# 占用：4字节# p = 0x999// 堆空间# 地址：0x999# 占用：4字节# 值：10\n\n\n\n\n\n堆空间的申请和释放：(C++语言-新 =&gt; new / delete)\n12345678void demo()&#123;    int *p = new int; // 等价于  int *p = (int *)malloc(4);    *p = 10;        // 释放    delete p;&#125;\n\n(new[] / delete [])\n123456789void demo()&#123;    char *p = new char[4]; // 等价于  char *p = (char *)malloc(4);    *p = 10;        // 释放    delete p; // 错误：此时 只会 释放地址p的第一个字节空间，后面3个字节没有释放    delete[] p; // 正确：释放 p 申请的所有空间&#125;\n\n\n\n注意：\n\n申请堆空间成功后，会返回那一段空间的地址\n申请和释放必须是一一对应的，不然会造成内存泄露\n\n\n\n3.3.2 堆空间初始化\n简单示例：(memset == memory set)\n1234int *p1 = (int *)malloc(sizeof(int)); // *p1 未初始化int *p2 = (int *)malloc(sizeof(int));memset(p2, 0, sizeof(int)); // *p2 的每个字节初始化为0\n\n\n\n其它初始化方式：\n12345678910int *p = new int; // 未初始化int *p = new int(); // 每个字节初始化为0// mov __memset(0), eaxint *p = new int(5); // 每个字节初始化为5int *p = new int[3]; // 数组三个元素未初始化int *p = new int[3](); // 数组三个元素初始化为0int *p = new int[3]&#123;&#125;; // 数组三个元素初始化为0int *p = new int[3]&#123;5&#125;; // 数组首元素初始化为5，其它元素初始化为0\n\n3.3.2.1 memset\nmemset 函数将较大的数据结构(对象，数组等等)内存清零的比较快的方式\n\n代码示例1：\n123456Person person;person.id = 1;person.age = 2;person.height = 3;memset(&amp;person, 0, sizeof(person));\n\n\n\n代码示例2：\n12Person persons[] = &#123;&#123;1, 2, 3&#125;, &#123;1, 2, 3&#125;, &#123;1, 2, 3&#125;&#125;;memset(persons, 0, sizeof(persons));\n\n3.4 对象的内存\n对象可以存在于3个地方\n\n全局区(数据段)：全局变量\n栈空间：函数里面的局部变量\n堆空间：动态申请内存(malloc, new等)\n\n\n代码示例：\n123456789101112// 全局区Person person;int main()&#123;    // 栈空间    Person person;        // 堆空间    Person *person = new Person;    return 0;&#125;\n\n4. 构造函数\n类的默认构造函数，无论其对象在什么地方创建，都会调用构造函数\n\n但存在特殊情况，在堆中创建对象，构造函数不会调用\n\n通过malloc()，不会调用构造函数\n\n代码示例：\n1234567Person *person = (Person *)malloc(sizeof(Person));free(person);// malloc 不会调用构造函数Person *person = new Person;delete person;// 这个 new 会调用构造函数\n\n4.1 构造函数的错误概念\n错误概念：当类内没有自己定义构造函数，编译器会默认添加一个空实现的，无参的，默认构造函数\n\n正确理解：在特定情况下，编译器才会为类生成空的无参构造函数\n\n具体情况：后面的虚函数会总结\n\n代码示例：(定义了构造函数)\n123456789101112class Person&#123;    int m_age;        Person()&#123;&#125;&#125;;int main()&#123;    Person person;    return 0;&#125;\n\n反汇编分析：\n1234# Person person;lea ecx, [person]call Person::Person (0A914BFh)// 定义了构造函数时，对象创建会调用构造函数\n\n\n\n代码示例：(没定义构造函数)\n1234567891011class Person&#123;    int m_age;&#125;;int main()&#123;    Person person;    person.m_age = 10;    return 0;&#125;\n\n反汇编分析：\n1234# Person person;# person.m_age = 10;mov dword ptr[person], 0Ah// 类没有定义构造函数时，编译时也不会创建所谓的：空实现的，无参的，默认构造函数\n\n\n\n代码示例：(没定义构造函数，但类中静态初始化了成员变量)\n1234567891011class Person&#123;    int m_age = 0;&#125;;int main()&#123;    Person person;    person.m_age = 10;    return 0;&#125;\n\n反汇编分析：\n1234567# Person person;lea ecx, [person]call Person::Person (0314C4h)# person.m_age = 10;mov dword ptr[person], 0Ah// 没定义构造函数，但类中静态初始化了成员变量，此时编译器会创建：空实现的，无参的，默认构造函数\n\n4.2 构造函数的调用\n通过多种创建对象的方式，判读是否调用了类的构造函数\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334class Person&#123;public:    int m_age;    Person()    &#123;        m_age = 0;        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;    &#125;    Person(int age)    &#123;        m_age = age;        cout &lt;&lt; &quot;Person(int)&quot; &lt;&lt; endl;    &#125;&#125;;Person g_person0; // Person()Person g_person1(); // 这是 g_person1() 函数的声明或定义，不会调用构造函数Person g_person2(10); // Person(int)int main()&#123;    Person person0; // Person()    Person person1(); // 这是 g_person1() 函数的声明或定义，不会调用构造函数    Person person2(20); // Person(int)    Person *p0 = new Person; // Person()    Person *p1 = new Person(); // Person() ，这是在堆空间中创建对象    Person *p2 = new Person(30); // Person(int)    return 0;&#125;\n\n打印结果：\n12345678PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo1Person()Person(int)Person()Person(int)Person()Person()Person(int)\n\n4.3 构造函数的成员变量初始化\n默认情况下，没有自定义构造函数时，只有全局区和堆区的对象创建，会初始化为0，其余栈空间不会初始化成员变量\n\n如果自定义了构造函数，除了全局区，其它内存空间的成员变量默认都不会被初始化，需要手动初始化\n\n代码示例1：(无自定义构造函数)\n1234567891011121314151617181920212223242526class Person&#123;public:        int m_age;&#125;;// 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0Person g_person;int main()&#123;    // 栈空间的对象直接被编译器优化了，不会初始化成员变量    // Person person;    // 没有初始化    Person *p0 = new Person;    // 初始化    Person *p1 = new Person();    cout &lt;&lt; g_person.m_age &lt;&lt; endl;    cout &lt;&lt; p0-&gt;m_age &lt;&lt; endl;    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo20141840480\n\n得出结论：\n\n全局区内，内存值默认全是 0\n堆空间内，通过 () 申请的内存，默认初始化为 0\n栈空间内，默认初始化为 cccccccc\n\n\n代码示例2：(有自定义构造函数) -&gt; 空实现\n12345678910111213141516171819202122232425class Person&#123;public:        int m_age;        Person()&#123;&#125;&#125;;// 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0Person g_person;int main()&#123;    // 没有初始化    Person *p0 = new Person;    // 没有初始化，初始化工作交给自定义构造函数，然而自定义构造函数是空实现，所以没有初始化    Person *p1 = new Person();    cout &lt;&lt; g_person.m_age &lt;&lt; endl;    cout &lt;&lt; p0-&gt;m_age &lt;&lt; endl;    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo201418404814184048\n\n4.4 构造函数的集体初始化\n通过memset()方法实现\n\n代码示例：\n123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Person&#123;public:        int m_age;    Person()    &#123;        // memset() 方法，方便用于类成员变量集体初始化或清零        memset(this, 0, sizeof(Person));    &#125;&#125;;int main()&#123;    Person *p1 = new Person();    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo30\n\n5. 析构函数\n又名析构器，在对象销毁时自动调用，一般用于完成对象的清理工作\n没有返回值，不能重载\n通过malloc()分配的对象，free()时，不会调用析构函数\n类中的构造函数和析构函数，需要public:修饰后，才能被外界调用\n全局区的对象，不会调用析构函数\n\n5.1 malloc与析构函数\n代码示例1：\n1234567891011121314151617181920212223242526class Person&#123;public:        int m_age;    Person()    &#123;        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;    &#125;    ~Person()    &#123;        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    // malloc 的 对象不会调用 构造函数 和 析构函数    Person *p0 = (Person *)malloc(sizeof(Person));    free(p0);    Person *p1 = new Person();    delete p1;    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo4Person()~Person()\n\n5.2 对象内申请的堆区对象\n对象析构时，只会回收对象，如果对象的成员变量指向堆空间，需要手动释放，否则会造成内存泄漏\n\n内存泄漏：该释放的内存，没有去释放\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041class Car&#123;public:    int m_price;    Car()    &#123;        cout &lt;&lt; &quot;Car()&quot; &lt;&lt; endl;    &#125;       ~Car()    &#123;        cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;    &#125; &#125;;class Person&#123;public:        int m_age;    Car *m_car;    Person()    &#123;        // 此处的 m_car是在堆空间中声明，需要delete才能回收        // 如果是栈空间声明，person在调用析构函数时，会先回收m_car        m_car = new Car;        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;    &#125;    ~Person()    &#123;        delete m_car;        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Person person;    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo5Car()Person()~Car()~Person()\n\n6. 声明和实现\n类的定义和声明分离，分别在 .h和.cpp中实现\n\n6.1 具体演示Person.h\n123456789101112class Person&#123;private:    int m_age;public:    Person();    ~Person();    void set_Age(int age);    int get_Age();&#125;;\n\n\n\nPerson.cpp\n1234567891011121314151617Person::Person()&#123;    cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;&#125;Person::~Person()&#123;    cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;&#125;void Person::set_Age(int age)&#123;    m_age = age;&#125;int Person::get_Age()&#123;    return m_age;&#125;\n\n\n\nmain.cpp\n12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123;    Person person;    person.set_Age(10);    int age = person.get_Age();    cout &lt;&lt; age &lt;&lt; endl;    return 0;&#125;\n\n\n\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\Project\\Demo2&gt; .\\demo1.exePerson()10~Person()\n\n7. 命名空间\n作用：\n解决重复命名的问题\n命名空间不影响内存布局和结构\n\n\n\n7.1 命名空间的基本用法\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;namespace fh1&#123;    class Person    &#123;    private:        int m_age;    public:        Person();        ~Person();    &#125;;&#125;namespace fh2&#123;    class Person    &#123;    private:        int m_age;    public:        Person();        ~Person();    &#125;;&#125;int main()&#123;    fh1::Person person1;    fh2::Person person2;    return 0;&#125;\n\n7.2 命名空间的嵌套\n命名空间可以一直嵌套\n\n代码示例：\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;namespace fh1&#123;    namespace fh2    &#123;        class Person        &#123;        private:            int m_age;        public:            Person();            ~Person();        &#125;;    &#125;&#125;int main()&#123;    fh1::fh2::Person person;    return 0;&#125;\n\n7.3 存在最大默认命名空间\n代码示例：\n1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;namespace fh&#123;    void func()    &#123;        cout &lt;&lt; &quot;fh::func()&quot; &lt;&lt; endl;    &#125;&#125;void func()&#123;    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;&#125;int main()&#123;    fh::func();    // 通过默认的全局命名空间，访问 fh    ::fh::func();    func();       \t// 通过默认的全局命名空间，访问 func()    ::func();    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo2&gt; .\\demo4.exefh::func()fh::func()func()func()\n\n8. 继承\n继承可以让子类拥有父类的所有成员\n\n8.1 继承的内存布局\n子对象中的成员变量分布：最上层的父类的成员变量在子对象的首地址，依次向下排列\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int height;    &#125;;class Student : public Person&#123;public:    int age;    &#125;;class My : public Student&#123;public:    int id;    &#125;;int main()&#123;    Person person;    Student student;    My my;    my.height = 9;    my.age = 10;    my.id = 11;    cout &lt;&lt; &quot;Person: &quot; &lt;&lt; sizeof(person) &lt;&lt; endl;    cout &lt;&lt; &quot;Student: &quot; &lt;&lt; sizeof(student) &lt;&lt; endl;    cout &lt;&lt; &quot;My: &quot; &lt;&lt; sizeof(my) &lt;&lt; endl;        cout &lt;&lt; &amp;my.height &lt;&lt; endl;    cout &lt;&lt; &amp;my.age &lt;&lt; endl;    cout &lt;&lt; &amp;my.id &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n1234567PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo1.exePerson: 4Student: 8My: 120x7bfe080x7bfe0c0x7bfe10\n\n总结：父类的成员变量在前面，子类的在后面\n\n补充：父类的成员变量，子类中没有使用，子类的对象大小依然不变，编译器不会去优化，所以要合理设计类\n\n\n8.2 成员访问权限\n成员访问权限、继承方式有3种：\n\npublic：公共的，任何地方都可以访问（struct默认）\nprivate：私有的，只有当前类内部可以访问（class默认）\nprotected：子类内部和当前类可以访问\n\n\n子类在继承父类时，使用了权限修饰：子类内部访问父类成员的权限，是一下两项中权限最小的\n\n成员本身的访问权限\n上一级父类的继承方式\n\n\n开发中最多的继承方式是public继承，保留父类原来的成员访问权限\n\n访问权限，不影响对象的内存布局\n\n\n9. 初始化列表\n特点：\n\n一种便捷的初始化成员变量的方式\n只用于构造函数\n初始化顺序，只跟成员变量的声明顺序有关\n\n\n补充：\n\n如果构造函数的声明和实现分离，初始化列表只能写在实现中\n\n\n语法：\n12345678910111213141516171819class Person&#123;private:        int m_age;    int m_height;public:    // 普通写法    Person(int age, int height)    &#123;        m_age = age;        m_height = height;    &#125;    // 初始化列表    Person(int age, int height) : m_age(age), m_height(height)    &#123;    &#125;&#125;;\n\n两种写法完全等价：(反汇编查看)\n123456789101112131415161718192021// 普通构造函数// m_age = age;mov eax, dword ptr[this]mov ecx, dword ptr[age]mov dword ptr[eax], ecx// m_height = height;mov eax, dword ptr[this]mov ecx, dword ptr[height]mov dword ptr [eax+4], ecx// 初始化列表// m_age(age)mov eax, dword ptr[this]mov ecx, dword ptr[age]mov dword ptr[eax], ecx// m_height(height)mov eax, dword ptr[this]mov ecx, dword ptr[height]mov dword ptr [eax+4], ecx\n\n10. 构造函数互调10.1 互调语法\n代码示例：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Person&#123;private:        int m_age;    int m_height;public:    // 错误的写法    // Person() &#123;Person(10, 20);&#125;        // 正确的写法    Person() : Person(0, 0)&#123;&#125;    Person(int age, int height)    &#123;        m_age = age;        m_height = height;        cout &lt;&lt; m_age &lt;&lt; &quot; &quot; &lt;&lt; m_height &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Person person1;    Person person2(10, 20);    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo3.exe0 010 20\n\n10.2 语法分析\n通过反汇编分析两种写法的正确性\n12345678910111213141516171819202122232425262728// 错误的写法// 原因：在函数体中写的 Person(0, 0); 是创建临时Person的对象，0 赋值给了临时的Person对象// Person() &#123;Person(0, 0);&#125;lea ecx, [person1]call Person::Person(0E61118h)mov dword ptr [this], ecxpush 14hpush 0Ahlea ecx, [person] // person是临时对象call Person::Person(0E61311h)mov dword ptr[this], ecx// 正确的写法// Person() : Person(0, 0)&#123;&#125;lea ecx, [person2]call Person::Person(01221118h)mov dword ptr [this], ecxpush 14hpush 0Ahmov dword ptr[this], ecxcall Person::Person(01221311h)mov dword ptr[this], ecx\n\n10.3 父类的构造函数\n子类的构造函数默认会调用父类的无参构造函数\n\n子类的构造函数主动调用了父类的有参构造函数，则父类的无参构造函数不会被调用\n\n如果父类缺少无参构造函数，子类构造函数就必须显式调用父类的有参构造函数\n\n代码示例1：(默认会调用父类的无参构造函数)\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Person&#123;public:        Person()    &#123;        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;    &#125;&#125;;class Student : public Person&#123;public:        Student()    &#123;        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Student student;    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo4.exePerson::Person()Student::Student()\n\n\n\n代码示例2：(主动调用了父类的有参构造函数)\n12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Person&#123;public:        Person()    &#123;        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;    &#125;    Person(int age)    &#123;        cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;    &#125;&#125;;class Student : public Person&#123;public:        Student() : Person(10)    &#123;        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Student student;    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo4.exePerson::Person(int)Student::Student()\n\n10.4 构造和析构的顺序\n代码示例：\n12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Person&#123;public:        Person()    &#123;        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;    &#125;    ~Person()    &#123;        cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;    &#125;&#125;;class Student : public Person&#123;public:        Student()    &#123;        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;    &#125;    ~Student()    &#123;        cout &lt;&lt; &quot;Student::~Student()&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Student student;    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo5.exePerson::Person()Student::Student()Student::~Student()Person::~Person()\n\n11. 多态\n默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态\n\n多态是面向对象非常重要的特性\n\n同一个操作，用于不同的对象，可以有不同的解释，产生不同的结果\n在运行时，可以识别出真正的对象类型，调用对应子类中的函数\n\n\n多态的要素：\n\n子类重写父类的成员函数(override)\n父类指针指向子类\n利用父类指针调用重写的成员函数\n\n\n\n11.1 父类和子类指针\n父类指针指向子类对象是安全的，子类的继承方式是public\n\n子类指针指向父类对象是不安全的\n\n代码示例1：父类指针指向子类对象\n123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;struct Person&#123;    int m_age;&#125;;struct Student : Person&#123;    int m_score;&#125;;int main()&#123;    Person *person = new Student;    person-&gt;m_age = 10;    cout &lt;&lt; &quot;person-&gt;m_age: &quot; &lt;&lt; person-&gt;m_age &lt;&lt; &quot;\\n&quot;;    return 0;&#125;\n\n打印结果\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exeperson-&gt;m_age: 10\n\n总结：\n\n父类指针指向子类对象，这样用父类指针使用成员变量时，会很安全，不会影响到子类独有的成员变量\n父类的成员变量存在得到内存空间，肯定在子类对象的内存范围内，不会超出子类对象的内存范围，所以安全\n\n\n代码示例2：子类指针指向父类对象\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;struct Person&#123;    int m_age;&#125;;struct Student : Person&#123;    int m_score;&#125;;int main()&#123;        Student *student = (Student *)new Person;    student-&gt;m_age = 10;    student-&gt;m_score = 100;        cout &lt;&lt; &quot;m_age: &quot; &lt;&lt; student-&gt;m_age &lt;&lt; &quot;\\n&quot;          &lt;&lt; &quot;m_score: &quot; &lt;&lt; student-&gt;m_score &lt;&lt; &quot;\\n&quot;;    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exem_age: 10m_score: 100\n\n总结：\n\n子类指针指向父类的对象，子类指针指向的成员变量，可能会超出父类对象内存范围内的成员变量，不安全\n因为可能会覆盖掉，别的子类对象内存范围内的成员变量的值\n\n\n代码示例3：通过反汇编查看强制类型转换\n12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;    void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal&#123;public:    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;&#125;;class Cat : public Animal&#123;public:    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;\tCat *animal = (Cat *)new Dog;    animal-&gt;speak();    animal-&gt;run();    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exeCat::speak()Cat::run()\n\n查看反汇编结果：\n123456789101112// Cat *animal = (Cat *)new Dog;mov dword ptr[ebp-0DCh], 0mov ecx, dword ptr[ebp-0DCh]mov dword ptr[animal], ecx// animal-&gt;speak();mov ecx, dword ptr[animal]call Cat::speak(0F714F6h)// animal-&gt;run();mov ecx, dword ptr[animal]call Cat::run(0F714F1h)\n\n总结：\n\n由上面的示例3可知：指针的类型决定了，指针所能访问的内存范围\n此时还未实现多态\n\n\n\n11.2 虚函数实现多态\n通过虚函数(virtual function)实现多态\n\n虚函数：被virtual修饰的成员函数\n\n在父类中声明为虚函数，子类中重写的成员函数会自动转成虚函数\n\n代码示例：\n\n\n  123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    virtual void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;    virtual void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal&#123;public:    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;&#125;;class Cat : public Animal&#123;public:    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;&#125;;void playAnimal(Animal *animal)&#123;    animal-&gt;speak();    animal-&gt;run();&#125;int main()&#123;    playAnimal(new Dog);    playAnimal(new Cat);    return 0;&#125;\n\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo2.exeDog::speak()Dog::run()Cat::speak()Cat::run()\n\n11.3 虚表\n虚函数的实现原理是虚表，这个虚表里存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表\n\n11.3.1 虚表的大小\n前提：\n\n类中的普通函数，在对象中不占用空间，因为函数存在代码区中，而对象在栈区中，只有成员变量占用空间\n父类的虚函数，在子类重写后，这些函数会存入一个虚函数表中，虚函数表占用子类对象的内存空间\nx86环境，指针是4字节\nx64环境，指针是8字节\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    int m_age;    virtual void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;    virtual void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal&#123;public:    int m_height;    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;&#125;;class Cat&#123; public:    int m_health;    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    cout &lt;&lt; &quot;Cat::sizeof()= &quot; &lt;&lt; sizeof(Cat) &lt;&lt; endl;    cout &lt;&lt; &quot;Dog::sizeof()= &quot; &lt;&lt; sizeof(Dog) &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; ./demo3.exeCat::sizeof()= 4Dog::sizeof()= 16\n\n结果分析：\n\nDog对象，继承了父类Animal，对象类有两个int类型成员变量：8字节\n父类还有虚函数的存在，所以需要在Dog对象内创建虚函数表：x86是4字节，x64是8字节\nDog对象重写的父类的方法，存在代码区中，不和对象一起在栈区中，所以不占用对象内存\n\n\n\n11.3.2 反汇编分析虚表\nx86环境中，内存的布局\n\n代码示例：\n123456int main()&#123;    Animal *animal = new Dog();    animal-&gt;m_age = 20;    return 0;&#125;\n\n\n\n\n\n内存地址\n内存数据\n内存地址\n内存数据\n\n\n\ndog\n0x00E69B60\n0x00B89B64&#x3D;&#x3D;虚表内存地址\n0x00B89B64\n0x00B814E7&#x3D;&#x3D;Dog::speak()的调用地址\n\n\n\n0x00E69B61\n\n0x00B89B65\n\n\n\n\n0x00E69B62\n\n0x00B89B66\n\n\n\n\n0x00E69B63\n\n0x00B89B67\n\n\n\n&amp;m_age\n0x00E69B64\n20\n0x00B89B68\n0x00B814CE&#x3D;&#x3D;Dog::run()的调用地址\n\n\n\n0x00E69B65\n\n0x00B89B69\n\n\n\n\n0x00E69B66\n\n0x00B89B6A\n\n\n\n\n0x00E69B67\n\n0x00B89B6B\n\n\n\n&amp;m_height\n0x00E69B68\n0\n\n\n\n\n\n0x00E69B69\n\n\n\n\n\n\n0x00E69B6A\n\n\n\n\n\n\n0x00E69B6B\n\n\n\n\n\n\n总结：\n\n可以看到，父类中有虚函数，子类对象从首地址开始，存放虚函数表\n虚函数表内存放着内存地址，而这个内存地址指向的是代码区的地址，也正是子类对象内重写父类方法的地址\n所以实现多态后，父类指针指向子类对象时，可以通过虚函数表，使得指针调用子类的方法，以达到多态的目的\n\n\n反汇编查看：\n\n代码示例：\n1234567int main()&#123;    Animal *animal = new Dog();    animal-&gt;m_age = 20;    animal-&gt;speak();    return 0;&#125;\n\n12345678910111213// animal-&gt;m_age = 20;mov eax, dword ptr[animal] // animal == ebp-8 是指针变量，eax 是Dog对象的地址，里面存放着虚表的地址值mov dword ptr[eax+4], 14h// animal-&gt;speak();mov eax, dword ptr[animal]mov edx, dword ptr[eax] // 从Dog对象的地址开始往后4个字节内的数据存入到 寄存器edx 中，edx 得到 虚表的地址mov esi, espmov ecx, dword ptr[animal]mov eax, dword ptr[edx] // 从 edx 中取4个字节，eax 得到虚表中存放 Dog对象方法的地址，(但不是方法的真正地址，需要jump到真正地址)call eax // 调用 Dog对象的方法\n\n11.3.3 虚表的设计思想\n前提：项目中实现了多态，其父类指针多次指向不同的子类对象，且父类的方法用virtual修饰\n原理：\n编译器在编译时，并不知道，项目中父类指针多次指向不同的子类对象\n即便父类指针指向的对象是自己本身的对象，也一样生成用于存放虚表地址的内存空间\n编译文件是静态的，而程序在内存中执行是动态过程\n\n\n目的：\n多态中，每个子对象都要有一个虚函数表\n实现程序在内存中执行的动态性\n\n\n虚表的相关优化：\n当父类指针多次指向多个子类对象，且都是同一个类的对象\n此时，这些对象依然有各自独立存放虚表地址的内存空间\n这些子类对象的前4字节空间中存放的虚表地址值(对象的方法所在代码区的地址)是相等的\n\n\n总结：相同类的对象，不管在什么区中，共用一份虚表\n\n11.3.4 多态实现的需求\n实现需求：大致两种\n\n完全重写父类的成员函数\n在父类的成员函数基础上，利用多态附加子类对象的成员函数\n\n\n代码示例1：第一种(完全重写)\n12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    // 子类会完全重写的虚函数是 可以 为空实现    virtual void speak()&#123;cout &lt;&lt; &quot;Animal&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal&#123;public:    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    Animal *animal = new Dog;    animal-&gt;speak();    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; ./demo4.exeDog::speak()\n\n\n\n代码示例2：第二种(父类的方法实现基础上附加子类的实现)\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    // 父类的方法实现基础上附加子类的实现，此处的父类虚函数实现 可以 不为空实现    virtual void speak()&#123;cout &lt;&lt; &quot;Animal&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal&#123;public:    void speak()    &#123;        Animal::speak();        cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Animal *animal = new Dog;    animal-&gt;speak();    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; ./demo4.exeAnimalDog::speak()\n\n11.4 虚析构函数\n父类指针指向子类对象，含有虚函数的父类，应该将析构函数声明为虚函数(虚析构函数)\n\ndelete父类指针，才会调用子类的析构函数，保证析构的完整型\n\n代码示例：\n1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    Animal()&#123;cout &lt;&lt; &quot;Animal::Animal()&quot; &lt;&lt; endl;&#125;    virtual ~Animal()&#123;cout &lt;&lt; &quot;Animal::~Animal()&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal&#123;public:    Dog()&#123;cout &lt;&lt; &quot;Dog::Dog()&quot; &lt;&lt; endl;&#125;    ~Dog()&#123;cout &lt;&lt; &quot;Dog::~Dog()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    Animal *animal = new Dog;    delete animal;    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; ./demo5.exeAnimal::Animal()Dog::Dog()Dog::~Dog()Animal::~Animal()\n\n补充：\n\n先构造父类，再构造子类\n先析构子类，再析构父类\n父类构造可以不用virtual修饰\n\n\n\n11.5 纯虚函数\n定义：没有函数体其初始化为0的虚函数，用来定义接口规范\n\n抽象类（Abstract Class）\n\n含有纯虚函数的类，不可以实例化（不可以创建对象）\n抽象类也可以是包含非纯虚函数，成员变量\n如果父类是抽象类，子类没有完全实现纯虚函数，那么这个子类依然是抽象类\n\n\n代码示例：\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    int m_age;    virtual void speak() = 0;    virtual void run() = 0;&#125;;class Dog : public Animal&#123;public:    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    Animal *animal = new Dog();    cout &lt;&lt; animal-&gt;m_age &lt;&lt; endl;    animal-&gt;run();    animal-&gt;speak();    return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; ./demo1.exe0Dog::run()Dog::speak()\n\n11.6 多继承11.6.1 多继承概念\nC++允许一个类，继承多个类（不建议使用）\n\n如果子类继承的多个父类都有虚函数，那么子类对象会产生对应的多张虚函数表\n\n代码示例：\n12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Student&#123;public:    int m_score;&#125;;class Worker&#123;public:    int m_salary;&#125;;class Undergraduate : public Student, public Worker&#123;public:    int m_grade;&#125;;int main()&#123;    Undergraduate under;    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(under) &lt;&lt; endl;    under.m_score = 100;    under.m_salary = 2000;    under.m_grade = 4;    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; ./demo2.exesizeof: 12\n\n\n\n内存布局：\n\n\n\n\n\n内存地址\n内存数据\n\n\n\n&amp;under\n&amp;m_score\n0x00E69B60\n100\n\n\n\n\n0x00E69B61\n\n\n\n\n\n0x00E69B62\n\n\n\n\n\n0x00E69B63\n\n\n\n\n&amp;m_salary\n0x00E69B64\n2000\n\n\n\n\n0x00E69B65\n\n\n\n\n\n0x00E69B66\n\n\n\n\n\n0x00E69B67\n\n\n\n\n&amp;m_grade\n0x00E69B68\n4\n\n\n\n\n0x00E69B69\n\n\n\n\n\n0x00E69B6A\n\n\n\n\n\n0x00E69B6B\n\n\n\n\n\n11.6.2 同名成员函数&#x2F;变量\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class Animal_A&#123;public:    int m_age;    void run()&#123;cout &lt;&lt; &quot;Animal_A::run()&quot; &lt;&lt; endl;&#125;&#125;;class Animal_B&#123;public:    int m_age;    void run()&#123;cout &lt;&lt; &quot;Animal_B::run()&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal_A, public Animal_B&#123;public:    int m_age;    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    Dog dog;    dog.m_age = 10;    dog.Animal_A::m_age = 11;    dog.Animal_B::m_age = 12;    dog.Dog::m_age = 13;        dog.run();    dog.Animal_A::run();    dog.Animal_B::run();    dog.Dog::run();    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; ./demo3.exeDog::run()Animal_A::run()Animal_B::run()Dog::run()\n\n11.6.3 菱形继承11.6.3.1 菱形继承结构\n基本结构：\n\n定义一个类：A\n定义类B1，继承A；定义类B2，继承A\n定义类C，继承B1，B2\n\n\n菱形继承的问题：\n\n最底层的对象，从基类继承的成员变量冗余，重复\n最底层的对象，无法访问基类的成员变量，存在二义性\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class A&#123;    int a;&#125;;class B1 : A // 继承A的成员变量，2*int = 8字节&#123;    int b1;&#125;;class B2 : A // 同理，2*int = 8字节&#123;    int b2;&#125;;class C : B1, B2 // 继承B1，B2，加上自身成员变量，2+2+1 int = 20字节&#123;    int c;&#125;;int main()&#123;    C c;    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; ./demo4.exesizeof: 20\n\n11.6.3.2 虚继承\n解决菱形继承带来的底层对象的成员变量冗余，重复和二义性\n\n基本结构：\n\n定义一个类：A\n定义类B1，继承 virtual A；定义类B2，继承 virtual A\n定义类C，继承B1，B2\n\n\n此时，A为 虚基类\n\n作用：B1，B2会共同继承同一份 A 的成员，而不是各自继承一份，解决了底层对象的成员冗余\n\n代码示例：\n123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;struct A&#123;    int a;&#125;;struct B1 : virtual A // 虚表8字节，成员变量4字节，12&#123;    int b1;&#125;;struct B2 : virtual A // 虚表8字节，成员变量4字节，12&#123;    int b2;&#125;;struct C : B1, B2 // 2*12 = 24，虚表8字节，成员变量4字节，虚基类成员变量4字节 = 24 + 8 + 4 + 4 = 40&#123;    int c;&#125;;int main()&#123;    C c;    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; ./demo4.exesizeof: 40\n\n虚继承的类结构：\n\n首地址存放虚指针和偏移量\n存放自己的成员变量\n存放虚基类的成员变量\n\n\n\n12. 静态成员12.1 静态成员基本定义\n定义：static修饰的成员变量&#x2F;函数\n\n可以通过对象.静态成员，对象指针-&gt;静态成员，类名::静态成员变量，进行访问\n\n\n静态成员变量：\n\n存储在数据段（全局区，类似全局变量），整个程序运行过程中只有一份内存\n对比全局变量，它可以设定访问权限（public, protected, private），达到局部共享的目的\n必须初始化，必须在类外面初始化，初始化不能带static，如果类的声明和实现分离（在实现中初始化）\n\n\n静态成员函数：\n\n内部不能使用this指针（this指针只能用于非静态成员函数内部）\n不能是虚函数（虚函数只能是非静态成员函数）\n内部不能访问非静态成员变量\\函数，只能访问静态成员变量\\函数\n构造函数和析构函数不可以是静态的\n当声明和实现分离，实现不能带static\n\n\n总结：\n\n涉及到，通过对象来管理，调用成员的变量和函数，都不可以用static修饰\nstatic修饰的成员变量&#x2F;函数只能通过类，利用作用域使用，或者在静态的函数内使用静态成员变量\n\n\n代码示例：\n12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Car&#123;public:        static int m_price;    static void byCar();&#125;;int Car::m_price = 1000;void Car::byCar()&#123;    cout &lt;&lt; &quot;Car is running&quot; &lt;&lt; endl;&#125;int main()&#123;    cout &lt;&lt; &quot;Car price: &quot; &lt;&lt; Car::m_price &lt;&lt; endl;    Car::byCar();    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo1.exeCar price: 1000Car is running\n\n12.2 反汇编分析静态成员\n代码示例：\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Car&#123;public:    int m_age;    static int m_price;&#125;;int Car::m_price = 0;int g_age;int main()&#123;    Car car1;    Car car2;        g_age = 0;    car1.m_age = 1;    car1.m_price = 2;    car2.m_price = 3;            return 0;&#125;\n\n反汇编分析，静态成员变量\n1234567891011// g_age = 0;mov dword ptr ds:[00A9A318h], 0\t=&gt; ds 数据段// car1.m_age = 1;mov dword ptr[car], 1\t=&gt; mov dword ptr[ebp-8], 1// car1.m_price = 2;mov dword ptr[Car::m_price 00A9A314h)], 2\t=&gt; mov dword ptr ds:[00A9A314h], 2// car2.m_price = 3;mov dword ptr[Car::m_price (00A9A314h)], 3\t=&gt; mov dword ptr ds:[00A9A314h], 3\n\n总结：\n\n全局变量和类中的静态变量，都存放在数据区内，且程序运行时，仅有一份\n静态变量和全局变量的区别：\n静态变量可以在类中定义，同时通过public, protected, private修饰其访问权限\n\n\n\n\n\n12.3 静态成员应用12.3.1 统计对象个数\n应用：无论在那个区域增加或删除对象，都能有一个唯一值去统计当前的对象个数\n\n代码示例：\n123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Car&#123;private:    static int ms_count;public:    Car()&#123;++ms_count;&#125;    ~Car()&#123;--ms_count;&#125;    static int getCount()&#123;return ms_count;&#125;&#125;;int Car::ms_count = 0;Car g_car; // 1int main()&#123;    Car car; // 2    Car *p_car = new Car; // 3    cout &lt;&lt; Car::getCount() &lt;&lt; endl;        return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo2.exe3\n\n12.3.2 单例模式\n单例模式的构建：\n\n构造&#x2F;析构函数，私有化\n定义一个私有化的 static成员变量指向唯一得到单例对象\n提供一个公共的访问单例对象的接口\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;class Rocket&#123;private:    // 构造/析构函数，私有化    Rocket()&#123;&#125;    ~Rocket()&#123;&#125;    // 定义一个私有化的 static成员变量指向唯一得到单例对象    static Rocket* ms_rocket;public:    // 提供一个公共的访问单例对象的接口    static Rocket* sharedRocket()    &#123;        // 需要考虑多线程安全        if (ms_rocket == NULL)        &#123;            ms_rocket = new Rocket();        &#125;        return ms_rocket;    &#125;    // 提供一个公共的访问单例对象的接口    static void deleteRocket()    &#123;        // 需要考虑多线程安全        if (ms_rocket != NULL)        &#123;            ms_rocket = NULL;            delete ms_rocket;        &#125;    &#125;    // 测试用函数    void startRocket()&#123;cout &lt;&lt; &quot;Start Rocket&quot; &lt;&lt; endl;&#125;    &#125;;Rocket* Rocket::ms_rocket = NULL;int main()&#123;    Rocket *p_rocket_1 = Rocket::sharedRocket();    Rocket *p_rocket_2 = Rocket::sharedRocket();    Rocket *p_rocket_3 = Rocket::sharedRocket();    cout &lt;&lt; p_rocket_1 &lt;&lt; &quot;\\n&quot; &lt;&lt; p_rocket_2 &lt;&lt; &quot;\\n&quot; &lt;&lt; p_rocket_3 &lt;&lt; endl;    p_rocket_1-&gt;startRocket();        return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo3.exe0x8e6b800x8e6b800x8e6b80Start Rocket\n\n总结：由打印结果可看出，指向堆区的对象指针的地址始终不变，对象的单例模型已经实现\n\n补充：delete\n\nnew是堆空间，开辟一块区域，用来存放数据\ndelete是删除堆空间开辟的区域，使得这片区域可以被别的new使用，但里面的数据没有变化，\n需要在delete之前或之后，使其初始化为null\n\n\n\n13. const成员\n被const修饰的成员变量、非静态成员函数\n\nconst成员变量：\n\n必须在类内部初始化，可以在声明时，直接赋值\n非static的const成员变量还可以在初始化列表中初始化\n\n\nconst成员函数：\n\nconst关键字写在参数列表后面，函数的声明和实现都要写const\n内部不能修改非static成员变量\n内部只能调用const修饰的成员函数，static成员函数\n非const成员函数可以调用const成员函数\n\n\nconst成员函数和非const成员函数构成重载\n非const对象（指针）优先调用非const成员函数\n\n\nconst对象（指针）只能调用const成员函数，static成员函数\n\n\n\n14. 引用类型成员\n引用类型成员变量必须初始化（不考虑static）\n在声明的时候直接初始化\n通过初始化列表初始化\n\n\n\n15. 拷贝构造函数\n拷贝构造函数是构造函数的一种\n当利用已经存在的对象创建一个新对象时（类似于拷贝），就会调用对象的拷贝构造函数进行初始化\n拷贝构造函数的格式是固定的，接收一个const修饰的引用类型参数\n\n15.1 默认拷贝构造函数\n代码示例：(默认拷贝构造函数)\n12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Car&#123;private:    int m_price;    int m_length;public:    Car(int price = 0, int lenght = 0) : m_price(price), m_length(lenght)&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;        void display()&#123;cout &lt;&lt; &quot;price:&quot; &lt;&lt; m_price &lt;&lt; &quot; length: &quot; &lt;&lt; m_length &lt;&lt; endl;&#125;&#125;;int main()&#123;    Car car1(1, 1);    car1.display();    Car car2(car1);    car2.display();        return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo1.exeCar::Car()price:1 length: 1price:1 length: 1\n\n反汇编查看原理：（默认构造函数）\n1234567891011121314151617181920212223// x86环境// Car car2(car1);mov eax, dword ptr[ebp-10h] =&gt; 10h = 16mov dword ptr[ebp-20h], eax =&gt; 20h = 32// =&gt; car2.m_prcie = car1.m_price;mov ecx, dword ptr[ebp-0Ch] =&gt; 0Ch = 12mov dword ptr[ebo-1Ch], ecx =&gt; 1Ch = 28// =&gt; car2.m_length = car1.m_length;// car2.display();lea ecx, [ebp-20h]call 0024141A// x64环境// Car car2(car1);mov rax, qword ptr[rbp+8] =&gt; 8h = 8mov qword ptr[rbp+28h], rax =&gt; 28h = 40// car2.display();lea rcx, [rbp+28h]call 00007FF685AF12FD\n\n15.2 自定义拷贝构造函数\n代码示例：（自定义拷贝构造函数）\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Car&#123;private:    int m_price;    int m_length;public:    Car(int price = 0, int lenght = 0) : m_price(price), m_length(lenght)&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;        Car(const Car &amp;car) : m_price(car.m_price), m_length(car.m_length)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;    void display()&#123;cout &lt;&lt; &quot;price:&quot; &lt;&lt; m_price &lt;&lt; &quot; length: &quot; &lt;&lt; m_length &lt;&lt; endl;&#125;&#125;;int main()&#123;    Car car1(1, 1);    car1.display();    Car car2(car1);    car2.display();        return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo1.exeCar::Car()price:1 length: 1Car::Car(const)price:1 length: 1\n\n15.3 调用父类拷贝构造函数\n代码示例：\n123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int m_age;    Person(int age) : m_age(age)&#123;&#125;;    Person(const Person &amp;person) : m_age(person.m_age)&#123;&#125;&#125;;class Student : public Person&#123;public:    int m_score;        Student(int age, int score) : Person(age), m_score(score)&#123;&#125;           Student(const Student &amp;student) : Person(student), m_score(student.m_score)&#123;&#125;&#125;;int main()&#123;    Student stu1(1, 100);    Student stu2(stu1);    cout &lt;&lt; stu2.m_age &lt;&lt; &quot; &quot; &lt;&lt; stu2.m_score &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo2.exe1 100\n\n补充：如果是完全拷贝对象内的数据，可以直接使用默认拷贝构造函数\n\n\n15.4 浅复制\n代码示例：\n12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class Student&#123;public:    int m_score;        Student(int score = 0) : m_score(score)&#123;cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;&#125;           Student(const Student &amp;student) : m_score(student.m_score)&#123;cout &lt;&lt; &quot;Student::Student(const Student &amp;student)&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    // 默认构造    Student s1(10);        // 拷贝构造    Student s2(s1);    // 拷贝构造 =&gt; 创建对象的同时，将 s2 的数据给 s3，符合拷贝构造    Student s3 = s2;        // 浅复制 =&gt; 创建了对象，但没有利用已经存在的对象进赋值，所以是 默认构造    Student s4;    s4 = s3; // 此时的两个对象都是 已经存在的对象，不是拷贝g    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo3.exeStudent::Student()Student::Student(const Student &amp;student)Student::Student(const Student &amp;student)Student::Student()\n\n15.5 浅&#x2F;深拷贝15.5.1 解决浅拷贝问题\n编译器默认的都是浅拷贝\n\n浅拷贝的缺点：\n\n如果出现堆空间指向栈空间，那么浅拷贝后，堆空间内存储着栈空间的地址\n栈空间的生命周期是不可控制的，可能会使得堆空间指向栈空间的指针变成野指针\n\n\n代码示例：解决浅拷贝的问题\n123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Car&#123;private:    int m_price;    char *m_name;public:    Car(int price = 0, const char *name = nullptr) : m_price(price)    &#123;        if (name == nullptr)&#123;return;&#125;        m_name = new char[strlen(name) + 1]&#123;&#125;;        strcpy(m_name, name);    &#125;        ~Car()    &#123;        if (m_name == nullptr)&#123;return;&#125;        m_name = nullptr;        delete[] m_name;    &#125;    void printInfo()&#123;cout &lt;&lt; m_price &lt;&lt; &quot; &quot; &lt;&lt; m_name &lt;&lt; endl;&#125;&#125;;int main()&#123;    char name[] = &#123;&#x27;b&#x27;, &#x27;w&#x27;, &#x27;m&#x27;, &#x27;\\0&#x27;&#125;;    Car *car = new Car(100, name);    car-&gt;printInfo();    Car *car2 = new Car(200, &quot;bwm&quot;);    car2-&gt;printInfo();        return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo4.exe100 bwm200 bwm\n\n15.5.2 深拷贝\n使用深拷贝的原因：\n\n当类中有数据会在堆空间中开辟，且在类的对象析构时释放时\n此时这个类已有一个对象，而新的对象利用已有的对象进行默认的拷贝构造（浅拷贝）\n此时，两个对象的某一个指向堆空间的成员变量，所指的地址相同\n当其中一个对象释放，另一个对象中的某个指向堆空间的成员变量也会被释放，使得另一个对象中的成员变量无效化\n如果两个对象都释放，则会出现同一个堆空间，两次释放\n\n\n深拷贝定义：\n\n将指针指向的内容拷贝到新的存储空间\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Car&#123;private:    int m_price;    char *m_name;    void copy(const char *name = nullptr)    &#123;        if (name == nullptr)&#123;return;&#125;        m_name = new char[strlen(name) + 1]&#123;&#125;;        strcpy(m_name, name);    &#125;public:    Car(int price = 0, const char *name = nullptr) : m_price(price)&#123;copy(name);&#125;        Car(const Car &amp;car) : m_price(car.m_price)&#123;copy(car.m_name);&#125;    ~Car()    &#123;        if (m_name == nullptr)&#123;return;&#125;        m_name = nullptr;        delete[] m_name;    &#125;    void printInfo()&#123;cout &lt;&lt; m_price &lt;&lt; &quot; &quot; &lt;&lt; m_name &lt;&lt; endl;&#125;&#125;;int main()&#123;    Car car1(100, &quot;bwm&quot;);    Car car2 = car1;    car2.printInfo();        return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo5.exe100 bwm\n\n16. 对象类型参数和返回值\n代码示例1：\n12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class Car&#123;public:    Car()&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;    Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;    &#125;;void test(Car car)&#123;&#125;int main()&#123;    Car car1;    test(car1);    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo6.exeCar::Car() // Car car1;Car::Car(const) // Car car = car1;\n\n\n\n\n\n\n\n代码示例2：\n123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Car&#123;public:    Car()&#123;cout &lt;&lt; &quot;Car::Car() &quot;&lt;&lt; this &lt;&lt; endl;&#125;        Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const) &quot; &lt;&lt; this &lt;&lt; endl;&#125;&#125;;void test1(Car car)&#123;&#125;Car test2()&#123;    Car car;    return car;&#125;int main()&#123;    Car car;    test1(car);    cout &lt;&lt; endl;    Car car1;    car1 = test2();    return 0;&#125;\n\n打印结果：\n123456PS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo6.exeCar::Car() 0x7bfe1dCar::Car(const) 0x7bfe1eCar::Car() 0x7bfe1cCar::Car() 0x7bfe1f\n\n17. 匿名对象\n又名：临时对象\n\n没有名称，不被指针指向，一次性使用，立即销毁\n\n代码示例：\n12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class Car&#123;public:    Car()&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;    Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;        ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()&quot; &lt;&lt; endl;&#125;&#125;;void test(Car car)&#123;&#125;int main()&#123;    test(Car());    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo1.exeCar::Car()Car::~Car()\n\n18. 隐式构造\n又名：转换构造\n\n在某些情况下，会隐式调用单参数的构造函数\n\n通过关键字explicit禁用隐式构造\n\n代码示例1：\n12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;class Person&#123;private:    int m_age;    public:    Person()&#123;cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;&#125;    Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Car::Car(int)&quot; &lt;&lt; endl;&#125;    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;&#125;;void test(Person person)&#123;&#125;Person test2()&#123;return 40;&#125;int main()&#123;    Person p1 = 20;    test2();    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; g++ demo2.cpp -o demo2; .\\demo2Car::Car(int)Car::Car(int)Person::~Person()Person::~Person()\n\n\n\n\n\n代码示例2：\n12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;class Person&#123;private:    int m_age;    public:    Person()&#123;cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;&#125;    explicit Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Car::Car(int)&quot; &lt;&lt; endl;&#125;    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;&#125;;void test(Person person)&#123;&#125;int main()&#123;    // Person p1 = 20; // 此时这样的写法被 禁用    Person p1(20);    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; g++ demo3.cpp -o demo3; .\\demo3Car::Car(int)Person::~Person()\n\n19. 编译器自动生成的构造函数\nC++编译器会在特定的情况下，会给类自动生成无参的构造函数\n\n成员变量在声明时，初始化\n有定义虚函数\n虚继承了其它类\n包含了对象类型的成员，且这个成员有构造函数（可以是编译器自动生成的，或自定义的）\n\n\n总结：\n\n对象创建后，需要进行一些额外的操作（内存操作，函数调用，成员变量初始化，虚函数，虚继承，调用父类构造等等）\n编译器都会自动生成无参的构造函数\n\n\n代码示例1：成员变量在声明时，初始化\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Car&#123;public:    int m_age = 5;    &#125;;// 此段代码 完全等价 上面的写法/*class Car&#123;public:    int m_age = 5;        Car()&#123;m_age = 5;&#125;&#125;;*/int main()&#123;    Car car;    return 0;&#125;\n\n反汇编查看：\n123456// Car car;lea ecx, [car]call Car::Car(0A1384h)mov dword ptr[eax], 5mov eax, dword ptr[this]\n\n\n\n\n\n代码示例2：有定义虚函数\n123456789101112131415#include &lt;iostream&gt;using namespace std;class Car&#123;public:    int m_age;      virtual void run()&#123;&#125;&#125;;int main()&#123;    Car car;    return 0;&#125;\n\n反汇编查看：\n1234567lea ecx, [car]call Car::Car(0E5111Dh)mov dword ptr[this], ecxmov eax, dword ptr[this]mov dword ptr[eax], offset Car::`vftable`(0E57B34h) // vftable == virtual function table 虚函数表mov eax, dword ptr[this]\n\n\n\n\n\n代码示例3：虚继承了其它类\n123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int m_age;      void run()&#123;&#125;&#125;;class Student : virtual public Person&#123;public:    int m_score;&#125;;int main()&#123;    Student student;    return 0;&#125;\n\n反汇编查看：\n123456lea ecx, [student]call Student::Student(012213A7h)mov eax, dword ptr[this]mov dword ptr[eax], offset Student::`vftable`(01227B30h)mov eax, dword ptr[this]\n\n20. 友元\n友元包括：\n\n友元函数\n如果将函数A（非成员函数）声明为类B的友元函数，那么函数A内部可以直接访问类B对象的所有成员\n\n\n友元类\n类A内声明了类B的友元，类B可以访问类A的所有成员\n\n\n\n\n代码示例1：友元函数\n1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class Point&#123;private:    int m_x;    int m_y;    // 声明 友元函数    friend Point add_P(Point &amp;, Point &amp;);  public:    Point(int x = 0, int y = 0) : m_x(x), m_y(y)&#123;&#125;    void printPoint()&#123;cout &lt;&lt; m_x &lt;&lt; &quot; &quot; &lt;&lt; m_y &lt;&lt; endl;&#125;    &#125;;// 实现 友元函数Point add_P(Point &amp;p1, Point &amp;p2)&#123;    return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);&#125;int main()&#123;    Point p1(10, 10);    Point p2(20, 20);    Point p3(add_P(p1, p2));    p3.printPoint();    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo530 30\n\n\n\n\n\n代码示例2：友元类\n123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Point&#123;private:    int m_x;    int m_y;        // 声明 友元类    friend class FH_Math;public:    Point(int x = 0, int y = 0) : m_x(x), m_y(y)&#123;&#125;    void printPoint()&#123;cout &lt;&lt; m_x &lt;&lt; &quot; &quot; &lt;&lt; m_y &lt;&lt; endl;&#125;    &#125;;// 实现 友元类class FH_Math&#123;public:        Point add_P(Point &amp;p1, Point &amp;p2)    &#123;        return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);    &#125;&#125;;int main()&#123;    Point p1(10, 10);    Point p2(20, 20);    Point p3 = FH_Math().add_P(p1, p2);    p3.printPoint();    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo630 30\n\n21. 内部类21.1 内部类的定义\n定义：\n\n类B定义在类A中，B就是A的内部类（嵌套类）\n类A就是B的外部类\n\n\n特点：\n\n支持：public, protected, private权限\n内部类成员函数可以访问外部类所有成员\n外部类则无法访问内部类的成员\n成员函数可以直接不带类名，对象名访问其外部类的static修饰的成员\n不会影响外部类的内存布局\n\n\n代码示例1：\n12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Person&#123;private:    int m_age;public:    void test1()&#123;cout &lt;&lt; &quot;Person::test1()&quot; &lt;&lt; endl;&#125;    static void test2()&#123;cout &lt;&lt; &quot;Person::test2(static)&quot; &lt;&lt; endl;&#125;public:    class Student    &#123;    private:        int m_id;    public:                void test3()&#123;test2();&#125;            &#125;;&#125;;int main()&#123;    Person::Student s;    s.test3();    cout &lt;&lt; sizeof(Person) &lt;&lt; endl;    cout &lt;&lt; sizeof(Person::Student) &lt;&lt; endl;        return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo1Person::test2(static)44\n\n21.2 内部类声明与实现分离\n跟正常的函数声明和实现分离差不多\n标明类的作用域就可以了\n\n22. 局部类\n在一个函数中定义一个类：局部类\n特点：\n作用域仅限于所在的函数内部，不允许static修饰成员\n局部类的成员函数不能直接访问所在函数的局部变量（static可以）\n\n\n\n23. 运算符重载\n注意：\n有些运算符不可以重载：\n对象成员访问运算符.\n域运算符::\n三目运算符?\nsizeof\n\n\n有些运算符只能重载为成员函数：\n赋值运算符=\n下标运算符[]\n函数运算符()\n指针访问成员-&gt;\n\n\n\n\n\n23.1 基本运算符重载\n作用：给运算符增加一些新的功能\n\n设计思路：\n\n如果仅和类相关，重载运算符函数优先写在类里面\n如果是&lt;&lt;，&gt;&gt;的重载，尽量写成全局函数\n\n\n代码示例1：+, -, +=, -=, ==, !=, -, ++, --\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;using namespace std;class Point&#123;private:    int m_x;    int m_y;public:    Point(int x = 0, int y = 0) : m_x(x), m_y(y)&#123;&#125;    void showPoint()&#123;cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;             // operator +, -    const Point operator+(const Point &amp;point) const    &#123;        return Point(this-&gt;m_x + point.m_x, this-&gt;m_y + point.m_y);    &#125;    // operator +=, -=    Point &amp;operator+=(const Point &amp;point)    &#123;        this-&gt;m_x += point.m_x;        this-&gt;m_y += point.m_y;        return *this;    &#125;    // operator ==, !=    const bool operator==(const Point &amp;point)    &#123;        return (this-&gt;m_x == point.m_x &amp;&amp; this-&gt;m_y == point.m_y);    &#125;    // operator -    const Point operator-() const    &#123;        return Point(-m_x, -m_y);    &#125;    // operator ++, --    Point &amp;operator++()    &#123;        ++this-&gt;m_x;        ++this-&gt;m_y;        return *this;    &#125;    const Point operator++(int)    &#123;        Point origin_P(this-&gt;m_x, this-&gt;m_y);        ++this-&gt;m_x;        ++this-&gt;m_y;        return origin_P;    &#125;&#125;;int main()&#123;    // operator +, -    cout &lt;&lt; &quot;operator +, -&quot; &lt;&lt; endl;    Point p1(10, 10);    Point p2(20, 20);    Point p3 = p1 + p2;    Point p4 = p1 + p2 + p3;    p4.showPoint();    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;    // operator +=, -=    cout &lt;&lt; &quot;operator +=, -=&quot; &lt;&lt; endl;    Point p5(1, 1);    Point p6(2, 2);    Point p7;    (p7 += p5) = p6;    p4.showPoint();    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;    // operator ==, !=    cout &lt;&lt; &quot;operator ==, !=&quot; &lt;&lt; endl;    Point p8(1, 1);    Point p9(1, 1);    cout &lt;&lt; (p1 == p2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;    // operator -    cout &lt;&lt; &quot;operator -&quot; &lt;&lt; endl;    Point p10(1, 1);    Point p11(0, 0);    Point p12;    p11 = -p10;    p10.showPoint();    p11.showPoint();    p12 = -(-p1);    p12.showPoint();    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;    // operator ++, --    cout &lt;&lt; &quot;// operator ++, --&quot; &lt;&lt; endl;    Point p13(1, 1);    Point p14(0, 0);    Point p15(2, 2);    ++p13;    p13++;    p13.showPoint();    p14 = (p13++) + p15;    p14.showPoint();    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;        return 0;&#125;\n\n打印结果：\n12345678910111213141516171819PS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo3operator +, -(60, 60)---------operator +=, -=(60, 60)---------operator ==, !=false---------operator -(1, 1)(-1, -1)(10, 10)---------// operator ++, --(3, 3)(5, 5)---------\n\n\n\n代码示例2：&lt;&lt; &gt;&gt;\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;class Point&#123;private:    int m_x;    int m_y;public:    Point(int x = 0, int y = 0) : m_x(x), m_y(y)&#123;&#125;     // operator &lt;&lt;, &gt;&gt;    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);    friend istream &amp;operator&gt;&gt;(istream &amp;cin, Point &amp;point);&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)&#123;    cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;    return cout;&#125;istream &amp;operator&gt;&gt;(istream &amp;cin, Point &amp;point)&#123;    cout &lt;&lt; &quot;input m_x: &quot;;    cin &gt;&gt; point.m_x;    cout &lt;&lt; &quot;input m_y: &quot;;    cin &gt;&gt; point.m_y;    return cin;&#125;int main()&#123;    // operator &lt;&lt;, &gt;&gt;    cout &lt;&lt; &quot;operator &lt;&lt;&quot; &lt;&lt; endl;    Point p1(10, 10);    cout &lt;&lt; p1 &lt;&lt; endl;    cout &lt;&lt; p1 &lt;&lt; p1 &lt;&lt; endl;    cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;operator &gt;&gt;&quot; &lt;&lt; endl;    Point p2;    Point p3;    cin &gt;&gt; p2 &gt;&gt; p3;    cout &lt;&lt; p2 &lt;&lt; &quot;\\n&quot; &lt;&lt; p3 &lt;&lt; endl;    cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n12345678910111213PS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo4    operator &lt;&lt;(10, 10)(10, 10)(10, 10)--------operator &gt;&gt;input m_x: 1input m_y: 1input m_x: 2input m_y: 2(1, 1)(2, 2)--------\n\n23.2 调用父类的运算符重载\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;class Person&#123;public:        int m_age;    Person &amp;operator=(const Person &amp;person)    &#123;        this-&gt;m_age = person.m_age;        return *this;    &#125;&#125;;class Student : public Person&#123;public:     int m_score;    Student &amp;operator=(const Student &amp;student)    &#123;        Person::operator=(student);        this-&gt;m_score = student.m_score;        return *this;    &#125;    void showInfo()    &#123;        cout &lt;&lt; m_age &lt;&lt; &quot; &quot; &lt;&lt; m_score &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Student s1;    s1.m_age = 10;    s1.m_score = 20;    Student s2 = s1;    s2.showInfo();    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo510 20\n\n23.3 仿函数\n定义：\n\n仿函数(functor)，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator这个类就有了类似函数的行为\n将一个对象，作为一个函数来使用\n对比普通的函数，仿函数可以保存状态\n\n\n代码示例：\n12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;class Sum&#123;private:    int m_age;public:    int operator()(int a = 0, int b = 0)    &#123;        return a + b;    &#125;&#125;;int main()&#123;    Sum s1;    cout &lt;&lt; s1(10, 20) &lt;&lt; endl;        return 0;&#125;\n\n打印示例：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo130\n\n24. 模板\n泛型：一种类型参数化以达到代码复用的技术\n种类：函数模板，类模板\n模板没有被使用，不会被实例化\n\n24.1 函数模板定义\n代码示例：函数模板, 多参数函数模板\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class Point&#123;private:    int m_x;    int m_y;    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);public:    Point(int x = 0, int y = 0) : m_x(x), m_y(y)&#123;&#125;    Point operator+(const Point &amp;point)    &#123;        return Point(this-&gt;m_x + point.m_x, this-&gt;m_y + point.m_y);    &#125;         &#125;;ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)&#123;    return cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;&#125;// 函数模板template&lt;typename T&gt;T add(T a, T b)&#123;    return a + b;&#125;// 多参数函数模板template&lt;typename T_int, typename T_double&gt;T_double add(T_int a, T_double b)&#123;    return a + b;&#125;int main()&#123;    cout &lt;&lt; add&lt;int&gt;(1, 2) &lt;&lt; endl;    cout &lt;&lt; add&lt;int, double&gt;(1, 2.1) &lt;&lt; endl;    cout &lt;&lt; add&lt;Point&gt;(Point(1, 1), Point(2, 2)) &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo133.1(3, 3)\n\n24.2 函数模板分离\n编译基本过程：\n\n先把A.cpp包含的A.h的内容复制到A.cpp中(声明和实现回到同一个cpp文件中)\n再编译main.cpp和A.cpp成main.obj和A.obj\n再通过main.ilk链接main.cpp和A.cpp\n修正了main.cpp中调用A.cpp中函数时，call的函数地址\n最后生成main.exe\n\n\n代码示例：模板的错误编译\n\nadd.h\n12template&lt;typename T&gt;T add(T a, T b);\n\nadd.cpp\n123456#include &#x27;add.h&#x27;T add(T a, T b)&#123;    return a + b;&#125;\n\nmain.cpp\n123456789#include &lt;iostream&gt;#include &#x27;add.h&#x27;using namespace std;int main()&#123;    add(1, 2);    return 0;&#125;\n\n以上代码编译不会报错，但链接报错，不会生成.exe\n\n原因：\n\n模板没有被使用，不会被实例化\n所以add.cpp在编译过程中，编译器未发现在add.cpp中有使用add()模板函数的地方\n于是，便将add.h和add.cpp中未被使用的add()模板函数优化了(即便链接后，add()在main.cpp中被使用)\n链接后，main.cpp中调用add()函数，得不到有效的函数实现地址(此时main.cpp中是有函数声明的，因为包含了add.h)，所以会报错\n\n\n代码示例：正确的写法\n\nadd.h\n12345template&lt;typename T&gt;T add(T a, T b)&#123;    return a + b;&#125;\n\nmain.cpp\n123456789#include &lt;iostream&gt;#include &#x27;add.h&#x27;using namespace std;int main()&#123;    add(1, 2);    return 0;&#125;\n\n写模板函数时，不要进行声明实现分离，全部写在.h中，正规的方式是.hpp\n\n\n24.3 类模板的定义\n注意：类模板中的友元函数声明\n\n需先声明类和友元函数的模板\n再实现友元函数\n且最好友元函数的模板参数和类模板的参数类型不同\n另一种方式：声明和实现中都要在&lt;&lt;后加入&lt;&gt;\nostream &amp;operator&lt;&lt; &lt;&gt;(ostream &amp;cout, const Array&lt;Arr&gt; &amp;arr);\n\n\n\n\n代码示例：\n\narray.hpp\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//// Created by FHang on 2022/3/9 14:06//#ifndef INC_8_CPP_STRUCTURE_SEQLIST_HPP#define INC_8_CPP_STRUCTURE_SEQLIST_HPPusing std::cout;using std::endl;#define MAXSIZE 100template&lt;typename tab_T&gt;class SeqList;template&lt;typename T&gt;std::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab);template &lt;typename tab_T&gt;class SeqList&#123;private:    tab_T *m_tabData;    int m_capacity;    int m_size;public:    explicit SeqList(int capacity);    ~SeqList();    int size() const;    tab_T get(int index) const;    void add(tab_T value);    void insert(int i, tab_T value);    void remove(int i);    void removeByRange(int i, int range);    void replaceByValue(tab_T tagValue, tab_T newValue);    tab_T operator[](int index) const;    template&lt;typename T&gt;    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab);&#125;;template&lt;typename tab_T&gt;SeqList&lt;tab_T&gt;::SeqList(int capacity)&#123;    m_capacity = (capacity &gt; 0) ? capacity : MAXSIZE;    m_tabData = new tab_T[m_capacity];    if (m_tabData == nullptr)&#123;return;&#125;    else&#123;cout &lt;&lt; &quot;&lt;-- SeqList Created --&gt;\\n&quot;;&#125;    m_size = 0;&#125;template&lt;typename tab_T&gt;SeqList&lt;tab_T&gt;::~SeqList()&#123;    if (m_tabData == nullptr)&#123;return;&#125;    else&#123;cout &lt;&lt; &quot;&lt;-- SeqList Deleted --&gt;\\n&quot;;&#125;    delete[] m_tabData;&#125;template&lt;typename tab_T&gt;int SeqList&lt;tab_T&gt;::size() const&#123;    return m_size;&#125;template&lt;typename tab_T&gt;tab_T SeqList&lt;tab_T&gt;::get(int index) const&#123;    if (index &lt; 0 || index &gt;= m_size)    &#123;        throw(&quot;&lt;&lt; !!! 数组下标越界 !!! &gt;&gt;&quot;);    &#125;    return m_tabData[index];&#125;template&lt;typename tab_T&gt;void SeqList&lt;tab_T&gt;::add(tab_T value)&#123;    if (m_size &gt;= m_capacity)    &#123;        //TODO Reset Capacity    &#125;    m_tabData[m_size] = value;    ++m_size;&#125;template&lt;typename tab_T&gt;void SeqList&lt;tab_T&gt;::insert(int i, tab_T value)&#123;    if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;    if (m_size == MAXSIZE)&#123;return;&#125;    for (int j = m_size - 1; j &gt;= i - 1; --j)    &#123;        m_tabData[j + 1] = m_tabData[j];    &#125;    m_tabData[i] = value;    ++m_size;&#125;template&lt;typename tab_T&gt;void SeqList&lt;tab_T&gt;::remove(int i)&#123;    if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;        for (int j = i; j &lt;= m_size -1; ++j)    &#123;        m_tabData[j] = m_tabData[j + 1];    &#125;    --m_size;&#125;template&lt;typename tab_T&gt;void SeqList&lt;tab_T&gt;::removeByRange(int i, int range)&#123;     if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;     for (int j = i; j &lt;= m_size - 1; ++j)     &#123;         m_tabData[j] = m_tabData[j + range];     &#125;     m_size -= range;&#125;template&lt;typename tab_T&gt;void SeqList&lt;tab_T&gt;::replaceByValue(tab_T tagValue, tab_T newValue)&#123;    for (int i = 0; i &lt; m_size; ++i)    &#123;        if (m_tabData[i] == tagValue)        &#123;            m_tabData[i] = newValue;        &#125;    &#125;&#125;template&lt;typename tab_T&gt;tab_T SeqList&lt;tab_T&gt;::operator[](int index) const&#123;    return get(index);&#125;template&lt;typename T&gt;std::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab)&#123;    int size = tab.size();    f_cout &lt;&lt; &quot;[&quot;;    for (int i = 0; i &lt; size; ++i)    &#123;        if (i != 0)&#123;f_cout &lt;&lt; &quot;,&quot;;&#125;        f_cout &lt;&lt; tab[i];    &#125;    return f_cout &lt;&lt; &quot;]&quot;;&#125;#endif //INC_8_CPP_STRUCTURE_SEQLIST_HPP\n\n\n\nMain.cpp\n123456789101112131415161718192021222324252627282930//// Created by FHang on 2022/3/9 14:06//#include &lt;iostream&gt;#include &quot;SeqList.hpp&quot;int main()&#123;    SeqList&lt;int&gt; seqList(10);    for (int i = 0; i &lt; 10; ++i)    &#123;        seqList.add(1);    &#125;    cout &lt;&lt; seqList &lt;&lt; endl;    seqList.insert(2, 9);    cout &lt;&lt; seqList &lt;&lt; endl;    seqList.remove(2);    cout &lt;&lt; seqList &lt;&lt; endl;    seqList.removeByRange(2, 3);    cout &lt;&lt; seqList &lt;&lt; endl;    seqList.replaceByValue(1, 9);    cout &lt;&lt; seqList &lt;&lt; endl;    return 0;&#125;\n\n\n\n\n\ndemo2.cpp\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;array.hpp&quot;#include &lt;iostream&gt;using namespace std;class Point&#123;private:    int m_x;    int m_y;public:    Point(int x = 0, int y = 0) : m_x(x), m_y(y)&#123;&#125;          friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)&#123;    return cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;&#125;int main()&#123;    cout &lt;&lt; &quot;----Array&lt;int&gt;----&quot; &lt;&lt; endl;    Array&lt;int&gt; array(3);    array.add(1);    array.add(2);    array.add(3);    array.add(4);    cout &lt;&lt; &quot;arr[0]: &quot; &lt;&lt; array.get(0) &lt;&lt; endl;    cout &lt;&lt; &quot;arr[1]: &quot; &lt;&lt; array[1] &lt;&lt; endl;    cout &lt;&lt; &quot;size: &quot; &lt;&lt; array.size() &lt;&lt; endl;    cout &lt;&lt; &quot;arr: &quot; &lt;&lt; array &lt;&lt; endl;    cout &lt;&lt; &quot;\\n&quot;;    cout &lt;&lt; &quot;----Array&lt;Point&gt;----&quot; &lt;&lt; endl;    Array&lt;Point&gt; arr_Point(2);    arr_Point.add(Point(1, 1));    arr_Point.add(Point(2, 2));    cout &lt;&lt; &quot;arr_Point: &quot; &lt;&lt; arr_Point &lt;&lt; endl;    cout &lt;&lt; &quot;\\n&quot;;    return 0;&#125;\n\n打印结果：\n12345678910PS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo2----Array&lt;int&gt;----size not freearr[0]: 1arr[1]: 2size: 3arr: [1, 2, 3]----Array&lt;Point&gt;----arr_Point: [(1, 1), (2, 2)]\n\n25. 其它语法-特性25.1 类型转换\nC语言风格的类型转换符\n\n(type)expression\ntype(expression)\n\n\nC++四种转换\n\nstatic_cast\n\ndynamic_cast\n\nreinterpret_cast\n\nconst_cast\n使用格式：xx_cast&lt;type&gt;(expression)\n\n\n\n\n25.1.1 const_cast\n一般用于去除const属性，将const转换成非const\n\n代码示例：\n1234567891011121314#include &lt;iostream&gt;using namespace std;class Person&#123;&#125;;int main()&#123;    const Person *p1 = new Person;    // 两种写法完全等价    Person *p2 = const_cast&lt;Person *&gt;(p1);    Person *p3 = (Person *)p1;        return 0;&#125;\n\n反汇编查看\n1234567// Person *p2 = const_cast&lt;Person *&gt;(p1);mov eax, dword ptr[p1]mov dword ptr[p2], eax// Person *p3 = (Person *)p1;mov eax, dword ptr[p1]mov dword ptr[p3], eax\n\n25.1.2 dynamic_cast\n一般用于多态类型转换，有运行时的安全检测\n\n代码示例：\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Person&#123;    virtual void run();&#125;;class Student : public Person&#123;&#125;;int main()&#123;    Person *p1 = new Person;    Person *p2 = new Student;    // 两种写法完全等价    Student *s1 = (Student *)p1; // 不安全    Student *s1 = dynamic_cast&lt;Student *&gt;(p1); // 不安全        Student *s2 = dynamic_cast&lt;Student *&gt;(p2); // 安全        return 0;&#125;\n\n反汇编查看：\n1234// Student *s1 = dynamic_cast&lt;Student *&gt;(p1);mov eax, dword ptr[p1]call __RTDynamicCast(0C14ABh)mov dword ptr[s1], eax\n\n25.1.3 static_cast\n对比dynamic_cast确实安全检测\n\n不能交叉转换（不是同一继承体系的，无法转换）\n\n常用于基本数据类型转换，非const转换const\n\n代码示例：交叉转换\n1234567891011121314151617#include &lt;iostream&gt;using namespace std;class Person&#123;&#125;;class Car&#123;&#125;;int main()&#123;    Person *p1 = new Person;        // 两个类之间完全没有关系，强行转化：交叉转换    Car *c1 = (Car *)p1;    Car *c2 = dynamic_cast&lt;Car *&gt;(p1);        return 0;&#125;\n\n\n\n代码示例：非const转换const\n123456789101112#include &lt;iostream&gt;using namespace std;class Person&#123;&#125;;int main()&#123;    Person *p1 = new Person;    const Person *p2 = static_cast&lt;Person *&gt;(p1);        return 0;&#125;\n\n25.1.4 reinterpret_cast\n属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅只是简单的二进制数据拷贝\n\n代码示例：\n1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 10;        // C语言的隐式转换    double b = a;        double d = reinterpret_cast&lt;double&amp;&gt;(a);        return 0;&#125;\n\n内存分析：反汇编\n1234567891011121314int a = 10;// 二进制：00001010 00000000 00000000 00000000// 十六进制：0A 00 00 00// 小段模式：int类型4字节，从右往左读取double b = a;// 00 00 00 00 00 00 24 40// cvtsi2sd xmm0, dword ptr[a]// movsd mmword ptr[d], xmm0double d = reinterpret_cast&lt;double&amp;&gt;(a);// 0A 00 00 00 cc cc cc cc// movsd xmm0, mmword ptr[a]// movsd mmword ptr[d], xmm0\n\n25.2 C++11特性\nauto：\n\n可以初始化表达式中推断出变量的类型，提高开发效率\n\n属于编译器特性，不影响最终的机器码质量，不影响运行效率\n123auto i = 10; // intauto str = &quot;c++&quot;; // const char *auto p = new Person; // Person *\n\n\ndecltype:\n\n可以获取变量的类型\n12int a = 10;decltype(a) b = 20;\n\n\nnullptr:\n\n可以解决NULL的二义性问题\n\nNULL本质是define NULL 0\n\n在c++98中void fun(int)&#123;&#125;``void fun(int *)&#123;&#125;时会遇到二义性，在c++11之后，默认为0\n1234567891011121314#include &lt;iostream&gt;using namespace std;void func(int a)&#123;cout &lt;&lt; &quot;func(int): &quot; &lt;&lt; a &lt;&lt; endl;&#125;void func(int *a)&#123;cout &lt;&lt; &quot;func(int *): &quot; &lt;&lt; a &lt;&lt; endl;&#125;int main()&#123;    // func(NULL);    func(nullptr);    return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo3func(int *): 0\n\n\n快速遍历：\n12int arr[] = &#123;&#125;;for (int a : arr)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;\n\n25.3 Lambda表达式\nlambda表达式：\n本质是函数\n完整结构：[capture list] (params list) mutable exception -&gt; return type &#123;function body&#125;;\ncapture list：捕获外部变量列表\nparams list：形参列表，不能使用默认参数，不能省略参数名\nmutable：用于说明是否可以修改捕获的变量\nexception ：异常设定\nreturn type：返回值类型\nfunction body：函数体\n\n\n省略的写法：\n[capture list] (params list) -&gt; return type &#123;function body&#125;;\n[capture list] (params list)&#123;function body&#125;; \n[capture list]&#123;function body&#125;; \n\n\n\n\n\n25.3.1 lambda基本用法\n代码示例1：\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int main()&#123;    // 无参，无返回值，默认调用    ([]    &#123;        cout &lt;&lt; &quot;func() - 1&quot; &lt;&lt; endl;    &#125;)();    // 可以用指针存储    void (*p)() = []    &#123;        cout &lt;&lt; &quot;func() - p&quot; &lt;&lt; endl;    &#125;;    p();    // 直接用auto存储更方便    auto p1 = []    &#123;        cout &lt;&lt; &quot;func() - p1&quot; &lt;&lt; endl;    &#125;;    p1();    // 有返回值和参数    auto add1 = [](int a, int b) -&gt; auto    &#123;        return a + b;    &#125;;    cout &lt;&lt; add1(1, 2) &lt;&lt; endl;    // 返回值类型也可省略    auto add2 = [](int a, int b)    &#123;        return a + b;    &#125;;    cout &lt;&lt; add2(2, 3) &lt;&lt; endl;        return 0;&#125;\n\n打印结果：\n123456PS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo4func() - 1func() - pfunc() - p135\n\n\n\n代码示例2：\n1234567891011121314151617#include &lt;iostream&gt;using namespace std;void calculate(int a, int b, int (*func)(int, int))&#123;    cout &lt;&lt; func(a, b) &lt;&lt; endl;&#125;int main()&#123;    calculate(1, 2, [](int a, int b)&#123;return a + b;&#125;);    calculate(4, 2, [](int a, int b)&#123;return a - b;&#125;);    calculate(8, 2, [](int a, int b)&#123;return a * b;&#125;);    calculate(8, 2, [](int a, int b)&#123;return a / b;&#125;);    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo532164\n\n25.3.2 lambda变量捕获\n代码示例：\n12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 10;    int b = 20;    auto add1 = [a, b](int c, int d)    &#123;        cout &lt;&lt; a + b &lt;&lt; &quot;\\n&quot; &lt;&lt; c + d &lt;&lt; endl;    &#125;;    add1(1, 98);    // 隐式捕获:（全捕获）    // [=] 值类型    // [&amp;] 引用类型     auto add2 = [=]    &#123;        cout &lt;&lt; a + b &lt;&lt; &quot;\\n&quot;;    &#125;;    add2();        return 0;&#125;\n\n25.4 C++14特性\n泛型lambda表达式：\n1auto func = [](auto a, auto b)&#123;return a + b;&#125;;\n\n\n\n捕获的变量进行初始化\n12345int a = 9;auto func = [a = 10]&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;;func(); //打印结果：10cout &lt;&lt; a &lt;&lt; endl; // 打印结果：9\n\n25.5 C++17特性\n可以进行初始化的if和switch语句\n\n代码示例：if，else if\n1234if (int a = 10; a &gt; 0)&#123;    cout &lt;&lt; a &lt;&lt; endl;&#125;\n\n\n\n代码示例：switch\n123456789switch(int a = 1; a)&#123;    case 0:        break;    case 1:        break;    default:        break;&#125;\n\n26. 异常26.1 异常基本用法\n编程过程中常见的错误：\n\n语法错误\n逻辑错误\n异常\n\n\n异常：一种程序运行过程中可能会发生的错误\n\n每次异常可能类型不同，不能确定\n异常没有处理，程序会直接中断或崩溃等等\n\n\n异常处理过程：\n\nthrow异常后，会在当前函数中查找匹配的catch\n找不到就会终止当前的函数代码，去上一层函数中查找\n如果都找不到，程序直接终止\n\n\n代码示例1：简单的异常演示\n123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123;    int i = 0;    for (i ; i &lt; 99999; ++i)    &#123;        try        &#123;            int *p = new int[999999];        &#125;        catch(...)        &#123;            cout &lt;&lt; &quot;for loop &quot; &lt;&lt; i &lt;&lt; &quot; error!&quot; &lt;&lt; endl;            break;        &#125;    &#125;        return 0;&#125;\n\n打印结果：多次打印（每次的异常结果可能不同）\n123456PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1for loop 6176 error!PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1for loop 6180 error!PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1for loop 6182 error!\n\n\n\n\n\n代码示例2：主动抛出异常\n123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void divide(int a, int b)&#123;    if (b == 0)    &#123;        throw 0;    &#125;    cout &lt;&lt; a / b &lt;&lt; endl;&#125;int main()&#123;    try    &#123;        divide(10, 1);        divide(10, 0);        divide(10, 2);    &#125;    catch(const int exc)    &#123;        cout &lt;&lt; &quot;Divide Error &quot; &lt;&lt; exc &lt;&lt; &quot;\\n&quot;;    &#125;        return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo210Divide Error 0\n\n总结：throw后面的类型，要和catch里面接受的类型保持一致\n\n代码示例3：异常处理过程\n\n没有catch\n12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;void func1()&#123;    cout &lt;&lt; &quot;func1()-begin&quot; &lt;&lt; endl;    throw 0; // 抛出异常，func1()中没有catch，向上层函数func2()中找    cout &lt;&lt; &quot;func1()-end&quot; &lt;&lt; endl;&#125;void func2()&#123;    cout &lt;&lt; &quot;func2()-begin&quot; &lt;&lt; endl;    func1(); // throw 来到func2()，也没有发现catch，继续向上到main()    cout &lt;&lt; &quot;func2()-end&quot; &lt;&lt; endl;&#125;int main()&#123;    cout &lt;&lt; &quot;main()-begin&quot; &lt;&lt; endl;    func2(); // throw来到main()中，依然没有发现catch，此时程序终止    cout &lt;&lt; &quot;main()-end&quot; &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo3main()-beginfunc2()-beginfunc1()-begin\n\n\n\n有catch\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;void func1()&#123;    cout &lt;&lt; &quot;func1()-begin&quot; &lt;&lt; endl;    try    &#123;        throw 0;    &#125;    catch(int exc)    &#123;        cout &lt;&lt; &quot;Error &quot; &lt;&lt; exc &lt;&lt; &quot;\\n&quot;;    &#125;        cout &lt;&lt; &quot;func1()-end&quot; &lt;&lt; endl;&#125;void func2()&#123;    cout &lt;&lt; &quot;func2()-begin&quot; &lt;&lt; endl;    func1();    cout &lt;&lt; &quot;func2()-end&quot; &lt;&lt; endl;&#125;int main()&#123;    cout &lt;&lt; &quot;main()-begin&quot; &lt;&lt; endl;    func2();    cout &lt;&lt; &quot;main()-end&quot; &lt;&lt; endl;    return 0;&#125;\n\n打印结果：\n12345678PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo3main()-beginfunc2()-beginfunc1()-beginError 0func1()-endfunc2()-endmain()-end\n\n26.2 异常抛出声明\n为了增强可读性和方便团队协作，函数内部抛出异常，建议函数声明一下函数类型\n\n代码示例：\n12void func1() throw()&#123;&#125; // 不抛出异常void func2() throw(int, double)&#123;&#125; // 可能抛出 int，double 类型的异常\n\n26.3 自定义异常类型\n代码示例1：\n12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Exception&#123;public:        virtual const char *what() = 0;&#125;;class DivideException : public Exception&#123;public:        const char *what()&#123;return &quot;Divide Error&quot;;&#125;&#125;;void divide(int a, int b)&#123;    if (b == 0)&#123;throw DivideException();&#125;    cout &lt;&lt; a / b &lt;&lt; &quot;\\n&quot;;&#125;int main()&#123;    try    &#123;        divide(10, 0);    &#125;    catch(DivideException e)    &#123;        cout &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;;    &#125;        return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo4Divide Error\n\n\n\n\n\n代码示例2：\n12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Exception&#123;public:        virtual const char *what() const = 0;&#125;;class DivideException : public Exception&#123;public:        const char *what() const&#123;return &quot;Divide Error&quot;;&#125;&#125;;void divide(int a, int b)&#123;    if (b == 0)&#123;throw DivideException();&#125;    cout &lt;&lt; a / b &lt;&lt; &quot;\\n&quot;;&#125;int main()&#123;    try    &#123;        divide(10, 0);    &#125;    catch(const Exception &amp;e)    &#123;        cout &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;;    &#125;        return 0;&#125;\n\n打印结果：\n12PS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo4Divide Error\n\n27. 智能指针\n目的：改善传统指针存在的问题\n\n传统指针存在的问题：\n\n需要手动管理内存\n容易发生内存泄漏\n忘记释放\n出现抛出异常\n\n\n释放后会变成野指针\n\n\n智能指针的作用：\n\nauto_ptr：C++98，存在缺陷，不能用于数组\nshared_ptr：C++11\nunique_ptr：C++11\n\n\n\n27.1 智能指针基本使用\n代码示例：\n12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Person&#123;private:    int m_age;public:    Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;&#125;    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;            void run()&#123;cout &lt;&lt; &quot;Person::run() &quot; &lt;&lt; m_age &lt;&lt; endl;&#125;&#125;;void test1()&#123;    shared_ptr&lt;Person&gt; p(new Person(10));    p-&gt;run();&#125;int main()&#123;    test1();        return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo1Person::Person(int)Person::run() 10Person::~Person()\n\n27.2 自定义智能指针\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;template&lt;typename class_T&gt;class fh_ptr&#123;private:    class_T *obj_ptr;public:    fh_ptr(class_T *ptr) : obj_ptr(ptr)&#123;&#125;    ~fh_ptr()    &#123;        if (obj_ptr == nullptr)&#123;return;&#125;        delete obj_ptr;        obj_ptr = nullptr;    &#125;        class_T *operator-&gt;()&#123;return obj_ptr;&#125;&#125;;class Person&#123;private:    int m_age;public:    Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;&#125;    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;            void run()&#123;cout &lt;&lt; &quot;Person::run() &quot; &lt;&lt; m_age &lt;&lt; endl;&#125;&#125;;void test1()&#123;    fh_ptr&lt;Person&gt; p(new Person(10));    p-&gt;run();&#125;int main()&#123;    test1();        return 0;&#125;\n\n打印结果：\n1234PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo2Person::Person(int)Person::run() 10Person::~Person()\n\n27.3 shared_ptr27.3.1 shared_ptr原理\n一个shared_ptr会对一个对象产生强引用\n每个对象都会有一个对应的强引用计数，记录着当前的对象被多少shared_ptr强引用\n可以通过shared_ptr的use_count函数获得强引用计数\n\n\n当有一个新的shared_ptr指向对象时，对象的强引用计数会加1\n当一个shared_ptr销毁时，对象的强引用计数减1\n当一个对象的强引用计数为0时，对象就会自动销毁\n\n27.3.2 shared_ptr循环引用27.3.2.1 演示循环引用问题\n循环引用的问题：\n\nshared_ptr是强引用智能指针\n\n发生两个类的对象相互引用，产生循环引用\n\n循环引用会产生栈空间的智能指针对象销毁后，指向堆区的对象不会被销毁\n\n\n\n代码示例：演示循环引用的问题\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Person;class Car&#123;public:    shared_ptr&lt;Person&gt; m_person;    Car()&#123;cout &lt;&lt; &quot;Car::Car()\\n&quot;;&#125;    ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()\\n&quot;;&#125;&#125;;class Person&#123;public:    shared_ptr&lt;Car&gt; m_car;    Person()&#123;cout &lt;&lt; &quot;Person::Person()\\n&quot;;&#125;    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()\\n&quot;;&#125;&#125;;void test()&#123;    shared_ptr&lt;Person&gt; person(new Person);    shared_ptr&lt;Car&gt; car(new Car);    person-&gt;m_car = car;    car-&gt;m_person = person;&#125;int main()&#123;    test();    return 0;&#125;\n\n打印结果：\n123PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo3Person::Person()Car::Car()\n\n27.3.2.2 解决循环引用问题\nweak_ptr\n\n会对对象产生弱引用\n解决shared_ptr的循环引用问题\n\n\n代码示例：解决循环引用问题\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Person;class Car&#123;public:    // 只需要其中一个 是 弱引用 即可    weak_ptr&lt;Person&gt; m_person;    Car()&#123;cout &lt;&lt; &quot;Car::Car()\\n&quot;;&#125;    ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()\\n&quot;;&#125;&#125;;class Person&#123;public:    shared_ptr&lt;Car&gt; m_car;    Person()&#123;cout &lt;&lt; &quot;Person::Person()\\n&quot;;&#125;    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()\\n&quot;;&#125;&#125;;void test()&#123;    shared_ptr&lt;Person&gt; person(new Person);    shared_ptr&lt;Car&gt; car(new Car);    person-&gt;m_car = car;    car-&gt;m_person = person;&#125;int main()&#123;    test();    return 0;&#125;\n\n打印结果：\n12345PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo3Person::Person()Car::Car()Person::~Person()Car::~Car()\n\n27.4 unique_ptr\n同样是强引用，但可以确保同一时间只有一个指针指向对象\n\n当unique销毁时，指向的对象也就自动销毁\n\n使用std::move函数转移unqiue_ptr的所有权\n123unique_ptr&lt;A&gt; a1;unique_ptr&lt;A&gt; a2(new A);a1 = std::move(a2)\n\n","slug":"1_C++_面向对象反汇编补充_08","date":"2022-10-06T07:28:25.917Z","categories_index":"编程","tags_index":"Assemly,C/C++","author_index":"FangH"},{"id":"c90c4a4848e304bff822a98a4aa17a84","title":"C++_基础","content":"C++_基础[toc]\n1. 第一阶段1. HelloWorld12345678#include &lt;iostream&gt;using namespace std;void main()&#123;\tcout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;&#125;\n\n\n\n2. 变量123456789#include &lt;iostream&gt;using namespace std;void main()&#123;    int a = 10;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;&#125;\n\n\n\n3. 常量定义常量的两张方法：\n\n#define 宏常量\n通常在文件的上方定义\n\nconst 修饰的变量\n通常在变量定义前加关键字const\n\n\n常量定义后，不可被修改\n123456789101112131415#include &lt;iostream&gt;using namespace std;#define Day 7 // #define 常量名 常量值int main()&#123;\tconst int Month = 12; // const 常量类型 常量名 = 常量值\tcout &lt;&lt; &quot;One Week have &quot; &lt;&lt; Day &lt;&lt; &quot; day&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;One Year have &quot; &lt;&lt; Month &lt;&lt; &quot; month&quot; &lt;&lt; endl;&#125;\n\n\n\n4. 标识符命名规则\n标识符不能是关键字\n标识符只能是字母、数字、下划线组成\n标识符第一个字符必须是下划线或字母\n标识符区分大小写\n\n2. 数据类型1. 整型\n\n\n数据类型\n占用空间\n取值范围\n\n\n\nshort（短整型）\n2字节\n（-2^15 - 2^15-1）\n\n\nint（整型）\n4字节\n（-2^31 - 2^31-1）\n\n\nlong（长整型）\nwindows为4字节，Linux为4字节（32位），8字节（64位）\n（-2^31 - 2^31-1）\n\n\nlong long（长长整型）\n8字节\n（-2^63 - 2^63-1）\n\n\n2. sizeof 关键字\n作用：统计数据类型所占内存的大小\n语法：sizeof(数据类型/变量)\n\n1234567891011121314#include&lt;iostream&gt;using namespace std;void main()&#123;\tcout &lt;&lt; &quot;short Size is &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;\tcout &lt;&lt; &quot;int Size is &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;\tcout &lt;&lt; &quot;long Size is &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;\tcout &lt;&lt; &quot;long long Size is &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;&#125;\n\n\n\n2.1 sizeof补充\nsizeof()是编译器的一种特性，并非函数，只是用起来像，在C++编译转汇编时，编译器会自动将sizeof()的正确的值写在汇编中\n\n3. 浮点型\n\n\n数据类型\n占用空间\n有效数字范围\n\n\n\nfloat\n4字节\n7位有效数字\n\n\ndouble\n8字节\n15 - 16位有效数字\n\n\n123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;void main()&#123;\t//默认情况下显示6位有效数字\tfloat f1 = 3.1415926f;\tdouble d1 = 3.1415926;\tcout &lt;&lt; &quot;float f1 : &quot; &lt;&lt; f1 &lt;&lt; endl;\tcout &lt;&lt; &quot;double d1 : &quot; &lt;&lt; d1 &lt;&lt; endl;\t//统计float和double占用的空间\tcout &lt;&lt; &quot;float size : &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;\tcout &lt;&lt; &quot;double size : &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;\t//科学计数法\t//3e2 : 3 * 10 ^2\tfloat f2 = 3e2;\tcout &lt;&lt; &quot;float f2 : &quot; &lt;&lt; f2 &lt;&lt; endl;\t//3e2 : 3 * 0.1 ^2\tfloat f3 = 3e-2;\tcout &lt;&lt; &quot;float f3 : &quot; &lt;&lt; f3 &lt;&lt; endl;&#125;\n\n\n\n4. 字符型\n作用：显示单个字符\n语法：char 变量名 = &#39;变量值&#39;\n注意：char定义的变量只能用单引号；只能有一个字符\n占用：char占用1个字节；将字符对应的ASCII码放入存储单元\n\n123456789101112131415#include &lt;iostream&gt;using namespace std;void main()&#123;\t//定义char\tchar c1 = &#x27;a&#x27;;\t//查看char占用的大小\tcout &lt;&lt; &quot;Char c1 size : &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;\t//查看 &#x27;a&#x27; 对应的ASCII码\tcout &lt;&lt; &quot;Char a by ASCII : &quot; &lt;&lt; int(c1) &lt;&lt; endl;&#125;\n\n\nASCII：\t\n0 - 31 分配个控制字符\n32 - 126 分配个键盘上能找到的字符\n\n\n5. 转义字符12345678910111213141516#include &lt;iostream&gt;using namespace std;void main()&#123;\tcout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;\t// \\n 是换行\tcout &lt;&lt; &quot;hello world\\n&quot; &lt;&lt; endl;\t// \\\\ 是反斜杠\tcout &lt;&lt; &quot;hello world\\\\&quot; &lt;&lt; endl;\t// \\t 是水平制表（换行对齐）\tcout &lt;&lt; &quot;hello world\\t&quot; &lt;&lt; endl;&#125;\n\n\n\n6. 字符串类型123456789#include &lt;iostream&gt;using namespace std;void main()&#123;\tstring s1 = &quot;abc&quot;;\tcout &lt;&lt; &quot;string s1 : &quot; &lt;&lt; s1 &lt;&lt; endl;&#125;\n\n\n\n7. 布尔类型12345678910111213141516#include &lt;iostream&gt;using namespace std;void main()&#123;\t//true = 1; false = 0;\tbool b1 = true;\tbool b2 = false;\tcout &lt;&lt; &quot;Bool b1 : &quot; &lt;&lt; b1 &lt;&lt; endl;\tcout &lt;&lt; &quot;Bool b2 : &quot; &lt;&lt; b2 &lt;&lt; endl;\t//计算bool类占用的大小\tcout &lt;&lt; &quot;Bool size is : &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl;&#125;\n\n\n\n8.数据的输入\n\n作用：获取从键盘中输入的值\n关键字：cin\n语法：cin &gt;&gt; 变量\n\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;void main()&#123;\t//int\tint a;\tcout &lt;&lt; &quot;Please enter num : &quot; &lt;&lt; endl;\tcin &gt;&gt; a;\tcout &lt;&lt; &quot;Your enter num : &quot; &lt;&lt; a &lt;&lt; endl;\t//string\tstring b;\tcout &lt;&lt; &quot;Please enter string : &quot; &lt;&lt; endl;\tcin &gt;&gt; b;\tcout &lt;&lt; &quot;Your enter string : &quot; &lt;&lt; b &lt;&lt; endl;\t//float or double\tfloat c;\tdouble d;\tcout &lt;&lt; &quot;Please enter floatNum : &quot; &lt;&lt; endl;\tcin &gt;&gt; c;\tcout &lt;&lt; &quot;Your enter floatNum : &quot; &lt;&lt; c &lt;&lt; endl;\tcout &lt;&lt; &quot;Please enter doubleNum : &quot; &lt;&lt; endl;\tcin &gt;&gt; d;\tcout &lt;&lt; &quot;Your enter doubleNum : &quot; &lt;&lt; d &lt;&lt; endl;\t//bool\tbool bl1; \tcout &lt;&lt; &quot;Please enter boolVlaue bl1 : &quot; &lt;&lt; endl;\tcin &gt;&gt; bl1;\tcout &lt;&lt; &quot;Your enter boolValue : &quot; &lt;&lt; bl1 &lt;&lt; endl;\t\t//bool类型 除了0，其他都为真=1&#125;\n\n\n\n9. 自增自减的区别123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;void main()&#123;\t//前置++ 或 前置--\tint i1 = 10;\tint j1;\tcout &lt;&lt; &quot;i1 = &quot; &lt;&lt; i1 &lt;&lt; endl;\tj1 = ++i1 * 10;\tcout &lt;&lt; &quot;++i1 * 10 = &quot; &lt;&lt; j1 &lt;&lt; endl;\tj1 = --i1 * 10;\tcout &lt;&lt; &quot;--i1 * 10 = &quot; &lt;&lt; j1 &lt;&lt; endl;\t//后置++ 或 后置--\tint i2 = 10;\tint j2;\tcout &lt;&lt; &quot;i2 = &quot; &lt;&lt; i1 &lt;&lt; endl;\tj2 = ++i2 * 10;\tcout &lt;&lt; &quot;++i2 * 10 = &quot; &lt;&lt; j2 &lt;&lt; endl;\tj2 = --i2 * 10;\tcout &lt;&lt; &quot;--i2 * 10 = &quot; &lt;&lt; j2 &lt;&lt; endl;\t//后置与前置的区别\tint a1 = 10;\tint b1 = ++a1 * 10; //a1此时先+1为11\tcout &lt;&lt; &quot;a1 = &quot; &lt;&lt; a1 &lt;&lt; endl;\tcout &lt;&lt; &quot;b1 = &quot; &lt;&lt; b1 &lt;&lt; endl;\tint a2 = 10;\tint b2 = a2++ * 10; //a2此时仍为10,b2计算完后，a2+1 为11\tcout &lt;&lt; &quot;a2 = &quot; &lt;&lt; a2 &lt;&lt; endl;\tcout &lt;&lt; &quot;b2 = &quot; &lt;&lt; b2 &lt;&lt; endl;&#125;\n\n\n\n10. 逻辑运算符\n\n\n运算符\n术语\n示例\n结果\n\n\n\n！\n非\n！a\na为假，则 !a 为真\n\n\n&amp;&amp;\n与\na &amp;&amp; b\n有假则假，全真为真\n\n\n||\n或\na || b\n有真则真，全假为假\n\n\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void main()&#123;\tint a = 1;\tint b = 0;\tint c = 1;\tint d = 0;\t//逻辑非\tcout &lt;&lt; &quot;!a = &quot; &lt;&lt; !a &lt;&lt; endl;\tcout &lt;&lt; &quot;!!a = &quot; &lt;&lt; !!a &lt;&lt; endl;\t//逻辑与\tcout &lt;&lt; &quot;a &amp;&amp; b = &quot; &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;\tcout &lt;&lt; &quot;a &amp;&amp; c = &quot; &lt;&lt; (a &amp;&amp; c) &lt;&lt; endl;\t//逻辑或\tcout &lt;&lt; &quot;a || b = &quot; &lt;&lt; (a || b) &lt;&lt; endl;\tcout &lt;&lt; &quot;a || c = &quot; &lt;&lt; (a || c) &lt;&lt; endl;\tcout &lt;&lt; &quot;b || d = &quot; &lt;&lt; (b || d) &lt;&lt; endl;&#125;\n\n\n\n\n\n3. 程序流程结构三种基本结构： 顺序结构，选择结构，循环结构\n\n顺序结构：程序按顺序执行，不发生跳转\n选择结构：依据条件是否满足，有选择的执行相应功能\n循环结构：依据条件是否满足，循环多次执行某段代码\n\n1. 选择结构1.1 if 语句1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;void main()&#123;\tint enterValue;\tcout &lt;&lt; &quot;Please enter value : &quot; &lt;&lt; endl;\tcin &gt;&gt; enterValue;\tcout &lt;&lt; &quot;Your enter value is : &quot; &lt;&lt; enterValue &lt;&lt; endl;\tif (enterValue &gt;= 650)\t&#123;\t\tcout &lt;&lt; &quot;You are so good !&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;You can do it !&quot; &lt;&lt; endl;\t&#125;&#125;\n\n\n\n1.2 多条件if语句12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;void main()&#123;\tint value;\tcout &lt;&lt; &quot;Please enter value : &quot; &lt;&lt; endl;\tcin &gt;&gt; value;\tcout &lt;&lt; &quot;Your enter value is : &quot; &lt;&lt; value &lt;&lt; endl;\tif (value &gt;= 650)\t&#123;\t\tcout &lt;&lt; &quot;You are A !&quot; &lt;&lt; endl;\t&#125;\telse if (value &gt;= 550)\t&#123;\t\tcout &lt;&lt; &quot;You are B !&quot; &lt;&lt; endl;\t&#125;\telse if (value &gt;= 450)\t&#123;\t\tcout &lt;&lt; &quot;You are C !&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;You are D !&quot; &lt;&lt; endl;\t&#125;&#125;\n\n\n\n1.3 嵌套if语句12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;void main()&#123;\tint value;\tcout &lt;&lt; &quot;Please enter value : &quot; &lt;&lt; endl;\tcin &gt;&gt; value;\tcout &lt;&lt; &quot;Your enter value is : &quot; &lt;&lt; value &lt;&lt; endl;\tif (value &gt;= 650)\t&#123;\t\tif (value &gt;= 750)\t\t&#123;\t\t\tcout &lt;&lt; &quot;You are S !&quot; &lt;&lt; endl;\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;You are A !&quot; &lt;&lt; endl;\t\t&#125;\t&#125;\telse if (value &gt;= 450)\t&#123;\t\tcout &lt;&lt; &quot;You are C !&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;You are D !&quot; &lt;&lt; endl;\t&#125;&#125;\n\n\n\n1.4 案列\n分别给a，b，c三个赋int值；判断最大的值，并打印\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;;using namespace std;void main()&#123;\tint a, b, c;\tcout &lt;&lt; &quot;Please enter a value : &quot; &lt;&lt; endl;\tcin &gt;&gt; a;\tcout &lt;&lt; &quot;Please enter b value : &quot; &lt;&lt; endl;\tcin &gt;&gt; b;\tcout &lt;&lt; &quot;Please enter c value : &quot; &lt;&lt; endl;\tcin &gt;&gt; c;\tcout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\tcout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;\tif (a &gt; b) //如果a 比 b 大，则 a 继续与 c 比较\t&#123;\t\tif (a &gt; c) //如果a 比 c 大，则 a 最大\t\t&#123;\t\t\tcout &lt;&lt; &quot;Max value is a = &quot; &lt;&lt; a &lt;&lt; endl;\t\t&#125;\t\telse //否则 c 最大\t\t&#123;\t\t\tcout &lt;&lt; &quot;Max value is c = &quot; &lt;&lt; c &lt;&lt; endl;\t\t&#125;\t&#125;\telse //如果b 比 a 大，则 b 继续与 c 比较\t&#123;\t\tif (b &gt; c) //如果b 比 c 大，则 b 最大\t\t&#123;\t\t\tcout &lt;&lt; &quot;Max value is b = &quot; &lt;&lt; b &lt;&lt; endl;\t\t&#125;\t\telse //否则 c 最大\t\t&#123;\t\t\tcout &lt;&lt; &quot;Max value is c = &quot; &lt;&lt; c &lt;&lt; endl;\t\t&#125;\t&#125;&#125;\n\n\n\n1.5 三目运算符\n作用：通过三目运算符实现简单的判断\n语法：表达式a ？表达式b ：表达式c\n解释：\na为真，执行b，并返回b的结果；\na为假，执行c，并返回c的结果；\n\n\n\n1234567891011121314151617#include &lt;iostream&gt;using namespace std;void main()&#123;\tint a = 10, b = 20;\tint c;\t\tc = (a &gt; b ? a : b);\tcout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\t//三目运算符表达式返回的是 变量，所以可以直接作为左值被赋值；\t(a &lt; b ? a : b) = 100;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; &#125;\n\n\n\n1.6 switch语句\n语法：\n\n12345678910111213switch (表达式)&#123;    case 结果1:    执行语句;    break；    case 结果1:    执行语句;    break；    ...    default:    执行语句;    break；&#125;\n\n\n注意：\nswitch语句的表达式类型只能是整型或字符型；\ncase后没有break语句，程序会一直向下执行；\n\n\n123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;void main()&#123;\tint value;\tcout &lt;&lt; &quot;Enter int value : &quot; &lt;&lt; endl;\tcin &gt;&gt; value;\tswitch (value)\t&#123;\tcase 10:\t\tcout &lt;&lt; &quot;Return S&quot; &lt;&lt; endl;\t\tbreak;\tcase 9:\t\tcout &lt;&lt; &quot;Return A&quot; &lt;&lt; endl;\t\tbreak;\tcase 8:\t\tcout &lt;&lt; &quot;Return A&quot; &lt;&lt; endl;\t\tbreak;\tcase 7:\t\tcout &lt;&lt; &quot;Return B&quot; &lt;&lt; endl;\t\tbreak;\tcase 6:\t\tcout &lt;&lt; &quot;Return B&quot; &lt;&lt; endl;\t\tbreak;\tcase 5:\t\tcout &lt;&lt; &quot;Return C&quot; &lt;&lt; endl;\t\tbreak;\tcase 4:\t\tcout &lt;&lt; &quot;Return C&quot; &lt;&lt; endl;\t\tbreak;\tdefault:\t\tcout &lt;&lt; &quot;Return D&quot; &lt;&lt; endl;\t\tbreak;\t&#125;&#125;\n\n\n\n\n\n2. 循环结构2.1 while循环\n作用：满足判断条件，执行循环语句\n\n语法：\n1234while (判断条件)&#123;\t循环语句;&#125;\n\n案列：\n123456789101112131415#include &lt;iostream&gt;using namespace std;void main()&#123;\tint num = 0;\twhile (num &lt; 10)\t&#123;\t\tcout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\t\tnum++;\t&#125;&#125;\n\n2.2 while案列\n随机生成 1 - 100 的数字，控制台输入数字，正确结束，错误则判断过大还是过小，直到正确为止（限定判断10次）。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;time.h&gt; //使用随机种子需要添加的头文件using namespace std;void main()&#123;\tint randNum;\tint enterNum;\tint countNum = 0;\t//通过系统实时的时间作为当前随机数的随机种子\tsrand((unsigned int)time(NULL));\t//此时的randNum为真随机\trandNum = rand() % 100 + 1;\t//每循环一次 countNum 加 1 ；为真继续执行，为假直接结束\twhile (countNum &lt; 10) \t&#123;\t\t//显示当前执行的次数\t\tcout &lt;&lt; &quot;******** &quot; &lt;&lt; countNum + 1 &lt;&lt; &quot; ********&quot; &lt;&lt; endl; \t\tcout &lt;&lt; &quot;Enter Num : &quot;;\t\tcin &gt;&gt; enterNum;\t\tif (enterNum &gt; randNum)\t\t&#123;\t\t\tcout &lt;&lt; &quot;enter num is to big !\\n&quot; &lt;&lt; endl;\t\t\tcountNum++; //只要enterNum != randNum 则 countNum 加 1\t\t&#125;\t\telse if (enterNum &lt; randNum)\t\t&#123;\t\t\tcout &lt;&lt; &quot;enter num is to small !\\n&quot; &lt;&lt; endl;\t\t\tcountNum++;\t\t&#125;\t\telse \t\t&#123;\t\t\tcout &lt;&lt; &quot;enter num is true !&quot; &lt;&lt; endl;\t\t\tbreak; //enterNum == randNum 则 结束\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;\\nTrue num is : &quot; &lt;&lt; randNum &lt;&lt; endl; //while 结束后 显示正确的随机数值&#125;\n\n2.3 do…while 语句\n作用：先执行循环语句，再满足判断条件，执行循环语句\n\n注意：do…while 与 while的区别在于，do…while 先执行一次循环语句，再判断条件是否满足继续执行\n\n语法：\n1234do&#123;    循环语句;&#125;while (循环条件);\n\n123456789101112131415#include &lt;iostream&gt;using namespace std;void main()&#123;\tint num = 0;\tdo\t&#123;\t\tcout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\t\tnum++;\t&#125; while (num &lt; 10);&#125;\n\n2.4 水仙花案列\n说明：一个三位的整数满足每一位的三次方的和依旧等于这个三位数 （do … while）\n123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void main()&#123;\tint dNum = 100; //最小的三位数\tdo\t&#123;\t\tdouble a, b, c, d; // a为百位，b为十位，c为个位，d为 a b c三次方的和\t\t//pow(x, y) == x 的 y 次方\t\ta = pow(dNum / 100, 3);\t\tb = pow(dNum / 10 % 10, 3);\t\tc = pow(dNum % 10, 3);\t\td = a + b + c;\t\t//判断当前的三位数是不是水仙花数\t\tif (d == dNum)\t\t&#123;\t\t\t//条件为真时 打印水仙花数\t\t\tcout &lt;&lt; dNum &lt;&lt; endl;\t\t&#125;\t\tdNum++; //每当while条件满足都执行一遍\t&#125; while (dNum &lt; 1000); //判断当前是否是三位数&#125;\n\n2.5 for 循环\n作用：满足条件，执行语句\n\n语法：\n1234for (起始表达式; 循环条件; 循环体)&#123;\t循环语句;&#125;\n\n1234567891011#include &lt;iostream&gt;using namespace std;void main()&#123;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tcout &lt;&lt; i &lt;&lt; endl;\t&#125;&#125;\n\n2.6 for 循环案列\n说明：1 - 100 的区间数字，满足 各位 或 十位 或 倍数 与 7 有关，打印 yes，其余直接打印数字；\n12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void main()&#123;\tfor (int i = 1; i &lt;= 100; i++) //循环打印 1 - 100 \t&#123;\t\t//判断遍历的数字是否满足条件\t\tif (i % 10 == 7 || i / 10 % 10 == 7 || i % 7 == 0)\t\t&#123;\t\t\tcout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; //满足调件打印 yes\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; i &lt;&lt; endl; //不满足条件打印 原数字\t\t&#125;\t&#125;&#125;\n\n2.7 嵌套循环\n作用：在循环语句内再添加循环，解决实际问题\n\n描述：打印 10*10 的矩阵\n123456789101112131415 #include &lt;iostream&gt;using namespace std;void main()&#123;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tfor (int j = 0; j &lt; 10; j++)\t\t&#123;\t\t\tcout &lt;&lt; &quot;* &quot;;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;&#125;\n\n2.8 乘法表案列\n描述：打印乘法表\n123456789101112131415#include &lt;iostream&gt;using namespace std;void main()&#123;\tfor (int h = 1; h &lt;= 9; h++) //行数\t&#123;\t\tfor (int v = 1; v &lt;= h; v++) //列数，但不超过行数\t\t&#123;\t\t\tcout &lt;&lt; v &lt;&lt; &quot; * &quot; &lt;&lt; h &lt;&lt; &quot;\t&quot;; //结果为 列数*行数=\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;&#125;\n\n3. 跳转语句3.1 break语句\n作用：用于跳出选择结构或者循环结构\n使用：\n出现在switch语句中，终止case并跳出switch；\n出现在循环语句中，跳出循环；\n出现在嵌套循环中，跳出内层循环；\n\n\n\n3.2 continue语句\n作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一循环\n\n1234567891011121314151617#include &lt;iostream&gt;using namespace std;void main()&#123;\t//从1 -100 遍历100次\tfor (int i = 1; i &lt;= 100; i++)\t&#123;\t\t//如果i 为偶数，则跳过当前循环，执行下一次遍历\t\tif (i % 2 == 0)\t\t&#123;\t\t\tcontinue;\t\t&#125;\t\tcout &lt;&lt; i &lt;&lt; endl;\t&#125;&#125;\n\n\n\n3.3 goto语句\n作用：无条件跳转语句\n语法：goto 标记;\n解释：程序执行到goto时，如果标记存在，怎直接跳转到标记处，并继续执行\n\n123456789101112131415161718#include &lt;iostream&gt;using namespace std;void main()&#123;\tcout &lt;&lt; &quot;S&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;A&quot; &lt;&lt; endl;\tgoto GotoTarget; //此处的 goto 语句标记为 GotoTarget\tcout &lt;&lt; &quot;B&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;C&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;D&quot; &lt;&lt; endl;\tGotoTarget: //程序直接跳转至此处，并继续向下执行\tcout &lt;&lt; &quot;E&quot; &lt;&lt; endl;&#125;\n\n\n\n\n\n4. 数组解释：数组就是相同类型数据的元素集合\n特点：\n\n元素类型相同\n数组由连续的内存位置组成\n\n注意：\n\n数组的命名不要和其他变量名重名\n数组的索引从下标0开始\n\n1. 一维数组1.1 一维数组的定义\n数据类型 数组名[数组长度];\n\n数据类型 数组名[数组长度] &#x3D; {元素1，元素2，…..};\n\n数据类型 数组名[] &#x3D; {元素1，元素2，…..};\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;void main()&#123;\t//1. 数据类型 数组名[数组长度];\tcout &lt;&lt; &quot;数据类型 数组名[数组长度]&quot; &lt;&lt; endl;\tint arr1[3];\tarr1[0] = 1;\tarr1[1] = 2;\tarr1[2] = 3;\t\tfor (int i = 0; i &lt; 3; i++)\t&#123;\t\tcout &lt;&lt; arr1[i] &lt;&lt; &quot;  &quot;;\t&#125;\tcout &lt;&lt; endl;\t//2. 数据类型 数组名[数组长度] = &#123;元素1，元素2，.....&#125;;\tcout &lt;&lt; &quot;数据类型 数组名[数组长度] = &#123;元素1，元素2，.....&#125;&quot; &lt;&lt; endl;\tint arr2[3] = &#123; 1, 2, 4 &#125;;\t\tfor (int j = 0; j &lt; 3; j++)\t&#123;\t\tcout &lt;&lt; arr2[j] &lt;&lt; &quot;  &quot;;\t&#125;\tcout &lt;&lt; endl;\t//3. 数据类型 数组名[] = &#123;元素1，元素2，.....&#125;;\tcout &lt;&lt; &quot;数据类型 数组名[] = &#123;元素1，元素2，.....&#125;&quot; &lt;&lt; endl;\tint arr3[] = &#123;1, 2, 3&#125;;\tfor (int k = 0; k &lt; 3; k++)\t&#123;\t\tcout &lt;&lt; arr1[k] &lt;&lt; &quot;  &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n1.2 一维数组名作用作用：\n\n可以统计整个数组在内存中的长度\n\n可以获取数组在内存中的首地址\n\n可以获取数组元素的个数\n12345678910111213141516#include &lt;iostream&gt;using namespace std;void main()&#123;\tint arr[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;\tcout &lt;&lt; &quot;arr数组占用的内存空间：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组单个元素占用空间：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组的元素个数：&quot; &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组的首地址：&quot; &lt;&lt; (int)arr &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组第一元素的地址：&quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组第二元素的地址：&quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\tcout &lt;&lt; &quot;arr数组最后元素的地址：&quot; &lt;&lt; (int)&amp;arr[sizeof(arr) / sizeof(arr[0])] &lt;&lt; endl;&#125;\n\n1.3 一维数组案列\n案列1：在给定的数组中，打印其中最大的元素；\n123456789101112131415161718#include &lt;iostream&gt;using namespace std;void main()&#123;\tint arr[] = &#123; 100, 200, 500, 300, 999, 1000, 888888 &#125;;\tint maxEle = arr[0]; //默认将数组中第一个元素作为最大值，存入maxEle\tfor (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++)\t&#123;\t\tif (arr[i + 1] &gt; maxEle) //将后一位的元素与默认的元素值进行比较\t\t&#123;\t\t\tmaxEle = arr[i + 1]; //如果后一位大于前一位，将后一位的值作为默认值存入maxEle\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;Max element is : &quot; &lt;&lt; maxEle &lt;&lt; endl;&#125;\n\n\n\n案列2：将一个给定的数组，反向排列；\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;void main()&#123;\tint arr[] = &#123; 1, 3, 2, 5, 4&#125;;\tint arrIndex = 0; //定义一个数组首元素的下标\tint arrEnd = sizeof(arr) / sizeof(arr[0]) - 1; //定义数组末元素的下标\tint arrTemp; //定义一个临时数组元素的下标\tcout &lt;&lt; &quot;逆向前: &quot;;\tfor (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++)\t&#123;\t\tcout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\twhile (arrIndex &lt;= arrEnd) //当首元素下标 &lt;= 末元素下标时才执行\t&#123;\t\t//互换两个下标元素的值\t\tarrTemp = arr[arrIndex];\t\tarr[arrIndex] = arr[arrEnd];\t\tarr[arrEnd] = arrTemp;\t\t//首元素下标加1\t\tarrIndex++;\t\t//末元素下标减1\t\tarrEnd--;\t&#125;\tcout &lt;&lt; &quot;逆向后: &quot;;\tfor (int j = 0; j &lt; sizeof(arr) / sizeof(arr[0]); j++)\t&#123;\t\tcout &lt;&lt; arr[j] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n1.4 冒泡排序法作用：常用的排序算法，将数组内的元素进行排序\n原理：\n\n比较相邻的元素，如果第一个比第二个大，就互换它们的位置\n\n对每一个相邻的两个元素进行这种比较，找到一个最大值\n\n重复执行，每次执行后次数 -1\n123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;void main()&#123;\tint arr[] = &#123; 5, 6, 3, 0, 4, 1, 2, 9, 7, 8 &#125;;\tint arrtemp;\tcout &lt;&lt; &quot;排序前：&quot;;\tfor (int a = 0; a &lt; sizeof(arr) / sizeof(arr[0]); a++)\t&#123;\t\tcout &lt;&lt; arr[a] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tfor (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]) - 1; i++) //排序的论数 = 数组元素个数 - 1\t&#123;\t\tfor (int j = 0; j &lt; sizeof(arr) / sizeof(arr[0]) - i - 1; j++) //每轮排序的次数 = 数组元素个数 - 排序的论数 -1\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1]) //每排序一次，满足条件就执行一次互换位置\t\t\t&#123;\t\t\t\tarrtemp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = arrtemp;\t\t\t&#125;\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;排序后：&quot;;\tfor (int b = 0; b &lt; sizeof(arr) / sizeof(arr[0]); b++)\t&#123;\t\tcout &lt;&lt; arr[b] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n2. 二维数组\n二维数组就是在一维数组的基础上增加一个维度\n\n2.1 二维数组的定义四种定义方式：\n\n数据类型 数组名 [行数] [列数]；\n数据类型 数组名 [行数] [列数] &#x3D; ｛｛数据1，数据2｝，｛数据3，数据4｝｝；\n数据类型 数组名 [行数] [列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n数据类型 数组名 [] [列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n\n第二种更直观，可读性更高\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;void main()&#123;\t//1. 数据类型 数组名[行数][列数]；\tint arr1[2][3];\t\tarr1[0][0] = 1;\tarr1[0][1] = 2;\tarr1[0][2] = 3;\tarr1[1][0] = 4;\tarr1[1][1] = 5;\tarr1[1][2] = 6;\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数]------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\tfor (int a = 0; a &lt; 2; a++)\t&#123;\t\tfor (int a1 = 0; a1 &lt; 3; a1++)\t\t&#123;\t\t\tcout &lt;&lt; arr1[a][a1] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\tcout &lt;&lt; endl;\t//2. 数据类型 数组名[行数][列数] = &#123;｛数据1，数据2｝，｛数据3，数据4｝&#125;；\tint arr2[2][3] =\t&#123;\t\t&#123;1, 2, 3&#125;,\t\t&#123;4, 5, 6&#125;\t&#125;;\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数] = &#123;｛数据1，数据2｝，｛数据3，数据4｝&#125;------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\tfor (int b = 0; b &lt; 2; b++)\t&#123;\t\tfor (int b1 = 0; b1 &lt; 3; b1++)\t\t&#123;\t\t\tcout &lt;&lt; arr2[b][b1] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\tcout &lt;&lt; endl;\t//3. 数据类型 数组名[行数][列数] = ｛数据1，数据2，数据3，数据4｝；\tint arr3[2][3] = &#123; 1, 2, 3, 4, 5, 6 &#125;;\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数] = ｛数据1，数据2，数据3，数据4｝------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\tfor (int c = 0; c &lt; 2; c++)\t&#123;\t\tfor (int c1 = 0; c1 &lt; 3; c1++)\t\t&#123;\t\t\tcout &lt;&lt; arr3[c][c1] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\tcout &lt;&lt; endl;\t//4. 数据类型 数组名[][列数] = ｛数据1，数据2，数据3，数据4｝；\tint arr4[][3] = &#123; 1, 2, 3, 4, 5, 6 &#125;;\tcout &lt;&lt; &quot;------数据类型 数组名[][列数] = ｛数据1，数据2，数据3，数据4｝------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\tfor (int d = 0; d &lt; 2; d++)\t&#123;\t\tfor (int d1 = 0; d1 &lt; 3; d1++)\t\t&#123;\t\t\tcout &lt;&lt; arr4[d][d1] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n\n\n2.2 二维数组名作用\n查看二维数组所占空间\n\n查看二维数组的首地址\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void main()&#123;\tint arr[2][3] =\t&#123;\t\t&#123;1, 2, 3&#125;,\t\t&#123;4, 5, 6&#125;\t&#125;;\tcout &lt;&lt; &quot;二维数组的大小：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组一行的大小：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组元素的大小：&quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组的行数：&quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组的列数：&quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;\tcout &lt;&lt; &quot;*************************&quot; &lt;&lt; endl;\t//地址\tcout &lt;&lt; &quot;二维数组的首地址：&quot; &lt;&lt; (int)arr &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组第一行的地址：&quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组第二行的地址：&quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组第一个元素的地址：&quot; &lt;&lt; (int)&amp;arr[0][0] &lt;&lt; endl;\tcout &lt;&lt; &quot;二维数组第二个元素的地址：&quot; &lt;&lt; (int)&amp;arr[0][1] &lt;&lt; endl;&#125;\n\n2.3 二维数组案列\n分别输出二维数组每一行的数值总和\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void main()&#123;\tint num[3][3] =\t&#123;\t\t&#123;100, 100, 100&#125;,\t\t&#123;80, 70, 60&#125;,\t\t&#123;10, 100, 90&#125;\t&#125;;\tstring name[] = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;\tfor (int i = 0; i &lt; 3; i++)\t&#123;\t\tint sum = 0;\t\tfor (int j = 0; j &lt; 3; j++)\t\t&#123;\t\t\tsum += num[i][j];\t\t&#125;\t\tcout &lt;&lt; name[i] &lt;&lt; &quot; = &quot; &lt;&lt; sum &lt;&lt; endl;\t&#125;&#125;\n\n5. 函数作用：\n\n将一段经常使用的可复用性代码封装起来，作为一个函数，可重复调用\n一个较大的程序，一般分为多个执行程序模块，每个模块执行特定的功能\n\n1. 函数基础\n返回值类型\n函数名\n参数列表\n函数体语句\nreturn表达式\n\n1.1 函数语法12345返回值类型 函数名 （参数列表）&#123;    函数体语句；    return 表达式；&#125;\n\n\n\n1.2 函数定义案列实现一个加法函数，通过传入两个整型数据，返回加法计算结果\n12345678910111213141516#include &lt;iostream&gt;using namespace std;void main()&#123;&#125;int add(int num1, int num2)&#123;\tint sum;\tsum = num1 + num2;\treturn sum;&#125;\n\n\n\n1.3 函数的调用功能：使用定义好的函数\n语法：函数名（参数）；\n12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int add(int num1, int num2)&#123;\tint sum = num1 + num2;\treturn sum;&#125;void main()&#123;\tint a = 10;\tint b = 20;\tint c;\tc = add(10, 20);\t\tcout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; c &lt;&lt; endl;&#125;\n\n\n\n1.4 函数值传递\n函数调用时实参将数值传入形参\n\n值传递时，形参发生变化，不影响实参\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;void swap(int num1, int num2)&#123;\tcout &lt;&lt; &quot;值传递前：&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;\tcout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;\tcout &lt;&lt; &quot;***************&quot; &lt;&lt; endl;\tint temp;\ttemp = num1;\tnum1 = num2;\tnum2 = temp;\tcout &lt;&lt; &quot;值传递后：&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;\tcout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;\tcout &lt;&lt; &quot;***************&quot; &lt;&lt; endl;&#125;void main()&#123;\tint a = 10;\tint b = 20;\tcout &lt;&lt; &quot;最先执行main中传递前 a值 和 b值&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; &quot;***************&quot; &lt;&lt; endl;\tswap(a, b);\tcout &lt;&lt; &quot;最后执行main中传递后 a值 和 b值&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;\n\n1.5 函数的常见样式类型：\n\n无参无返\n有参无返\n无参有返\n有参有返\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;//1. 无参无返void demo1()&#123;\tcout &lt;&lt; &quot;无参无返&quot; &lt;&lt; endl;&#125;//2. 有参无返void demo2(string str)&#123;\tcout &lt;&lt; str &lt;&lt; endl;&#125;//3. 无参有返string demo3()&#123;\tcout &lt;&lt; &quot;无参有返&quot; &lt;&lt; endl;\treturn &quot;无参有返&quot;;&#125;//4. 有参有返string demo4(string str)&#123;\tcout &lt;&lt; &quot;有参有返&quot; &lt;&lt; endl;\treturn str;&#125;void main()&#123;\t//1. 无参无返\tdemo1();\t//2. 有参无返\tdemo2(&quot;有参无返&quot;);\t//3. 无参有返\tdemo3();\t//4. 有参有返\tdemo4(&quot;有参有返&quot;);&#125;\n\n\n\n1.6 函数的声明\n作用：\n​\t告诉编辑器函数的名称以及如何调用函数，函数的实际主体可以单独定义\n​\t在main之前声明函数，函数主体的定义可以写在main之后，没有提前声明，函数只能定义在main之前\n\n注意：函数可以声明多次，但函数的定义只能一次\n1234567891011121314151617#include &lt;iostream&gt;using namespace std;//提前声明函数，函数主体就可以定义到main后面int maxValue(int a, int b);void main()&#123;\tcout &lt;&lt; &quot;MaxValue = &quot; &lt;&lt; maxValue(10, 20) &lt;&lt; endl;&#125;//有了提前声明，此时，函数主体就可以定义到main后面int maxValue(int a, int b)&#123;\treturn a &gt; b ? a : b;&#125;\n\n1.7 函数的分文件编写作用：\n\n让项目的代码更加清晰，可读性和维护性更高\n\n步骤：\n\n创建后缀名为 .h 的头文件\n创建后缀名为 .cpp 的源文件\n在头文件中写函数的声明\n在源文件中写函数的定义\n在main中调用函数源文件中的函数\n\n示例：\n\n头文件\n12345#include &lt;iostream&gt;using namespace std;void swap(int a, int b);\n\n\n\n函数源文件\n123456789101112131415161718#include &quot;swap.h&quot;void swap(int a, int b)&#123;\tcout &lt;&lt; &quot;转换前：&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; &quot;******************&quot; &lt;&lt; endl;\tint temp;\ttemp = a;\ta = b;\tb = temp;\tcout &lt;&lt; &quot;转换后：&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;\n\n\n\nmain文件\n123456789#include &lt;iostream&gt;#include &quot;swap.h&quot;using namespace std;void main()&#123;\tswap(10, 20);&#125;\n\n1.8 头源 main文件头文件：\n1234567891011121314151617181920212223// 头文件中写入main函数需要用到的库以及函数的定义（明确函数的参数类型）#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#ifndef DEMO_FEATURE_H#define DEMO_FEATURE_Hstruct personInfo&#123;    string name;    int age;&#125;;void printHello();int sumNum(int a, int b);void returnInfo(personInfo *s_per);#endif //DEMO_FEATURE_H\n\n源文件：\n1234567891011121314151617181920// 源文件内写函数的具体内容// 导入相关联的头文件#include &quot;feature.h&quot;void printHello()&#123;    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;&#125;int sumNum(int a, int b)&#123;    int c = a + b;    return c;&#125;void returnInfo(personInfo *s_per)&#123;    cout &lt;&lt; &quot;name: &quot; &lt;&lt; s_per-&gt;name &lt;&lt; &quot; age: &quot; &lt;&lt; s_per-&gt;age &lt;&lt; endl;&#125;\n\nmain文件：\n12345678910111213141516171819// 导入需要的头文件#include &quot;cmake-build-debug/feature.h&quot;int main()&#123;    // 无返回值函数    printHello();    // 有返回值函数    int sum;    sum = sumNum(10, 20);    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;    // 参数为结构体的函数    personInfo s_per = &#123;&quot;FH&quot;, 22&#125;;    returnInfo(&amp;s_per);    return 0;&#125;\n\n\n\n\n\n6. 指针1. 指针概念作用：\n\n可通过指针间接访问内存\n\n注意：\n\n内存编号从0开始记录，一般用16进制数字表示\n可利用指针变量保存地址\n\n2. 指针变量的定义和使用\n语法：\n数据类型* 指针变量名 &#x2F;&#x2F;定义指针\n指针变量名 = &amp;变量名 &#x2F;&#x2F;将定义的变量存储的内存地址给指针\n*指针变量名 = 值或变量名 &#x2F;&#x2F;通过指针间接的读写指向地址的值\n\n示例：\n1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;  void main()  &#123;  \tint a = 10;   \t//定义一个指针变量  \tint* p_a;  \t  \t//将变量a的地址给指针  \tp_a = &amp;a;  \t//查看两个变量的地址  \tcout &lt;&lt; &quot;a address is &quot; &lt;&lt; &amp;a &lt;&lt; endl;  \tcout &lt;&lt; &quot;p_a &#x27;s value is &quot; &lt;&lt; p_a &lt;&lt; endl;  \tcout &lt;&lt; &quot;****************&quot; &lt;&lt; endl;  \t//通 *指针变量名 = 值 可以间接读写内存地址内的值  \t*p_a = 1000;  \tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;  \tcout &lt;&lt; &quot;p_a = &quot; &lt;&lt; *p_a &lt;&lt; endl;  &#125;\n\n3. 指针占用的内存空间\n说明：\n32位操作系统：指针占用4个字节\n64位操作系统：指针占用8个字节\n1234567891011121314151617#include &lt;iostream&gt;  using namespace std;  void main()&#123;  \tint a = 10;  \tint* p_a = &amp;a;    \tcout &lt;&lt; &quot;sizeof (p_a) = &quot; &lt;&lt; sizeof(p_a) &lt;&lt; endl;  \tcout &lt;&lt; &quot;sizeof (int*) = &quot; &lt;&lt; sizeof(int*) &lt;&lt; endl;  \tcout &lt;&lt; &quot;sizeof (float*) = &quot; &lt;&lt; sizeof(float*) &lt;&lt; endl;  \tcout &lt;&lt; &quot;sizeof (double*) = &quot; &lt;&lt; sizeof(double*) &lt;&lt; endl;  \tcout &lt;&lt; &quot;sizeof (bool*) = &quot; &lt;&lt; sizeof(bool*) &lt;&lt; endl;  \tcout &lt;&lt; &quot;sizeof (char*) = &quot; &lt;&lt; sizeof(char*) &lt;&lt; endl;  \tcout &lt;&lt; &quot;sizeof (string*) = &quot; &lt;&lt; sizeof(string*) &lt;&lt; endl;&#125;\n\n4. 空指针和野指针4.1 空指针\n空指针：指针变量指向内存中编号为0的空间\n\n用途：初始化指针变量\n\n空指针指向的内存空间是不可访问的（0-255是系统占用的）\n12345678910111213141516#include &lt;iostream&gt;using namespace std;void main()&#123;\t//指针变量指向内存中编号为0的空间\t//初始化指针变量\tint* p = NULL;\t//空指针指向的内存空间是不可访问的（0 - 255是系统占用的）\tcout &lt;&lt; p &lt;&lt; endl;\t*p = 10; //提示该句无效\tcout &lt;&lt; p &lt;&lt; endl; //什么都没有&#125;\n\n4.2 野指针\n野指针：指向非法的内存空间\n\n注意：程序中尽量避免出现野指针\n123456789#include &lt;iostream&gt;using namespace std;void main()&#123;\tint* p = (int*)0x1100;\tcout &lt;&lt; *p &lt;&lt; endl; //打印指针指向的内存值无效&#125; \n\n5. const修饰指针\n三种情况：\n\nconst修饰指针 –常量指针\nconst修饰常量 –指针常量\nconst即修饰指针又修饰常量\n\n\n示例：\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void main()&#123;\tint a = 10;\tint b = 20;\t//1. const修饰指针 --常量指针\tconst int* p = &amp;a; // =&gt; const *p (常量指针)\t*p = b; //错误：指针指向的内存空间值不能修改\tp = &amp;b; //指针的地址编号可以改\t//2. const修饰常量 --指针常量\tint* const p1 = &amp;a; // =&gt; const p1 (指针常量)\t*p1 = b; //指针指向的内存空间的值可以修改\tp1 = &amp;b; //错误：指针的地址编号不能修改\t//3. const即修饰指针又修饰常量\tconst int* const p2 = &amp;a;\t*p2 = b; //错误：指针指向的内存空间值不能修改\tp2 = &amp;b; //错误：指针的地址编号不能修改&#125;\n\n6. 指针和数组\n利用指针访问数组中的元素\n12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void main()&#123;\tint arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\tint* p = arr;\tcout &lt;&lt; &quot;arr[0] = &quot; &lt;&lt; arr[0] &lt;&lt; endl;\tcout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;\tfor (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++)\t&#123;\t\tcout &lt;&lt; *p &lt;&lt; endl;\t\tcout &lt;&lt; p &lt;&lt; endl; //每次遍历的内存地址\t\tp++;//*p 是指针指向内存空间的值，p 是内存地址，p++ 内存地址向后移8个单位（64位）4个单位（32位）\t&#125;&#125;\n\n7. 指针和函数\n利用指针作为函数的实参，可以修改传入函数的实参值\n12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;void swap(int* p1, int* p2) //将指针指向内存的值进行调换&#123;\tint temp = *p1;\t*p1 = *p2;\t*p2 = temp;\t//此时 &amp;a &amp;b 的地址没变，但地址内存的值变了&#125;void main()&#123;\tint a = 10;\tint b = 20;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tswap(&amp;a, &amp;b);\tcout &lt;&lt; &quot;swap a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;swap b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;\n\n8. 指针 数组 函数\n案列：封装一个函数，用冒泡排序，实现对整型数组的升序排序\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;void upSort(int* arrIndex, int arrlength)&#123;\tfor (int i = 0; i &lt; arrlength - 1; i++)\t&#123;\t\tfor (int j = 0; j &lt; arrlength - i - 1; j++)\t\t&#123;\t\t\tif (arrIndex[j] &gt; arrIndex[j + 1])\t\t\t&#123;\t\t\t\tint temp = arrIndex[j];\t\t\t\tarrIndex[j] = arrIndex[j + 1];\t\t\t\tarrIndex[j + 1] = temp;\t\t\t&#125;\t\t&#125;\t&#125;&#125;void printArray(int* arrIndex, int arrLength)&#123;\tfor (int i = 0; i &lt; arrLength; i++)\t&#123;\t\tcout &lt;&lt; arrIndex[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;void main()&#123;\tint arr[] = &#123;4, 3, 2, 1, 8, 6, 9, 5, 7, 0&#125;;\tint arrLength = sizeof(arr) / sizeof(arr[0]);\tprintArray(arr, arrLength);\tupSort(arr, arrLength);\tprintArray(arr, arrLength);&#125;\n\n9. 指针补充1234567int *p;// 指针数组，数组里面可以存放3个int*int *arr1[3] = &#123;p, p, p&#125;;// 用于指向数组的指针int (*arr2)[3];\n\n\n\n\n\n\n\n7. 结构体1. 结构体基本概念\n结构体属于用户自定义的数据类型，允许用户存储不同的数据类型\n\n2. 结构体定义和使用\n语法：struct 结构体名 ｛结构体成员列表&#125;;\n\n创建：\n\nstruct 结构体名 变量名；\nstruct 结构体名 &#x3D; ｛成员1值，成员2值，…};\n定义结构体时创建变量\n\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;//语法：struct 结构体名 ｛结构体成员列表｝；struct studentID&#123;\tstring name;\tint age;&#125;;void main()&#123;\t//1. struct 结构体名 变量名；\tstruct studentID s1;\ts1.age = 23;\ts1.name = &quot;FH&quot;;\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; s1.name &lt;&lt; &quot;  age: &quot; &lt;&lt; s1.age &lt;&lt; endl;\t//2. struct 结构体名 = ｛成员1值，成员2值，...｝；\tstruct studentID s2 = &#123;&quot;XX&quot;, 99&#125;;\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; s2.name &lt;&lt; &quot;  age: &quot; &lt;&lt; s2.age &lt;&lt; endl;\t&#125;\n\n3. 结构体数组\n作用：将自定义的结构体存入数组中方便管理\n\n语法：struct 结构体名 数组名[元素个数] = ｛｛｝，｛｝，... ，｛｝&#125;;\n1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;struct stuInfo&#123;\tstring name;\tint age;&#125;;void main()&#123;\tstruct stuInfo stuInfoArr[] =\t&#123;\t\t&#123;&quot;XX&quot;, 66&#125;,\t\t&#123;&quot;YY&quot;, 99&#125;\t&#125;;\t//修改结构体数组中第0个元素的值\tstuInfoArr[0] = &#123; &quot;FH&quot;, 23 &#125;;\t//修改结构体数组中第1个元素的值\tstuInfoArr[1].name = &quot;CYL&quot;;\tstuInfoArr[1].age = 22;\tfor (int i = 0; i &lt; sizeof(stuInfoArr) / sizeof(stuInfoArr[0]); i++)\t&#123;\t\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; stuInfoArr[i].name\t\t\t&lt;&lt; &quot;  Age: &quot; &lt;&lt; stuInfoArr[i].age\t\t\t&lt;&lt; endl;\t&#125;&#125; \n\n4. 结构体指针\n作用：通过指针访问或修改结构体中的成员\n\n利用操作符 -&gt; 可以通过结构体指针访问结构体属性\n1234567891011121314151617#include &lt;iostream&gt;using namespace std;struct stuInfo&#123;\tstring name;\tint age;&#125;;void main()&#123;\tstuInfo stu = &#123; &quot;FH&quot;, 23 &#125;;\tstuInfo* p_stu = &amp;stu;\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; p_stu-&gt;name &lt;&lt; &quot;  Age: &quot; &lt;&lt; p_stu-&gt;age &lt;&lt; endl;&#125;\n\n5. 结构体嵌套结构体\n作用：\n结构体中的成员可以是另一个结构体\n结构体中可以定义另一个结构体成员\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;struct stuInfo&#123;\tstring name;\tint age;&#125;;struct teaInfo&#123;\tstring name;\tint id;\tstruct stuInfo stu;&#125;;void main()&#123;\tstuInfo s1 = &#123; &quot;FH&quot;, 23 &#125;;\t//stuInfo s2 = &#123; &quot;CYL&quot;, 22 &#125;;\tteaInfo t1 = &#123; &quot;XX&quot;, 1001, s1&#125;;\t\tteaInfo t2;\tt2.name = &quot;YY&quot;;\tt2.id = 1002;\tt2.stu.name = &quot;CYL&quot;;\tt2.stu.age = 22;\tcout &lt;&lt; &quot;TeacherName: &quot; &lt;&lt; t1.name &lt;&lt; &quot;  TeacherID: &quot; &lt;&lt; t1.id \t\t&lt;&lt; &quot;  StudentName: &quot; &lt;&lt; s1.name &lt;&lt; &quot;  StudentAge: &quot; &lt;&lt; s1.age &lt;&lt; endl;\tcout &lt;&lt; &quot;TeacherName: &quot; &lt;&lt; t2.name &lt;&lt; &quot;  TeacherID: &quot; &lt;&lt; t2.id \t\t&lt;&lt; &quot;  StudentName: &quot; &lt;&lt; t2.stu.name &lt;&lt; &quot;  StudentAge: &quot; &lt;&lt; t2.stu.name &lt;&lt; endl;&#125;\n\n6. 结构体做函数参数\n作用：将结构体作为参数向函数中传递\n\n方式：\n\n值传递\n地址传递\n\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;struct stuInfo&#123;\tstring name;\tint age;&#125;;void printInfo(stuInfo s)&#123;\tcout &lt;&lt; &quot;Value Transfer: &quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;Modify Argument before: &quot;;\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; s.name &lt;&lt; &quot;  Age: &quot; &lt;&lt; s.age &lt;&lt; endl;\ts.age = 99;\tcout &lt;&lt; &quot;Modify Argument later: &quot;;\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; s.name &lt;&lt; &quot;  Age: &quot; &lt;&lt; s.age &lt;&lt; endl;&#125;void printInfo2(stuInfo* p_s1)&#123;\tcout &lt;&lt; &quot;Pointer Address Transfer: &quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;Modify Argument before: &quot;;\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; p_s1-&gt;name &lt;&lt; &quot;  Age: &quot; &lt;&lt; p_s1-&gt;age &lt;&lt; endl;\tp_s1-&gt;age = 99;\tcout &lt;&lt; &quot;Modify Argument later: &quot;;\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; p_s1-&gt;name &lt;&lt; &quot;  Age: &quot; &lt;&lt; p_s1-&gt;age &lt;&lt; endl;&#125;void main()&#123;\tstuInfo s = &#123;&quot;FH&quot;, 23&#125;;\tstuInfo p_s1 = &#123; &quot;CYL&quot;, 22 &#125;;\tprintInfo(s);\tcout &lt;&lt; &quot;====================&quot; &lt;&lt; endl;\tprintInfo2(&amp;p_s1);&#125;\n\n7. 结构体const应用\n作用：用const防止误操作\n123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;struct stuInfo&#123;\tstring name;\tint age;&#125;;void printInfo(const stuInfo* p_s)&#123;\t//p_s-&gt;age = 99; //const 限定修饰后的结构体 内存值不能被修改\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; p_s-&gt;name &lt;&lt; &quot;  Age: &quot; &lt;&lt; p_s-&gt;age &lt;&lt; endl;&#125;void main()&#123;\tstuInfo p_s = &#123;&quot;FH&quot;, 23&#125;;\tprintInfo(&amp;p_s);&#125;\n\n8. 结构体案列8.1 案列1\n描述：三位老师，每位老师下五名学生\n\n要求：设计老师，学生的结构体，老师结构体内有老师姓名和存放学生的数组；学生结构体内有姓名，年龄；创建数组存放老师；通过函数给老师及其下学生赋值，并打印\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;struct stuInfo&#123;\tstring name;\tint age;&#125;;struct teaInfo&#123;\tstring name;\tstuInfo sArr[5];&#125;;void noteValue(teaInfo tArr[], int tLength)&#123;\tstring nameSeed = &quot;ABCDE&quot;;\tfor (int i = 0; i &lt; tLength; i++)\t&#123;\t\ttArr[i].name = &quot;Tea_&quot;;\t\ttArr[i].name += nameSeed[i];\t\tfor (int j = 0; j &lt; 5; j++)\t\t&#123;\t\t\ttArr[i].sArr[j].name = &quot;Stu_&quot;;\t\t\ttArr[i].sArr[j].name += nameSeed[j];\t\t\tint ranAge = rand() % 21 + 10;\t\t\ttArr[i].sArr[j].age = ranAge;\t\t&#125;\t&#125;&#125;void printInfo(teaInfo tArr[], int tLength)&#123;\tfor (int i = 0; i &lt; tLength; i++)\t&#123;\t\tcout &lt;&lt; tArr[i].name &lt;&lt; endl;\t\tfor (int j = 0; j &lt; 5; j++)\t\t&#123;\t\t\tcout &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;Name: &quot; &lt;&lt; tArr[i].sArr[j].name &lt;&lt; &quot;  Age: &quot; &lt;&lt; tArr[i].sArr[j].age &lt;&lt; endl;\t\t&#125;\t&#125;&#125;void main()&#123;\tteaInfo tArr[3];\tint tLength = sizeof(tArr) / sizeof(tArr[0]);\tsrand((unsigned int)time(NULL));\tnoteValue(tArr, tLength);\tprintInfo(tArr, tLength);&#125;\n\n8.2 案列2\n描述：设计一个角色，包含姓名，年龄，性别；创建结构体数组，存放3个角色；通过冒泡排序，将角色按照年龄大小升序排序，并打印\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &quot;Struct_demo8.h&quot;using namespace std;struct roleInfo&#123;\tstring name;\tint age;\tstring sex;&#125;;void upSort(roleInfo rArr[], int rLength)&#123;\tfor (int i = 0; i &lt; rLength - 1; i++)\t&#123;\t\tfor (int j = 0; j &lt; rLength - i - 1; j++)\t\t&#123;\t\t\tif (rArr[j].age &gt; rArr[j + 1].age)\t\t\t&#123;\t\t\t\troleInfo tempInfo = rArr[j];\t\t\t\trArr[j] = rArr[j + 1];\t\t\t\trArr[j + 1] = tempInfo;\t\t\t&#125;\t\t&#125;\t&#125;&#125;void printInfo(roleInfo rArr[], int rlength)&#123;\tfor (int i = 0; i &lt; rlength; i++)\t&#123;\t\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; rArr[i].name &lt;&lt; &quot;  Age: &quot; &lt;&lt; rArr[i].age &lt;&lt; &quot;  Sex: &quot; &lt;&lt; rArr[i].sex &lt;&lt; endl;\t&#125;&#125;void main()&#123;\troleInfo rArr[] =\t&#123;\t\t&#123;&quot;FH&quot;, 23, &quot;M&quot;&#125;,\t\t&#123;&quot;MM&quot;, 22, &quot;W&quot;&#125;,\t\t&#123;&quot;XY&quot;, 21, &quot;W&quot;&#125;\t&#125;;\tint rlength = sizeof(rArr) / sizeof(rArr[0]);\tupSort(rArr, rlength);\tprintInfo(rArr, rlength);&#125;\n\n8. const补充\nconst修饰的是其右边的内容\nconst的位置带来的效果与变量类型名，没有联系\n\n8.1 const多种情况12345678910111213141516171819int age = 10;const int *p1 = &amp;age;# =&gt; const 修饰的是 *p1，*p1 不可更改# =&gt; p1 不受影响int const *p2 = &amp;age;# =&gt; const 修饰的是 *p2，*p2 不可更改# =&gt; p2 不受影响int * const p3 = &amp;age;# =&gt; const 修饰的是 p3，p3 不可更改# =&gt; *p3 不受影响const int * const p4 = &amp;age;# =&gt; const 修饰的是 *p4 和 p4，*p4 和 p4 不可更改int const * const p5 = &amp;age;# =&gt; const 修饰的是 *p5 和 p5，*p5 和 p5 不可更改\n\n\n\n12345678910111213141516171819202122struct Student &#123;int age;&#125;;Student stu1 = &#123;10&#125;;Student stu2 = &#123;20&#125;;const Student *p_Stu1 = &amp;stu1;# =&gt; const 在最左边，修饰的是 *p_Stu1 (值常量)# =&gt; p_Stu1 是 指针，不受影响# *p_Stu1 = stu2; (报错)# (*p_Stu1).age = 20; (报错)# p_Stu1-&gt;age = 20; (报错)# p_Stu1 = &amp;stu2; (正确)Student * const p_Stu2 = &amp;stu2;# =&gt; const 在 p_Stu2 左边，修饰的是 p_Stu2 (指针常量)# =&gt; *p_Stu2 是 值，不受影响# *p_Stu2 = stu1; (正确)# (*p_Stu2).age = 30; (正确)# p_Stu2-&gt;age = 30; (正确)# p_Stu2 = &amp;stu1; (错误)\n\n","slug":"1_C++_基础_01","date":"2022-10-06T07:28:25.915Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"e94a77a3753f22f554c8c36e4173e356","title":"C++_核心编程","content":"C++_核心编程[toc]\n1. 内存分区模型C++程序在执行时，内存大方向划分为4个区域\n\n代码区：存放函数的二进制代码，由操作系统进行管理的\n全局区：存放全局变量和静态变量以及常量\n栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n堆区：由程序员分配和释放，若不释放，程序执行结束后会系统回收\n\n内存分区的意义：\n\n不同区域存放的数据，赋予不同的生命周期\n\n1.1 程序运行前程序编译后，生成可执行的 .exe 文件 未执行前，分成两个区域\n代码区：\n\n存放CPU执行的机器指令\n代码区是共享的，目的是对于频繁的执行程序，只需在内存中存放一份即可\n代码区是只读的，目的是防止程序意外的修改了它的指令\n\n全局区：\n\n全局变量和静态变量存放其中\n全局区还包括了常量区，字符串常量和其他常量也存放其中\n该区域的数据在程序结束后由操作系统释放\n\n分类：\n\n全局区：全局变量，静态变量，常量\n常量区：const修饰的全局变量，字符串常量\n局部区：局部变量，const修饰的局部变量和常量\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;//Global variable outside Functionint g_a = 10;int g_b = 20;//Global constant variable outside Functionconst int g_c_a = 10;const int g_c_b = 20;int main()&#123;    //Local variable inside Function    int l_a = 10;    int l_b = 20;    //Static variable    static int s_a = 10;    static int s_b = 20;    //Constant Local variable inside Function    const int l_c_a = 10;    const int l_c_b = 20;    //Debug local variable    cout &lt;&lt; &quot;Local Area_Local variable l_a: &quot; &lt;&lt; (int) &amp;l_a &lt;&lt; endl;    cout &lt;&lt; &quot;Local Area_Local variable l_b: &quot; &lt;&lt; (int) &amp;l_b &lt;&lt; endl;    //Debug constant local variable    cout &lt;&lt; &quot;Local Area_Constant local variable l_c_a:&quot; &lt;&lt; (int) &amp;l_c_a &lt;&lt; endl;    cout &lt;&lt; &quot;Local Area_Constant local variable l_c_b:&quot; &lt;&lt; (int) &amp;l_c_b &lt;&lt; endl;    //Debug global variable    cout &lt;&lt; &quot;Global Area_Global variable g_a: &quot; &lt;&lt; (int) &amp;g_a &lt;&lt; endl;    cout &lt;&lt; &quot;Global Area_Global variable g_b: &quot; &lt;&lt; (int) &amp;g_b &lt;&lt; endl;    //Debug static variable    cout &lt;&lt; &quot;Global Area_Static variable s_a: &quot; &lt;&lt; (int) &amp;s_a &lt;&lt; endl;    cout &lt;&lt; &quot;Global Area_Static variable s_b: &quot; &lt;&lt; (int) &amp;s_b &lt;&lt; endl;    //Debug string constant    cout &lt;&lt; &quot;Global Area_String constant str_c_a:&quot; &lt;&lt; (int) &amp;&quot;Hello World&quot; &lt;&lt; endl;    //Debug global constant variable    cout &lt;&lt; &quot;Global Area_global constant variable g_c_a:&quot; &lt;&lt; (int) &amp;g_c_a &lt;&lt; endl;    cout &lt;&lt; &quot;Global Area_global constant variable g_c_b:&quot; &lt;&lt; (int) &amp;g_c_b &lt;&lt; endl;    return 0;&#125;\n\n\n\n\n\n1.2 程序运行后\n栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n\n注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n示例：\n123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;//定义一个返回值int类型的函数int *demoFunc()&#123;    //定义一个局部变量，存在栈区中    int a = 10;    //返回一个局部变量的地址    return &amp;a;&#125;int main()&#123;    //接受局部变量传来的地址    int *p_a = demoFunc();    cout &lt;&lt; *p_a &lt;&lt; endl; //第一次能正常的解析地址对应的值，函数执行结束，系统回收了数据    cout &lt;&lt; *p_a &lt;&lt; endl; //第二次，无法正常解析到对应的值，因为函数执行一次结束后，没有返回值了&#125;\n\n堆区：由程序员释放，若不释放，程序结束时由操作系统回收\n\n方式：C++通过 new 在堆区中开辟内存\n\n示例：\n12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int *demoFunc()&#123;    //通过指针地址存放 new 关键字对int类型的值在堆中开辟的内存所在的地址    //这个 int的值存放在堆中，改函数执行结束后，依然存在    int *p_a = new int(10);    return p_a;&#125;int main()&#123;    int *p_a = demoFunc();    cout &lt;&lt; *p_a &lt;&lt; endl;    cout &lt;&lt; *p_a &lt;&lt; endl; //函数执行结束后，指针指向的指针内存空间依然存在，所以可以正常得到内存中的值    return 0;&#125;\n\n1.3 new操作符\n\nC++ 通过 new 在堆区开辟数据\n堆区的数据，由程序员手动开辟，手动释放，利用 delet 操作符\n语法：new 数据类型（）；\n利用new创建的数据，会返回该数据对应的类型的指针地址\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;//创建一个返回int类型的地址函数int *newKeyDemo()&#123;    //new操作符开辟的数据会返回一个指针    int *p_a = new int(10);    //返回指针    return p_a;&#125;void printDemo1Info()&#123;    //创建一个指针接受返回值    int *Info1 = newKeyDemo();    cout &lt;&lt; *Info1 &lt;&lt; endl;    //delete 操作符会释放 new在堆中的数据    delete Info1;    cout &lt;&lt; *Info1 &lt;&lt; endl;&#125;//利用new操作符创建数组void printDemo2Info()&#123;    int *p_arr = new int[10];    for (int i = 0; i &lt; 10; i++)    &#123;        p_arr[i] = i + 1;    &#125;    for (int j = 0; j &lt; 10; j++)    &#123;        cout &lt;&lt; p_arr[j] &lt;&lt; &quot; &quot;;    &#125;    delete[] p_arr;&#125;int main()&#123;    printDemo1Info();    printDemo2Info();    return 0;&#125;\n\n\n\n\n\n2. 引用2.1 引用的基本使用\n作用：给变量起别名\n\n语法：数据类型 &amp;别名 = 原名；\n\n示例：\n1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 10;    int &amp;b = a;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    b = 20;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    return 0;&#125;\n\n2.2 引用注意事项\n引用必须初始化\n\n引用在初始化后不可以改变\n\n示例：\n12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 10;    int c = 10;    //int &amp;b; 引用必须初始化    int &amp;b = a;    //int &amp;b = c; 引用初始化后不可更改    return 0;&#125;\n\n2.3 引用做函数参数\n作用：函数传参时，可以利用引用的技术让形参修饰实参\n\n优点：可以简化指针修改实参\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;void swap01(int a, int b)&#123;    int temp = a;    a = b;    b = temp;&#125;void swap02(int *p_a, int *p_b)&#123;    int temp = *p_a;    *p_a = *p_b;    *p_b = temp;&#125;void swap03(int &amp;a, int &amp;b)&#123;    int temp = a;    a = b;    b = temp;&#125;int main()&#123;    int a = 10;    int b = 20;//    swap01(a, b); 值传递，形参不修饰实参//    swap02(&amp;a, &amp;b); 地址传递，形参修饰实参    swap03(a, b); // 引用传递，形参修饰实参    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    return 0;&#125;\n\n2.4 引用做函数的返回值\n作用：引用可以作为函数的返回值\n\n注意：不要返回局部变量引用\n\n用法：函数调用作为左值\n\n示例：\n1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int &amp;demo1()&#123;    int a = 10; //函数体内定义的局部变量，函数执行完后，系统自动回收    return a;&#125;int &amp;demo2()&#123;    static int b = 20; //static 修饰的静态变量，存储在全局区，整个程序执行完后，系统自动回收    return b;&#125;int main()&#123;    int &amp;ref_a = demo1();    int &amp;ref_b = demo2();    cout &lt;&lt; &quot;ref_a = &quot; &lt;&lt; ref_a &lt;&lt; endl;    cout &lt;&lt; &quot;ref_a = &quot; &lt;&lt; ref_a &lt;&lt; endl;    cout &lt;&lt; &quot;ref_b = &quot; &lt;&lt; ref_b &lt;&lt; endl;    cout &lt;&lt; &quot;ref_b = &quot; &lt;&lt; ref_b &lt;&lt; endl;    demo2() = 1000; //函数的调用是引用，可以作为左值    cout &lt;&lt; &quot;ref_b = &quot; &lt;&lt; ref_b &lt;&lt; endl;    cout &lt;&lt; &quot;ref_b = &quot; &lt;&lt; ref_b &lt;&lt; endl;    return 0;&#125;\n\n2.5 引用的本质\n本质：在C++内部实现一个指针常量\n\n示例：\n1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;// 转换为 int *const ref_b = &amp;avoid demo1(int &amp;ref_b)&#123;    ref_b = 100;&#125;int main()&#123;    int a = 10;    // 自动转换为 int *const ref_a = &amp;a; &lt;&lt; = &gt;&gt; 指针常量；因为指针的指向（地址）不可改变，所以引用的初始化后不可更改    int &amp;ref_a = a;    // ref是引用，自动转换成 *ref = 20；    ref_a = 20;      cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;ref_a = &quot; &lt;&lt; ref_a &lt;&lt; endl;      demo1(ref_a);      return 0;&#125;\n\n结论：引用本质是指针，使用方便\n\n\n2.6 常量引用\n作用：常量引用一般用来修饰形参，防止误操作\n\n使用：在函数形参列表中，可以加 const 修饰形参，防止形参被实参修改\n\n示例：\n123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;void printInfo(const int &amp;ref_b)&#123;    //常量引用的值不可以修改    //ref_b = 1000;    cout &lt;&lt; &quot;ref_b = &quot; &lt;&lt; ref_b &lt;&lt; endl;&#125;int main()&#123;    // 编辑器 转换为 int temp = 10;   const int &amp;a = temp;    //const int &amp;ref_a = 10;    // ref_a 用 const 修饰后值不能被修改    //ref_a = 20;\tint a = 100;\tprintInfo(a);\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\treturn 0;&#125;\n\n2.7 引用补充\n一个引用占用一个指针的大小\n\n证明引用本质是指针\n1234567891011121314151617// 指针转汇编// int *p = &amp;age;lea eax, [age]mov dword ptr [p], eax// *p = 30;mov eax, dword ptr [p]mov dword ptr [eax], 1Eh// 引用转汇编// int &amp;ref = age;lea eax, [age]mov dword ptr [p], eax// ref = 30;mov eax, dword ptr [p]mov dword ptr [eax], 1Eh\n\n\n\n数组引用\n123456int array[] = &#123;1, 2, 3&#125;;// 数组名 array 是数组的首元素地址，=&gt; (i)// 两种写法int (&amp;ref1)[3] = array;int *const &amp;ref2 = array;\n\n\n\n\n不存在的引用\n\n引用的引用\n指向引用的指针\n引用数组\n\n\n常引用\n\nconst 必须写在 &amp; 左边，才算是常引用\n\n\n常引用的特点\n\n可以指向临时数据：常量、表达、函数返回值等\n1234567891011121314151617// 默认情况下，&amp;ref 只能将变量赋值给它int a = 10;int &amp;ref = a;// 常量const int &amp;ref = 10;// 表达式int a = 10;int b = 20;const int &amp;ref = a + b;// 函数返回值int func()&#123;return 10;&#125;const int &amp;ref = func();\n\n\n\n可以指向不同类型的数据\n12int a = 10;const double &amp;ref = a;\n\n\n\n作为函数参数时(规则适用于 const指针)\n\n可以接受 const 和 非const 实参(非const 引用，只能接受 非const 实参)\n1234567891011121314151617181920int sum(const int &amp;a, const int &amp;b)&#123;    return a + b;&#125;int main()&#123;    // const实参    const int a = 10;    const int b = 20;    sum(a, b);    sum(10, 20);        // 非const实参    int a = 10;    int b = 20;    sum(a, b);        return 0;&#125;\n\n\n\n可以跟 非const 引用构成重载\n12345678910111213141516171819202122232425262728293031// sum_1int sum(const int &amp;a, const int &amp;b)&#123;    return a + b;&#125;// sum_2int sum(int &amp;a, int &amp;b)&#123;    return a + b;&#125;int main()&#123;    // const实参    const int a = 10;    const int b = 20;        // 调用 sum_1    sum(a, b);    sum(10, 20);        // 非const实参    int a = 10;    int b = 20;        // 调用 sum_2    sum(a, b);        return 0;&#125;\n\n\n\n\n当常量引用指向不同类型的数据时，会产生临时变量，即引用指向的并不是初始化时的那个变量\n12345678910int age = 10;const long &amp;rAge = age;age = 30;cout &lt;&lt; &quot;rAge: &quot; &lt;&lt; rAge &lt;&lt; endl;cout &lt;&lt; &quot;age: &quot; &lt;&lt; age &lt;&lt; endl;// 运行结果&gt;&gt;rAge: 10age: 30\n\n利用反汇编分析：\n12345678910// 查看反汇编mov dword ptr[age], 0Ah// 常量引用指向不同类型数据，会产生如下两句；指向同类型不会mov eax, dword ptr[age]mov dword ptr[temp], eaxlea ecx, [temp]mov dword ptr[rAge], ecxmov dword prt[age], 1Eh\n\n实际代码：\n12345678910// 源代码int age = 10;const long &amp;rAge = age;age = 30;// 实际代码int age = 10;int temp = age;const long &amp;rAge = temp;age = 30;\n\n3. 函数进阶3.1 函数默认参数\n在C++中，函数的形参列表中的形参可以有默认值\n\n语法：返回值类型 函数名 （参数 = 默认值）&#123;&#125;\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;// 无默认值参数，通过调用函数传入参数值int func01(int a, int b, int c)&#123;    return a + b + c;&#125;// 有默认值参数，可以通过调用函数传入参数值，也可以不传参数值int func02(int a = 10, int b = 20, int c = 30)&#123;    return a + b + c;&#125;// 当函数定义中，有默认参数值的一项形参，其之后的其他形参也要有形参//int func03(int a = 10, int b, int c)//&#123;//    return a + b + c;//&#125;// 函数在声明时，形参有默认值，定义时，形参不得定义默认值int func04(int a = 10, int b = 20);//int func04(int a = 20, int b = 10)//&#123;//    return a + b;//&#125;int main()&#123;    cout &lt;&lt; &quot;Func01: &quot; &lt;&lt; func01(10, 20, 30) &lt;&lt; endl;    cout &lt;&lt; &quot;Func02: &quot; &lt;&lt; func02() &lt;&lt; endl;    return 0;&#125;\n\n3.1.1 函数默认参数补充\n默认参数可以是全局变量\n123456789101112int b = 20;int sum(int a = 20, b = a)&#123;    return a + b;&#125;int main()&#123;    cout &lt;&lt; sum() &lt;&lt; endl;    return 0;&#125;\n\n\n\n默认参数可以是函数名(函数所在内存的地址：指针变量)\n123456789101112131415void test(int a)&#123;    cout &lt;&lt; &quot;test(int) - &quot; &lt;&lt; a &lt;&lt; endl;&#125;void func(int v1, void(*ptr_Test)(int) = test)&#123;    ptr_Test(v1);&#125;int main()&#123;    func(20, test);    return 0;&#125;\n\nvoid(*ptr_Test)(int) = test;\nptr_Test(10);\n\n默认参数，需要保证从右到左依次赋予默认参数，不能出现右边形参没有默认值的情况\n\n原理：C++编译转汇编时，调用有默认参数的函数时，先进行push参数，再调用函数，其中优先push最右边的参数值\n12345678910void sum(int a, int b = 2)&#123;    cout &lt;&lt; a + b;&#125;int main()&#123;    sum(1);    return 0;&#125;\n\n1234push 2push 1call sum()add esp, 8\n\n3.2 函数占位参数\nC++函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n\n占位参数可以有默认值\n\n语法：返回值类型 函数名 （数据类型）&#123;&#125;；\n\n示例：\n12345678910111213141516#include &lt;iostream&gt;using namespace std;// 占位参数可以有默认值void func1(int a, int = 10)&#123;    cout &lt;&lt; &quot;Func1 Test&quot; &lt;&lt; endl; &#125;int main()&#123;    // 有默认值可以不传实参，否则占位参数也要传实参    func1(10, 10);    return 0;&#125;\n\n3.3 函数重载3.3.1 函数重载概述\n作用：函数名可以重复，提高复用性\n\n条件：\n\n同一作用域下\n函数名相同\n函数参数类型不同 或 个数不同 或 顺序不同\n\n\n注意：函数的返回值不可以作为函数重载的条件\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;void func()&#123;    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;&#125;void func(int a)&#123;    cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl;&#125;void func(int a, int b)&#123;    cout &lt;&lt; &quot;func(int a, int b)&quot; &lt;&lt; endl;&#125;void func(int a, double b)&#123;    cout &lt;&lt; &quot;func(int a, double b)&quot; &lt;&lt; endl;&#125;// 返回值不可以作为函数重载的条件//int func()//&#123;//    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;//&#125;int main()&#123;    func();    func(10);    func(10, 20);    func(10, 20.20);    return 0;&#125;\n\n3.3.2 函数重载注意事项\n引用作为重载条件\n\n函数重载碰到函数默认参数\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;void func()&#123;    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;&#125;void func(int &amp;a)&#123;    cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;&#125;void func(const int &amp;a)&#123;    cout &lt;&lt; &quot;func(const int &amp;a)&quot; &lt;&lt; endl;&#125;void func(int &amp;a, int &amp;b)&#123;    cout &lt;&lt; &quot;func(int &amp;a, int &amp;b)&quot; &lt;&lt; endl;&#125;void func2(int a)&#123;    cout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;&#125;void func2(int a, int b = 10)&#123;    cout &lt;&lt; &quot;func(int a, int b = 10)&quot; &lt;&lt; endl;&#125;int main()&#123;    int a = 10;    int b = 20;    func();    func(a);    func(10);    func(a, b);    // func2 函数有重载，且其中一个参数有默认值    //func2(a);    return 0;&#125;\n\n3.3.2.1 函数重载补充内容\n函数重载后，并非是所有的重载函数，共同有一个相同的函数名，仅参数不同\n12345void func();void func(int a);void func(int a, int b);\n\n以上三个函数func是重载函数，在编辑器和我们人类的视角中是有着相同的函数名称func；\n12345call func_1()call func_2()call func_3()\n\n以上是当编译时，C++转汇编时，汇编中的情况，同时这些重载函数的内存地址自然也是不一样的；\n但在编译器中，不同版本或类型的编译器，在编译时会这些重载函数进行重新进行命名；\n\n\n3.4 内联函数\n功能描述：编译器会将内联函数的调用，直接展开成函数体\n\n使用inline修饰函数的声明或实现，可以使其变成内联函数(建议声明和实现都使用inline修饰)\n\n代码示例：\n123456789101112inline int sum(int a, int b)&#123;    return a + b;&#125;int main()&#123;    int c = sum(1, 2);    return 0;&#125;// sum(1, 2)  =&gt; a + b;\n\n\n\n内联函数\n\n缺点：会增加代码的体积\n优点：函数调用，需要开辟栈空间，内联函数不需要，节省资源\n\n\n使用场景：\n\n函数的体积不大(不超过10行)\n不会被频繁调用\n\n\n补充知识：\n\n不是所有函数被inline修饰后，编译器都会将其变成内联函数：递归函数\n\n\n通过反汇编查看内联函数\n12345678910inline int sum(int a, int b)&#123;    return a + b;&#125;int main()&#123;    int c = sum(1, 2);    return 0;&#125;\n\n12345678910111213// int c = sum(1, 2);// 普通函数--反汇编push 0Apush 0Bcall sum()add esp, 8mov dword ptr[c], eax// 内联函数--反汇编mov eax, 0Aadd eax, 0Bmov dword ptr[c],\n\n4. 类和对象\nC++面向对象的三大特性：封装，继承，多态\n\n4.1 封装4.1.1 封装的意义\n意义一：\n\n将属性和行为作为一个整体，表现生活中的事物\n将属性和行为加以权限控制\n在设计类时，属性和行为写在一起，表现事物\n\n\n语法：class 类名 &#123; 访问权限：属性 / 行为 &#125;；\n\n示例1：设计一个圆，求圆的周长\n12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;// 类名 （圆）class Circle&#123;    // 权限（公开）public:    // 属性    const double Pi = 3.14;    double cir_R;    // 计算圆周长的函数    double calculatePerimeter()    &#123;        return  2 * Pi * cir_R;    &#125;&#125;;int main()&#123;    // 通过Circle类创建一个实例（对象） c1    Circle c1;    // 通过对象，对类中的属性 cir_R 进行赋值     c1.cir_R = 10.0;    double value = c1.calculatePerimeter();    cout &lt;&lt; &quot;Circle perimeter : &quot; &lt;&lt; value &lt;&lt; endl;    return 0;&#125;\n\n示例2：设计一个学生类，属性有姓名和学号，对属性进行赋值，并显示属性信息（两种写法）\n123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Student&#123;public:    string stu_Name;    int stu_ID;    void printStudentInfo()    &#123;        cout &lt;&lt; &quot;Student Info : &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; stu_Name &lt;&lt; &quot;  ID: &quot; &lt;&lt; stu_ID &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Student s1;    s1.stu_ID = 123456;    s1.stu_Name = &quot;FH&quot;;    s1.printStudentInfo();    return 0;&#125;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Student&#123;public:    string stu_Name;    int stu_ID;    void setName(string name)    &#123;        stu_Name = name;    &#125;    void setID(int id)    &#123;        stu_ID = id;    &#125;    void printStudentInfo()    &#123;        cout &lt;&lt; &quot;Student Info : &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; stu_Name &lt;&lt; &quot;  ID: &quot; &lt;&lt; stu_ID &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Student s1;    s1.setName(&quot;FH&quot;);    s1.setID(123456);    s1.printStudentInfo();    Student s2;    s2.setName(&quot;CYL&quot;);    s2.setID(666666);    s2.printStudentInfo();    return 0;&#125;\n\n意义二：不属性和行为放在不同的权限下，加以控制\n\n访问权限三种：\n\n\n\npublic 公开\n成员类内可访问，类外可访问\n子类可访问\n\n\n\nprotected 保护\n成员类内可访问，类外不可访问\n子类可访问保护内容\n\n\nprivate 私有\n成员类内可访问，类外不可访问\n子类不可访问私有内容\n\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Person&#123;public:    string name;protected:    string car;private:    int password;private:    void func()    &#123;        name = &quot;FH&quot;;        car = &quot;XXX&quot;;        password = 123456;    &#125;&#125;;int main()&#123;    Person p1;    p1.name = &quot;CYL&quot;;    //p1.car = &quot;YYY&quot;; // 保护权限内容，类外不可访问和修改    //p1.password = 999999; // 私有权限内容，类外不可访问和修改    return 0;&#125;\n\n4.1.2 struct和class区别\n区别：struct 默认权限为公开；class默认权限为私有\n\n示例：\n123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class C1&#123;    int a;&#125;;struct C2&#123;    int a;&#125;;int main()&#123;    C1 c1;    C2 c2;        //c1.a = 10; // class默认私有，无法访问    c2.a = 10; // struct默认公开，可以访问        return 0;&#125;\n\n4.1.3 成员属性私有化\n优点：\n\n将所有成员属性设置为私有，可以自己控制读写权限\n对于写权限，可以检测数据的有效性\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Person&#123;public:    void setName(string name)    &#123;        p_Name = name;    &#125;    string getName()    &#123;        return p_Name;    &#125;    int getAge()    &#123;        p_Age = 24;        return p_Age;    &#125;    void setID(int id)    &#123;        p_ID = id;    &#125;private:    string p_Name; // 可读可写    int p_Age; // 可读    int p_ID; // 可写&#125;;int main()&#123;    Person p;    p.setName(&quot;FH&quot;);    p.setID(123455);    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.getName() &lt;&lt; endl;    cout &lt;&lt; &quot;Age: &quot; &lt;&lt; p.getAge() &lt;&lt; endl;    return 0;&#125;\n\n4.1.4 案例：设计立方体\n要求：设计立法体类（cube），求面积和体积，分别用全局函数和成员函数判断两个立方体是否相等\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;using namespace std;class Cube&#123;private:    float c_Length = 1.0;    float c_Width = 1.0;    float c_Height = 1.0;public:    void setLength(float length)    &#123;        c_Length = length;    &#125;    float getLength() const    &#123;        return c_Length;    &#125;    void setWidth(float width)    &#123;        c_Width = width;    &#125;    float getWidth() const    &#123;        return c_Width;    &#125;    void setHeight(float height)    &#123;        c_Height = height;    &#125;    float getHeight() const    &#123;        return c_Height;    &#125;    float calculateArea() const    &#123;        return 2 * c_Length * c_Width + 2 * c_Length * c_Height + 2 * c_Width * c_Height;    &#125;    float calculateVolume() const    &#123;        return c_Height * c_Width * c_Length;    &#125;    // 成员函数判断两个立方体是否相等    string calculateSameFromClass(Cube &amp;c) const    &#123;        if (c.getLength() == c_Length &amp;&amp; c.getWidth() == c_Width &amp;&amp; c.getHeight() == c_Height)        &#123;            return &quot;Class_Same!!!&quot;;        &#125;        return &quot;Class_No Same!!!&quot;;    &#125;&#125;;// 全局函数判断两个立方体是否相等string calculateSameFromGlobal(Cube &amp;c1, Cube &amp;c2)&#123;    if (c1.getHeight() == c2.getHeight() &amp;&amp; c1.getWidth() == c2.getWidth() &amp;&amp; c1.getLength() == c2.getLength())    &#123;        return &quot;Global_Same!!!&quot;;    &#125;    return &quot;Global_No Same!!!&quot;;&#125;int main()&#123;    Cube c1;    Cube c2;    Cube c3;    c1.setHeight(10.0);    c1.setLength(10.0);    c1.setWidth(10.0);    c2.setHeight(10.0);    c2.setLength(10.0);    c2.setWidth(10.0);    c3.setHeight(20.0);    c3.setLength(20.0);    c3.setWidth(20.0);    // 存储立方体的面积以及体积返回的值    float cube_Area = c1.calculateArea();    float cube_Volume = c1.calculateVolume();    // 存储两种函数等到的判断返回结果    string global_Same = calculateSameFromGlobal(c1, c2);    string class_Same = c1.calculateSameFromClass(c3);    cout &lt;&lt; &quot;Cube Area: &quot; &lt;&lt; cube_Area &lt;&lt; endl;    cout &lt;&lt; &quot;Cube Volume: &quot; &lt;&lt; cube_Volume &lt;&lt; endl;    cout &lt;&lt; &quot;Global_Same: &quot; &lt;&lt; global_Same &lt;&lt; endl;    cout &lt;&lt; &quot;Class_Same: &quot; &lt;&lt; class_Same &lt;&lt; endl;    return 0;&#125;\n\n4.1.5 案例：点圆的关系\n要求：设计圆类（Circle）设计点类（Point），计算点和圆的包含关系（圆外）（圆上）（圆内）（圆心）\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;using namespace std;// 点类class Point&#123;private:    // 点X坐标    double p_X;    // 点Y坐标    double p_Y;public:    void set_X(double x)    &#123;        p_X = x;    &#125;    double get_X() const    &#123;        return p_X;    &#125;    void set_Y(double y)    &#123;        p_Y = y;    &#125;    double get_Y() const    &#123;        return p_Y;    &#125;&#125;;// 圆类class Circle&#123;private:    // 圆的半径    double c_Radius;    // 圆心的坐标    Point c_Center;public:    void setRadius(double radius)    &#123;        c_Radius = radius;    &#125;    double getRadius() const    &#123;        return c_Radius;    &#125;    void setCenter(Point &amp;center)    &#123;        c_Center = center;    &#125;    Point getCenter()    &#123;        return c_Center;    &#125;&#125;;// 计算圆与点之间的关系void calculateCircleAndPoint(Circle &amp;c, Point &amp;p)&#123;    // 圆心点X - 点X    double ppDistanceX = c.getCenter().get_X() - p.get_X();    // 圆心点Y - 点Y    double ppDistanceY = c.getCenter().get_Y() - p.get_X();    // 圆的半径    double rDistanceR = c.getRadius();    // 分别计算：圆心X到点X的平方值，圆心Y到点Y的平方值，圆半径的平方值    double powX = pow(ppDistanceX, 2);    double powY = pow(ppDistanceY, 2);    double powR = pow(rDistanceR, 2);    // 等到判断关系值 （x - x1）^2 + (y - y1)^2 = r^2    double ppDistance = powX + powY;    double rDistance = powR;    if (ppDistance == rDistance)    &#123;        cout &lt;&lt; &quot;Point On The Circle&quot; &lt;&lt; endl;    &#125;    else if (ppDistance &lt; rDistance)    &#123;        cout &lt;&lt; &quot;Point Within The Circle&quot; &lt;&lt; endl;    &#125;    else if (ppDistance &gt; rDistance)    &#123;        cout &lt;&lt; &quot;Point Outside The Circle&quot; &lt;&lt; endl;    &#125;&#125;int main()&#123;    // 实例化一个圆    Circle c&#123;&#125;;    // 实例化一个圆心的坐标 和 点的坐标    Point p_center&#123;&#125;;    Point p&#123;&#125;;    p_center.set_X(10.0);    p_center.set_Y(0);    p.set_X(10.0);    p.set_Y(10.0);    c.setRadius(10.0);    c.setCenter(p_center);    calculateCircleAndPoint(c, p);    return 0;&#125;\n\n4.2 对象初始化和清理\nC++中每个对象都有初始设置以及对象销毁前的清理数据的设置\n\n4.2.1 构造函数和析构函数问题：\n\n对象的初始化和清理是两个很重要的安全问题\n一个对象或者变量没有初始化状态，使用的后果是未知的\n使用完一个对象或变量，没有及时清理，也会造成安全问题\n\n解决：\n\nC++利用构造函数和析构函数解决问题，这两个函数被编译器自动调用，完成对象的初始化和清理工作\n对象的初始化和清理工作是编译器强制要求的，如果不提供构造函数和析构函数，编译器会提供编译器提供的构造函数和析构函数是空实现\n\n含义：\n\n构造函数：主要为创建对象时为对象的成员属性赋值，构造函数由编译器自动调用\n析构函数：主要为对象销毁前系统自动调用，执行清理工作\n\n构造函数语法：类名（）&#123;&#125;;\n\n构造函数，没有返回值和void\n函数名称和类名相同\n构造函数可以有参数，所以可以重载\n程序在调用对象时，会自动调用构造函数，且只调用一次\n\n析构函数语法：~ 类名（）&#123;&#125;;\n\n析构函数，没有返回值和void\n函数名称和类名不相同，在前面加 ~\n构造函数部可以有参数，所以不可以重载\n程序在调用对象时，会自动调用析构函数，且只调用一次\n\n示例：\n1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Test&#123;public:    Test()    &#123;        cout &lt;&lt; &quot;Test构造函数&quot; &lt;&lt; endl;    &#125;    ~Test()    &#123;        cout &lt;&lt; &quot;Test析构函数&quot; &lt;&lt; endl;    &#125;&#125;;void demo()&#123;    Test t1;&#125;int main()&#123;    demo(); // 函数执行时调用构造函数，结束时调用析构函数    Test t2; // 函数执行时调用构造函数    system(&quot;pause&quot;); // 程序在此处暂停，析构函数为被调用，按任意键后执行析构函数    return 0;&#125;\n\n\n\n\n\n4.2.2 构造函数分类及调用\n分类：\n\n按参数分为：有参构造，无参构造\n按类型分为：普通构造，拷贝构造\n\n\n调用：\n\n括号法\n显示法\n隐式转换法\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;class Person&#123;public:    // 创建构造函数    Person()    &#123;        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;    &#125;    Person(int a)    &#123;        age = a;        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;    &#125;    Person(const Person &amp;p) // 将对象的属性拷贝进来    &#123;        age = p.age;        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;    &#125;    ~Person()    &#123;        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;    &#125;    int age;&#125;;// 调用构造函数void demo()&#123;    // 括号法调用    // 注意：无参构造函数不用括号：Person p1(); 编译器会作为 void func(); 声明来处理，调用空实现的构造函数    Person p1; // 无参构造函数    Person p2(10); // 有参构造函数    Person p3(p2); // 拷贝构造函数    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.age &lt;&lt; endl;    cout &lt;&lt; &quot;p3 age: &quot; &lt;&lt; p3.age &lt;&lt; endl;    // 显示法调用    Person p4;    Person p5 = Person(20);    Person p6 = Person(p5);    // 注意 Person(20) 单独写出来为匿名对象，程序中无法使用，执行完会被系统立即回收    // 注意 不用拷贝函数初始化匿名对象，Person(p6) 编译器等价于 Person p6 , 而 Person p6 已经作为对象被实例化了    // 隐式转换法调用    Person p7 = 10; // 等价于 Person p7 = Person(10);    Person p8 = p7;    system(&quot;pause&quot;);&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.2.3 拷贝构造函数调用时机\nC++中拷贝构造函数调用时机三种情况\t\n\n使用一个已经创建的对象来初始化一个新对象\n值传递的方式给函数参数传值\n以值方式返回局部对象\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int p_age;    Person()    &#123;        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;    &#125;    Person(int a)    &#123;        p_age = a;        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;    &#125;    Person(const Person &amp;person)    &#123;        p_age = person.p_age;        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;    &#125;    ~Person()    &#123;        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;    &#125;&#125;;//1. 使用一个已经创建的对象来初始化一个新对象void demo1()&#123;    Person p1(10); // 有参构造    Person p2(p1); // 拷贝构造    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.p_age &lt;&lt; endl;&#125;//2. 值传递的方式给函数参数传值void test2(Person person)&#123;&#125;void demo2()&#123;    Person p3; // 默认构造    test2(p3); // 拷贝构造 - 此处 p3 为p3对象的副本（拷贝）&#125;//3. 以值方式返回局部对象Person test3()&#123;    Person p4; // 默认构造    cout &lt;&lt; &quot;p4 address: &quot; &lt;&lt; (int *) &amp;p4 &lt;&lt; endl;    return p4; // 此处 p4 为p4对象的副本（拷贝）&#125;void demo3()&#123;    Person p5 = test3(); // 拷贝构造 - 得到 p4 的对象副本    cout &lt;&lt; &quot;p5 address: &quot; &lt;&lt; (int *) &amp;p5 &lt;&lt; endl;&#125;int main()&#123;    //demo1();    //demo2();    demo3();    return 0;&#125;\n\n4.2.4 构造函数调用规则\n默认情况下，C++编译器至少给一个类添三个函数\n\n默认构造函数（无参，函数体为空）\n默认析构函数（无参，函数体为空）\n默认拷贝构造函数 对类实例化的对象的属性值拷贝\n\n\n调用规则：\n\n如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数\n如果自定义拷贝构造函数，编译器不提供其他构造函数\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int p_age;    Person()    &#123;        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;    &#125;    Person(int a)    &#123;        p_age = a;        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;    &#125;    Person(const Person &amp;person)    &#123;        p_age = person.p_age;        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;    &#125;    ~Person()    &#123;        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;    &#125;&#125;;//1. 如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数void demo1() // 默认构造函数不会被调用&#123;    Person p1(10);    Person p2(p1);&#125;//2. 如果自定义拷贝构造函数，编译器不提供其他构造函数void demo2() // 自定义拷贝构造函数后，其他构造函数需自己添加&#123; Person p3; Person p4(p3);&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n4.2.5 深拷贝和浅拷贝\n深拷贝：在堆区重新申请空间，进行拷贝操作\n\n浅拷贝：简单的赋值拷贝（编译器默认提供的拷贝构造函数就是浅拷贝）\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int p_age;    int *p_height;    Person()    &#123;        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;    &#125;    Person(int a, int height)    &#123;        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;        p_age = a;        p_height = new int(height);    &#125;    // 通过深拷贝的方法解决浅拷贝带来的问题 深拷贝定义后，编译器默认执行该构造函数    Person(const Person &amp;person)    &#123;        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;        p_age = person.p_age;        p_height = new int(*person.p_height); // 自定义的赋值方式，堆中开辟空间        //p_height = person.p_height; // 编译器默认的赋值方式    &#125;// 浅拷贝时，p2 内的 p_height 被释放，p1 无可释放，程序执行非法操作（报错）// 深拷贝时，p2 内的 p_height 是单独的堆区空间被释放，不影响 p1 的 p_height 内存释放（正确）    ~Person()    &#123;        cout &lt;&lt; &quot;Person析构函数&quot; &lt;&lt; endl;        if (p_height != NULL)        &#123;            delete p_height;            p_height = NULL;        &#125;    &#125;&#125;;void demoTest() // 栈区内存释放的顺序是先进后出，所以析构函数 释放内存是从 p2 开始&#123;    Person p1(10, 170);    cout &lt;&lt; &quot;p1 age: &quot; &lt;&lt; p1.p_age &lt;&lt; &quot; p1 height: &quot; &lt;&lt; *p1.p_height &lt;&lt; endl;    Person p2(p1); // 编译器提供的浅构造函数，解析的是p1指针指向的内存空间    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.p_age &lt;&lt; &quot; p2 height: &quot; &lt;&lt; *p2.p_height &lt;&lt; endl;&#125;int main()&#123;    demoTest();    return 0;&#125;\n\n4.2.6 初始化列表\n作用：C++提供初始化列表，用来初始化属性\n\n语法：构造函数（）：属性1（值1），属性2（值2）... &#123;&#125;\n\n示例：\n1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int p_a;    int p_b;    // 通过有参构造函数初始化属性值//    Person(int a, int b)//    &#123;//        p_a = a;//        p_b = b;//    &#125;// 通过初始化列表来初始化属性值    Person(int a, int b) : p_a(a), p_b(b)    &#123;    &#125;&#125;;int main()&#123;    Person p1(10, 20);    cout &lt;&lt; &quot;p1 a: &quot; &lt;&lt; p1.p_a &lt;&lt; endl;    cout &lt;&lt; &quot;p1 b: &quot; &lt;&lt; p1.p_b &lt;&lt; endl;    return 0;&#125;\n\n4.2.7 类对象作为类成员\nC++类中的成员可以说另一个类的对象，称为：对象成员\n\n例如：\n12345class A &#123;&#125;class B&#123;    A a;&#125;\n\nB类中有对象作为成员，A为对象成员\n\n程序执行时，先构造A，再构造B\n\n程序结束时，先析构B，再析构A\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;class Phone&#123;public:    string p_Name;    Phone(string name)    &#123;        cout &lt;&lt; &quot;Phone 构造函数调用 (先构造)&quot; &lt;&lt; endl;        p_Name = name;    &#125;    ~Phone()    &#123;        cout &lt;&lt; &quot;Phone 析构函数调用&quot; &lt;&lt; endl;    &#125;&#125;;class Human&#123;public:    string h_Name;    Phone h_Phone;    Human(string name, string phone) : h_Name(name), h_Phone(phone)    &#123;        cout &lt;&lt; &quot;Human 构造函数调用&quot; &lt;&lt; endl;    &#125;    ~Human()    &#123;        cout &lt;&lt; &quot;Human 析构函数调用 (先析构)&quot; &lt;&lt; endl;    &#125;&#125;;void demo()&#123;    Human h(&quot;FH&quot;, &quot;Apple&quot;);    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; h.h_Name &lt;&lt; &quot; Phone: &quot; &lt;&lt; h.h_Phone.p_Name &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.2.8 静态成员\n定义：在成员变量和成员函数前加关键字static，称为静态成员\n\n分类：\n\n静态成员变量\n所有对象共享一份数据\n在编译阶段分配内存\n类内声明，类外初始化\n\n\n静态成员函数\n所有对象共享一个函数\n静态成员函数只能访问静态成员变量\n\n\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class Person&#123;public:    static int p_num; // 静态成员变量 类内声明    static void func() // 静态成员函数    &#123;        p_num = 100;        cout &lt;&lt; &quot;num: &quot; &lt;&lt; p_num &lt;&lt; endl;    &#125;private: // 静态成员变量的访问权限可以为私密 类外无法访问    static void func2()    &#123;        cout &lt;&lt; &quot;private func2&quot; &lt;&lt; endl;    &#125;&#125;;int Person::p_num = 0; // 静态成员变量 类外初始化int main()&#123;    // 通过对象访问    Person p;    p.func();    // 通过类名访问 （静态成员函数可以直接通过类的作用域直接调用）    Person::func();    return 0;&#125;\n\n4.3 对象模型和this指针4.3.1 成员变量和成员函数分开存储\nC++中，类内的成员变量和成员函数分开存储\n\n只有非静态成员变量才属于类的对象上\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;class demo1&#123;    // 空对象 默认 占内存空间 1&#125;;class demo2&#123;    int num = 0; // 非空对象 占内存空间 依据成员变量&#125;;class demo3&#123;    int num3 = 0;    static int s_num; // 静态成员变量 不在类的对象上    void func()    &#123;        // 成员函数 不在类的对象上 (无论是否静态)    &#125;&#125;;int demo3::s_num = 0;void Test1()&#123;    cout &lt;&lt; &quot;Size of demo1: &quot; &lt;&lt; sizeof(demo1) &lt;&lt; endl;&#125;void Test2()&#123;    cout &lt;&lt; &quot;Size of demo2: &quot; &lt;&lt; sizeof(demo2) &lt;&lt; endl;&#125;void Test3()&#123;    cout &lt;&lt; &quot;Size of demo3: &quot; &lt;&lt; sizeof(demo3) &lt;&lt; endl;&#125;int main()&#123;    Test1();    Test2();    Test3();    return 0;&#125;\n\n4.3.2 this指针概念\n作用：this指针指向被调用的成员函数所属对象\n\nthis指针是隐含每个非静态成员函数的一种指针\n\nthis指针不需定义，直接使用\n\n用途：\n\n当形参和成员变量同名时，可用this指针来区分\n在类的非静态成员函数返回对象本身，可使用 return *this；\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int age;    Person(int age)    &#123;        // this可以区分相同名称的变量        this-&gt;age = age;    &#125;    //返回的是Person对象的引用    Person &amp;addPersonAge(Person &amp;p)    &#123;        this-&gt;age += p.age;        return *this; // 返回对象为 *this    &#125;&#125;;void func1()&#123;    Person p1(10);    cout &lt;&lt; &quot;p1 Age: &quot; &lt;&lt; p1.age &lt;&lt; endl;&#125;void func2()&#123;    Person p2(20);    Person p3(20);    // 链式编程思想    // p3.addPersonAge(p2) 的执行结果是返回 对象的本身，所以可以链式调用成员函数    p3.addPersonAge(p2).addPersonAge(p2).addPersonAge(p2);    cout &lt;&lt; &quot;p3 Age: &quot; &lt;&lt; p3.age &lt;&lt; endl;&#125;int main()&#123;    func1();    func2();    return 0;&#125;\n\n4.3.3 空指针访问成员函数\nC++中空指针可以调用成员函数，但要注意是否用到this\n\n如果用到this，需要加上判断，保证代码的安全\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class Demo&#123;public:    int age = 10;    void func1()    &#123;        cout &lt;&lt; &quot;func1&quot; &lt;&lt; endl;    &#125;    void func2()    &#123;        // 为保证安全性，防止传入的空指针调用成员变量导致崩溃        if (this == NULL)        &#123;            return;        &#125;        // 此处的this 《==》 this.age this是空的，无实际对象，无法调用        cout &lt;&lt; &quot;func2 &quot; &lt;&lt; age &lt;&lt; endl;    &#125;&#125;;void test()&#123;    // 创建一个对象的地址为空    Demo *d = NULL;    d-&gt;func1();    d-&gt;func2();&#125;int main()&#123;    test();    return 0;&#125;\n\n4.3.4 const修饰成员函数\n常函数：\n\n成员函数后加const，该函数称为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable，在常函数中依然可以修改\n\n\n常对象\n\n声明对象前加const，则称为常对象\n常对象只能调用常函数\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int age;    // mutable 修饰的成员变量    mutable int id;    // this指针是指针常量，指针的指向不可修改    // const Person *const this；    // 常量函数的const 修饰的this指针 让this指针指向的值也不可修改    void printAge() const    &#123;        // this-&gt;age = 10;        // 常函数可以修改 mutable的值        this-&gt;id = 10;    &#125;    void printID()    &#123;    &#125;&#125;;void demo()&#123;    // 常对象    const Person p&#123;&#125;;    p.printAge();    //p.printID(); // 常对象只能调用 常函数    //p.age = 100; // 常对象内的成员变量属性值不能修改    p.id = 100; // 常对象内的mutable成员变量属性值能修改&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.4 友元\n作用：目的是让一个函数或者类访问另一个类中的私有成员\n关键字：friend\n实现：\n全局函数做友元\n类做友元\n成员函数做友元\n\n\n\n4.4.1 全局函数做友元123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class Room&#123;    // 将一个全局函数 在类中 通过friend关键在修饰 声明后，该全局函数可以访问 类中私有的成员变量属性    friend void Func_Friend(Room *room);private:    string privateRoom;public:    string publicRoom;    Room()    &#123;        privateRoom = &quot;privateRoom Access Succeeded&quot;;        publicRoom = &quot;publicRoom Access Succeeded&quot;;    &#125;&#125;;void Func_Friend(Room *room)&#123;    cout &lt;&lt; &quot;Friend Function Access: &quot; &lt;&lt; room-&gt;publicRoom &lt;&lt; endl;    // 声明友元后，可以正常访问类中的私有成员变量    cout &lt;&lt; &quot;Friend Function Access: &quot; &lt;&lt; room-&gt;privateRoom &lt;&lt; endl;&#125;void Test()&#123;    Room room;    Func_Friend(&amp;room);&#125;int main()&#123;    Test();    return 0;&#125;\n\n\n\n\n\n4.4.2 类做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;// 先声明一个 Service类class Service;class User&#123;private:    // 定义一个 私有 Service类对象的指针    Service *service;public:    // 构造函数和成员函数写在类外    User();    void access();&#125;;class Service&#123;    // 将 User类 声明为 Service类的友元类 使得User类的对象是 Service类得到友元对象，可以访问私有成员变量的属性    friend class User;private:    string priContent;public:    string pubContent;    // 构造函数声明在外    Service();&#125;;// 通过User类的作用域创建一个User类的构造函数，初始化User类中的成员变量的属性值User::User()&#123;    // 创建一个Service类的对象指针    service = new Service;&#125;// 通过User类的作用域创建一个User类的成员函数void User::access()&#123;    cout &lt;&lt; &quot;User Access Service: &quot; &lt;&lt; service-&gt;pubContent &lt;&lt; endl;    // 当User类成为Service类的友元后，可以在User的函数内访问 Service类中的私有成员变量属性    cout &lt;&lt; &quot;User Access Service: &quot; &lt;&lt; service-&gt;priContent &lt;&lt; endl;&#125;// 通过Service类的作用域创建一个Service类的构造函数Service::Service()&#123;    this-&gt;priContent = &quot;priContent&quot;;    this-&gt;pubContent = &quot;pubContent&quot;;&#125;void demo()&#123;    User user;    user.access();&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n\n\n\n4.4.3 成员函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;class Service;class User&#123;public:    Service *service;    User();    void access1();    void access2();&#125;;class Service&#123;    // 通过friend关键字 声明User类中的成员函数access2() 是Service类的友元函数    friend void User::access2();private:    string priContent;public:    string pubContent;    Service();&#125;;// User类和Service类的构造函数和成员函数在类外创建，类内声明User::User()&#123;    service = new Service;&#125;void User::access1()&#123;    cout &lt;&lt; &quot;Access pubContent: &quot; &lt;&lt; service-&gt;pubContent &lt;&lt; endl;&#125;// 访问Service类中的私有成员变量的属性void User::access2()&#123;    cout &lt;&lt; &quot;Access priContent: &quot; &lt;&lt; service-&gt;priContent &lt;&lt; endl;&#125;Service::Service()&#123;    priContent = &quot;priContent&quot;;    pubContent = &quot;pubContent&quot;;&#125;void demo()&#123;    User user;    user.access1();    user.access2();&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n\n\n\n4.5 运算符重载\n概念：对已有的运算符进行重新的定义，赋予另一种功能，以适应不同的数据类型\n\n4.5.1 加号运算符重载\n作用：实现两个自定义数据类型相加的运算\n\n编辑器提供了通用名称：operator+\n\n内置的不能使用运算符重载，只有自定义类型的可以使用\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//// Created by FHang on 2020/8/11.//#include &lt;iostream&gt;using namespace std;class Num&#123;public:    int num1;    int num2;    // 类中 成员函数 实现的 重载运算‘+’    Num operator+(Num &amp;n) const    &#123;        Num my_n&#123;&#125;;        my_n.num1 = this-&gt;num1 + n.num1;        my_n.num2 = this-&gt;num2 + n.num2;        return my_n;    &#125;&#125;;// 全局函数 运算符重载的默认写法Num operator+(Num &amp;n1, Num &amp;n2)&#123;    Num my_n&#123;&#125;;    my_n.num1 = n1.num1 + n2.num1;    my_n.num2 = n1.num2 + n2.num2;    return my_n;&#125;// 运算符函数 重载Num operator+(Num &amp;n, int num)&#123;    Num my_n&#123;&#125;;    my_n.num1 = n.num1 + num;    my_n.num2 = n.num2 + num;    return my_n;&#125;void demo1()&#123;    Num n1&#123;&#125;;    n1.num1 = 10;    n1.num2 = 10;    Num n2&#123;&#125;;    n2.num1 = 5;    n2.num2 = 5;    Num n3&#123;&#125;;    // 重载后的简化写法    n3 = n1 + n2;    // 成员函数 重载的默认写法    // n3 = n1.operator+(n2);    // 全局函数 重载的默认写法    // n3 = operator+(n1, n2);    cout &lt;&lt; &quot;Operator: n3 = n1 + n2 = &quot; &lt;&lt; n3.num1 &lt;&lt; endl;    cout &lt;&lt; &quot;Operator: n3 = n1 + n2 = &quot; &lt;&lt; n3.num2 &lt;&lt; endl;&#125;void demo2()&#123;    Num n4&#123;&#125;;    n4.num1 = 20;    int num2 = 10;    // 重载运算符函数的 重载写法 （Num类型 + int类型）    Num n5 = n4 + num2;    cout &lt;&lt; &quot;Operator: n5 = n4 + num2 = &quot; &lt;&lt; n5.num1 &lt;&lt;endl;    cout &lt;&lt; &quot;Operator: n5 = n4 + num2 = &quot; &lt;&lt; n5.num2 &lt;&lt;endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n4.5.2 左移运算符重载\n作用：输出自定义的数据类型\n\n左移运算符重载 最好在声明为全局函数\n\n配合友元使用\n123456789101112131415161718192021222324252627282930313233343536373839404142//// Created by Admin on 2021/4/29.//#include &lt;iostream&gt;using namespace std;class Person&#123;    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, Person &amp;p);private:    string name;    int age&#123;&#125;;public:    Person(string name, int age);&#125;;Person::Person(string newName, int newAge)&#123;    name = newName;    age = newAge;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;c, Person &amp;p)&#123;    cout &lt;&lt; &quot;Person Name: &quot; &lt;&lt; p.name &lt;&lt; endl;    cout &lt;&lt; &quot;Person Age: &quot; &lt;&lt; p.age &lt;&lt; endl;    return c;&#125;void demo()&#123;    Person p(&quot;FHang&quot;, 24);    cout &lt;&lt; p &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.5.3 递增运算符重载\n需要配合 全局左移运算符 重载\n\n配合使用 友元\n\n前置重载 返回引用\n\n后置重载 返回类内值\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Created by Admin on 2021/6/20.//#include &lt;iostream&gt;using namespace std;class MyInt&#123;    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt);private:    int my_num;public:    MyInt()    &#123;        my_num = 0;    &#125;    // 重载 前置 ++ 运算符    // 返回引用的目的是 仅对当前的对象进行计算，若是返回对象，则一次计算后，生成另一个新对象    MyInt &amp;operator++()    &#123;        my_num++;        return *this;    &#125;    // 重载 后置 ++ 运算符    // MyInt &amp;operator++(int) =&gt; int 是 占位参数，告诉编译器，用于区分，前后置重载    // 此处 返回值 不返回自身引用，该函数内 自身的引用指向的值 是临时变量，一次操作后，被回收，若是连续多次使用 后置 ++，便是访问NULL，非法操作    MyInt operator++(int)    &#123;        MyInt tempInt = *this;        my_num++;        return tempInt;    &#125;&#125;;// 全局重载 左移运算符ostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt)&#123;    cout &lt;&lt; myInt.my_num;    return c;&#125;void demo1()&#123;    cout &lt;&lt; &quot;&lt;---------demo1-----------&gt;&quot; &lt;&lt; endl;    MyInt myInt;    cout &lt;&lt; myInt &lt;&lt; endl;&#125;void demo2()&#123;    cout &lt;&lt; &quot;&lt;---------demo2-----------&gt;&quot; &lt;&lt; endl;    MyInt myInt;    cout &lt;&lt; myInt &lt;&lt; endl;    cout &lt;&lt; ++myInt &lt;&lt; endl;    cout &lt;&lt; ++(++myInt) &lt;&lt; endl;    cout &lt;&lt; myInt++ &lt;&lt; endl;    cout &lt;&lt; myInt &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n4.5.4 递减运算符重载\n基本情况 同 递增运算符重载\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// Created by Admin on 2021/6/20.//#include &lt;iostream&gt;using namespace std;class MyInt&#123;    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt);private:    int my_num;public:    MyInt()    &#123;        my_num = 10;    &#125;    // 重置 前置 -- 返回引用    MyInt &amp;operator--()    &#123;        my_num--;        return *this;    &#125;    // 重置 后置 -- 返回值    MyInt operator--(int)    &#123;        MyInt tempInt = *this;        my_num--;        return tempInt;    &#125;&#125;;// 全局重载 左移运算符ostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt)&#123;    cout &lt;&lt; myInt.my_num;    return c;&#125;void demo1()&#123;    cout &lt;&lt; &quot;&lt;---------demo1-----------&gt;&quot; &lt;&lt; endl;    MyInt myInt;    cout &lt;&lt; myInt &lt;&lt; endl;&#125;void demo2()&#123;    cout &lt;&lt; &quot;&lt;---------demo2-----------&gt;&quot; &lt;&lt; endl;    MyInt myInt;    cout &lt;&lt; myInt &lt;&lt; endl;    cout &lt;&lt; --myInt &lt;&lt; endl;    cout &lt;&lt; --(--myInt) &lt;&lt; endl;    cout &lt;&lt; myInt-- &lt;&lt; endl;    cout &lt;&lt; myInt &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n4.5.5 赋值运算符重载\nC++ 编译器至少给一个类添加4个函数\n\n默认构造函数（无参，函数体为空）\n默认析构函数（无参，函数体为空）\n默认拷贝构造函数，对属性值进行值拷贝\n赋值运算符 operator&#x3D;，对属性值进行值拷贝\n\n\n如果类中有属性指向堆区，做赋值操作也会出现深浅拷贝问题\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//// Created by Admin on 2021/6/20.//#include &lt;iostream&gt;using namespace std;class Person&#123;public:    int *my_Age;    explicit Person(int age)    &#123;        my_Age = new int(age);    &#125;    ~Person()    &#123;        if (my_Age != nullptr)        &#123;            delete my_Age;            my_Age = nullptr;        &#125;    &#125;    // 重载 赋值运算符 让每一个对象 都各自对应一块堆区，避免浅拷贝带来的多个对象指向同一堆区，在析构函数的作用下，重复释放堆区    Person &amp;operator=(Person &amp;person)    &#123;        // 编译器 默认 浅拷贝        // my_Age = person.my_Age;        // 1. 在 p2 = p1 中，p2在堆区中已有属性值，所以在进行深拷贝之前，先释放 p2 堆区        if (my_Age != nullptr)        &#123;            delete my_Age;            my_Age = nullptr;        &#125;        // 2. 进行 深拷贝        my_Age = new int(*person.my_Age);        return *this;    &#125;&#125;;void demo1()&#123;    Person p1(18);    Person p2(24);    // 该 赋值操作 为 浅拷贝    p2 = p1;    // 浅拷贝时 堆区 my_Age 占有 的内存 被析构函数 重复释放    cout &lt;&lt; *p1.my_Age &lt;&lt; endl;    cout &lt;&lt; *p2.my_Age &lt;&lt; endl;&#125;void demo2()&#123;    Person p1(18);    Person p2(24);    Person p3(36);    p3 = p2 = p1;    cout &lt;&lt; *p1.my_Age &lt;&lt; endl;    cout &lt;&lt; *p2.my_Age &lt;&lt; endl;    cout &lt;&lt; *p3.my_Age &lt;&lt; endl;&#125;int main()&#123;    // demo1();    demo2();    return 0;&#125;\n\n4.5.6 关系运算符重载\n让自定义的两个对象类型进行比较操作\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Created by Admin on 2021/6/20.//#include &lt;iostream&gt;using namespace std;class Person&#123;public:    string my_Name;    int my_Age;    Person(string name, int age)    &#123;        my_Name = std::move(name);        my_Age = age;    &#125;    // 重载 关系运算符 返回值类型可以为：int类型 0/1；或者 bool类型    // 此次 重载的关系运算符为 ==，其他例如：!=, &lt;, &gt; ...同理    int operator==(Person &amp;person) const    &#123;        if (this-&gt;my_Name == person.my_Name &amp;&amp; this-&gt;my_Age == person.my_Age)        &#123;            return 1;        &#125;        return 0;    &#125;&#125;;void demo1()&#123;    Person p1(&quot;FH&quot;, 24);    Person p2(&quot;HF&quot;, 24);    // 此处 的 p1 == p2 是 p1.operator==(p2), 返回一个 bool类型 或者 0/1的int类型，进行if语句判断    if (p1 == p2)    &#123;        cout &lt;&lt; &quot;P1 = P2&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;P1 != P2&quot; &lt;&lt; endl;    &#125;    // 此次 得到的返回值为 int类型的 0/1，所以亦可采用 switch语句来xie    switch (p1 == p2)    &#123;        case 0:            cout &lt;&lt; &quot;P1 != P2&quot; &lt;&lt; endl;            break;        case 1:            cout &lt;&lt; &quot;P1 = P2&quot; &lt;&lt; endl;    &#125;&#125;int main()&#123;    demo1();    return 0;&#125;\n\n4.5.7 函数调用运算符重载\n函数调用运算符（）也可重载\n\n重载后使用的方式，类似函数的调用，被称为 “仿函数”\n\n仿函数 的写法灵活，没有固定写法\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by Admin on 2021/6/20.//#include &lt;iostream&gt;using namespace std;class FPrint&#123;public:    void operator()(const string &amp;text)    &#123;        cout &lt;&lt; text &lt;&lt; endl;    &#125;&#125;;class FAdd&#123;public:    void operator()(int num1, int num2)    &#123;        cout &lt;&lt; num1 + num2 &lt;&lt; endl;    &#125;&#125;;void demo1()&#123;    FPrint fPrint;    fPrint(&quot;Hello World !&quot;);&#125;void demo2()&#123;    FAdd fAdd;    fAdd(10, 20);    // 匿名函数对象    FAdd()(20, 40);&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n4.6 继承4.6.1 继承的基本使用\n继承的作用：减少编写重复的代码\n\n继承的语法：\n1234class 子类 : 继承方式 父类 1. 子类 也叫 派生类 （derived class）2. 父类 也叫 基类 (base class)3. 继承方式：public\n\n继承的演示：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//// Created by Admin on 2021/6/22.//#include &lt;iostream&gt;using namespace std;// 公共页面 是 其子类页面 公用拥有的属性class BasePage&#123;public:    void pageHeader()    &#123;        cout &lt;&lt; &quot; -首页 公开课 登陆 注册 (公共)&quot; &lt;&lt; endl;    &#125;    void pageLeft()    &#123;        cout &lt;&lt; &quot; -Java C# C/C++ Php Golang (公共)&quot; &lt;&lt; endl;    &#125;    void pageFoot()    &#123;        cout &lt;&lt; &quot; -帮助中心 交流合作 友链 (公共)&quot; &lt;&lt; endl;    &#125;&#125;;// 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容class JavaPage : public BasePage&#123;public:    JavaPage()    &#123;        cout &lt;&lt; &quot;&lt;&lt;-- Java Web Page --&gt;&gt;&quot; &lt;&lt; endl;    &#125;        ~JavaPage()    &#123;        cout &lt;&lt; endl;    &#125;    void pageBody()    &#123;        cout &lt;&lt; &quot; -Java_demo1 Java_demo2 Java_demo3 (Java)&quot; &lt;&lt; endl;    &#125;&#125;;// 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容class CPP : public BasePage&#123;public:    CPP()    &#123;        cout &lt;&lt; &quot;&lt;&lt;-- C/C++ Web Page --&gt;&gt;&quot; &lt;&lt; endl;    &#125;        ~CPP()    &#123;        cout &lt;&lt; endl;    &#125;    void pageBody()    &#123;        cout &lt;&lt; &quot; -C/C++_demo1 C/C++_demo2 C/C++_demo3 (C/C++)&quot; &lt;&lt; endl;    &#125;&#125;;void java_demo()&#123;    JavaPage javaPage;    javaPage.pageHeader();    javaPage.pageLeft();    javaPage.pageBody();    javaPage.pageFoot();&#125;void cpp_demo()&#123;    CPP cpp;    cpp.pageHeader();    cpp.pageLeft();    cpp.pageBody();    cpp.pageFoot();&#125;int main()&#123;    java_demo();    cpp_demo();    return 0;&#125;\n\n4.6.2 继承的方式\n继承语法: class 子类 : 继承方式 父类\n\n继承方式：\n\n公共继承：public\n保护继承：protected\n私有继承：private\n\n\n继承方式演示：\n123456789101112131415161718192021222324252627282930313233343536373839// 父类中的 private 可以被 子类  任何继承方式 继承；但 ！ 子类 无法 访问 和 使用class Father&#123;public:    int a;protected:    int b;private:    int c;&#125;;class Son : public Father&#123;// public继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 无改动；public:    int a;protected:    int b;&#125;;class Son : protected Father&#123;// protected继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 protectedprotected:    int a;    int b;&#125;;class Son : private Father&#123;// private继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 privateprivate:    int a;    int b;&#125;;// 总结：// 父类的 private 可以被 任何 继承方式 继承；但 ！ 子类 无法 访问 和 使用// 子类通过某个 继承方式 继承 父类 后，父类中的 public，protected 中的成员变量 在子类中 以某种继承方式出现；\n\n4.6.3 继承中的对象模型4.6.3.1 验证子类模型\n父类中的所有成员变量(非静态)，无论是什么权限保护的成员，都会被子类继承，但子类无法访问和使用\n12345678910111213141516171819202122232425262728293031323334//// Created by Admin on 2021/6/22.//#include &lt;iostream&gt;using namespace std;class Base&#123;public:    int base_A;protected:    int base_B;private:    int base_C;&#125;;class Derived_1 : public Base&#123;public:    int derived_A;&#125;;void demo1()&#123;    Derived_1 derived1&#123;&#125;;    cout &lt;&lt; sizeof(derived1) &lt;&lt; endl;&#125;int main()&#123;    demo1();    return 0;&#125;\n\n4.6.3.2 Developer Powershell - VS\nVisual Studio 提供的工具\n\n使用方式：\n\n首先找到上面的案例代码的所在文件位置\n打开 Visual Studio 提供的 Developer Powershell\n将工作路径切换到案例代码的所在文件路径\n通过开发命令，查看案例代码中，子类对象的结构\n\n\n使用步骤：\n123456789101112131415161718# 切换路径 和 查看路径下 是否存在 案例代码 cpp 文件************************************************************************ Visual Studio 2019 Developer PowerShell v16.9.4** Copyright (c) 2021 Microsoft Corporation**********************************************************************PS C:\\Users\\Admin\\source\\repos&gt; D:PS D:\\DevelopmentTool\\VisualStudio\\IDE&gt; cd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; ls    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9Mode                 LastWriteTime         Length Name----                 -------------         ------ -----a----         2021/6/22     15:09           1515 Inherit_Base.cpp-a----         2021/6/22     15:42            397 Inherit_ObjectModel.cpp\n\n12345678910111213141516171819# 通过开发命令，查看案例代码中，子类对象的结构PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl /d1 reportSingleClassLayoutDerived_1 &quot;.\\Inherit_ObjectModel.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Inherit_ObjectModel.cppclass Derived_1 size(16): # 此处可以看到 子类Derived_1对象的大小 和 之前的案例代码的打印结果一致        +--- 0      | +--- (base class Base) # 子类Derived_1完全继承父类中所有成员 中的 base_A base_B  base_C 0      | | base_A 4      | | base_B 8      | | base_C        | +---12      | derived_A # 同时 子类Derived_1 自身的成员也在 derived_A        +---# 总结：子类 Derived_1中 四个int类型的成员变量，占内存大小为16字节\n\n1234567891011121314# 用到的指令# 切换盘符 到 案例代码 所在 的 盘D:# 切换到具体的路径地址cd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9# 查看路径下 的 案例代码文件 Inherit_ObjectModel.cppls# 指定 报告单个类的布局 ：子类Deriverd_1# cl /d1 reportSingleClassLayout需要查看的类 &quot;类所在的具体文件&quot;cl /d1 reportSingleClassLayoutDerived_1 &quot;.\\Inherit_ObjectModel.cpp&quot;\n\n4.6.4 继承中构造和析构顺序\n子类继承父类之后，当创建子类对象时，也会调用父类的构造和析构函数\n\n案例验证，子类和父类的构造和析构函数的调用先后顺序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by Admin on 2021/6/22.//#include &lt;iostream&gt;using namespace std;class Base&#123;public:    Base()    &#123;        cout &lt;&lt; &quot;Base Constructor Transfer&quot; &lt;&lt; endl;    &#125;    ~Base()    &#123;        cout &lt;&lt; &quot;Base Destructor Transfer&quot; &lt;&lt; endl;    &#125;&#125;;class Derived : public Base&#123;public:    Derived()    &#123;        cout &lt;&lt; &quot;Derived Constructor Transfer&quot; &lt;&lt; endl;    &#125;    ~Derived()    &#123;        cout &lt;&lt; &quot;Derived Destructor Transfer&quot; &lt;&lt; endl;    &#125;&#125;;void demo()&#123;    Derived derived;&#125;int main()&#123;    demo();    return 0;&#125;\n\n123456# 案例结果D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_3.exeBase Constructor TransferDerived Constructor TransferDerived Destructor TransferBase Destructor Transfer\n\n由 案例结果 可以 看出\n\n当创建子类时，子类和父类 的 构造和析构函数的调用 顺序\n\n子类构造\n父类构造\n父类析构\n子类析构\n\n\n\n4.6.5 继承同名成员处理方式\n继承时的问题：当子类和父类出现同名成员，如何通过子类对象，访问子类或父类的同名数据\n\n访问子类同名成员，直接访问\n访问父类同名成员，添加作用域\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//// Created by Admin on 2021/6/22.//#include &lt;iostream&gt;using namespace std;class Base&#123;public:    int num;    Base()    &#123;        num = 100;    &#125;    void FPrint()    &#123;        cout &lt;&lt; &quot;Base Print&quot; &lt;&lt; endl;    &#125;    void FPrint(int n)    &#123;        cout &lt;&lt; &quot;Base Print (int n) : Overload Function&quot; &lt;&lt; endl;    &#125;&#125;;class Derived : public Base&#123;public:    int num;    Derived()    &#123;        num = 200;    &#125;    void FPrint()    &#123;        cout &lt;&lt; &quot;Derived Print&quot; &lt;&lt; endl;    &#125;&#125;;void demo()&#123;    Derived derived;    cout &lt;&lt; &quot;Derived num = &quot; &lt;&lt; derived.num &lt;&lt; endl;    cout &lt;&lt; &quot;Base num = &quot; &lt;&lt; derived.Base::num &lt;&lt; endl;    derived.FPrint();    derived.Base::FPrint();    // 当父类和子类中，存在同名成员时，会默认隐藏父类的成员，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用    // derived.FPrint(10);  // 父类被隐藏，所以直接传参也无法找到 重载的函数，因为子类没有 FPrint的重载函数    derived.Base::FPrint(10); // 加上 父类作用域后 可调用&#125;int main()&#123;    demo();    return 0;&#125;\n\n解决方法：\n\n子类对象可以直接访问到子类同名成员\n子类对象加上作用域可以访问到父类同名成员\n当子类和父类拥有同名的成员函数，子类会隐藏父类同名成员函数，子类加作用域可以访问到父类中同名函数\n\n\n\n4.6.6 继承同名静态成员处理方式\n问题：继承中，同名的静态成员在子类对象上如何访问\n\n静态成员和非静态成员出现同名，处理方式一致\n\n访问子类同名成员，直接访问\n访问父类同名成员，添加作用域\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//// Created by FHang on 2021/6/24 10:23//#include &lt;iostream&gt;using namespace std;// 基类class Base&#123;public:    static int num;    static void func()    &#123;        cout &lt;&lt; &quot;Base-Static Func&quot; &lt;&lt; endl;    &#125;    ~Base()    &#123;        cout &lt;&lt; endl;    &#125;&#125;;int Base::num = 100;// 子类class Derived : public Base&#123;public:    static int num;    static void func()    &#123;        cout &lt;&lt; &quot;Derived-Static Func&quot; &lt;&lt; endl;    &#125;&#125;;int Derived::num = 200;// 同名静态成员属性void demo1()&#123;    Derived derived;    // 通过对象访问    cout &lt;&lt; &quot;通过对象访问&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Derived Num = &quot; &lt;&lt; derived.num &lt;&lt; endl;    cout &lt;&lt; &quot;Base Num = &quot; &lt;&lt; derived.Base::num &lt;&lt; endl;    // 通过类目访问    cout &lt;&lt; &quot;通过类目访问&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Derived Num = &quot; &lt;&lt; Derived::num &lt;&lt; endl;    cout &lt;&lt; &quot;Base Num = &quot; &lt;&lt; Base::num &lt;&lt; endl;    // 第一个 :: 表示使用类名访问；第二个 :: 表示父类作用域下    cout &lt;&lt; &quot;Base Num = &quot; &lt;&lt; Derived::Base::num &lt;&lt; endl;&#125;// 同名静态成员变量void demo2()&#123;    Derived derived;    // 通过对象访问    cout &lt;&lt; &quot;通过对象访问&quot; &lt;&lt; endl;    derived.func();    derived.Base::func();    // 通过类目访问    cout &lt;&lt; &quot;通过类目访问&quot; &lt;&lt; endl;    Derived::func();    Derived::Base::func();&#125;// 当父类和子类中，存在同名成员变量时，会默认隐藏父类的成员变量，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n总结：同名静态成员处理方式和非同名静态的处理方式一样\n\n区别：同名静态成员处理：\n\n通过对象调用\n通过类目调用\n\n\n\n4.6.7 多继承语法\nC++ 允许一个类继承多个类\n\n语法：class 子类 : 继承方式 父类1, 继承方式 父类2…\n\n多继承可能会引发父类中同名成员出现，需要加作用域区分使用\n\n实际开发中，建议不用，不易于维护\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//// Created by FHang on 2021/6/24 11:03//#include &lt;iostream&gt;using namespace std;class Base1&#123;public:    int num;    Base1()    &#123;        num = 100;    &#125;&#125;;class Base2&#123;public:    int num;    Base2()    &#123;        num = 200;    &#125;&#125;;class Derived : public Base1, public Base2&#123;public:    int num;    Derived()    &#123;        num = 300;    &#125;&#125;;void demo()&#123;    Derived derived;    cout &lt;&lt; &quot;Sizeof derived = &quot; &lt;&lt; sizeof(derived) &lt;&lt; endl;    cout &lt;&lt; &quot;Derived Num = &quot; &lt;&lt; derived.num &lt;&lt; endl;    cout &lt;&lt; &quot;Base1 Num = &quot; &lt;&lt; derived.Base1::num &lt;&lt; endl;    cout &lt;&lt; &quot;Base2 Num = &quot; &lt;&lt; derived.Base2::num &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n此处也使用了 Developer PowerShell 查看了 Derived 类的结构\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364************************************************************************ Visual Studio 2019 Developer PowerShell v16.9.4** Copyright (c) 2021 Microsoft Corporation**********************************************************************PS C:\\Users\\Admin\\source\\repos&gt; D:PS D:\\DevelopmentTool\\VisualStudio\\IDE&gt; cd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemoPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo&gt; ls    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemoMode                 LastWriteTime         Length Name----                 -------------         ------ ----d-----          2021/5/4      9:34                .idead-----         2021/6/24     11:12                cmake-build-debugd-----          2021/5/4      9:34                Code1d-----          2021/5/4      9:34                Code2d-----          2021/5/4      9:34                Code3d-----          2021/5/4      9:34                Code4d-----          2021/5/4      9:34                Code4_CirclePointd-----          2021/5/4      9:34                Code5d-----          2021/5/4      9:34                Code6d-----          2021/5/4      9:34                Code7d-----         2021/6/20     21:27                Code8d-----         2021/6/24     11:11                Code9-a----         2021/2/21     19:24            174 .gitignore-a----         2021/6/24     11:12           2930 CMakeLists.txtPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo&gt; cd Code9PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; ls    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9Mode                 LastWriteTime         Length Name----                 -------------         ------ -----a----         2021/6/22     15:09           1515 Inherit_Base.cpp-a----         2021/6/22     16:36            590 Inherit_ConstructorDestructorTransferOrder.cpp-a----         2021/6/22     17:32           1216 Inherit_DealWithSameName.cpp-a----         2021/6/24     10:49           1431 Inherit_DealWithSameNameObject.cpp-a----         2021/6/24     11:11            126 Inherit_DiamondInheritance.cpp-a----         2021/6/24     11:10            730 Inherit_MoreInherit.cpp-a----         2021/6/22     16:01            395 Inherit_ObjectModel.cppPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl /d1 reportSingleClassLayoutDerived &quot;.\\Inherit_MoreInherit.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Inherit_MoreInherit.cppclass Derived   size(12):        +--- 0      | +--- (base class Base1) 0      | | num        | +--- 4      | +--- (base class Base2) 4      | | num        | +--- 8      | num        +---\n\n4.6.8 菱形继承\n概念：\n\n两个派生类继承同一个基类\n又有某一个类同时继承了两个派生类\n\n\n问题解决：\n\n默认情况下\n1234567891011121314151617181920212223242526272829303132333435363738394041//// Created by FHang on 2021/6/24 11:11//#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    int age;    Animal()    &#123;        age = 10;    &#125;&#125;;class Tiger : public Animal&#123;&#125;;class Lion : public Animal&#123;&#125;;class LionTiger : public Tiger, public Lion&#123;&#125;;void demo1()&#123;    LionTiger lionTiger;    // 菱形继承，两个父类拥有相同的数据，通过作用域区分，同时造成资源浪费，通过 虚继承 解决问题    lionTiger.Tiger::age = 20;    lionTiger.Lion::age = 30;    cout &lt;&lt; &quot;Tiger Age = &quot; &lt;&lt; lionTiger.Tiger::age &lt;&lt; endl;    cout &lt;&lt; &quot;Lion Age = &quot; &lt;&lt; lionTiger.Lion::age &lt;&lt; endl;&#125;int main()&#123;    demo1();    return 0;&#125;\n\n12345// 打印结果D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_7.exe// 此时，可看出，LionTiger同时继承了两个成员变量，在作用域下可单独赋值Tiger Age = 20Lion Age = 30\n\n123456789101112131415161718192021# 利用 Developer Powershell 工具， 查看 LionTriger 类 的结构PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl /d1 reportSingleClassLayoutLionTiger &quot;.\\Inherit_DiamondInheritance.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Inherit_DiamondInheritance.cpp.\\Inherit_DiamondInheritance.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以 防止数据丢失class LionTiger size(8): # 可以看到，LionTiger 继承了两个 重复的成员        +--- 0      | +--- (base class Tiger) 0      | | +--- (base class Animal) 0      | | | age        | | +---        | +--- 4      | +--- (base class Lion) 4      | | +--- (base class Animal) 4      | | | age        | | +---        | +---        +---\n\n使用虚继承解决问题，关键字：virtual\n1234567891011121314151617181920212223242526272829303132333435363738394041424344//// Created by FHang on 2021/6/24 11:11//#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    int age;    Animal()    &#123;        age = 10;    &#125;&#125;;// 利用 虚继承 解决菱形继承的问题// 使用 关键字 virtual ，两个派生类继承同一个父类时，两个派生类 可虚拟共享同一个 父类中继承来的成员，（继承了虚基类 Animal的age 的地址）// Animal 类，称为 虚基类class Tiger : virtual public Animal&#123;&#125;;class Lion : virtual public Animal&#123;&#125;;class LionTiger : public Tiger, public Lion&#123;&#125;;void demo1()&#123;    LionTiger lionTiger;    // 菱形继承，两个父类拥有相同的数据，通过作用域区分，同时造成资源浪费，通过 虚继承 解决问题    lionTiger.Tiger::age = 20;    lionTiger.Lion::age = 30;    cout &lt;&lt; &quot;Tiger Age = &quot; &lt;&lt; lionTiger.Tiger::age &lt;&lt; endl;    cout &lt;&lt; &quot;Lion Age = &quot; &lt;&lt; lionTiger.Lion::age &lt;&lt; endl;&#125;int main()&#123;    demo1();    return 0;&#125;\n\n12345// 打印结果D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_7.exe// 使用 虚继承 后，LionTiger 只继承了一个 成员变量Tiger Age = 30Lion Age = 30\n\n12345678910111213141516171819202122232425262728293031323334# 利用 Developer Powershell 工具， 查看 LionTriger 类 的结构 (使用了 虚继承)PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl /d1 reportSingleClassLayoutLionTiger &quot;.\\Inherit_DiamondInheritance.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Inherit_DiamondInheritance.cpp.\\Inherit_DiamondInheritance.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以 防止数据丢失class LionTiger size(12):        +--- 0      | +--- (base class Tiger) 0      | | &#123;vbptr&#125; # 指向 LionTiger::$vbtable@Tiger@:         | +--- 4      | +--- (base class Lion) 4      | | &#123;vbptr&#125; # 指向 LionTiger::$vbtable@Lion@:        | +---        +---        +--- (virtual base Animal) 8      | age        +---LionTiger::$vbtable@Tiger@: # 偏移量 8，从类结构布局的开始 +8，刚好指向 virtual base Animal 的 成员变量 age 0      | 0 1      | 8 (LionTigerd(Tiger+0)Animal) LionTiger::$vbtable@Lion@: # 偏移量 4，从类结构布局的开始 +4，刚好指向 virtual base Animal 的 成员变量 age 0      | 0 1      | 4 (LionTigerd(Lion+0)Animal)vbi:       class  offset o.vbptr  o.vbte fVtorDisp          Animal       8       0       4 0#  一些解释，上面的结构vbptr -&gt; v=virtual, b=base, ptr=pointer; vbptr 指向 vbtablevbtable -&gt; v=virtual, b=base, table\n\n\n\n4.7 多态4.7.1 多态的基本概念多态是C++面向对象的三大特性之一\n\n多态分为两类\n\n静态多态：函数重载 和 运算符重载 属于静态多态，复用函数名\n动态多态：派生类 和 虚函数 实现运行时，为多态\n\n\n静态多态和动态多态的区别\n\n静态多态的函数地址早绑定 — 编译阶段确定函数地址\n动态多态的函数地址晚绑定 — 运行阶段确定函数地址\n\n\n案例说明\n\n静态多态\n12345678910111213141516171819202122232425262728293031323334353637383940414243//// Created by FHang on 2021/6/24 14:56//#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    void speak()    &#123;        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;    &#125;&#125;;class Cat : public Animal&#123;public:    void speak()    &#123;        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;    &#125;&#125;;// 该函数的地址是早绑定，编译阶段确定引用的 Animal类的对象地址，后面调用时，传入Cat对象，不改变结果（静态多态）// 将基类Animal中的 函数 speak() 设为虚函数，运行时才确定地址，后面调用时，传入Cat对象，引用的便是Cat的对象地址（动态多态）void doSpeak(Animal &amp;animal)&#123;    animal.speak();&#125;void demo()&#123;    Cat cat;    doSpeak(cat);&#125;int main()&#123;    demo();    return 0;&#125;\n\n123// 运行结果D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code10_1.exeAnimal Speaking\n\n动态多态\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Created by FHang on 2021/6/24 14:56//#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    // 使用关键字 virtual，使得变成虚函数    virtual void speak()    &#123;        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;    &#125;&#125;;class Cat : public Animal&#123;public:    void speak()    &#123;        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;    &#125;&#125;;class Dog : public Animal&#123;public:    void speak()    &#123;        cout &lt;&lt; &quot;Dog Speaking&quot; &lt;&lt; endl;    &#125;&#125;;// 该函数内传入引用对象调用的speak()函数的地址是早绑定，编译阶段确定引用的 Animal类的对象地址，后面调用时，传入Cat对象，不改变结果（静态多态）// 将基类Animal中的 函数 speak() 设为虚函数，运行时才确定地址，后面调用时，传入Cat对象，引用的便是Cat的对象地址（动态多态）void doSpeak(Animal &amp;animal)&#123;    // speak()早绑定时，默认是传入基类Animal的引用对象地址    // speak()使用virtual后是晚绑定时，传入指定引用对象地址    animal.speak();&#125;void demo()&#123;    Cat cat;    Dog dog;    doSpeak(cat);    doSpeak(dog);&#125;int main()&#123;    demo();    return 0;&#125;\n\n1234// 运行结果D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code10_1.exeCat SpeakingDog Speaking\n\n\n动态多态的满足条件\n\n有继承关系\n子类重写父类的虚函数\n重写：函数返回值类型，函数名，参数列表，完全一致\n\n\n动态多态的使用：父类的指针或引用，执行子类对象\n\n\n4.7.2 多态深入原理案例代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by FHang on 2021/6/24 14:56//#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    virtual void speak()    &#123;        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;    &#125;&#125;;class Cat : public Animal&#123;public:    void speak()    &#123;        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;    &#125;&#125;;class Dog : public Animal&#123;public:    void speak()    &#123;        cout &lt;&lt; &quot;Dog Speaking&quot; &lt;&lt; endl;    &#125;&#125;;void doSpeak(Animal &amp;animal) // 此处 =&gt; Animal &amp;animal = cat&#123;    animal.speak();&#125;void demo()&#123;    Cat cat;    Dog dog;    doSpeak(cat);     doSpeak(dog);&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n静态多态\n\n基类 Animal 中的 speak() 没有 virtual 前是早绑定，函数地址在类外，此时Animal类是空类，大小为1；\n\n\n动态多态\n\n基类 Animal 中的 speak() 有 virtual 是晚绑定，函数地址在类内，此时Animal类不是空类，大小为4；\n\n此时 虚函数speak()，在类内中是 vfptr &#x3D; virtualFunctionPointer ( 虚函数(表)指针 )，指向vftable (虚函数表)，函数地址入口是 &amp;Animal::speak;\n\n子类Cat继承Animal后，默认情况下，Cat类完全继承了Animal类的属性；\n\n但案例代码中，Cat类内实现了speak()的重写，此时函数地址入口是 &amp;Cat::speak;\n\n子类中的虚函数表内部会替换成子类的虚函数地址；\n\n此时，当父类的指针或引用指向子类对象时，发生多态；\n\n\n\n验证：Developer PowerShell\n\n静态多态\n12345678910# 基类Animal 的函数表PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl /d1 reportSingleClassLayoutAnimal &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Polymorphism_DeepUnderlying.cppclass Animal    size(1):        +---        +---\n\n1234567891011121314151617181920212223242526PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl /d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Polymorphism_DeepUnderlying.cppclass _s__CatchableType size(28):        +--- 0      | properties 4      | pType 8      | _PMD thisDisplacement20      | sizeOrOffset24      | copyFunction        +---class _s__CatchableTypeArray    size(4):        +--- 0      | nCatchableTypes 4      | arrayOfCatchableTypes        +---class Cat       size(1):        +--- 0      | +--- (base class Animal) #基类没有实现虚函数，为静态多态时，子类完全继承基类，即使子类重写了speak，也依然是默认的基类对象引用        | +---        +---\n\n\n\n动态多态\n123456789101112131415161718# 基类Animal 的函数表PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl /d1 reportSingleClassLayoutAnimal &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Polymorphism_DeepUnderlying.cppclass Animal    size(4):        +--- 0      | &#123;vfptr&#125;        +---Animal::$vftable@:        | &amp;Animal_meta        |  0 0      | &amp;Animal::speakAnimal::speak this adjustor: 0\n\n123456789101112131415161718192021222324252627282930313233# 子类Cat 没有发生重写时的 函数表PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl /d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Polymorphism_DeepUnderlying.cppclass _s__CatchableType size(28):        +--- 0      | properties 4      | pType 8      | _PMD thisDisplacement20      | sizeOrOffset24      | copyFunction        +---class _s__CatchableTypeArray    size(4):        +--- 0      | nCatchableTypes 4      | arrayOfCatchableTypes        +---class Cat       size(4):        +--- 0      | +--- (base class Animal) 0      | | &#123;vfptr&#125;        | +---        +---Cat::$vftable@:        | &amp;Cat_meta        |  0 0      | &amp;Animal::speak # Cat内没有重写 speak 时，Cat类的函数指针指向的函数表是 Animal 的\n\n1234567891011121314151617181920212223242526272829303132333435# 子类Cat 发生重写时的 函数表PS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl /d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版版权所有(C) Microsoft Corporation。保留所有权利。Polymorphism_DeepUnderlying.cppclass _s__CatchableType size(28):        +--- 0      | properties 4      | pType 8      | _PMD thisDisplacement20      | sizeOrOffset24      | copyFunction        +---class _s__CatchableTypeArray    size(4):        +--- 0      | nCatchableTypes 4      | arrayOfCatchableTypes        +---class Cat       size(4):        +--- 0      | +--- (base class Animal) 0      | | &#123;vfptr&#125;        | +---        +---Cat::$vftable@:        | &amp;Cat_meta        |  0 0      | &amp;Cat::speak  # Cat内重写 speak 后，Cat类的函数指针指向的函数表是 Cat 的Cat::speak this adjustor: 0\n\n\n\n4.7.3 多态案例-计算器\n案例描述：分别使用普通的方法和多态，设计实现两个操作数进行运算的计算器类\n\n多态的优点：\n\n代码组织结构清晰\n可读性强\n利于前期和后期的扩展和维护\n\n\n示例：普通实现\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by FHang on 2021/6/24 16:39//#include &lt;iostream&gt;using namespace std;class Calculator&#123;public:    int num1;    int num2;    float getResult(string f_operator)    &#123;        if (f_operator == &quot;+&quot;)        &#123;            return num1 + num2;        &#125;        if (f_operator == &quot;-&quot;)        &#123;            return num1 - num2;        &#125;        if (f_operator == &quot;*&quot;)        &#123;            return num1 * num2;        &#125;    &#125;&#125;;void demo()&#123;    Calculator calculator&#123;&#125;;    calculator.num1 = 10;    calculator.num2 = 15;    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; + &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; = &quot; &lt;&lt; calculator.getResult(&quot;+&quot;) &lt;&lt; endl;    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; - &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; = &quot; &lt;&lt; calculator.getResult(&quot;-&quot;) &lt;&lt; endl;    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; * &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; = &quot; &lt;&lt; calculator.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n多态实现\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//// Created by FHang on 2021/6/24 18:46//#include &lt;iostream&gt;using namespace std;class AbstractCalculator&#123;public:    int num1;    int num2;    virtual float getResult()    &#123;        return 0.0;    &#125;&#125;;class SumCalculator : public AbstractCalculator&#123;public:    virtual float getResult()    &#123;        return float (num1 + num2);    &#125;&#125;;class SubCalculator : public AbstractCalculator&#123;public:    virtual float getResult()    &#123;        return float (num1 - num2);    &#125;&#125;;class MulCalculator : public AbstractCalculator&#123;public:    virtual float getResult()    &#123;        return float (num1 * num2);    &#125;&#125;;void demo()&#123;    // 父类指针或引用指向子类执行    AbstractCalculator *abs;    // Sum    abs = new SumCalculator;    abs-&gt;num1 = 10;    abs-&gt;num2 = 15;    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; + &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; = &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;    delete abs;    // Sub    abs = new SubCalculator;    abs-&gt;num1 = 10;    abs-&gt;num2 = 15;    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; - &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; = &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;    delete abs;    // Mul    abs = new MulCalculator;    abs-&gt;num1 = 10;    abs-&gt;num2 = 15;    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; * &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; = &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;    delete abs;&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.7.4 纯虚函数和抽象类\n纯函数和抽象类的定义和语法：\n\n在多态中，通常父类中虚函数的实现是无意义的，主要是调用子类中重写的内容，因此可将该虚函数称为 纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0；\n当类中存在纯虚函数时，该类亦可称为抽象类；（例如：4.7.3中的AbstractCalculator类）\n\n\n抽象类的特点：\n\n无法实例化对象\n子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435//// Created by FHang on 2021/6/24 19:15//#include &lt;iostream&gt;using namespace std;// 抽象类class Base&#123;public:    // 纯虚函数    virtual void func() = 0;&#125;;class Derived : public Base&#123;public:    virtual void func()    &#123;        cout &lt;&lt; &quot;Derived Function&quot; &lt;&lt; endl;    &#125;&#125;;void demo()&#123;    Base *base = new Derived;    base-&gt;func();&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.7.5 多态案例-制作饮品\n案例描述：煮水 -&gt; 冲泡 -&gt; 倒入杯中 -&gt; 加入辅料\n\n实现要求：利用多态，提供抽象制作的饮品基类，提供子类制作咖啡和茶叶\n\n案例代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//// Created by FHang on 2021/6/24 19:29//#include &lt;iostream&gt;using namespace std;class AbstractMakeDrinks&#123;public:    virtual void boilWater() = 0;    virtual void brew() = 0;    virtual void pourIntoCup() = 0;    virtual void addAccessories() = 0;    void makeDrinks()    &#123;        boilWater();        brew();        pourIntoCup();        addAccessories();    &#125;    ~AbstractMakeDrinks()    &#123;        cout &lt;&lt; endl;    &#125;&#125;;class MakeCoffee : public AbstractMakeDrinks&#123;public:    MakeCoffee()    &#123;        cout &lt;&lt; &quot;&lt; -- Make Coffee --&gt;&quot; &lt;&lt; endl;    &#125;    virtual void boilWater()    &#123;        cout &lt;&lt; &quot;BoilWater&quot; &lt;&lt; endl;    &#125;    virtual void brew()    &#123;        cout &lt;&lt; &quot;Brew Coffee&quot; &lt;&lt; endl;    &#125;    virtual void pourIntoCup()    &#123;        cout &lt;&lt; &quot;Pour Coffee Into The Cup&quot; &lt;&lt; endl;    &#125;    virtual void addAccessories()    &#123;        cout &lt;&lt; &quot;Add Accessories Like Milk&quot; &lt;&lt; endl;    &#125;&#125;;class MakeTea : public AbstractMakeDrinks&#123;public:    MakeTea()    &#123;        cout &lt;&lt; &quot;&lt; -- Make Tea --&gt;&quot; &lt;&lt; endl;    &#125;    virtual void boilWater()    &#123;        cout &lt;&lt; &quot;BoilWater&quot; &lt;&lt; endl;    &#125;    virtual void brew()    &#123;        cout &lt;&lt; &quot;Brew Tea&quot; &lt;&lt; endl;    &#125;    virtual void pourIntoCup()    &#123;        cout &lt;&lt; &quot;Pour Tea Into The Cup&quot; &lt;&lt; endl;    &#125;    virtual void addAccessories()    &#123;        cout &lt;&lt; &quot;Add Accessories Like Sugar&quot; &lt;&lt; endl;    &#125;&#125;;// 参数是 指针地址 的写法void makeDrinks(AbstractMakeDrinks *abstractMakeDrinks)&#123;    abstractMakeDrinks-&gt;makeDrinks();    delete abstractMakeDrinks;&#125;void makeDrinks_Coffee()&#123;    makeDrinks(new MakeCoffee);&#125;void makeDrinks_Tea()&#123;    makeDrinks(new MakeTea);&#125;// 参数是 对象引用 的写法//void makeDrinks(AbstractMakeDrinks &amp;abstractMakeDrinks)//&#123;//    abstractMakeDrinks.makeDrinks();//    delete &amp;abstractMakeDrinks;//&#125;////void makeDrinks_Coffee()//&#123;//    makeDrinks(*new MakeCoffee);//&#125;////void makeDrinks_Tea()//&#123;//    makeDrinks(*new MakeTea);//&#125;int main()&#123;    makeDrinks_Coffee();    makeDrinks_Tea();    return 0;&#125;\n\n4.7.6 虚析构和纯虚析构\n多态使用时，如果子类中有属性开辟到堆区，父类指针在释放时无法调用到子类的析构代码\n\n解决方式：将父类中的析构函数改为虚析构或纯虚析构\n\n虚析构和纯虚析构的共性：\n\n可以解决父类指针释放子类对象\n都需要具体的函数实现\n\n\n虚析构和纯虚析构的区别：\n\n如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n\n虚析构语法：virtual ~类名 () &#123;&#125;\n\n纯虚析构语法：\n\n类内：virtual ~类名 () = 0;\n类外：类名::~类名() &#123;&#125;\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//// Created by FHang on 2021/6/24 20:24//#include &lt;iostream&gt;using namespace std;class Animal&#123;public:    Animal()    &#123;        cout &lt;&lt; &quot;Animal Construct Transfer&quot; &lt;&lt; endl;    &#125;    // 虚析构，此时释放父类时，会调用子类的析构函数    virtual ~Animal()    &#123;        cout &lt;&lt; &quot;Animal Destruct Transfer&quot; &lt;&lt; endl;    &#125;    // 纯虚析构，在类外实现具体    // virtual ~Animal() = 0;    // 纯虚函数    virtual void speak() = 0;&#125;;// 类外实现的 纯虚析构//Animal::~Animal()//&#123;//    cout &lt;&lt; &quot;Animal Destruct Transfer&quot; &lt;&lt; endl;//&#125;class Cat : public Animal&#123;public:    string *cat_Name;    Cat(string name)    &#123;        cout &lt;&lt; &quot;Cat Construct Transfer&quot; &lt;&lt; endl;        cat_Name = new string(name);    &#125;    ~Cat()    &#123;        if (cat_Name != nullptr)        &#123;            cout &lt;&lt; &quot;Cat Destruct Transfer&quot; &lt;&lt; endl;            delete cat_Name;            cat_Name = nullptr;        &#125;    &#125;    virtual void speak()    &#123;        cout &lt;&lt; *cat_Name &lt;&lt; &quot;Cat is Speaking&quot; &lt;&lt; endl;    &#125;&#125;;void demo()&#123;    // 父类指针指向子类调用    Animal *animal = new Cat(&quot;Tom&quot;);    animal-&gt;speak();    // 释放父类对象析构时，不会调用子类的析构函数，出现内存泄露    // 在基类的析构函数前 加入关键字 virtual，即可解决问题    delete animal;&#125;int main()&#123;    demo();    return 0;&#125;\n\n总结：\n\n虚析构和纯虚析构，用来解决父类指针释放子类对象\n如果子类在堆区中，没有开辟空间，可以不写虚析构或纯虚析构\n拥有纯虚析构的类，属于抽象类\n\n\n\n4.7.7 多态案例-电脑组装\n案例描述：\n\n电脑主要组成部分：CPU，显卡，内存条；\n将每个零件封装成抽象基类，并且提供不同的厂商生产不同的零件，例如：Inter和AMD；\n创建电脑类提供电脑工作的函数，并且调用每个零件工作的接口；\n测试时，组装三台电脑进行测试\n\n\n案例代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//// Created by FHang on 2021/6/25 14:06//#include &lt;iostream&gt;using namespace std;// 抽象 CPU类class CPU&#123;public:    virtual void calculation() = 0;&#125;;// 抽象 显卡类class GraphicsCard&#123;public:    virtual void display() = 0;&#125;;// 抽象 内存类class RAM&#123;public:    virtual void storage() = 0;&#125;;// 电脑类class Computer&#123;private:    string *name;    CPU *cpu;    GraphicsCard *graphicsCard;    RAM *ram;public:    // 电脑零件组装    Computer(string *name, CPU *cpu, GraphicsCard *graphicsCard, RAM *ram)    &#123;        this-&gt;name = name;        this-&gt;cpu = cpu;        this-&gt;graphicsCard = graphicsCard;        this-&gt;ram = ram;        cout &lt;&lt; &quot;&lt; --&quot; &lt;&lt; *this-&gt;name &lt;&lt; &quot; Computer Is Start Run&quot; &lt;&lt; &quot;-- &gt;&quot; &lt;&lt; endl;    &#125;    ~Computer()    &#123;        if (cpu != nullptr)        &#123;            delete cpu;            cpu = nullptr;        &#125;        if (graphicsCard != nullptr)        &#123;            delete graphicsCard;            graphicsCard = nullptr;        &#125;        if (ram != nullptr)        &#123;            delete ram;            ram = nullptr;        &#125;        cout &lt;&lt; &quot;&lt; --&quot; &lt;&lt; *this-&gt;name &lt;&lt; &quot; Computer Is Running Normal&quot; &lt;&lt; &quot;-- &gt;&quot; &lt;&lt; endl;        cout &lt;&lt; endl;    &#125;    // 电脑运行函数    void computerRun()    &#123;        // 电脑零件 接口调用        cpu-&gt;calculation();        graphicsCard-&gt;display();        ram-&gt;storage();    &#125;&#125;;// 具体厂商的类// Inter Classclass Inter_CPU : public CPU&#123;public:    void calculation() override    &#123;        cout &lt;&lt; &quot;Inter CPU Is Calculation&quot; &lt;&lt; endl;    &#125;&#125;;class Inter_GraphicsCard : public GraphicsCard&#123;public:    void display() override    &#123;        cout &lt;&lt; &quot;Inter Graphics Card Is Displaying&quot; &lt;&lt; endl;    &#125;&#125;;class Inter_RAM : public RAM&#123;public:    void storage() override    &#123;        cout &lt;&lt; &quot;Inter RAM Is In Storage&quot; &lt;&lt; endl;    &#125;&#125;;// AMD Classclass AMD_CPU : public CPU&#123;public:    void calculation() override    &#123;        cout &lt;&lt; &quot;AMD CPU Is Calculation&quot; &lt;&lt; endl;    &#125;&#125;;class AMD_GraphicsCard : public GraphicsCard&#123;public:    void display() override    &#123;        cout &lt;&lt; &quot;AMD Graphics Card Is Displaying&quot; &lt;&lt; endl;    &#125;&#125;;class AMD_RAM : public RAM&#123;public:    void storage() override    &#123;        cout &lt;&lt; &quot;AMD RAM Is In Storage&quot; &lt;&lt; endl;    &#125;&#125;;// 组装不同厂商组件的电脑// Assembling Inter Computervoid assemblingComputer_Inter()&#123;    // 准备 Inter Computer 的 Component    string name = &quot;Inter&quot;;    CPU *interCPU = new Inter_CPU;    GraphicsCard *interGraphicsCard = new Inter_GraphicsCard;    RAM *interRAM = new Inter_RAM;    // Assembling Inter Computer    Computer *computer = new Computer(&amp;name, interCPU, interGraphicsCard, interRAM);    // Running Inter Computer    computer-&gt;computerRun();    delete computer;&#125;// Assembling AMD Computervoid assemblingComputer_AMD()&#123;    // 准备 AMD Computer 的 Component    string name = &quot;AMD&quot;;    CPU *amdCPU = new AMD_CPU;    GraphicsCard *amdGraphicsCard = new AMD_GraphicsCard;    RAM *amdRAM = new AMD_RAM;    // Assembling AMD Computer    Computer *computer = new Computer(&amp;name, amdCPU, amdGraphicsCard, amdRAM);    // Running AMD Computer    computer-&gt;computerRun();    delete computer;&#125;int main()&#123;    assemblingComputer_Inter();    assemblingComputer_AMD();    return 0;&#125;\n\n5. 文件操作\n文件作用：\n程序运行时产生的数据都是临时数据，程序结束后，都会被释放\n通过文件，可以将数据持久化\nC++中对文件操作，需要包含头文件 &lt;fstream&gt;\n\n\n文件类型：\n文本文件：文件以文本的ASCII码形式存储在计算机中\n二进制文件：文件以文本的二进制形式存储在计算机中，无法直接读懂\n\n\n操作文件的三大类：\nofstream：写操作\t\nifstream：读操作\nfstream：读写操作\n\n\n\n5.1 文本文件5.1.1 写文本文件\n写文件步骤：\n\n包含头文件：#include &lt;fstream&gt;\n创建流对象：ofstream ofs\n打开文件：ofs.open(&quot;文件路径&quot;, 打开方式)\n写数据：ofs &lt;&lt; &quot;写入数据&quot;;\n关闭文件：ofs.close()\n\n\n文件的打开方式：\n\n\n\n打开方式\n解释\n\n\n\nios::in\n为读文件而打开文件\n\n\nios::out\n为写文件而打开文件\n\n\nios::ate\n初始位置：文件尾\n\n\nios::app\n追加方式写文件\n\n\nios::trunc\n如果文件存在，先删除，再创建\n\n\nios::binary\n二进制方式\n\n\n\n注意：文件打开方式，可以配合使用，利用 |操作符\n\n例如：用二进制方式写文件：ios::binary | ios::out\n\n代码示例：\n12345678910111213141516171819202122232425//// Created by FHang on 2021/6/25 15:56//#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;void demo()&#123;    ofstream ofs;    ofs.open(R&quot;(C:\\Users\\Admin\\Desktop\\demo.txt)&quot;, ios::out);    ofs &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;    ofs &lt;&lt; &quot;Hello FHang&quot; &lt;&lt; endl;    ofs.close();&#125;int main()&#123;    demo();    return 0;&#125;\n\n5.1.2 读文本文件\n写文件步骤：\n\n包含头文件：#include &lt;fstream&gt;\n创建流对象：ifstream ifs\n先判断打开文件是否成功，打开文件：ifs.open(&quot;文件路径&quot;, 打开方式)\n读数据：四种读取方式\n关闭文件：ifs.close()\n\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by FHang on 2021/6/25 16:06//#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;void demo()&#123;    ifstream ifs;    ifs.open(R&quot;(C:\\Users\\Admin\\Desktop\\demo.txt)&quot;, ios::in);    if (!ifs.is_open())    &#123;        cout &lt;&lt; &quot;Open File Failed&quot; &lt;&lt; endl;\treturn;    &#125;    // 读数据，四种    // 1. 一行行读，不喜欢这个//    char buf[1024] = &#123;0&#125;;//    while (ifs &gt;&gt; buf)//    &#123;//        cout &lt;&lt; buf &lt;&lt; endl;//    &#125;    // 2. 一行行读，感觉一般//    char buf[1024] = &#123;0&#125;;//    while (ifs.getline(buf, sizeof(buf)))//    &#123;//        cout &lt;&lt; buf &lt;&lt; endl;//    &#125;    // 3. 一行行读，个人一般常用    string buf;    while (getline(ifs, buf))    &#123;        cout &lt;&lt; buf &lt;&lt; endl;    &#125;    // 4. 一个个读，慢//    char buf;//    while ((buf = ifs.get()) != EOF)//    &#123;//        cout &lt;&lt; buf;//    &#125;    ifs.close();&#125;int main()&#123;    demo();    return 0;&#125;\n\n5.2 二进制文件\n以二进制的方式对文件进行读写操作\n打开方式需要指定：ios:binary\n\n5.2.1 写二进制文件\n二进制写文件主要利用 流对象 调用成员函数 write()\n\n函数原型：ostream &amp;write(const char *buffer, int len);\n\n参数解释：字符指针 buffer指向内存中一段内存空间，len是读写的字节数\n\n代码示例：\n1234567891011121314151617181920212223242526272829//// Created by FHang on 2021/6/25 16:34//#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;class Person&#123;public:    string f_Name;    int f_Age;&#125;;void demo()&#123;    Person person = &#123;&quot;FHang&quot;, 24&#125;;    ofstream ofs;    ofs.open(R&quot;(C:\\Users\\Admin\\Desktop\\Person.txt)&quot;, ios::out | ios::binary);    ofs.write((const char *) &amp;person, sizeof(Person));    ofs.close();&#125;int main()&#123;    demo();    return 0;&#125;\n\n5.2.2 读二进制文件\n二进制方式读文件，主要利用 流对象 调用成员函数 read\n\n函数原型：ostream &amp;read(char *buffer, int len);\n\n参数解释：字符指针 buffer指向内存中一段内存空间，len是读写的字节数\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839//// Created by FHang on 2021/6/25 17:00//#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;class Person&#123;public:    string f_Name;    int f_Age;&#125;;void demo()&#123;    Person person;    ifstream ifs;    ifs.open(R&quot;(C:\\Users\\Admin\\Desktop\\Person.txt)&quot;, ios::in | ios::binary);    if (!ifs.is_open())    &#123;        cout &lt;&lt; &quot;Open File Failed&quot; &lt;&lt; endl;        return;    &#125;    ifs.read((char *) &amp;person, sizeof(Person));    cout &lt;&lt; &quot;Name = &quot; &lt;&lt; person.f_Name &lt;&lt; endl;    cout &lt;&lt; &quot;Age = &quot; &lt;&lt; person.f_Age &lt;&lt; endl;    ifs.close();&#125;int main()&#123;    demo();    return 0;&#125;\n\n6. extern C\n功能描述：将C++代码，以C语言的形式进行编译\n\n作用：用于C/C++混合开发时，C++中使用C写的第三方库时使用\n\n注意：C不支持函数重载\n\n代码示例：\n12345678910111213141516extern &quot;C&quot;&#123;    int func();    int func(int a);&#125;int main()&#123;    func();    func(1);    return o;&#125;int func()&#123;return 0;&#125;int func(int a)&#123;return a;&#125;\n\n以上是 extern C 的使用方式，但这个程序编译会报错；\n在 C/C++ 中，编译时转汇编，依据编译器的区别，函数名会变改名：\n12345// C call _func()// C++call func_i()\n\n所以，当C++文件中，使用extern C修饰重载函数后，编译会出错\n\n\n6.1 实例演示1\nmath.h\n1234extern &quot;C&quot;&#123;    int sum(int a, int b);&#125;\n\nmath.c\n1234int sum(int a, int b)&#123;    return a + b;&#125;\n\ndemo.cpp\n12345678#include &lt;iostream&gt;#include &quot;math.h&quot;int main()&#123;    std::cout &lt;&lt; sum(1, 2) &lt;&lt; std::endl;    return 0;&#125;\n\n在C++文件中，不能直接使用C文件中的函数，因为编译器的区别，相同的函数名，在编译时，函数的名称会变得不同，所以C++文件中就找不到C中的函数声明和实现，只能指向自己文件中的声明；\n所以需要 extern C修饰，这样编译器就会在编译时修改函数名，修改成C的规范，这样C++文件中就可以找到C文件中的函数声明和实现;\n\n补充：如果别的 C 文件中要使用 math.h ，直接包含 math.h 会报错，因为 C 的编译器 无法识别 extern C\n\n注意：\n\nextern C 直接修饰 C的头文件内的声明即可，同时修饰实现也可以，但没必要；唯独不能只修饰实现；\n\n\n\n6.2 实例演示2\n补充知识：\n\nCpp 文件开头默认会有#define __cpluscplus，用于编译时标识自己是 Cpp 文件\nCpp 头文件中一般可以使用： \n#ifdef 项目文件名\n#endif\n包含头文件内容\n\n\n\n\n代码示例：\nmath.h \n12345678910#ifdef __cpluscplusextern &quot;C&quot;&#123;#endif // __cpluscplus        int sum(int a, int b);    #ifdef __cpluscplus    &#125;#endif // __cpluscplus\n\n\n\ndemo.cpp\n12345678910#define __cpluscplus // 编译时 默认存在的#include &lt;iostream&gt;#include &quot;math.h&quot;int main()&#123;    std::cout &lt;&lt; sum(1, 2) &lt;&lt; std::endl;    return 0;&#125;\n\n当 Cpp 文件包含这个头文件时，编译时会识别到 #ifdef和#endif，这样 extern C就可以生效；\n当 C 文件包含这个头文件时，编译时就会忽略 extern C；\n这样的写法格式的好处：C 文件 和 Cpp 文件 都可以直接包含 math.h文件，进行使用\n\n补充知识：实际开发中，避免重复引用头文件，浪费资源，需要使用 #ifndef __文件名_H 、#define __文件名_H 、#endif\nmath.h\n123456789101112131415#ifndef __MATH_H // 规范写法#define __MATH_H#ifdef __cpluscplusextern &quot;C&quot;&#123;#endif // __cpluscplus        int sum(int a, int b);    #ifdef __cpluscplus    &#125;#endif // __cpluscplus#endif // MATH\n\n#ifdef：如果定义了，参与编译\n\n#ifndef：如果没有被其它文件引用或定义\n\n#define：定义这个文件的内容\n\n#endif：结束定义\n\n简单写法：#pragma once\nmath.h\n123456789101112#pragma once#ifdef __cpluscplusextern &quot;C&quot;&#123;#endif // __cpluscplus        int sum(int a, int b);    #ifdef __cpluscplus    &#125;#endif // __cpluscplus\n\n效果和 #ifndef __文件名_H 、#define __文件名_H 、#endif 是一样的\n\n#ifndef __文件名_H 、#define __文件名_H 、#endif受到C&#x2F;C++标准支持，不受编译器限制\n\n#pragma once 老版编译器不兼容(GCC 3.4之前的版本)\n\n\n","slug":"1_C++_核心编程_03","date":"2022-10-06T07:28:25.912Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"1314ed16965aff00f28615c8023e8a57","title":"C++_STL算法","content":"C++_STL算法[toc]\n概述：\n\n算法主要是头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt; 组成\n&lt;algorithm&gt; 是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等到\n&lt;numeric&gt; 体积很小，包括几个序列上面进行简单数学运算和模板函数\n&lt;functional&gt; 定义了一些类模板，用以声明函数对象\n\n1. 常用遍历算法\n\n\n算法简介\n\n\n\n\nfor_each\n遍历容器\n\n\ntransform\n搬运容器到另一个容器\n\n\n1.1 for_each\n功能描述：实现遍历容器\n\n函数原型：\n\nfor_each(iterator begin, iterator end, _functional);\n_functional 函数或函数对象\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by FHang on 2021/11/20 13:48//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class PrintVector_Class&#123;public:    void operator()(int &amp;value)    &#123;        cout &lt;&lt; value &lt;&lt; &quot; &quot;;    &#125;&#125;;void printVector_func(int &amp;value)&#123;    cout &lt;&lt; value &lt;&lt; &quot; &quot;;&#125;void demo()&#123;    vector&lt;int&gt; v;    v.reserve(5);    for (int i = 0; i &lt; 5; ++i)    &#123;        v.push_back(i);    &#125;    for_each(v.begin(), v.end(), printVector_func);    cout &lt;&lt; endl;    for_each(v.begin(), v.end(), PrintVector_Class());    cout &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n1.2 transform\n功能描述：搬运容器到另一个容器中\n\ntransform(iterator begin_1, iterator end_1, iterator iterator_2, _functional);\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// Created by FHang on 2021/11/20 14:29//#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;class TransVector&#123;public:    int operator()(int &amp;value)    &#123;        return value;    &#125;&#125;;int transVector_Func(int &amp;value)&#123;    return value;&#125;void printVector(const vector&lt;int&gt; &amp;v)&#123;    for (int it: v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    v1.reserve(5);    for (int i = 0; i &lt; 5; ++i)    &#123;        v1.push_back(i);    &#125;    v2.resize(v1.size());    // transform(v1.begin(), v1.end(), v2.begin(), TransVector());    transform(v1.begin(), v1.end(), v2.begin(), transVector_Func);    printVector(v2);&#125;int main()&#123;    demo();    return 0;&#125;\n\n2. 常用查找算法\n\n\n算法简介\n\n\n\n\nfind\n查找元素\n\n\nfind_if\n按条件查找元素\n\n\nadjacent_find\n查找相邻重复的元素\n\n\nbinary_search\n二分查找法\n\n\ncount\n统计元素个数\n\n\ncount_if\n按条件统计元素个数\n\n\n2.1 find\n功能描述：查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()\n\n函数原型：find(iterator begin, iterator end, value);\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// Created by FHang on 2021/11/20 14:52//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Person&#123;public:    string name;    int age;    Person(const string &amp;name, const int &amp;age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    // find 底层无法比较 自定义数据类型，所以要 重载==    // find 底层是直接 解析元素迭代器去比较要 查找的元素值，所以 自定义类型的数据，无法直接比较    bool operator==(const Person &amp;person)    &#123;        if (this-&gt;name == person.name &amp;&amp; this-&gt;age == person.age)        &#123;            return true;        &#125;        else        &#123;            return false;        &#125;    &#125;&#125;;void demo()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;QQ&quot;, 12);    Person p2(&quot;WW&quot;, 12);    Person p3(&quot;EE&quot;, 12);    Person p4(&quot;RR&quot;, 12);    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);    if (it == v.cend())    &#123;        cout &lt;&lt; &quot;No Find&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; it-&gt;name &lt;&lt; &quot; = &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;    &#125;&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n\n总结：\n\nfind 底层无法比较自定义数据类型，所以要重载==\nfind 底层是直接解析元素迭代器去比较要查找的元素值，所以自定义类型的数据，无法直接比较\n\n\n\n2.2 find_if\n功能描述：按条件查找\n\n函数原型：find_if(iterator begin, iterator end, _Pred);\n\n_Pred：函数或谓词(返回bool类型)\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//// Created by FHang on 2021/11/20 15:42//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Person&#123;public:    string name;    int age;    Person(const string &amp;name, const int &amp;age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;&#125;;class FindIF_MoreThan_3&#123;public:    bool operator()(const int &amp;value)    &#123;        return value &gt; 3;    &#125;&#125;;class FindIF_MoreThan_Age_8&#123;public:    bool operator()(const Person &amp;person)    &#123;        return person.age &gt; 8;    &#125;&#125;;class UpSort_Age&#123;public:    bool operator()(Person &amp;person1, Person &amp;person2)    &#123;        return person1.age &lt; person2.age;    &#125;&#125;;void printVector(const vector&lt;Person&gt; &amp;v)&#123;    for (vector&lt;Person&gt;::const_iterator it = v.cbegin(); it != v.cend(); ++it)    &#123;        cout &lt;&lt; it-&gt;name &lt;&lt; &quot; : &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;    &#125;&#125;void demo1()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 5; ++i)    &#123;        v.push_back(i);    &#125;    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), FindIF_MoreThan_3());    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; *it &lt;&lt; endl;&#125;void demo2()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;QQ&quot;, 13);    Person p2(&quot;WW&quot;, 8);    Person p3(&quot;EE&quot;, 10);    Person p4(&quot;RR&quot;, 12);    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    sort(v.begin(), v.end(), UpSort_Age());    printVector(v);    vector&lt;Person&gt;::iterator it = find_if(v.begin(),  v.end(), FindIF_MoreThan_Age_8());    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; = &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n2.3 adjacent_find\n功能描述：查找相邻重复元素\n\n函数原型：adjacent_find(iterator begin, iterator end);\n\n返回相邻元素的第一个位置的迭代器\n\n代码示例：\n12345678910111213141516171819202122232425262728//// Created by FHang on 2021/11/20 16:38//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void demo()&#123;    vector&lt;int&gt; v;    v.push_back(0);    v.push_back(1);    v.push_back(0);    v.push_back(2);    v.push_back(2);    vector&lt;int&gt;::iterator it = adjacent_find(v.begin(),  v.end());    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; *it &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n2.4 binary_search\n功能描述：查找指定元素是否存在\n\n函数原型：bool binary_search(iterator begin, iterator end, value);\n\n查找指定元素，找到返回 ture 否则返回 false\n\n不用于无序序列(就是容器内的元素不是有序排列的)\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536//// Created by FHang on 2021/11/20 16:51//#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 5; ++i)    &#123;        v.push_back(i);    &#125;    bool isSearch = binary_search(v.begin(),  v.end(), 5);    string searchRet = isSearch ? &quot;true&quot; : &quot;false&quot;;    if (isSearch)    &#123;        cout &lt;&lt; &quot;Search: &quot; &lt;&lt; searchRet &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Search: &quot; &lt;&lt; searchRet &lt;&lt; endl;    &#125;&#125;int main()&#123;    demo();    return 0;&#125;\n\n\n\n总结：binary_search()效率很高，只用于有序序列\n\n\n2.5 count\n功能描述：统计元素个数\n\n函数原型：count(iterator begin, iterator end, value);\n\n返回int类型\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//// Created by FHang on 2021/11/21 13:02//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;class Person&#123;public:    string name;    int age;    Person(const string &amp;name, const int &amp;age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    bool operator==(const Person &amp;p)    &#123;        if (this-&gt;age == p.age)        &#123;            return true;        &#125;        else        &#123;            return false;        &#125;    &#125;&#125;;void printVector(const vector&lt;int&gt; &amp;v)&#123;    for (int it : v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void printVector(const vector&lt;Person&gt; &amp;p)&#123;    for (Person it : p)    &#123;        cout &lt;&lt; it.name &lt;&lt; &quot; : &quot; &lt;&lt; it.age &lt;&lt; endl;    &#125;&#125;void demo1()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v.push_back(rand()%2);    &#125;    printVector(v);    int countNum = count(v.begin(),  v.end(), 0);    cout &lt;&lt; &quot;Count 0 : &quot; &lt;&lt; countNum &lt;&lt; endl;&#125;void demo2()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;QQ&quot;, 11);    Person p2(&quot;WW&quot;, 10);    Person p3(&quot;EE&quot;, 10);    Person p4(&quot;RR&quot;, 10);    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    Person p(&quot;SS&quot;, 10);    printVector(v);    int countNum = count(v.begin(),  v.end(), p);    cout &lt;&lt; &quot;Count P : &quot; &lt;&lt; countNum &lt;&lt; endl;&#125;int main()&#123;    srand((unsigned int) time(NULL));    demo1();    demo2();    return 0;&#125;\n\n2.6 count_if\n功能描述：按条件统计元素个数\n\n函数原型：count_if(iterator begin, iterator end, _Pred);\n\n_Pred谓词(条件)\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// Created by FHang on 2021/11/21 13:50//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Person&#123;public:    int age;    Person(const int &amp;age)    &#123;        this-&gt;age = age;    &#125;&#125;;bool great_4(const int &amp;value)&#123;    return value &gt; 4;&#125;bool equal_10(const Person &amp;p)&#123;    return p.age == 10;&#125;void demo1()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;=9; ++i)    &#123;        v.push_back(i);    &#125;    const int countNum = count_if(v.begin(),  v.end(), great_4);    cout &lt;&lt; countNum &lt;&lt; endl;&#125;void demo2()&#123;    vector&lt;Person&gt; v;    Person p1(11);    Person p2(10);    Person p3(10);    Person p4(10);    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    int countNum = count_if(v.begin(),  v.end(), equal_10);    cout &lt;&lt; countNum &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n3. 常用排序算法\n\n\n算法简介\n\n\n\n\nsort\n对容器内元素进行排序\n\n\nrandom_shuffle\n洗牌–指定范围内元素随机调整次序\n\n\nmerge\n容器元素合并，并存储到另一个容器中\n\n\nreverse\n反转指定范围的元素\n\n\n3.1 sort\n功能描述：对容器内元素进行排序\n\n函数原型：\n\nsort(iterator begin, iterator end, _Pred);\n按照谓词的条件查找元素，找到返回指定元素位置的迭代器，找不到返回结束迭代器位置\nsort(iterator begin, iterator end);\n默认从小到大排序\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// Created by FHang on 2021/11/21 14:09//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;template&lt;class T&gt;void printVector(const vector&lt;T&gt; &amp;v)&#123;    for (T it : v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;template&lt;class T&gt;bool downSort(const T &amp;value1, const T &amp;value2)&#123;    return value1 &gt; value2;&#125;void demo1()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;=9; ++i)    &#123;        v.push_back(rand()%10);    &#125;    printVector(v);    sort(v.begin(), v.end());    printVector(v);    sort(v.begin(), v.end(), downSort&lt;int&gt;);    printVector(v);&#125;int main()&#123;    srand((unsigned int)time(NULL));    demo1();    return 0;&#125;\n\n3.2 random_shuffle\n功能描述：洗牌–指定范围内的元素随机调整次序\n\n函数原型：random_shuffle(iterator begin, iterator end);\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940//// Created by FHang on 2021/11/21 14:27//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;template&lt;class T&gt;void printVector(const vector&lt;T&gt; &amp;v)&#123;    for (T it : v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo1()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v.push_back(i);    &#125;    printVector(v);    random_shuffle(v.begin(), v.end());    printVector(v);&#125;int main()&#123;    srand((unsigned int)time(NULL));    demo1();    return 0;&#125;\n\n3.3 merge\n功能描述：两个容器元素合并，存储到同一个容器中\n\n函数原型：merge(iterator begin1, iterator end1, iterator begin2, iterator end2, iterator newBegin);\n\n注意：两个容器内的元素，必须是有序序列\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738//// Created by FHang on 2021/11/21 15:41//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;template&lt;class T&gt;void printVector(T value)&#123;    cout &lt;&lt; value &lt;&lt; &quot; &quot;;&#125;void demo()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    vector&lt;int&gt; v3;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v1.push_back(i);        v2.push_back(9 - i);    &#125;    v3.resize(v1.size() + v2.size());    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());    for_each(v3.begin(), v3.end(), printVector&lt;int&gt;);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.4 reverse\n功能描述：将容器内元素进行反转\n\n函数原型：reverse(iterator begin, iterator end);\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// Created by FHang on 2021/11/21 15:51//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;template&lt;class T&gt;class PrintVector_T&#123;public:    void operator()(const T &amp;value)    &#123;        cout &lt;&lt; value &lt;&lt; &quot; &quot;;    &#125;&#125;;template&lt;class T&gt;void printVector_T(const T &amp;value)&#123;    cout &lt;&lt; value &lt;&lt; &quot; &quot;;&#125;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v.push_back(i);    &#125;    cout &lt;&lt; &quot;Meta: &quot;;    for_each(v.begin(), v.end(), PrintVector_T&lt;int&gt;());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;Reverse: &quot;;    reverse(v.begin(), v.end());    for_each(v.begin(), v.end(), printVector_T&lt;int&gt;);    cout &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n4. 常用拷贝替换算法\n\n\n算法简介\n\n\n\n\ncopy\n容器内指定范围的元素拷贝到另一个容器中\n\n\nreplace\n容器内指定范围的旧元素 改为 新元素\n\n\nreplace_if\n容器内指定范围的满足条件的旧元素 改为 新元素\n\n\nswap\n互换两个容器的元素\n\n\n4.1 copy\n功能描述：容器内指定范围的元素拷贝到另一个容器中\n\n函数原型：copy(iterator begin, iterator end, iterator newBegin);\n\n按值查找元素，返回找到的指定位置迭代器，找不到返回结束迭代器\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940//// Created by FHang on 2021/11/21 16:10//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class PrintVector&#123;public:    void operator()(int value)    &#123;        cout &lt;&lt; value &lt;&lt; &quot; &quot;;    &#125;&#125;;void demo()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v1.push_back(i);    &#125;    v2.resize(v1.size());    copy(v1.begin(), v1.end(), v2.begin());    for_each(v2.begin(), v2.end(), PrintVector());&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.2 replace\n功能描述：容器内指定范围的旧元素 改为 新元素\n\n函数原型：replace(iterator begin, iterator end, old_Value, new_Value);\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839//// Created by FHang on 2021/11/21 16:18//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)&#123;    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;    for (const int it: v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v.push_back(i);    &#125;    printVector(v, &quot;Meta&quot;);    replace(v.begin(), v.end(), 0, 9);    printVector(v, &quot;New&quot;);&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.3 replace_if\n功能描述：容器内指定范围的满足条件的旧元素 改为 新元素\n\n函数原型：replace_if(iterator beign, iterator end, _Pred, new_Value);\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344//// Created by FHang on 2021/11/21 16:25//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)&#123;    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;    for (const int it: v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;bool greater_5(int value)&#123;    return value &gt; 5;&#125;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v.push_back(i);    &#125;    printVector(v, &quot;Meta&quot;);    replace_if(v.begin(), v.end(), greater_5, 0);    printVector(v, &quot;New&quot;);&#125;int main()&#123;    demo();    return 0;&#125;\n\n4.4 swap\n功能描述：互换两个容器的元素\n\n函数原型：swap(contatiner c1, contatiner c2);\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243//// Created by FHang on 2021/11/21 16:30//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)&#123;    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;    for (const int it: v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v1.push_back(i);        v2.push_back(9 - i);    &#125;    printVector(v1, &quot;meta&quot;);    printVector(v2, &quot;meta&quot;);    swap(v1, v2);    printVector(v1, &quot;new&quot;);    printVector(v2, &quot;new&quot;);&#125;int main()&#123;    demo();    return 0;&#125;\n\n5. 常用算术生成算法\n注意：算术生成算法属于小型算法，使用时需要包含头文件#include &lt;numeric&gt;\n\n\n\n算法简介\n\n\n\n\naccumulate\n计算容器区间内元素累计总和\n\n\nfill\n向容器中填充元素\n\n\n\n\n5.1 accumulate\n功能描述：计算容器区间内元素累计总和\n\n函数原型：accumulate(iterator begin, iterator end, value);\n\nvalue起始值\n\n代码示例：\n123456789101112131415161718192021222324252627//// Created by FHang on 2021/11/21 17:02//#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;vector&gt;using namespace std;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v.push_back(i);    &#125;    const int sum = accumulate(v.cbegin(), v.cend(), 0);    cout &lt;&lt; sum &lt;&lt; endl;&#125;int main()&#123;    demo();    return 0;&#125;\n\n5.2 fill\n功能描述：向容器中填充元素\n\n函数原型：fill(iterator begin, iterator end, value);\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435//// Created by FHang on 2021/11/21 17:12//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printVector(const vector&lt;int&gt; &amp;v)&#123;    for (const int it : v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt;= 8; ++i)    &#123;        v.push_back(i);    &#125;    fill(v.begin(), v.end(), 9);    printVector(v);&#125;int main()&#123;    demo();    return 0;&#125;\n\n6. 常用集合算法\n\n\n算法简介\n\n\n\n\nset_intersection\n求两个容器的交集\n\n\nset_union\n求两个容器的并集\n\n\nset_difference\n求两个容器的差集\n\n\n\n注意：\n使用前，确保 新容器 的预设一个 合适大小\n算法返回的是 最后一个元素 所在位置的 迭代器\n遍历 新容器 要用 算法返回的迭代器，而不是使用 新容器自身的结束迭代器\n交集算法中，新容器自身的结束迭代器 可能超出 最后一个元素 所在位置的 迭代器\n\n\n\n6.1 set_intersection\n功能描述：求两个容器的交集\n\n函数原型：set_intersection(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// Created by FHang on 2021/11/21 17:27//#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void printVector(const vector&lt;int&gt; &amp;v, const char *containerName)&#123;    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;    for (const int it : v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)&#123;    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;    for (vector&lt;int&gt;::const_iterator itBegin = v.begin(); itBegin != it; ++itBegin)    &#123;        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    vector&lt;int&gt; v_tag;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v1.push_back(i);        v2.push_back(i + 5);    &#125;    printVector(v1, &quot;V1&quot;);    printVector(v2, &quot;V2&quot;);    v_tag.resize(min(v1.size(), v2.size()));    vector&lt;int&gt;::const_iterator itLast = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());    // 使用 新容器自身迭代器    printVector(v_tag, &quot;Target&quot;);    // 使用 set_intersection 返回的 最后一个元素的迭代器    printVector(v_tag, itLast, &quot;Target&quot;);&#125;int main()&#123;    demo();    return 0;&#125;\n\n6.2 set_union\n功能描述：求两个容器的并集\n\n函数原型：set_union(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by FHang on 2021/11/21 17:50//#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void printVector(const vector&lt;int&gt; &amp;v, const char *containerName)&#123;    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;    for (const int it : v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)&#123;    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;    for (vector&lt;int&gt;::const_iterator itBegin = v.begin(); itBegin != it; ++itBegin)    &#123;        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    vector&lt;int&gt; v_tag;    for (int i = 0; i &lt;= 4; ++i)    &#123;        v1.push_back(i);        v2.push_back(i + 4);    &#125;    printVector(v1, &quot;V1&quot;);    printVector(v2, &quot;V2&quot;);    v_tag.resize(v1.size() + v2.size());    vector&lt;int&gt;::const_iterator itLast = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());    // 使用 set_union 返回的 最后一个元素的迭代器    printVector(v_tag, itLast, &quot;Target&quot;);&#125;int main()&#123;    demo();    return 0;&#125;\n\n6.3 set_difference\n功能描述：求两个容器的差集\n\n差集：\n\n求出 c1 和 c2 的交集\n\nc1 与 c2 的差集：c1 的 减去 交集部分\n\nc2 与 c1 的差集：c2 的 减去 交集部分\n\n\n\n函数原型：set_difference(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);\n\n代码示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// Created by FHang on 2021/11/21 18:13//#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void printVector(const vector&lt;int&gt; &amp;v, const char *containerName)&#123;    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;    for (const int it: v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)&#123;    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;    for (vector&lt;int&gt;::const_iterator itBegin = v.begin(); itBegin != it; ++itBegin)    &#123;        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    vector&lt;int&gt; v_tag;    for (int i = 0; i &lt;= 9; ++i)    &#123;        v1.push_back(i);        v2.push_back(i + 5);    &#125;    printVector(v1, &quot;V1&quot;);    printVector(v2, &quot;V2&quot;);    v_tag.resize(max(v1.size(), v2.size()));    // V1 对于 V2 的 差集    vector&lt;int&gt;::const_iterator itLast_V1 = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());    printVector(v_tag, itLast_V1, &quot;V1 Difference&quot;);    // V2 对于 V1 的 差集    vector&lt;int&gt;::const_iterator itLast_V2 = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), v_tag.begin());    printVector(v_tag, itLast_V2, &quot;V2 Difference&quot;);&#125;int main()&#123;    demo();    return 0;&#125;\n\n","slug":"1_C++_STL算法_07","date":"2022-10-06T07:28:25.910Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"29cfc82accb2b6a310cfbec39b1d8603","title":"C++_STL函数对象","content":"C++_STL函数对象[toc]\n1. 函数对象1.1 函数对象概念\n概念：\n重载函数调用操作符的类，其对象常称为函数对象\n函数对象使用重载的()时，行为类似函数调用，也叫仿函数\n\n\n本质：\n函数对象(仿函数)是一个类，不是一个函数\n\n\n\n1.2 函数对象使用\n特点：\n\n函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值\n函数对象超出普通函数的概念，函数对象可以有自己的状态\n函数对象可以作为参数传递\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//// Created by FHang on 2021/11/14 15:17//#include &lt;iostream&gt;using namespace std;// 函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值class Fh_Add&#123;public:    int operator()(int value1, int value2)    &#123;        return value1 + value2;    &#125;&#125;;// 函数对象超出普通函数的概念，函数对象可以有自己的状态class Fh_Print&#123;public:    int transferCount;    Fh_Print()    &#123;        this-&gt;transferCount = 0;    &#125;    void operator()(const string &amp;printStr)    &#123;        cout &lt;&lt; printStr &lt;&lt; endl;        this-&gt;transferCount++;    &#125;&#125;;void demo1()&#123;    Fh_Add fhAdd;    cout &lt;&lt; &quot;Fh_Add&gt;&gt; &quot; &lt;&lt; fhAdd(1, 2) &lt;&lt; endl;    cout &lt;&lt; endl;&#125;void demo2()&#123;    Fh_Print fhPrint;    fhPrint(&quot;Hello World&quot;);    fhPrint(&quot;Hello World&quot;);    fhPrint(&quot;Hello World&quot;);    cout &lt;&lt; &quot;Fh_Print Transfer Count&gt;&gt; &quot; &lt;&lt; fhPrint.transferCount &lt;&lt; endl;    cout &lt;&lt; endl;&#125;// 函数对象可以作为参数传递void doPrint(Fh_Print &amp;fhPrint, const string &amp;printStr)&#123;    fhPrint(printStr);&#125;void demo3()&#123;    Fh_Print fhPrint;    doPrint(fhPrint, &quot;Hello World&quot;);    cout &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    demo3();    return 0;&#125;\n\n2. 谓词2.1 谓词基本概念\n概念：\n返回bool类型的仿函数称为谓词\n如果operator()接受一个参数，为一元谓词\n如果operator()接受二个参数，为二元谓词\n\n\n\n2.2 一元谓词\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by FHang on 2021/11/14 16:09//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class DownSort&#123;public:    bool operator()(const int &amp;value1, const int &amp;value2)    &#123;        return value1 &gt; value2;    &#125;&#125;;void printVector(const vector&lt;int&gt; &amp;other)&#123;    for (int it : other)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 1; i &lt; 6; ++i)    &#123;        v.push_back(i);    &#125;    printVector(v);    sort(v.begin(), v.end(), DownSort());    printVector(v);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3. 内建函数对象3.1 内建函数对象意义\n概念：\nSTL内建一些函数对象\n\n\n分类：\n算术仿函数\n关系仿函数\n逻辑仿函数\n\n\n用法：\n这些仿函数所产生的对象，用法和一般函数完全相同\n使用内建函数对象，需要引入头文件#include&lt;functional&gt;\n\n\n\n3.2 算术仿函数\n功能描述：\n\n实现四则运算\n其中negate是一元运算，其它的都是二元运算\n\n\n\n\n仿函数原型\n\n\n\n\ntemplate&lt;class T&gt; T plus&lt;T&gt;\n加法仿函数\n\n\ntemplate&lt;class T&gt; T minus&lt;T&gt;\n减法仿函数\n\n\ntemplate&lt;class T&gt; T multiplies&lt;T&gt;\n乘法仿函数\n\n\ntemplate&lt;class T&gt; T divides&lt;T&gt;\n除法仿函数\n\n\ntemplate&lt;class T&gt; T modulus&lt;T&gt;\n取模仿函数\n\n\ntemplate&lt;class T&gt; T negate&lt;T&gt;\n取反仿函数\n\n\n\n代码示例：\n1234567891011121314151617181920212223242526//// Created by FHang on 2021/11/14 16:45//#include &lt;iostream&gt;#include &lt;functional&gt;using namespace std;void demo1()&#123;    negate&lt;&gt; negate1;    cout &lt;&lt; negate1(10) &lt;&lt; endl;&#125;void demo2()&#123;    plus&lt;&gt; plus1;    cout &lt;&lt; plus1(10, 20) &lt;&lt; endl;&#125;int main()&#123;    demo1();    demo2();    return 0;&#125;\n\n3.3 关系仿函数\n功能描述：实现关系对比\n\n\n\n仿函数原型\n\n\n\n\ntemplate&lt;class T&gt; bool equal_to&lt;T&gt;\n等于\n\n\ntemplate&lt;class T&gt; bool not_equal_to&lt;T&gt;\n不等于\n\n\ntemplate&lt;class T&gt; bool greater&lt;T&gt;\n大于\n\n\ntemplate&lt;class T&gt; bool greater_equal&lt;T&gt;\n大于等于\n\n\ntemplate&lt;class T&gt; bool less&lt;T&gt;\n小于\n\n\ntemplate&lt;class T&gt; bool less_equal&lt;T&gt;\n小于等于\n\n\n\n代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839//// Created by FHang on 2021/11/14 16:58//#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void printVector(const vector&lt;int&gt; &amp;v)&#123;    for (int it : v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;int&gt; v;    for (int i = 1; i &lt; 6; ++i)    &#123;        v.push_back(i);    &#125;    printVector(v);    sort(v.begin(),  v.end(), greater&lt;&gt;());    printVector(v);&#125;int main()&#123;    demo();    return 0;&#125;\n\n3.4 逻辑仿函数\n功能描述：实现逻辑运算\n\n\n\n函数原型\n\n\n\n\ntemplate&lt;class T&gt; bool logical_and&lt;T&gt;\n逻辑与\n\n\ntemplate&lt;class T&gt; bool logical_or&lt;T&gt;\n逻辑或\n\n\ntemplate&lt;class T&gt; bool logical_not&lt;T&gt;\n逻辑非\n\n\n\n代码示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243//// Created by FHang on 2021/11/14 17:43//#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;using namespace std;void printVector(const vector&lt;bool&gt; &amp;v)&#123;    for (bool it : v)    &#123;        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void demo()&#123;    vector&lt;bool&gt; v1;    for (int i = 1; i &lt; 5; ++i)    &#123;        v1.push_back(rand()%2);    &#125;    printVector(v1);    vector&lt;bool&gt; v2;    v2.resize(v1.size());    transform(v1.begin(), v1.end(), v2.begin(), logical_not&lt;bool&gt;());    printVector(v2);&#125;int main()&#123;    srand((unsigned int)time(NULL));    demo();    return 0;&#125;\n\n","slug":"1_C++_STL函数对象_06","date":"2022-10-06T07:28:25.907Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"}]