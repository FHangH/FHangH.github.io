[{"id":"8f8247c813460cf709987d85ab2616f5","title":"BlogTest","content":"BlogTestBlog 功能测试1. 博客插入视频\n视频演示 &#x2F;&#x2F; 自适应大小\nBiliBili视频链接\n\n   \n  \n\n\n2. Google相册做图床\n哈哈哈，我特么好不要脸啊！！！\n实验证明：谷歌的链接可以多次访问\n缺点就是国内无法直接访问\n\n3. 花瓣采集做图床\n突然想到谷歌的国内访问不了\n\n试试花瓣能否满足需求\n\n\n事实证明：花瓣就是个垃圾！\n\n第一次访问可以，刷新后就无法加载了\n\n\n4. BiliBili专栏图床测试\n测试BiliBili的专栏图片是否可以作为图床使用\n\n\n嗯！B站和花瓣一样，小家子气！\n\n\n5. 最终图床解决方案\n谷歌的链接确实可以在全平台正常访问（前提是有科学上网，不方便国内访问）\n\n同时记录一下之前一篇名为：”C语言基础” 的博客图片有时无法正常访问的问题\n\n原本担心github上白嫖的cdn图床会有50MB限制于是创建了第二仓库，和原先第一个仓库一样使用PicGo上传，批量复制了url链接。所以没在意问题一开始访问很正常，PC，手机都正常，但只要刷新一下页面，就会出现无法加载图片的情况，尤其是手机端后来抽空找到了原因：第二个仓库，使用PicGo上传后，批量复制的链接域名变了：\nPicGo 直接批量复制的url：https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;FHangH&#x2F;FHangBlogCDN_02&#x2F;master&#x2F;1.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80&#x2F;1.png\n&#x2F;&#x2F; raw.githubusercontent.com 在国内好像被禁了\n\n修改后正确的url：\nhttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;FHangH&#x2F;FHangBlogCDN_02&#x2F;1.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80&#x2F;1.png\n&#x2F;&#x2F; 注意原链接里的 &#x2F;master&#x2F; 别忘记删\n\n最终的方案：还是白嫖 jsdelivr 香\n注意：\n  每个仓库不超过50MB\n  单个文件不超过20MB\n  不能拿来做图库网站的图床\n  一个仓库不够，多建一个就好\n  发布不同的 release 的也行（个人觉得麻烦）\n\n","slug":"999.BlogTest","date":"2022-10-06T07:28:25.980Z","categories_index":"Test","tags_index":"Test","author_index":"FangH"},{"id":"a6ccd9fe4a40d3d3e4e5ed99b6f169f1","title":"汇编_辅助C++","content":"汇编_辅助C++\n汇编语言种类：x64汇编（64bit）\n书写格式：intel\n汇编不区分大小写\n\n1. 汇编格式了解\n\n\n项目\nintel\n说明\n\n\n\n寄存器命名\neax\nintel不带%\n\n\n操作数顺序\nmov edx, eax\n将eax的值赋值给edx\n\n\n常数\\立即数\nmov eax, 3mov eax, 0x10\n将3赋值给eax将0x10赋值给eax\n\n\njmp指令\njmp edxjmp 0x4001002jmp [eax]\n在AT&amp;T的jmp地址前面加*\n\n\n操作数长度\nmov edx, eaxmov al, 0x10lea ax, [dx + 0x10]\n\n\n\n2. x64汇编-寄存器\n通用寄存器：(8字节, 1字节&#x3D;8位二进制)\n16bit: AX&#x2F;BX&#x2F;CX&#x2F;DX\n32bit: EAX&#x2F;EBX&#x2F;ECX&#x2F;EDX\n64bit: RAX&#x2F;RBX&#x2F;RCX&#x2F;RDX\n64bit: RBP&#x2F;RSI&#x2F;RDI&#x2F;RSP&#x2F;R8&#x2F;R9&#x2F;R10&#x2F;R11&#x2F;R12&#x2F;R13&#x2F;R14&#x2F;R15\n64bit 可以向下兼容 32bit，64bit 寄存就分一半就是 32bit\n\n\n兼容方式：\nRAX：\nEAX(低32bit -&gt; 4byte)\n\n\nEAX：\nAX(低16bit -&gt; 2byte)\n\n\nAX：\nAH(高8bit -&gt; 1byte)\nAL(低8bit)\n\n\n\n\n一般规律：\nR，64bit，8字节\nE，32bit，4字节\nA，16bit，2字节\nAH&#x2F;AL，8bit， 1字节\n\n\n\n3. 内联汇编\n在 cpp 文件中直接写 汇编代码，仅支持 x86\n\n格式：\n__asm\n&#123;\n    &#x2F;&#x2F; 汇编代码\n&#125;\n\n\n\n代码示例1：\nint main()\n&#123;\n    int a &#x3D; 10;\n    __asm\n    &#123;\n        mov eax, a\n    &#125;\n    \n    return 0;\n&#125;\n\n&#x2F;&#x2F; mov eax, a &#x3D;&gt; \n&#x2F;&#x2F; mov eax, dword ptr[a]\n&#x2F;&#x2F; 汇编中不存在 a， 只有 a 所在的地址\n\n__asm\n&#123;\n    mov eax, 10\n&#125;\n&#x2F;&#x2F; mov eax, 10 &#x3D;&gt;\n&#x2F;&#x2F; mov eax, 0Ah\n\n\n\n代码示例2：10是10进制，16进制是0AH，占用1个字节，需放入AX，低位AL中；11223344H是8位16进制，占用4字节，需放入EAX；\nint main()\n&#123;\n    __asm\n    &#123;\n        mov ax, 10\n\tmov eax, 11223344H\n    &#125;\n    return 0;\n&#125;\n\n&#x2F;&#x2F; mov ax, 10 &#x3D;&gt;\n&#x2F;&#x2F; mov eax, 11223344H\nmov eax, 0AH\nmov eax, 11223344H\n\n&#x2F;&#x2F; mov ax, 0AH\n此时：ax 低位 al这 &#x3D;&gt; 000A\n此时：eax &#x3D;&gt; CCCC000A\n\n&#x2F;&#x2F; mov eax, 11223344H\n此时：eax &#x3D;&gt; 11223344\n此时：ax &#x3D;&gt; 00003344\n此时：al &#x3D;&gt; 3344\n\n4. 汇编语法\n\n\n语法\n解释\n\n\n\nmov dest, src\nsrc来源，dest目标，mov赋值\n\n\n[指针值]\n内存地址\n\n\nword\\dword\\qword\nword2字节，dword4字节，qword8字节\n\n\ndword ptr\n指定内存大小\n\n\ncall 函数地址\n调用函数\n\n\nlea dest, [地址值]\n类似与指针，将地址赋值给dest\n\n\nret\n函数返回\n\n\nxor op1, op2\n将 op1 和 op2 异或的结果给 op1，类似 op1 = op1 ^ op2\n\n\nadd op1, op2\nop1 = op1 + op2\n\n\nsub op1, op2\nop1 = op1 - op2\n\n\ninc op\n自增op = op + 1\n\n\ndec op\n自减op = op -1\n\n\njmp 内存地址\n跳转到指定地址，执行机器码一般配合test，cmp进行使用，J开头基本都是jmp的特殊形态jmp是无条件跳转；jne : jump not equal\n\n\n\n代码示例：\nint a &#x3D; 3;\ncout &lt;&lt; &amp;a &lt;&lt; endl;\n\n&#x2F;&#x2F; &amp;a &#x3D; 010FFE4Ch\n\n# mov dword ptr [ebp-0Ch], 3\n&#x2F;&#x2F; ebp-0Ch 是 变量a 的地址\n&#x2F;&#x2F; ebp ：010FFE58h\n&#x2F;&#x2F; &amp;a : 010FFE4Ch &#x3D;&#x3D; ebp-0Ch\n\n","slug":"11_汇编_辅助C++_01","date":"2022-10-06T07:28:25.978Z","categories_index":"编程","tags_index":"Assemly,C/C++","author_index":"FangH"},{"id":"3316961ecf1671c6065b043220187c47","title":"Java基础","content":"Java基础1. Java环境配置1.1 手动配置Java环境1.1.1 Oracle官网获得JDK\nJava-JDK\n\n获得JDK，默认安装C盘即可\n\n\n1.1.2 配置环境变量\n在系统变量，设置三项属性：\n\nJAVA_HOME\nPATH\nCLASSPATH（JDK1.5版本以上，无需此项）\n\n\n配置：\n\nJAVA_HOME:C:\\Program Files\\Java\\[实际情况而定]\n\nPATH:\n\n%JAVA_HOME%\\bin\n\n%JAVA_HOME%\\jre\\bin\n\n\n\n\n\nCMD测试：\n\njava\njavac\njava -version\n\n\n\n1.1.3 测试Java编译\n在text中写入Java程序：Demo.text\npublic class Demo &#123;\n    public static void main(String[] args)&#123;\n        int appleNum &#x3D; 10;\n        int day;\n        for (day &#x3D; 1; day &lt;&#x3D; 3; ++day)\n        &#123;\n            appleNum -&#x3D; 2;\n        &#125;\n        System.out.println(&quot;Day &quot; + (day - 1) + &quot; , &quot; + &quot;Apple Count : &quot; + appleNum);\n    &#125;\n&#125;\n\n将text文件文件类型后缀名改为：Demo.java\n\n在文件所在地址，打开CMD或者Powershell\n\n通过命令来编译Demo.java–默认是在同地址创建同名的Demo.class，Demo.exe在系统文件System32中\njavac Demo.java\n\n通过命令来执行Demo.exe\njava Demo\n\n1.2 通过Intellij IDEA配置1.2.1 安装IDEA\nInterllij IDEA\n\n1.2.2 关键设置\nAdd Path\n选择安装Openjdk\n\n2. Java基础2.1 Java标识符\n标识符包括：字母，数字，_，$；\n标识符必须：字母，_，$开头，不能以数字开头；\n标识符不能使用关键字\n\n2.2 常量常量初始化后，不能再被修改；\nfinal double PI &#x3D; 3.14;\n\n\n\n2.3 数据类型2.3.1 数据类型的分类\n基本数据类型\n数值型\n整数类型：byte, short, int, long\n浮点类型：float, double\n\n\n字符型：char\n布尔型：bool\n\n\n引用数据类型\n类\n接口\n数组\n\n\n\n2.3.2 整型\nJava默认的整型是int\n\n\n\n\n数据类型\n名称\n字节\n数值范围\n\n\n\nbyte\n字节型\n1\n-128 ~ 127\n\n\nshort\n短整型\n2\n-32768 ~ 32767\n\n\nint\n整型\n4\n-2147483648 ~ 2147483647\n\n\nlong\n长整型\n8\n-2(63次方) ~ -2(63次方) - 1\n\n\nlong a &#x3D; 12345678; &#x2F;&#x2F; 编译成功\nlong b &#x3D; 12345678999; &#x2F;&#x2F; 编译失败，超出int长度\nlong c &#x3D; 12345678999L; &#x2F;&#x2F; 编译成功，标记 L ，数据是长整型\n\n\n\n2.3.3 浮点型\nJava默认的浮点型是double\n\n\n\n\n数据类型\n名称\n字节\n数值范围\n\n\n\nfloat\n单精度\n4\n-3.403E38 ~ 3.403E38\n\n\ndouble\n双精度\n8\n-1.798E308 ~ 1.798E308\n\n\n2.3.4 字符型\n占用2个字节\n可用于转义\n\n\n\n\n转义符\n含有\n\n\n\n\\b\n退格\n\n\n\\n\n换行\n\n\n\\r\n回车\n\n\n\\t\n制表符\n\n\n\\“\n双引号\n\n\n\\‘\n单引号\n\n\n\\\\\n反斜杠\n\n\nchar ec &#x3D; &#39;a&#39;;\nchar cc &#x3D; &#39;中&#39;;\nchar c &#x3D; &#39;\\n&#39;;\n\n\nchar只能放一个字符\nstring可以方一串字符\n\n2.3.4 布尔型\n布尔型只有两个常量值：true，false\n\nboolean flag;\nflag &#x3D; true;\n\n\n\n2.4 Java输入\n语法\n\nimport java.util.Scanner;\n\npublic class Demo()\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Scanner scan &#x3D; new Scanner(System.in);\n        \n        int a &#x3D; scan.nextInt();\n    &#125;\n&#125;\n\n\nScanner对象的方法说明\n\n\n\n方法\n说明\n\n\n\nnextByte()\n读取byte类型的整数\n\n\nnextShort()\n读取short类型的整数\n\n\nnextInt()\n读取int类型的整数\n\n\nnextLong()\n读取long类型的整数\n\n\nnextFloat()\n读取float类型的数\n\n\nnextDouble()\n读取double类型的数\n\n\nnext()\n读取字符串，遇到空白符结束\n\n\nnextLine()\n读取文本，回车结束\n\n\n\n\n2.5 三目运算符\n语法：a &gt; b ? a : b;\n\n实例：在三个数中，找到最大数；\nimport java.util.Scanner;\n\npublic class Demo()\n&#123;\n    public static void main(String[] args)\n    &#123;\n        int a &#x3D; 10, b &#x3D; 20, c &#x3D; 30, temp, max;\n        temp &#x3D; a &gt; b ? a : b;\n        max &#x3D; temp &gt; c ? temp : c;\n    &#125;\n&#125;\n\n2.6 Java例题2.6.1 输入三位数，将各个位数取出import java.util.Scanner;\n\npublic class Demo2\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Scanner scanner &#x3D; new Scanner(System.in);\n\n        System.out.print(&quot;输入三位数：&quot;);\n        int EnterNum &#x3D; scanner.nextInt();\n\n        int GW, SW, BW;\n\n        GW &#x3D; (EnterNum % 10);\n        SW &#x3D; (EnterNum % 100) &#x2F; 10;\n        BW &#x3D; (EnterNum &#x2F; 100);\n\n        System.out.println(&quot;个位：&quot; + GW + &quot; 十位：&quot; + SW + &quot; 百位：&quot; + BW);\n    &#125;\n&#125;\n\n\n\n2.6.2 将两个变量值互换2.6.2.1 设临时变量public class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        int a &#x3D; 10, b &#x3D; 20, temp;\n        temp &#x3D; a;\n        a &#x3D; b;\n        b &#x3D; temp;\n    &#125;\n&#125;\n\n\n\n2.6.2.2 两数加减public class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        int a &#x3D; 10, b &#x3D; 20;\n        b &#x3D; a + b;\n        a &#x3D; b - a;\n        b &#x3D; b - a;\n    &#125;\n&#125;\n\n\n\n2.6.2.3 异或public class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        int a &#x3D; 1, b &#x3D; 2;\n        a &#x3D; a ^ b;\n        b &#x3D; a ^ b;\n        a &#x3D; a ^ b;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;  a &#x3D; 1 &#x3D; 01, b &#x3D; 2 &#x3D; 10;\n# a &#x3D; a ^ b; &#x2F;&#x2F;  01 - 10 &#x3D;&gt; 00 &#x3D;&#x3D; a &#x3D; 0;\n# b &#x3D; a ^ b; &#x2F;&#x2F; 00 - 10 &#x3D;&gt; 01 &#x3D;&#x3D; b &#x3D; 1;\n# a &#x3D; a ^ b; &#x2F;&#x2F; 00 - 01 &#x3D;&gt; 10 &#x3D;&#x3D; a &#x3D; 2\n\n\n\n\n\n2.7 switch选择语句2.7.1 例题1\n学号-姓名-爱好-出生日期，以及是否是闰年\n\nimport java.util.Scanner;\n\nclass MySelf\n&#123;\n   private final String stu_ID;\n   private final String stu_Name;\n   private final String stu_Hobby;\n   private final int stu_Date;\n\n   MySelf()\n   &#123;\n       stu_ID &#x3D; &quot;82104322666&quot;;\n       stu_Name &#x3D; &quot;FHang&quot;;\n       stu_Hobby &#x3D; &quot;发呆&quot;;\n       stu_Date &#x3D; 1998;\n   &#125;\n\n    public String getStu_ID() &#123;\n        return stu_ID;\n    &#125;\n\n    public String getStu_Name() &#123;\n        return stu_Name;\n    &#125;\n\n    public String getStu_Hobby() &#123;\n        return stu_Hobby;\n    &#125;\n\n    public int getStu_Date() &#123;\n        return stu_Date;\n    &#125;\n\n    public String getIsLeapYear()\n    &#123;\n        return (stu_Date % 4 &#x3D;&#x3D; 0 &amp;&amp; stu_Date % 100 !&#x3D; 0) || (stu_Date % 400 &#x3D;&#x3D; 0) ? &quot;是&quot; : &quot;不是&quot;;\n    &#125;\n&#125;\n\npublic class Demo3\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Scanner scanner &#x3D; new Scanner(System.in);\n        MySelf mySelf &#x3D; new MySelf();\n\n        while (true)\n        &#123;\n            System.out.println(&quot;1_学号,2_姓名,3_爱好,4_出生日期,&lt;其它_退出&gt;&quot;);\n            System.out.print(&quot;选择: &quot;);\n            int num &#x3D; scanner.nextInt();\n\n            switch (num) &#123;\n                case 1 -&gt; System.out.println(&quot;学号: &quot; + mySelf.getStu_ID());\n                case 2 -&gt; System.out.println(&quot;姓名: &quot; + mySelf.getStu_Name());\n                case 3 -&gt; System.out.println(&quot;爱好: &quot; + mySelf.getStu_Hobby());\n                case 4 -&gt; System.out.println(&quot;出生日期: &quot; + mySelf.getStu_Date() + &quot; - 闰年: &quot; + mySelf.getIsLeapYear());\n                default -&gt; System.exit(0);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n2.7.2 例题2\n输入一个年份，判断是否是闰年以及每月的天数\n\nimport java.util.Scanner;\n\nclass Prophet\n&#123;\n    int year;\n    boolean isLeapYear;\n\n    public void CalLeapYear(int year)\n    &#123;\n        this.year &#x3D; year;\n        isLeapYear &#x3D; (year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0) || year % 400 &#x3D;&#x3D; 0;\n        String leapYear &#x3D; isLeapYear ? &quot;是闰年&quot; : &quot;不是闰年&quot;;\n        System.out.println(year + leapYear);\n    &#125;\n\n    public void CalDaysEveryMonth()\n    &#123;\n        System.out.println(this.year + &quot;的每月天数：&quot;);\n        int[] days &#x3D; &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;\n        for (int i &#x3D; 0; i &lt; days.length; ++i)\n        &#123;\n            if (this.isLeapYear &amp;&amp; i &#x3D;&#x3D; 1)\n            &#123;\n                System.out.println(&quot;第&quot; + (i + 1) + &quot;月: &quot; + (days[i] + 1));\n            &#125;\n            else\n            &#123;\n                System.out.println(&quot;第&quot; + (i + 1) + &quot;月: &quot; + days[i]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\npublic class Demo4\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Scanner scanner &#x3D; new Scanner(System.in);\n        Prophet pro &#x3D; new Prophet();\n\n        while (true)\n        &#123;\n            System.out.print(&quot;输入年份&lt;0_退出&gt;：&quot;);\n            int num &#x3D; scanner.nextInt();\n            if (num &#x3D;&#x3D; 0)\n            &#123;\n                System.exit(0);\n            &#125;\n            else\n            &#123;\n                pro.CalLeapYear(num);\n                pro.CalDaysEveryMonth();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n2.7.3 例题3\n设计一个加减计算的答题系统，随机生成题目，最少1题，最多10题，并最终返回答题正确数\n\nimport java.util.Scanner;\nimport java.util.Random;\n\nclass CalculatorSystem\n&#123;\n    private int questionCount;\n    private int scoreCount;\n\n    private enum CalculateOperation\n    &#123;\n        ADD, SUB, &#x2F;*MULTI, DIVIDE*&#x2F;\n    &#125;\n\n    Scanner scanner &#x3D; new Scanner(System.in);\n    Random random &#x3D; new Random(System.currentTimeMillis());\n\n    CalculatorSystem()\n    &#123;\n        this.scoreCount &#x3D; 0;\n    &#125;\n\n    public void CalStart()\n    &#123;\n        System.out.println(&quot;&lt;&lt;-- 输入题数(最少1题--最多10题) --&gt;&gt;&quot;);\n        System.out.print(&quot;输入&gt;&gt;&quot;);\n        questionCount &#x3D; scanner.nextInt();\n\n        if (questionCount &lt; 1 || questionCount &gt; 10)\n        &#123;\n            questionCount &#x3D; questionCount &lt; 1 ? 1 : 10;\n        &#125;\n\n        CalRandomQuestion();\n    &#125;\n\n    public void CalRandomQuestion()\n    &#123;\n        int tempA, tempB, inputC, a, b, c;\n        CalculateOperation calOperation;\n\n        for (int i &#x3D; 1; i &lt;&#x3D; questionCount; ++i)\n        &#123;\n            System.out.print(&quot;第&quot; + i + &quot;题: &quot;);\n            int curRand &#x3D; random.nextInt(2);\n\n            calOperation &#x3D; CalculateOperation.class.getEnumConstants()[curRand];\n            tempA &#x3D; random.nextInt(101);\n            tempB &#x3D; random.nextInt(101);\n            a &#x3D; Math.max(tempA, tempB);\n            b &#x3D; Math.min(tempB, tempA);\n\n            switch (calOperation)\n            &#123;\n                case ADD -&gt;\n                        &#123;\n                            c &#x3D; a + b;\n                            System.out.print(a + &quot;+&quot; + b + &quot;&#x3D;&quot;);\n                            inputC &#x3D; scanner.nextInt();\n                            CalCheckAnswer(c, inputC);\n                        &#125;\n                case SUB -&gt;\n                        &#123;\n                            c &#x3D; a - b;\n                            System.out.print(a + &quot;-&quot; + b + &quot;&#x3D;&quot;);\n                            inputC &#x3D; scanner.nextInt();\n                            CalCheckAnswer(c, inputC);\n                        &#125;\n            &#125;\n        &#125;\n\n        CalSumScore();\n    &#125;\n\n    public void CalCheckAnswer(int c, int inputC)\n    &#123;\n        String printLog &#x3D; (c &#x3D;&#x3D; inputC) ? &quot;正确&quot; : &quot;错误&quot;;\n        boolean isRight &#x3D; (c &#x3D;&#x3D; inputC);\n\n        if (isRight)\n        &#123;\n            this.scoreCount++;\n        &#125;\n        System.out.println(printLog);\n    &#125;\n\n    public void CalSumScore()\n    &#123;\n        System.out.println(&quot;答对&quot; + scoreCount + &quot;题&quot;);\n        scoreCount &#x3D; 0;\n        System.out.println();\n    &#125;\n\n    public void CalEnd()\n    &#123;\n        System.out.println(&quot;&lt;&lt;-- 已退出答题系统 --&gt;&gt;&quot;);\n    &#125;\n&#125;\n\npublic class Demo5\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Scanner scanner &#x3D; new Scanner(System.in);\n        CalculatorSystem calSys &#x3D; new CalculatorSystem();\n\n        while (true)\n        &#123;\n            System.out.println(&quot;&lt;&lt;-- (Y&#x2F;y_开始)--(N&#x2F;n_结束) --&gt;&gt;&quot;);\n            System.out.print(&quot;输入&gt;&gt;&quot;);\n            String inputChar &#x3D; scanner.next();\n\n            if (inputChar.equalsIgnoreCase(&quot;Y&quot;))\n            &#123;\n                calSys.CalStart();\n            &#125;\n            else if (inputChar.equalsIgnoreCase(&quot;N&quot;))\n            &#123;\n                calSys.CalEnd();\n                System.exit(1);\n            &#125;\n            else\n            &#123;\n                System.out.println(&quot;输入正确的选项&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n2.7.4 例题4\n提示输入信息—显示信息-退出，显示信息可返回上一级信息提示\n\nimport java.util.Scanner;\n\nclass PersonInfo\n&#123;\n    private String fh_ID;\n    private String fh_Name;\n    private String fh_Hobby;\n    private int fh_Date;\n\n    Scanner scanner &#x3D; new Scanner(System.in);\n\n    public String getFh_ID() &#123;\n        return fh_ID;\n    &#125;\n    public void setFh_ID(String fh_ID) &#123;\n        this.fh_ID &#x3D; fh_ID;\n    &#125;\n\n    public String getFh_Name() &#123;\n        return fh_Name;\n    &#125;\n    public void setFh_Name(String fh_Name) &#123;\n        this.fh_Name &#x3D; fh_Name;\n    &#125;\n\n    public String getFh_Hobby() &#123;\n        return fh_Hobby;\n    &#125;\n    public void setFh_Hobby(String fh_Hobby) &#123;\n        this.fh_Hobby &#x3D; fh_Hobby;\n    &#125;\n\n    public int getFh_Date() &#123;\n        return fh_Date;\n    &#125;\n    public void setFh_Date(int fh_Date) &#123;\n        this.fh_Date &#x3D; fh_Date;\n    &#125;\n\n    public void StartPersonInfo()\n    &#123;\n        while (true)\n        &#123;\n            System.out.println(&quot;&lt;-- 1_输入信息,2_显示信息,3_退出 --&gt;&quot;);\n            System.out.print(&quot;选择&gt;&gt;&quot;);\n            int num &#x3D; scanner.nextInt();\n            switch (num)\n            &#123;\n                case 1 -&gt; InputPersonInfo();\n                case 2 -&gt; ShowPersonInfoMenu();\n                case 3 -&gt; ExitPersonInfo();\n            &#125;\n        &#125;\n    &#125;\n\n    public void ShowPersonInfoMenu()\n    &#123;\n        System.out.println(&quot;&lt;-- 1_学号,2_姓名,3_爱好,4_年份,5_返回上一级 --&gt;&quot;);\n\n        while (true)\n        &#123;\n            System.out.print(&quot;选择&gt;&gt;&quot;);\n            int num &#x3D; scanner.nextInt();\n\n            switch (num)\n            &#123;\n                case 1 -&gt; System.out.println(&quot;ID: &quot; + getFh_ID());\n                case 2 -&gt; System.out.println(&quot;姓名: &quot; + getFh_Name());\n                case 3 -&gt; System.out.println(&quot;爱好: &quot; + getFh_Hobby());\n                case 4 -&gt; System.out.println(&quot;生日: &quot; + getFh_Date());\n                case 5 -&gt; StartPersonInfo();\n            &#125;\n        &#125;\n    &#125;\n\n    public void InputPersonInfo()\n    &#123;\n        System.out.print(&quot;输入ID&gt;&gt;&quot;);\n        setFh_ID(scanner.next());\n\n        System.out.print(&quot;输入姓名&gt;&gt;&quot;);\n        setFh_Name(scanner.next());\n\n        System.out.print(&quot;输入爱好&gt;&gt;&quot;);\n        setFh_Hobby(scanner.next());\n\n        System.out.print(&quot;输入生日&gt;&gt;&quot;);\n        setFh_Date(scanner.nextInt());\n    &#125;\n\n    public void ExitPersonInfo()\n    &#123;\n        System.out.println(&quot;&lt;-- 已退出 --&gt;&quot;);\n        System.exit(1);\n    &#125;\n&#125;\n\npublic class Demo6\n&#123;\n    public static void main(String[] args)\n    &#123;\n        new Scanner(System.in);\n        PersonInfo personInfo &#x3D; new PersonInfo();\n\n        personInfo.StartPersonInfo();\n    &#125;\n&#125;\n\n\n\n\n\n2.8 for循环2.8.1 例题1\n1 - 1000内的水仙花数\n\nclass FhMath\n&#123;\n    int B, S, G;\n\n    public void CalShuiXianHua()\n    &#123;\n        for (int i &#x3D; 100; i &lt;&#x3D; 900; ++i)\n        &#123;\n            B &#x3D; i &#x2F; 100;\n            S &#x3D; (i &#x2F; 10) % 10;\n            G &#x3D; i % 10;\n            if (Math.pow(B, 3) + Math.pow(S, 3) + Math.pow(G, 3) &#x3D;&#x3D; i)\n            &#123;\n                System.out.println(&quot;水仙花数: &quot; + i);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\npublic class Demo8\n&#123;\n    public static void main(String[] args)\n    &#123;\n        FhMath fhMath &#x3D; new FhMath();\n        fhMath.CalShuiXianHua();\n    &#125;\n&#125;\n\n\n\n\n\n2.8.2 例题2\n公鸡5元一个，母鸡3元一个，三只小鸡一元钱，现有100元，要买100只鸡，怎么买？\n\nclass Swap\n&#123;\n    public void swap(int x, int y, int z)\n    &#123;\n        for (x &#x3D; 1; x &lt;&#x3D; 20; ++x)\n        &#123;\n            for (y &#x3D; 1; y &lt;&#x3D; 33; ++y)\n            &#123;\n                z &#x3D; 100 - x - y;\n                if (x * 5 + y * 3 + z &#x2F; 3.0 &#x3D;&#x3D; 100.0)\n                &#123;\n                    System.out.println(&quot;X&#x3D; &quot; + x + &quot; Y&#x3D; &quot; + y + &quot; Z&#x3D; &quot; + z);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\npublic class Demo9\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Swap swap &#x3D; new Swap();\n        swap.swap(1, 2, 3);\n    &#125;\n&#125;\n\n\n\n2.8.3 例题3\n计算5的阶乘值的和（递归）\n\nclass MathJie\n&#123;\n    public int fact(int n)\n    &#123;\n        if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1)\n        &#123;\n            return 1;\n        &#125;\n        else\n        &#123;\n            return n * fact(n - 1);\n        &#125;\n    &#125;\n\n    public int sum(int n)\n    &#123;\n        if (n &#x3D;&#x3D; 1)\n        &#123;\n            return fact(n);\n        &#125;\n        else\n        &#123;\n            return fact(n) + fact(n - 1);\n        &#125;\n    &#125;\n&#125;\n\npublic class Demo10\n&#123;\n    public static void main(String[] args)\n    &#123;\n        MathJie mathJie &#x3D; new MathJie();\n        int S;\n        S &#x3D; mathJie.sum(5);\n        System.out.println(S);\n    &#125;\n&#125;\n\n\n\n2.9 函数重载题目2.9.1 例题1\n输入n个数，利用重载，打印最大值\n\nclass Calculator\n&#123;\n    void getMax(int...nums)\n    &#123;\n        int maxNum &#x3D; nums[0];\n\n        for (int num : nums)\n        &#123;\n            maxNum &#x3D; Math.max(maxNum, num);\n        &#125;\n        System.out.println(&quot;Max Num: &quot; + maxNum);\n    &#125;\n&#125;\n\npublic class Demo11\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Calculator calculator &#x3D; new Calculator();\n\n        calculator.getMax(1, 2);\n        calculator.getMax(1, 2, 3);\n        calculator.getMax(1, 2, 3, 4);\n    &#125;\n&#125;\n\n\n\n\n\n3.0 Java对象3.0.1 例题1\n创建一个宠物类，按提示输入相关信息，并最终打印出来\n\nimport java.util.Scanner;\n\nclass Pet\n&#123;\n    private String name;\n    private String type;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public String getType() &#123;\n        return type;\n    &#125;\n    public void setType(String type) &#123;\n        this.type &#x3D; type;\n    &#125;\n\n    Scanner scanner &#x3D; new Scanner(System.in);\n\n    Pet()\n    &#123;\n        TipInfo();\n\n        System.out.print(&quot;输入名称&gt;&gt;&quot;);\n        setName(scanner.next());\n\n        System.out.print(&quot;输入类别&gt;&gt;&quot;);\n        setType(scanner.next());\n\n        PrintPetInfo();\n    &#125;\n\n    void TipInfo()\n    &#123;\n        System.out.println(&quot;&lt;-- 输入宠物相关信息 --&gt;&quot;);\n    &#125;\n\n    void PrintPetInfo()\n    &#123;\n        System.out.println(&quot;&lt;-- 打印宠物相关信息 --&gt;&quot;);\n        System.out.println(&quot;宠物名称: &quot; + getName());\n        System.out.println(&quot;宠物类别: &quot; + getType());\n    &#125;\n&#125;\n\npublic class Demo10\n&#123;\n    public static void main(String[] args)\n    &#123;\n        new Pet();\n    &#125;\n&#125;\n\n\n\n\n\n3.1 对象继承3.1.1 继承概念\n继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法或子类从父类继承方法，使得子类具有父类相同的行为\n\n继承的格式：\nclass 父类 &#123;\n&#125;\n \nclass 子类 extends 父类 &#123;\n&#125;\n\n3.1.2 代码示例\nDemo.java\npackage project2;\n\npublic class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Human student &#x3D; new Student();\n        Human teacher &#x3D; new Teacher();\n\n        Getter getter &#x3D; new Getter();\n\n        getter.getInfo((Student) student);\n        System.out.println();\n        getter.getInfo((Teacher) teacher);\n    &#125;\n&#125;\n\nHuman.java\npackage project2;\n\npublic class Human\n&#123;\n&#125;\n\nStudent.java\npackage project2;\n\npublic class Student extends Human\n&#123;\n    private String name;\n    private int stuID;\n    private int roomID;\n\n    Student()\n    &#123;\n        name &#x3D; &quot;QQ&quot;;\n        stuID &#x3D; 1;\n        roomID &#x3D; 304;\n    &#125;\n\n    public String getName()\n    &#123;\n        return name;\n    &#125;\n    public void setName(String name)\n    &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public int getStuID()\n    &#123;\n        return stuID;\n    &#125;\n    public void setStuID(int stuID)\n    &#123;\n        this.stuID &#x3D; stuID;\n    &#125;\n\n    public int getRoomID()\n    &#123;\n        return roomID;\n    &#125;\n    public void setRoomID(int roomID)\n    &#123;\n        this.roomID &#x3D; roomID;\n    &#125;\n&#125;\n\nTeacher.java\npackage project2;\n\npublic class Teacher extends Human\n&#123;\n    private String name;\n    private String job;\n    private int salary;\n\n    Teacher()\n    &#123;\n        name &#x3D; &quot;WW&quot;;\n        job &#x3D; &quot;MathTeacher&quot;;\n        salary &#x3D; 1000;\n    &#125;\n\n    public String getName()\n    &#123;\n        return name;\n    &#125;\n    public void setName(String name)\n    &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public String getJob()\n    &#123;\n        return job;\n    &#125;\n    public void setJob(String job)\n    &#123;\n        this.job &#x3D; job;\n    &#125;\n\n    public int getSalary()\n    &#123;\n        return salary;\n    &#125;\n    public void setSalary(int salary)\n    &#123;\n        this.salary &#x3D; salary;\n    &#125;\n&#125;\n\nGetter.java\npackage project2;\n\npublic class Getter\n&#123;\n    void getInfo(Student student)\n    &#123;\n        System.out.println(&quot;Name: &quot; + student.getName() + &quot;\\nStuID: &quot; + student.getStuID() + &quot;\\nRoomID: &quot; + student.getRoomID());\n    &#125;\n\n    void getInfo(Teacher teacher)\n    &#123;\n        System.out.println(&quot;Name: &quot; + teacher.getName() + &quot;\\nJob: &quot; + teacher.getJob() + &quot;\\nSalary: &quot; + teacher.getSalary());\n    &#125;\n&#125;\n\n3.2 抽象类\n概念：\n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样\n由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类\n父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法\n在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口\n\n\n\n3.3 接口\n概念：\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念\n类描述对象的属性和方法，接口则包含类要实现的方法，除非实现接口的类是抽象类，否则该类要定义接口中的所有方法\n接口无法被实例化，但是可以被实现\n\n\n\n3.3.1 接口的声明[可见度] interface 接口名称 [extends 其他的接口名] &#123;\n        &#x2F;&#x2F; 声明变量\n        &#x2F;&#x2F; 抽象方法\n&#125;\n\n\n\n3.3.2 接口的特性\n接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字\n接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字\n接口中的方法都是公有的\n\n3.3.3 接口的实现...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...\n\n\n\n\n\n3.3.4 代码示例–文件结构\nproject3\n\nappliance\nApplianceBase.java\nComputer.java\nLight.java\nTelePhone.java\nWashMachine\n\n\nfunction\ncall.java\ncharge.java\nplayGame.java\n\n\nDemo.java\n\n\n代码源码：\n\nDemo.java\npackage project3;\n\nimport project3.appliance.Computer;\nimport project3.appliance.Light;\nimport project3.appliance.TelePhone;\nimport project3.appliance.WashMachine;\n\npublic class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        &#x2F;&#x2F; Light\n        Light light &#x3D; new Light(&quot;Light&quot;);\n        light.runStart();\n        light.startCharge();\n        light.overCharge();\n        light.runOver();\n\n        &#x2F;&#x2F; WashMachine\n        WashMachine washMachine &#x3D; new WashMachine(&quot;WashMachine&quot;);\n        washMachine.runStart();\n        washMachine.startCharge();\n        washMachine.runOver();\n\n        &#x2F;&#x2F; TelePhone\n        TelePhone telePhone &#x3D; new TelePhone(&quot;TelePhone&quot;);\n        telePhone.runStart();\n        telePhone.startCall();\n        telePhone.overCall();\n        telePhone.runOver();\n\n        &#x2F;&#x2F; Computer\n        Computer computer &#x3D; new Computer(&quot;Computer&quot;);\n        computer.runStart();\n        computer.playGames();\n        computer.overGames();\n        computer.runOver();\n    &#125;\n&#125;\n\nApplianceBase.java\npackage project3.appliance;\n\npublic class ApplianceBase\n&#123;\n    private boolean isRunning;\n\n    ApplianceBase(String name)\n    &#123;\n        isRunning &#x3D; false;\n        System.out.println(&quot;&lt;-- &quot; + name + &quot; --&gt;&quot;);\n    &#125;\n\n    public boolean isRunning()\n    &#123;\n        return isRunning;\n    &#125;\n\n    public void runStart()\n    &#123;\n        isRunning &#x3D; true;\n        System.out.println(&quot;Is Run Start&quot;);\n        getCurState();\n    &#125;\n    public void runOver()\n    &#123;\n        isRunning &#x3D; false;\n        System.out.println(&quot;Is Run Over&quot;);\n        getCurState();\n        System.out.println();\n    &#125;\n\n    public void getCurState()\n    &#123;\n        String state &#x3D; isRunning ? &quot;Running&quot; : &quot;Over&quot;;\n        System.out.println(&quot;CurState&gt;&gt; &quot; + state);\n    &#125;\n&#125;\n\nComputer.java\npackage project3.appliance;\n\nimport project3.function.charge;\nimport project3.function.playGame;\n\npublic class Computer extends ApplianceBase implements charge, playGame\n&#123;\n    public Computer(String name)\n    &#123;\n        super(name);\n    &#125;\n\n    @Override\n    public void runStart()\n    &#123;\n        super.runStart();\n    &#125;\n\n    @Override\n    public void runOver()\n    &#123;\n        super.runOver();\n    &#125;\n\n    @Override\n    public void getCurState()\n    &#123;\n        super.getCurState();\n    &#125;\n\n    @Override\n    public void startCharge()\n    &#123;\n        System.out.println(&quot;Computer Is Start Charge&quot;);\n    &#125;\n\n    @Override\n    public void overCharge()\n    &#123;\n        System.out.println(&quot;Computer Is Over Charge&quot;);\n    &#125;\n\n    @Override\n    public void playGames()\n    &#123;\n        System.out.println(&quot;Computer Play Games&quot;);\n    &#125;\n\n    @Override\n    public void overGames()\n    &#123;\n        System.out.println(&quot;Computer Over Games&quot;);\n    &#125;\n&#125;\n\nLight.java\npackage project3.appliance;\n\nimport project3.function.charge;\n\npublic class Light extends ApplianceBase implements charge\n&#123;\n    public Light(String name)\n    &#123;\n        super(name);\n    &#125;\n\n    @Override\n    public void runStart()\n    &#123;\n        super.runStart();\n    &#125;\n\n    @Override\n    public void runOver()\n    &#123;\n        super.runOver();\n    &#125;\n\n    @Override\n    public void getCurState()\n    &#123;\n        super.getCurState();\n    &#125;\n\n    @Override\n    public void startCharge()\n    &#123;\n        System.out.println(&quot;Light Is Start Charge&quot;);\n    &#125;\n\n    @Override\n    public void overCharge()\n    &#123;\n        System.out.println(&quot;Light Is Over Charge&quot;);\n    &#125;\n&#125;\n\nTelePhone.java\npackage project3.appliance;\n\nimport project3.function.call;\nimport project3.function.charge;\n\npublic class TelePhone extends ApplianceBase implements charge, call\n&#123;\n    public TelePhone(String name)\n    &#123;\n        super(name);\n    &#125;\n\n    @Override\n    public void runStart()\n    &#123;\n        super.runStart();\n    &#125;\n\n    @Override\n    public void runOver()\n    &#123;\n        super.runOver();\n    &#125;\n\n    @Override\n    public void getCurState()\n    &#123;\n        super.getCurState();\n    &#125;\n\n    @Override\n    public void startCharge()\n    &#123;\n        System.out.println(&quot;TelePhone Is Start Charge&quot;);\n    &#125;\n\n    @Override\n    public void overCharge()\n    &#123;\n        System.out.println(&quot;TelePhone Is Over Charge&quot;);\n    &#125;\n\n    @Override\n    public void startCall()\n    &#123;\n        System.out.println(&quot;TelePhone Start Call&quot;);\n    &#125;\n\n    @Override\n    public void overCall()\n    &#123;\n        System.out.println(&quot;TelePhone Over Call&quot;);\n    &#125;\n&#125;\n\nWashMachine.java\npackage project3.appliance;\n\nimport project3.function.charge;\n\npublic class WashMachine extends ApplianceBase implements charge\n&#123;\n    public WashMachine(String name)\n    &#123;\n        super(name);\n    &#125;\n\n    @Override\n    public void runStart()\n    &#123;\n        super.runStart();\n    &#125;\n\n    @Override\n    public void runOver()\n    &#123;\n        super.runOver();\n    &#125;\n\n    @Override\n    public void getCurState()\n    &#123;\n        super.getCurState();\n    &#125;\n\n    @Override\n    public void startCharge()\n    &#123;\n        System.out.println(&quot;WashMachine Is Start Charge&quot;);\n    &#125;\n\n    @Override\n    public void overCharge()\n    &#123;\n        System.out.println(&quot;WashMachine Is Over Charge&quot;);\n    &#125;\n&#125;\n\ncall.java\npackage project3.function;\n\npublic interface call\n&#123;\n    void startCall();\n    void overCall();\n&#125;\n\ncharge.java\npackage project3.function;\n\npublic interface charge\n&#123;\n    void startCharge();\n    void overCharge();\n&#125;\n\nplayGame.java\npackage project3.function;\n\npublic interface playGame\n&#123;\n    void playGames();\n    void overGames();\n&#125;\n\n3.4 数组和常用类\n案例描述：在一个九个元素的数组中，通过两组的三位数相加等于第三组组成的三位数，九个元素不重复，取值范围：[0 - 9]\n\n代码：\npackage project4;\n\nimport java.util.Arrays;\n\npublic class Demo1\n&#123;\n    int x,y,z;\n    int[] flagNo&#x3D;new int[]&#123;0,0,0, 0,0,0, 0,0,0&#125;;\n    public static void main(String[] args)\n    &#123;\n        Demo1 abc&#x3D;new Demo1();\n        abc.findRes();\n    &#125;\n\n    public void stau(int i)\n    &#123;\n        for (int j &#x3D; 0; j &lt;3 ; j++)\n        &#123;\n            if (i%10!&#x3D;0)\n                flagNo[i%10-1]&#x3D;1;\n            i&#x3D;i&#x2F;10;\n        &#125;\n    &#125;\n\n    public boolean isRepeat()\n    &#123;\n        boolean tmp&#x3D;true;\n        for (int j:flagNo)\n        &#123;\n            if (j &#x3D;&#x3D; 0)\n            &#123;\n                tmp &#x3D; false;\n                break;\n            &#125;\n        &#125;\n        return tmp;\n    &#125;\n\n    public void findRes()\n    &#123;\n        int counter&#x3D;0;\n        for (x&#x3D;123;x&lt;&#x3D;987;x++)\n            for (y&#x3D;x+1;y&lt;987;y++)\n            &#123;\n                Arrays.fill(flagNo, 0);\n\n                z&#x3D;x+y;\n                if (z&gt;123&amp;&amp;z&lt;&#x3D;987)\n                &#123;\n                    if (isRepeatXYZ())\n                    &#123;\n                        counter++;\n                        System.out.println(x+&quot;+&quot;+y+&quot;&#x3D;&quot;+z+&quot;【&quot;+counter+&quot;】&quot;);\n                    &#125;\n                &#125;\n            &#125;\n\n    &#125;\n\n    public boolean isRepeatXYZ()\n    &#123;\n        boolean tmp;\n        stau(x);\n        stau(y);\n        stau(z);\n        tmp&#x3D;isRepeat();\n        return tmp;\n    &#125;\n&#125;\n\n3.5 集合框架\n集合框架的概念：\n\n接口：代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象\n实现类：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap\n算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序\n\n\nSet 和 List的区别\n\nSet 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素\nSet检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;\nList和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt;\n\n\n代码示例：ArrayList\nimport java.util.*;\n \npublic class Test&#123;\n public static void main(String[] args) &#123;\n     List&lt;String&gt; list&#x3D;new ArrayList&lt;String&gt;();\n     list.add(&quot;Hello&quot;);\n     list.add(&quot;World&quot;);\n     list.add(&quot;HAHAHAHA&quot;);\n     &#x2F;&#x2F;第一种遍历方法使用 For-Each 遍历 List\n     for (String str : list) &#123;            &#x2F;&#x2F;也可以改写 for(int i&#x3D;0;i&lt;list.size();i++) 这种形式\n        System.out.println(str);\n     &#125;\n \n     &#x2F;&#x2F;第二种遍历，把链表变为数组相关的内容进行遍历\n     String[] strArray&#x3D;new String[list.size()];\n     list.toArray(strArray);\n     for(int i&#x3D;0;i&lt;strArray.length;i++) &#x2F;&#x2F;这里也可以改写为  for(String str:strArray) 这种形式\n     &#123;\n        System.out.println(strArray[i]);\n     &#125;\n     \n    &#x2F;&#x2F;第三种遍历 使用迭代器进行相关遍历\n     \n     Iterator&lt;String&gt; ite&#x3D;list.iterator();\n     while(ite.hasNext())&#x2F;&#x2F;判断下一个元素之后有值\n     &#123;\n         System.out.println(ite.next());\n     &#125;\n &#125;\n&#125;\n\n代码解析：第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度\n\n代码示例：Map\nimport java.util.*;\n \npublic class Test&#123;\n     public static void main(String[] args) &#123;\n      Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();\n      map.put(&quot;1&quot;, &quot;value1&quot;);\n      map.put(&quot;2&quot;, &quot;value2&quot;);\n      map.put(&quot;3&quot;, &quot;value3&quot;);\n      \n      &#x2F;&#x2F;第一种：普遍使用，二次取值\n      System.out.println(&quot;通过Map.keySet遍历key和value：&quot;);\n      for (String key : map.keySet()) &#123;\n       System.out.println(&quot;key&#x3D; &quot;+ key + &quot; and value&#x3D; &quot; + map.get(key));\n      &#125;\n      \n      &#x2F;&#x2F;第二种\n      System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;);\n      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it &#x3D; map.entrySet().iterator();\n      while (it.hasNext()) &#123;\n       Map.Entry&lt;String, String&gt; entry &#x3D; it.next();\n       System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());\n      &#125;\n      \n      &#x2F;&#x2F;第三种：推荐，尤其是容量大时\n      System.out.println(&quot;通过Map.entrySet遍历key和value&quot;);\n      for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;\n       System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());\n      &#125;\n    \n      &#x2F;&#x2F;第四种\n      System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;);\n      for (String v : map.values()) &#123;\n       System.out.println(&quot;value&#x3D; &quot; + v);\n      &#125;\n     &#125;\n&#125;\n\n3.5.1 集合排序package project8;\n\nimport java.util.Comparator;\nimport java.util.Vector;\n\nclass Student\n&#123;\n    int id;\n    String name;\n    String sex;\n    int computerGrade;\n    int cGrade;\n    int mathGrade;\n    int physicalGrade;\n\n    Student(int id, String name, String sex, int computerGrade, int cGrade, int mathGrade, int physicalGrade)\n    &#123;\n        this.id &#x3D; id;\n        this.name &#x3D; name;\n        this.sex &#x3D; sex;\n        this.computerGrade &#x3D; computerGrade;\n        this.cGrade &#x3D; cGrade;\n        this.mathGrade &#x3D; mathGrade;\n        this.physicalGrade &#x3D; physicalGrade;\n    &#125;\n&#125;\n\nclass DownSort implements Comparator&lt;Student&gt;\n&#123;\n    public int compare(Student s1, Student s2)\n    &#123;\n        int g1 &#x3D; s1.computerGrade + s1.cGrade + s1.mathGrade + s1.physicalGrade;\n        int g2 &#x3D; s2.computerGrade + s2.cGrade + s2.mathGrade + s2.physicalGrade;\n\n        return Integer.compare(g2, g1);\n    &#125;\n&#125;\n\npublic class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Vector&lt;Student&gt; vS &#x3D; new Vector&lt;&gt;();\n        Comparator&lt;Student&gt; comparator &#x3D; new DownSort();\n        Student s1 &#x3D; new Student(1001, &quot;mary&quot;, &quot;女&quot;, 90, 80, 78, 83);\n        Student s2 &#x3D; new Student(1002, &quot;tom&quot;, &quot;男&quot;, 80, 81, 79, 84);\n        Student s3 &#x3D; new Student(1003, &quot;jerry&quot;, &quot;男&quot;, 93, 82, 80, 85);\n        Student s4 &#x3D; new Student(1004, &quot;john&quot;, &quot;男&quot;, 90, 83, 81, 86);\n\n        vS.add(s1);\n        vS.add(s2);\n        vS.add(s3);\n        vS.add(s4);\n\n        System.out.println(&quot;全部显示》》&quot;);\n        printInfo(vS);\n\n        vS.sort(comparator);\n\n        System.out.println(&quot;按总分排序》》&quot;);\n        printInfo(vS);\n\n        System.out.println(&quot;查询》》&quot;);\n        searcher(vS, 1001);\n    &#125;\n\n    static void printInfo(Vector&lt;Student&gt; vS)\n    &#123;\n        for (Student s : vS)\n        &#123;\n            System.out.println(s.id + &quot; &quot; + s.name + &quot; &quot; + s.sex + &quot; &quot; + s.computerGrade + &quot; &quot; + s.cGrade + &quot; &quot; + s.mathGrade + &quot; &quot; + s.physicalGrade);\n        &#125;\n        System.out.println();\n    &#125;\n\n    static void searcher(Vector&lt;Student&gt; vs, int id)\n    &#123;\n        for (Student s : vs)\n        &#123;\n            if (s.id &#x3D;&#x3D; id)\n            &#123;\n                System.out.println(s.id + &quot; &quot; + s.name + &quot; &quot; + s.sex + &quot; &quot; + s.computerGrade + &quot; &quot; + s.cGrade + &quot; &quot; + s.mathGrade + &quot; &quot; + s.physicalGrade);\n            &#125;\n        &#125;\n        System.out.println();\n    &#125;\n&#125;\n\n\n\n\n\n\n3.6 异常处理\n异常概念：\n\n检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的\n运行时异常： 运行时异常是可能被程序员避免的异常\n错误： 错误不是异常，而是脱离程序员控制的问题\n\n\nException类的层次\n\nIOException 类\nRuntimeException 类\n\n\n\n3.6.1 异常方法\n\n\n序号\n方法及说明\n\n\n\n1\npublic String getMessage()返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。\n\n\n2\npublic Throwable getCause()返回一个Throwable 对象代表异常原因。\n\n\n3\npublic String toString()使用getMessage()的结果返回类的串级名字。\n\n\n4\npublic void printStackTrace()打印toString()结果和栈层次到System.err，即错误输出流。\n\n\n5\npublic StackTraceElement [] getStackTrace()返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\n\n\n6\npublic Throwable fillInStackTrace()用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。\n\n\n3.6.2 捕获异常\n使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方\n\ntry\n&#123;\n   &#x2F;&#x2F; 程序代码\n&#125;catch(ExceptionName e1)\n&#123;\n   &#x2F;&#x2F;Catch 块\n&#125;\n\nimport java.io.*;\npublic class ExcepTest&#123;\n \n   public static void main(String args[])&#123;\n      try&#123;\n         int a[] &#x3D; new int[2];\n         System.out.println(&quot;Access element three :&quot; + a[3]);\n      &#125;catch(ArrayIndexOutOfBoundsException e)&#123;\n         System.out.println(&quot;Exception thrown  :&quot; + e);\n      &#125;\n      System.out.println(&quot;Out of the block&quot;);\n   &#125;\n&#125;\n\n\n\n3.6.3 多重捕获块\n一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获\n\ntry&#123;\n   &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型1 异常的变量名1)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型2 异常的变量名2)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型3 异常的变量名3)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;\n\ntry &#123;\n    file &#x3D; new FileInputStream(fileName);\n    x &#x3D; (byte) file.read();\n&#125; catch(FileNotFoundException f) &#123; &#x2F;&#x2F; Not valid!\n    f.printStackTrace();\n    return -1;\n&#125; catch(IOException i) &#123;\n    i.printStackTrace();\n    return -1;\n&#125;\n\n\n\n\n\n3.6.4 throws &#x2F; throw 关键字\n如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明\n\nimport java.io.*;\npublic class className\n&#123;\n  public void deposit(double amount) throws RemoteException\n  &#123;\n    &#x2F;&#x2F; Method implementation\n    throw new RemoteException();\n  &#125;\n  &#x2F;&#x2F;Remainder of class definition\n&#125;\n\n\n\n3.6.5 finally 关键字\nfinally 关键字用来创建在 try 代码块后面执行的代码块\n无论是否发生异常，finally 代码块中的代码总会被执行\n在 finally 代码块中，可以运行清理类型等收尾善后性质的语句\n\ntry&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型1 异常的变量名1)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型2 异常的变量名2)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;finally&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;\n\npublic class ExcepTest&#123;\n  public static void main(String args[])&#123;\n    int a[] &#x3D; new int[2];\n    try&#123;\n       System.out.println(&quot;Access element three :&quot; + a[3]);\n    &#125;catch(ArrayIndexOutOfBoundsException e)&#123;\n       System.out.println(&quot;Exception thrown  :&quot; + e);\n    &#125;\n    finally&#123;\n       a[0] &#x3D; 6;\n       System.out.println(&quot;First element value: &quot; +a[0]);\n       System.out.println(&quot;The finally statement is executed&quot;);\n    &#125;\n  &#125;\n&#125;\n\n\n注意：\ncatch 不能独立于 try 存在\n在 try&#x2F;catch 后面添加 finally 块并非强制性要求的\ntry 代码后不能既没 catch 块也没 finally 块\ntry, catch, finally 块之间不能添加任何代码\n\n\n\n3.6.6 声明自定义异常\nJava 中可以自定义异常\n\n所有异常都必须是 Throwable 的子类\n如果写一个检查性异常类，则需要继承 Exception 类\n如果写一个运行时异常类，那么需要继承 RuntimeException 类\n\nclass MyException extends Exception&#123;&#125;\n\n代码示例：\n\nBankDemo.java\npublic class BankDemo\n&#123;\n   public static void main(String [] args)\n   &#123;\n      CheckingAccount c &#x3D; new CheckingAccount(101);\n      System.out.println(&quot;Depositing $500...&quot;);\n      c.deposit(500.00);\n      try\n      &#123;\n         System.out.println(&quot;\\nWithdrawing $100...&quot;);\n         c.withdraw(100.00);\n         System.out.println(&quot;\\nWithdrawing $600...&quot;);\n         c.withdraw(600.00);\n      &#125;catch(InsufficientFundsException e)\n      &#123;\n         System.out.println(&quot;Sorry, but you are short $&quot;\n                                  + e.getAmount());\n         e.printStackTrace();\n      &#125;\n    &#125;\n&#125;\n\nInsufficientFundsException.java\nimport java.io.*;\n \n&#x2F;&#x2F;自定义异常类，继承Exception类\npublic class InsufficientFundsException extends Exception\n&#123;\n  &#x2F;&#x2F;此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱\n  private double amount;\n  public InsufficientFundsException(double amount)\n  &#123;\n    this.amount &#x3D; amount;\n  &#125; \n  public double getAmount()\n  &#123;\n    return amount;\n  &#125;\n&#125;\n\nCheckingAccount.java\nimport java.io.*;\n \n&#x2F;&#x2F;此类模拟银行账户\npublic class CheckingAccount\n&#123;\n  &#x2F;&#x2F;balance为余额，number为卡号\n   private double balance;\n   private int number;\n   public CheckingAccount(int number)\n   &#123;\n      this.number &#x3D; number;\n   &#125;\n  &#x2F;&#x2F;方法：存钱\n   public void deposit(double amount)\n   &#123;\n      balance +&#x3D; amount;\n   &#125;\n  &#x2F;&#x2F;方法：取钱\n   public void withdraw(double amount) throws\n                              InsufficientFundsException\n   &#123;\n      if(amount &lt;&#x3D; balance)\n      &#123;\n         balance -&#x3D; amount;\n      &#125;\n      else\n      &#123;\n         double needs &#x3D; amount - balance;\n         throw new InsufficientFundsException(needs);\n      &#125;\n   &#125;\n  &#x2F;&#x2F;方法：返回余额\n   public double getBalance()\n   &#123;\n      return balance;\n   &#125;\n  &#x2F;&#x2F;方法：返回卡号\n   public int getNumber()\n   &#123;\n      return number;\n   &#125;\n&#125;\n\n\n\n代码示例：自定义异常处理–验证码\npackage project5;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass MyException extends Exception\n&#123;\n    MyException(String s)\n    &#123;\n        super(s);\n    &#125;\n&#125;\n\nclass VerifyDemo\n&#123;\n    int[] verifyArr &#x3D; new int[6];\n\n    void printArr(int[] arr)\n    &#123;\n        for (int j : arr)\n        &#123;\n            System.out.print(Character.toString(j) + &quot; &quot;);\n        &#125;\n    &#125;\n\n    void createVerifyCode()\n    &#123;\n        int verifySeed &#x3D; 65;\n        Random random &#x3D; new Random(System.currentTimeMillis());\n\n        for (int i &#x3D; 0; i &lt; 6; ++i)\n        &#123;\n            int rand &#x3D; random.nextInt(26);\n            verifyArr[i] &#x3D; verifySeed + rand;\n        &#125;\n\n        printArr(verifyArr);\n    &#125;\n\n    int[] transformStringToArrInt(String s)\n    &#123;\n        int[] arr &#x3D; new int[6];\n        char[] charArr &#x3D; s.toCharArray();\n        for (int i &#x3D; 0; i &lt; charArr.length; ++i)\n        &#123;\n            arr[i] &#x3D; charArr[i];\n        &#125;\n        return arr;\n    &#125;\n\n    boolean checkVerifyCode(int[] arr)\n    &#123;\n        boolean isTrue &#x3D; true;\n        for (int i &#x3D; 0; i &lt; arr.length; ++i)\n        &#123;\n            if (arr[i] !&#x3D; verifyArr[i])\n            &#123;\n                isTrue &#x3D; false;\n                break;\n            &#125;\n        &#125;\n        return isTrue;\n    &#125;\n&#125;\n\npublic class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Scanner scanner &#x3D; new Scanner(System.in);\n        VerifyDemo verifydemo &#x3D; new VerifyDemo();\n        String inputStr;\n\n        System.out.print(&quot;Verify Code: &quot;);\n        verifydemo.createVerifyCode();\n        System.out.println();\n        System.out.print(&quot;&gt;&gt; &quot;);\n        inputStr &#x3D; scanner.next();\n\n        int[] verifyArr &#x3D; verifydemo.transformStringToArrInt(inputStr);\n        boolean isVerifyTrue &#x3D; verifydemo.checkVerifyCode(verifyArr);\n\n        try\n        &#123;\n            if (isVerifyTrue)\n            &#123;\n                throw new MyException(&quot;&lt;-- Verification Code True! --&gt;&quot;);\n            &#125;\n            else\n            &#123;\n                throw new MyException(&quot;&lt;-- Verification Code Error! --&gt;&quot;);\n            &#125;\n        &#125;\n        catch (MyException exception)\n        &#123;\n            System.out.println(exception.getMessage());\n        &#125;\n    &#125;\n&#125;\n\n3.7 多线程3.7.1 线程的生命周期\n新建状态:\n使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程\n\n\n就绪状态:\n当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度\n\n\n运行状态:\n如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态\n处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态\n\n\n阻塞状态:\n如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态\n在睡眠时间已到或获得设备资源后可以重新进入就绪状态，可以分为三种：\n等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态\n同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)\n其他阻塞：\n通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态\n当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态\n\n\n\n\n\n\n死亡状态:\n一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态\n\n\n\n3.7.2 线程的优先级\n作用：每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序\n方法：其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）\n\n3.7.3 线程的创建\n创建方法：\n\n通过实现 Runnable 接口\n通过继承 Thread 类本身\n通过 Callable 和 Future 创建线程\n\n\n代码示例：两个各自跑完100m\npackage project6;\n\npublic class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        FH_Thread fh_thread_1 &#x3D; new FH_Thread();\n        FH_Thread fh_thread_2 &#x3D; new FH_Thread();\n\n        Thread thread_1 &#x3D; new Thread(fh_thread_1, &quot;&lt;Fang&gt; 跑&gt;&gt;&quot;);\n        Thread thread_2 &#x3D; new Thread(fh_thread_2, &quot;&lt;张三&gt; 跑&gt;&gt;&quot;);\n\n        thread_1.start();\n        thread_2.start();\n    &#125;\n&#125;\n\nclass FH_Thread implements Runnable\n&#123;\n    int all &#x3D; 100;\n\n    public void run()\n    &#123;\n        while (true)\n        &#123;\n            if (all &gt; 0)\n            &#123;\n                try\n                &#123;\n                    Thread.sleep((int)(100+Math.random()*500));\n                &#125;\n                catch (InterruptedException e)\n                &#123;\n                    e.printStackTrace();\n                &#125;\n\n                System.out.println(Thread.currentThread().getName() + &quot; 5m&quot;);\n                all -&#x3D; 5;\n            &#125;\n            else\n            &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 完100m&quot;);\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n3.8 文件IO\n文件IO类：\nFile Class(类)\nFileReader Class(类)\nFileWriter Class(类)\n\n\n\n3.8.1 代码示例：\n案例描述：通过文件IO，创建排行榜和排序\n\n文件结构：\n\nproject7\nDemo.java\nLeaderBoard.java\nPlayer.java\nUpSort.java\nLeaderBoard.txt\n\n\n\n\n源码：\n\nDemo.java\npackage project7;\n\npublic class Demo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        LeaderBoard leaderBoard &#x3D; new LeaderBoard();\n        leaderBoard.initPage();\n        leaderBoard.writePage();\n        leaderBoard.readPage();\n        leaderBoard.updatePage();\n        leaderBoard.readPage();\n    &#125;\n&#125;\n\nLeaderBoard.java\npackage project7;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class LeaderBoard\n&#123;\n    Scanner scanner &#x3D;new Scanner(System.in);\n    Vector&lt;Player&gt; vPlayer &#x3D; new Vector&lt;&gt;();\n    Comparator&lt;Player&gt; comparator &#x3D; new UpSort();\n\n    public void initPage()\n    &#123;\n        System.out.println(&quot;&lt;-- Origin Leader Board --&gt;&quot;);\n        Player player1 &#x3D; new Player(&quot;A&quot;, 1);\n        Player player2 &#x3D; new Player(&quot;B&quot;, 4);\n        Player player3 &#x3D; new Player(&quot;C&quot;, 5);\n        Player player4 &#x3D; new Player(&quot;D&quot;, 8);\n\n        vPlayer.add(player1);\n        vPlayer.add(player2);\n        vPlayer.add(player3);\n        vPlayer.add(player4);\n\n        vPlayer.sort(comparator);\n    &#125;\n\n    public void readPage()\n    &#123;\n        FileReader fileReader &#x3D; null;\n        try\n        &#123;\n            fileReader &#x3D; new FileReader(&quot;src\\\\project7\\\\leaderBoard.txt&quot;);\n            int i;\n            while ((i &#x3D; fileReader.read()) !&#x3D; -1)\n            &#123;\n                System.out.print((char)i);\n            &#125;\n        &#125;\n        catch (Exception e)\n        &#123;\n            System.out.println(&quot;Page Can&#39;t Read&quot;);\n        &#125;\n        finally\n        &#123;\n            try\n            &#123;\n                assert fileReader !&#x3D; null;\n                fileReader.close();\n            &#125;\n            catch (IOException e)\n            &#123;\n                System.out.println(&quot;Page Not Found&quot;);\n            &#125;\n        &#125;\n    &#125;\n\n    public void writePage()\n    &#123;\n        FileWriter fileWriter &#x3D; null;\n        try\n        &#123;\n            fileWriter &#x3D; new FileWriter(&quot;src\\\\project7\\\\leaderBoard.txt&quot;);\n            for (Player player : vPlayer)\n            &#123;\n                fileWriter.write(player.grade + &quot;: &quot; + player.name + &quot;\\r\\n&quot;);\n            &#125;\n        &#125;\n        catch (Exception e)\n        &#123;\n            System.out.println(&quot;Page Can&#39;t Write&quot;);\n        &#125;\n        finally\n        &#123;\n            try\n            &#123;\n                assert fileWriter !&#x3D; null;\n                fileWriter.close();\n            &#125;\n            catch (IOException e)\n            &#123;\n                System.out.println(&quot;Page Not Found&quot;);\n            &#125;\n        &#125;\n    &#125;\n\n    public void updatePage()\n    &#123;\n        System.out.println(&quot;Add New Player &gt;&gt;&quot;);\n\n        System.out.print(&quot;Input Name: &quot;);\n        String newName &#x3D; scanner.next();\n\n        System.out.print(&quot;Input Grade: &quot;);\n        int newGrade &#x3D; scanner.nextInt();\n\n        Player newPlayer &#x3D; new Player(newName, newGrade);\n        vPlayer.add(newPlayer);\n        vPlayer.sort(comparator);\n\n        System.out.println();\n        System.out.println(&quot;### Updated Leader Board ###&quot;);\n        System.out.println();\n        System.out.println(&quot;&lt;-- New Leader Board --&gt;&quot;);\n\n        writePage();\n    &#125;\n&#125;\n\nPlayer.java\npackage project7;\n\npublic class Player\n&#123;\n    String name;\n    int grade;\n\n    Player(String name, int grade)\n    &#123;\n        this.name &#x3D; name;\n        this.grade &#x3D; grade;\n    &#125;\n&#125;\n\nUpSort.java\npackage project7;\n\nimport java.util.Comparator;\n\npublic class UpSort implements Comparator&lt;Player&gt;\n&#123;\n    public int compare(Player player1, Player player2)\n    &#123;\n        return Integer.compare(player1.grade, player2.grade);\n    &#125;\n&#125;\n\nLeaderBoard.txt\n1: A\n2: E\n4: B\n5: C\n8: D\n\n","slug":"10.Java基础","date":"2022-10-06T07:28:25.975Z","categories_index":"编程","tags_index":"Java","author_index":"FangH"},{"id":"9db7fbf272adb83d4da91baa664ab4df","title":"Dart基础","content":"Dart1. Dart 安装\n配套Flutter使用，安装Flutter SDK 1.21之后的版本，默认包含了最新的Dart SDK，不需要再额外安装Dart SDK\n\n运行命令\nPS C:\\Windows\\System32&gt; dart --version\nDart SDK version: 2.12.3 (stable) (Wed Apr 14 11:02:39 2021 +0200) on &quot;windows_x64&quot;\n\n2. Dart 环境配置\n安装完Flutter之后，打开VSCode\n在VSCode的扩展项里，搜索 Dart 和 Code Runner 安装即可\n\n3. Dart 项目文件\n打开VSCode，Ctrl + N，新建文件\n\nCtrl + S，另存为，修改文件后缀名 .dart，即可 (demo.dart)\nvoid main() &#123;\n  print(&quot;Hello World !&quot;);\n&#125;\n\nCtrl + Alt + N，运行即可看到打印结果\n或者进入项目内：\ndart demo1.dart\n\n&#x2F;&#x2F; 实际效果\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo1.dart\nHello World !\n\n5. Dart 基本语法5.1 Dart 变量类型void main() &#123;\n  &#x2F;&#x2F; var 可以自动通过类型声明变量\n  var str1 &#x3D; &quot;Hello World 1&quot;;\n  var num1 &#x3D; 1111;\n  print(str1);\n  print(num1);\n\n  &#x2F;&#x2F; 常规的指定变量类型\n  String str2 &#x3D; &quot;Hello World 2&quot;;\n  int num2 &#x3D; 2222;\n  print(str2);\n  print(num2);\n&#125;\n\n\n\n\n\n5.2 Dart 常量\nconst 修饰，需要赋初值\n\nfinal 修饰，可不赋初值，只能赋值一次\n\n永远不改变的值，需要用 const 或 final 修饰，不可用 var 或 其他类型\nvoid main() &#123;\n  var str &#x3D; &quot;Hello World 01&quot;;\n  str &#x3D; &quot;Hello World 02&quot;;\n  var num &#x3D; 1111;  \n  num &#x3D; 2222;\n    \n  print(str);\n  print(num);\n\n  const str1 &#x3D; &quot;Fang&quot;;\n  const num1 &#x3D; 2222;\n  &#x2F;&#x2F; const 修饰后，再次赋值无效\n  str1 &#x3D; &quot;Hang&quot;;\n  num1 &#x3D; 1234;\n\n  print(str1);\n  print(num1);\n&#125;\n\n#打印效果：显示错误#\nPS C:\\Users\\Admin&gt; dart &quot;c:\\Users\\Admin\\Desktop\\dart_demo\\demo1.dart&quot;\nDesktop&#x2F;dart_demo&#x2F;demo1.dart:13:3: Error: Can&#39;t assign to the const variable &#39;str1&#39;.\n  str1 &#x3D; &quot;Hang&quot;;\n  ^^^^\nDesktop&#x2F;dart_demo&#x2F;demo1.dart:14:3: Error: Can&#39;t assign to the const variable &#39;num1&#39;.\n  num1 &#x3D; 1234;\n  ^^^^\n\nfinal 和 const 的区别：（final只有在在运行时才会赋值一次，而const必须提前赋值）\nvoid main() &#123;\n  final f_timeNow &#x3D; new DateTime.now();\n  print(f_timeNow);\n\n  &#x2F;&#x2F; 错误的用法\n  const c_timeNow &#x3D; new DateTime.now();\n  print(c_timeNow);\n&#125;\n\n#打印效果：显示错误#\nPS C:\\Users\\Admin&gt; dart &quot;c:\\Users\\Admin\\Desktop\\dart_demo\\demo1.dart&quot;\nDesktop&#x2F;dart_demo&#x2F;demo1.dart:5:21: Error: New expression is not a constant expression.\n  const c_timeNow &#x3D; new DateTime.now();\n                    ^^^\n\n5.3 Dart 数据类型\n常用的数据类型：\nNumber（数值）\nint\ndouble\n\n\nString（字符串）\nString\n\n\nBoolen（布尔）\nbool\n\n\nList（数组）\n在Dart中，数组是列表的对象，大部分情况下称之为列表\n\n\nMap（字典）\nMap是一个（键，值）对的对象，（键，值）可以是任何类型的对象\n\n\n\n\n不常用的数据类型：\nRune：Dart中UTF-32编码字符串，可以通过文字转换成符号表情或特定的字\nSymbol：Dart程序中声明的运算符和标识符\n\n\n\n5.4 Dart 字符串5.4.1 Dart 字符串定义\n不换行（示例）：单引号 &#x2F;&#x2F; 双引号\nvoid main() &#123;\n  var str1 &#x3D; &#39;test string 01&#39;;\n  String str2 &#x3D; &quot;test string 02&quot;;\n\n  print(str1);\n  print(str2);\n&#125;\n\n不换行（打印）：\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\ntest string 01\ntest string 02\n\n换行（示例）：三个单引号 &#x2F;&#x2F; 三对双引号\nvoid main() &#123;\n  String str1 &#x3D; &#39;&#39;&#39;\n  Test String 01\n  Test String 02\n  &#39;&#39;&#39;;\n\n  String str2 &#x3D; &quot;&quot;&quot;\n  Test String 03\n  Test String 04\n  &quot;&quot;&quot;;\n\n  print(str1);\n  print(str2);\n&#125;\n\n换行（打印）：\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\n  Test String 01\n  Test String 02\n\n  Test String 03\n  Test String 04\n\n5.4.2 Dart 字符串拼接\n将两个字符串拼接\n&#39;$str1 $str2&#39;\n&quot;$str1 $str2&quot;\n str1 + str2\n\nvoid main() &#123;\n  String str1 &#x3D; &#39;Hello&#39;;\n  String str2 &#x3D; &#39;Wrold&#39;;\n\n  print(str1 + &#39; &#39; + str2);\n  print(&#39;$str1 $str2&#39;);\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\nHello Wrold\nHello Wrold\n\n5.5 Dart 数值计算void main() &#123;\n  int a &#x3D; 12;\n  double b &#x3D; 24.0;\n  double c &#x3D; 48;\n\n  print(a);\n  print(b);\n  print(c);\n\n  print(&#39;-------&#39;);\n\n  var d &#x3D; a + c;\n  var e &#x3D; c - a;\n  var f &#x3D; a * b;\n  var g &#x3D; c &#x2F; a;\n  var h &#x3D; b % a;\n\n  print(d);\n  print(e);\n  print(f);\n  print(g);\n  print(h);\n&#125;\n\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\n12\n24.0   \n48.0   \n-------\n60.0   \n36.0\n288.0\n4.0\n0.0\n\n\n\n\n\n5.6 Dart 布尔类型void main() &#123;\n  int a &#x3D; 12;\n  int b &#x3D; 12;\n  if (a &#x3D;&#x3D; b) &#123;\n    print(&#39;a &#x3D; b&#39;);\n  &#125; else &#123;\n    print(&#39;a !&#x3D; b&#39;);\n  &#125;\n\n  bool c &#x3D; true;\n  bool d &#x3D; false;\n  if (c &#x3D;&#x3D; d) &#123;\n    print(&#39;c &#x3D; d&#39;);\n  &#125; else &#123;\n    print(&#39;c !&#x3D; d&#39;);\n  &#125;\n&#125;\n\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\na &#x3D; b\nc !&#x3D; d\n\n\n\n\n\n5.7 List 集合类型\n不指定类型\nvoid main() &#123;\n  var list1 &#x3D; [&quot;FHang&quot;, 24, true];\n  print(&quot;list1:&quot;);\n  print(list1);\n  print(&quot;--------&quot;);\n\n  print(&quot;list frist:&quot;);\n  print(list1.first);\n  print(list1[0]);\n  print(&quot;--------&quot;);\n\n  print(&quot;list second:&quot;);\n  print(list1[1]);\n  print(&quot;--------&quot;);\n\n  print(&quot;list last:&quot;);\n  print(list1.last);\n  print(list1[2]);\n  print(&quot;--------&quot;);\n\n  print(&quot;list length:&quot;);\n  print(list1.length);\n&#125;\n\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\nlist1:\n[FHang, 24, true]\n--------\nlist frist:      \nFHang\nFHang\n--------\nlist second:\n24\n--------\nlist last:\ntrue\ntrue\n--------\nlist length:\n3\n\n指定类型\nvoid main() &#123;\n  var list1 &#x3D; &lt;String&gt;[&quot;Fang&quot;, &quot;Hang&quot;];\n  print(list1.first);\n  print(list1.last);\n&#125;\n\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\nFang\nHang\n\n添加&#x2F;删除数据到集合\nvoid main() &#123;\n  var list1 &#x3D; [];\n  print(list1.length);\n  print(&quot;--------&quot;);\n\n  &#x2F;&#x2F;添加\n  list1.add(&quot;Fang&quot;);\n  list1.add(&quot;Hang&quot;);\n  list1.add(24);\n  print(list1);\n  print(list1.length);\n  print(&quot;--------&quot;);\n\n  &#x2F;&#x2F;删除\n  list1.removeAt(1);\n  print(list1);\n  print(list1.length);\n&#125;\n\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\n0\n--------        \n[Fang, Hang, 24]\n3\n--------        \n[Fang, 24]\n2\n\n通过List.filled 来创建固定大小的集合\nvoid main() &#123;\n  &#x2F;&#x2F; 不指定类型\n  var list1 &#x3D; List.filled(2, &quot;&quot;);\n  &#x2F;&#x2F; 指定类型\n  &#x2F;&#x2F; var list2 &#x3D; List&lt;String&gt;.filled(2, &quot;&quot;);\n  print(list1.length);\n  print(list1);\n\n  list1[0] &#x3D; &quot;Fang&quot;;\n  list1[1] &#x3D; &quot;hang&quot;;\n  print(list1);\n&#125;\n\nPS C:\\Users\\Admin\\Desktop\\dart_demo&gt; dart .\\demo01.dart\n2\n[, ]        \n[Fang, hang]\n\n","slug":"9.Dart基础_01","date":"2022-10-06T07:28:25.973Z","categories_index":"编程","tags_index":"Dart","author_index":"FangH"},{"id":"d3adb67f358afb69b06b3570d65b1657","title":"Flutter基础","content":"Flutter1. Flutter 安装\n\n开始使用 — Windows — 获取 Flutter SDK — 下载\n\n将压缩包解压 — 找到 bin 目录 — 复制 bin 目录路径\n\n进入Win10 环境变量设置 — 系统变量 — Path — 将复制的目录添加\n\n回到中国Flutter的官网，来到网页底端 — 使用镜像\n\n选择Flutter 社区镜像 — 再次进入Win10环境变量设置 — 系统变量\n添加：\nFLUTTER_STORAGE_BASE_URL: https:&#x2F;&#x2F;storage.flutter-io.cn\nPUB_HOSTED_URL: https:&#x2F;&#x2F;pub.flutter-io.cn\n\n检查Flutter版本：\nPS C:\\Windows\\System32&gt; flutter --version\n   Flutter 2.0.5 • channel stable • https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter.git\n   Framework • revision adc687823a (5 days ago) • 2021-04-16 09:40:20 -0700\n   Engine • revision b09f014e96\n   Tools • Dart 2.12.3\n\n检查Flutter配置是否完好\nPS C:\\Windows\\System32&gt; flutter doctor\nDoctor summary (to see all details, run flutter doctor -v):\n[✓] Flutter (Channel stable, 2.0.5, on Microsoft Windows [Version 10.0.19042.804], locale zh-CN)\n[✗] Android toolchain - develop for Android devices\n    ✗ Unable to locate Android SDK.\n      Install Android Studio from: https:&#x2F;&#x2F;developer.android.com&#x2F;studio&#x2F;index.html\n      On first launch it will assist you in installing the Android SDK components.\n      (or visit https:&#x2F;&#x2F;flutter.dev&#x2F;docs&#x2F;get-started&#x2F;install&#x2F;windows#android-setup for detailed instructions).\n      If the Android SDK has been installed to a custom location, please use\n      &#96;flutter config --android-sdk&#96; to update to that location.\n\n[✓] Chrome - develop for the web\n[!] Android Studio (not installed)\n[✓] Connected device (2 available)\n\n! Doctor found issues in 2 categories.\n\n可以看到 Android 栏是错误，因为没有安装 Android Studio，安装Android Studio后\n\n运行命令，即可\n\n\n   flutter config --android-sdk\n\n\n默认可以使用Web\n\n2. Flutter 项目","slug":"8.Flutter基础_01","date":"2022-10-06T07:28:25.970Z","categories_index":"编程","tags_index":"Flutter","author_index":"FangH"},{"id":"2d7038c614ab5b62d3dc8aa389662f8e","title":"UE4 智能指针","content":"UE4 智能指针1. 虚幻智能指针库\n为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担\n该实现包括行业标准 共享指针、弱指针 和 唯一指针。其还可添加 共享引用，此类引用的行为与不可为空的共享指针相同\n虚幻Objects使用更适合游戏代码的单独内存追踪系统，因此这些类无法与 UObject 系统同时使用\n\n2. 智能指针类型前提：\n\n智能指针可影响其包含或引用对象的寿命\n不同智能指针对对象有不同的限制和影响\n\n下表可用于协助决定各类型智能指针的适用情况：\n\n\n\n智能指针类型\n适用情形\n\n\n\n**共享指针**（TSharedPtr）\n共享指针拥有其引用的对象，无限防止该对象被删除，并在无共享指针或共享引用（见下文）引用其时，最终处理其的删除共享指针可为空白，意味其不引用任何对象任何非空共享指针都可对其引用的对象生成共享引用\n\n\n**共享引用(ProgrammingAndScripting&#x2F;ProgrammingWithCPP&#x2F;UnrealArchitecture&#x2F;SmartPointerLibrary&#x2F;SharedReference)**（TSharedRef）\n共享引用的行为与共享指针类似，即其拥有自身引用的对象对于空对象而言，其存在不同；共享引用须固定引用非空对象共享指针无此类限制，因此共享引用可固定转换为共享指针，且该共享指针固定引用有效对象要确认引用的对象是非空，或者要表明共享对象所有权时，请使用共享引用\n\n\n**弱指针(ProgrammingAndScripting&#x2F;ProgrammingWithCPP&#x2F;UnrealArchitecture&#x2F;SmartPointerLibrary&#x2F;WeakPointer)**（TWeakPtrTSharedPtr）\n弱指针类与共享指针类似，但不拥有其引用的对象，因此不影响其生命周期此属性中断引用循环，因此十分有用，但也意味弱指针可在无预警的情况下随时变为空因此，弱指针可生成指向其引用对象的共享指针，确保程序员能对该对象进行安全临时访问\n\n\n唯一指针（TUniquePtr）\n唯一指针仅会显式拥有其引用的对象仅有一个唯一指针指向给定资源，因此唯一指针可转移所有权，但无法共享复制唯一指针的任何尝试都将导致编译错误唯一指针超出范围时，其将自动删除其所引用的对象\n\n\n注意：\n\n对唯一指针引用的对象进行共享指针或共享引用的操作十分危险\n即使其他智能指针继续引用该对象，此操作不会取消唯一指针自身被销毁时删除该对象的行为\n同样，不应为共享指针或共享引用引用的对象创建唯一指针\n\n3. 智能指针\n\n\n优点\n描述\n\n\n\n防止内存泄漏\n共享引用不存在时，智能指针（弱指针除外）会自动删除对象\n\n\n弱引用\n弱指针会中断引用循环并阻止悬挂指针\n\n\n可选择的线程安全）\n虚幻智能指针库包括线程安全代码，可跨线程管理引用计数，如无需线程安全，可用其换取更好性能\n\n\n运行时安全\n共享引用从不为空，可固定随时取消引用\n\n\n授予意图\n可轻松区分对象所有者和观察者\n\n\n内存\n智能指针在64位下仅为C++指针大小的两倍（加上共享的16字节引用控制器），唯一指针除外，其与C++指针大小相同\n\n\n4. 助手类和函数\n\n\n助手类\n描述\n\n\n\nTSharedFromThis\n在添加 AsShared 或 SharedThis 函数的 TSharedFromThis 中衍生类，利用此类函数可获取对象的 TSharedRef\n\n\n\n\n\n函数\n描述\n\n\n\nMakeSharedMakeShareable\n在常规C++指针中创建共享指针MakeShared 会在单个内存块中分配新的对象实例和引用控制器，但要求对象提交公共构造函数MakeShareable 的效率较低，但即使对象的构造函数为私有，其仍可运行利用此操作可拥有非自己创建的对象，并在删除对象时支持自定义行为\n\n\nStaticCastSharedRefStaticCastSharedPtr\n静态投射效用函数，通常用于向下投射到衍生类型\n\n\nConstCastSharedRefConstCastSharedPtr\n将 const 智能引用或智能指针分别转换为 mutable 智能引用或智能指针\n\n\n5. 智能指针实现细节注：在功能和效率方面，虚幻智能指针库中的智能指针具有一些共同特征\n5.1 运行速度注：\n\n要使用智能指针时，始终考虑性能\n智能指针非常适合某些高级系统、资源管理或工具编程\n但部分智能指针类型比原始C++指针更慢，这种开销使得其在低级引擎代码（如渲染）中用处不大\n\n智能指针的部分一般性能优势包括：\n\n所有运算均为常量时间\n取消引用多数智能指针的速度和原始C++指针的相同（在发布版本中）\n复制智能指针永不会分配内存\n线程安全智能指针是无锁的\n\n智能指针的性能缺陷包括：\n\n创建和复制智能指针比创建和复制原始C++指针需要更多开销\n保持引用计数增加基本运算的周期\n部分智能指针占用的内存比原始的C++更多\n引用控制器有两个堆分配。使用 MakeShared 代替 MakeShareable 可避免二次分配，并可提高性能\n\n5.2 侵入性访问器定义：\n\n共享指针是非侵入性的，意味对象不知道其是否为智能指针拥有\n\n此通常是可以接受的，但在某些情况下，可能要将对象作为共享引用或共享指针进行访问\n\n为此，使用对象的类作为模板参数，在 TSharedFromThis 衍生对象的类\n\nTSharedFromThis 提供两个函数：AsShared 和 SharedThis，可将对象转换为共享引用（并从共享引用转换为共享指针）\n\n使用固定返回共享引用的类factory时，或需将对象传到需要共享引用或共享指针的系统时，此操作十分有用\n\nAsShared 会将类返回为最初作为模板参数传到 TSharedFromThis 的类型返回，其可能是调用对象的父类型，而 SharedThis 将直接从该类型衍生类型，并返回引用该类型对象的智能指针\n\n以下范例代码中演示这两种函数：\nclass FRegistryObject;\nclass FMyBaseClass: public TSharedFromThis&lt;FMyBaseClass&gt;\n&#123;\n    virtual void RegisterAsBaseClass(FRegistryObject* RegistryObject)\n    &#123;\n        &#x2F;&#x2F; 访问对&quot;this&quot;的共享引用。\n        &#x2F;&#x2F; 直接继承自&lt; TSharedFromThis &gt;，因此AsShared()和SharedThis(this)会返回相同的类型。\n        TSharedRef&lt;FMyBaseClass&gt; ThisAsSharedRef &#x3D; AsShared();\n        &#x2F;&#x2F; RegistryObject需要 TSharedRef&lt;FMyBaseClass&gt;，或TSharedPtr&lt;FMyBaseClass&gt;。TSharedRef可被隐式转换为TSharedPtr.\n        RegistryObject-&gt;Register(ThisAsSharedRef);\n    &#125;\n&#125;;\nclass FMyDerivedClass : public FMyBaseClass\n&#123;\n    virtual void Register(FRegistryObject* RegistryObject) override\n    &#123;\n        &#x2F;&#x2F; 并非直接继承自TSharedFromThis&lt;&gt;，因此AsShared()和SharedThis(this)不会返回相同类型。\n        &#x2F;&#x2F; 在本例中，AsShared()会返回在TSharedFromThis&lt;&gt; - TSharedRef&lt;FMyBaseClass&gt;中初始指定的类型。\n        &#x2F;&#x2F; 在本例中，SharedThis(this)会返回具备&quot;this&quot;类型的TSharedRef - TSharedRef&lt;FMyDerivedClass&gt;。\n        &#x2F;&#x2F; SharedThis()函数仅在与 &#39;this&#39;指针相同的范围内可用。\n        TSharedRef&lt;FMyDerivedClass&gt; AsSharedRef &#x3D; SharedThis(this);\n        &#x2F;&#x2F; FMyDerivedClass是FMyBaseClass的一种类型，因此RegistryObject将接受TSharedRef&lt;FMyDerivedClass&gt;。\n        RegistryObject-&gt;Register(ThisAsSharedRef);\n    &#125;\n&#125;;\nclass FRegistryObject\n&#123;\n    &#x2F;&#x2F; 此函数将接受到FMyBaseClass或其子类的TSharedRef或TSharedPtr。\n    void Register(TSharedRef&lt;FMyBaseClass&gt;);\n&#125;;\n\n\n\n注意：要在构造函数中调用 AsShared 或 Shared，共享引用此时并未初始化，将导致崩溃或断言\n\n\n5.3 投射可通过虚幻智能指针库包含的多个支持函数投射共享指针(和共享引用)\nUp-casting是隐式的，与C++指针相同\n可使用 ConstCastSharedPtr 函数进行常量投射，使用 StaticCastSharedPtr 进行静态投射（通常是向下投射到衍生类指针）\n无run-type类型的信息（RTTI），因此不支持动态转换；应使用静态投射\n如以下代码所示：\n&#x2F;&#x2F; 假设通过其他方式验证了FDragDropOperation实际为FAssetDragDropOp。\nTSharedPtr&lt;FDragDropOperation&gt; Operation &#x3D; DragDropEvent.GetOperation();\n&#x2F;&#x2F;现在可使用StaticCastSharedPtr进行投射。\nTSharedPtr&lt;FAssetDragDropOp&gt; DragDropOp &#x3D; StaticCastSharedPtr&lt;FAssetDragDropOp&gt;(Operation);\n\n\n\n\n\n5.4 线程安全通常仅在单线程上访问智能指针的操作才是安全的\n如需访问多线程，请使用智能指针类的线程安全版本：\n\nTSharedPtr&lt;T, ESPMode::ThreadSafe&gt;\nTSharedRef&lt;T, ESPMode::ThreadSafe&gt;\nTWeakPtr&lt;T, ESPMode::ThreadSafe&gt;\nTSharedFromThis&lt;T, ESPMode::ThreadSafe&gt;\n\n由于原子引用计数，此类线程安全版本比默认版本稍慢，但其行为与常规C++指针一致：\n\n读取和复制固定为线程安全\n写入和重置须同步后才安全\n\n注：\n\n如了解多线程永不访问指针，可通过避免使用线程安全版本获得更好性能\n\n6. 提示和限制\n避免将数据作为 TSharedRef 或 TSharedPtr 参数传到函数，此操作将因取消引用和引用计数而产生开销\n\n相反，建议将引用对象作为 const &amp; 进行传递\n\n可将共享指针向前声明为不完整类型\n\n共享指针与虚幻对象(UObject 及其衍生类)不兼容\n\n引擎具有 UObject 管理的单独内存管理系统（对象处理文档），两个系统未互相重叠\n\n\n7. 共享指针定义：\n\n一种支持共享拥有、自动失效、弱引用等特性的智能指针\n共享指针（Shared Pointers） 是指既健壮、又能为空指针的智能指针\n共享指针沿袭了普通智能指针的所有优点，它能避免出现内存泄漏、悬挂指针，还能避免指针指向未初始化的内存\n\n其他特点：\n\n共享所有权（Shared Ownership）： 引用计数支持多个共享指针，以确保它们引用的数据对象永远不被删除，前提是它们中的任意一个仍指向数据对象\n自动失效（Automatic Invalidation）： 你可安全引用易变对象，无需担心出现悬挂指针\n弱引用： 弱指针可中断引用循环\n意向指示（Indication of Intent）： 区分拥有者（参见共享引用）和观察者，并提供不可为空的引用\n\n其他特性：\n\n语法非常健壮\n非侵入式（但能反射）\n线程安全（视情况而定）\n性能佳，占用内存少\n\n注意：\n\n共享指针类似于共享引用，主要区别在于共享引用不可为空，因此会始终引用有效对象\n在共享引用和共享指针之间进行选择时，除非需要空对象或可为空的对象，否则建议你优先选择共享引用\n\n7.1 声明和初始化\n因为共享指针可为空，所以无论有无数据对象，都可以对它们进行初始化\n\n创建共享指针的一些示例：\n&#x2F;&#x2F; 创建一个空白的共享指针\nTSharedPtr EmptyPointer;\n&#x2F;&#x2F; 为新对象创建一个共享指针\nTSharedPtr&lt;FMyObjectType&gt; NewPointer(new FMyObjectType());\n&#x2F;&#x2F; 从共享引用创建一个共享指针\nTSharedRef&lt;FMyObjectType&gt; NewReference(new FMyObjectType());\nTSharedPtr&lt;FMyObjectType&gt; PointerFromReference &#x3D; NewReference;\n&#x2F;&#x2F; 创建一个线程安全的共享指针\nTSharedPtr&lt;FMyObjectType, ESPMode::ThreadSafe&gt; NewThreadsafePointer &#x3D; MakeShared&lt;FMyObjectType, ESPMode::ThreadSafe&gt;(MyArgs);\n\n在第二个示例中，NodePtr 实际上拥有新的 FMyObjectType 对象，因为没有其他共享指针引用该对象\n\n如果 NodePtr 超出范围，并且没有其他共享指针或共享引用指向该对象，那么该对象将被销毁\n\n复制共享指针时，系统将向它引用的对象添加一个引用\n&#x2F;&#x2F; 增加任意对象ExistingSharedPointer引用的引用数。\nTSharedPtr&lt;FMyObjectType&gt; AnotherPointer &#x3D; ExistingSharedPointer;\n\n对象将持续存在，直到不再有共享指针（或共享引用）引用它为止\n\n可以使用 Reset 函数、或分配一个空指针来重设共享指针，如下所示：\nPointerOne.Reset();\nPointerTwo &#x3D; nullptr;\n&#x2F;&#x2F; PointerOne和PointerTwo现在都引用nullptr。\n\n\n\n使用 MoveTemp（或 MoveTempIfPossible）函数将一个共享指针的内容转移到另一个共享指针，将原始的共享指针保留为空：\n&#x2F;&#x2F; 将PointerOne的内容移至PointerTwo。在此之后，PointerOne将引用nullptr。\nPointerTwo &#x3D; MoveTemp(PointerOne);\n&#x2F;&#x2F; 将PointerTwo的内容移至PointerOne。在此之后，PointerTwo将引用nullptr。\nPointerOne &#x3D; MoveTempIfPossible(PointerTwo);\n\n注意：MoveTemp 和 MoveTempIfPossible 的唯一不同之处在于 MoveTemp 包含静态断言，强制其只能在非常量左值（lvalue）上执行\n\n\n7.2 共享指针与引用转换\n在共享指针与共享引用之间进行转换是一种常见的做法。共享引用隐式地转换为共享指针，并提供新的共享指针将引用有效对象的额外保证\n\n转换由普通语法处理：\nTSharedPtr&lt;FMyObjectType&gt; MySharedPointer &#x3D; MySharedReference;\n\n\n\n只要共享指针引用了一个非空对象，你就可以使用 Shared Pointer 函数 ToSharedRef 从此共享指针创建一个共享引用\n\n试图从空共享指针创建共享引用将导致程序断言\n&#x2F;&#x2F; 在解引用之前，请确保共享指针有效，以避免可能出现的断言。\nif (MySharedPointer.IsValid())\n&#123;\n    MySharedReference &#x3D; MySharedPointer.ToSharedRef();\n&#125;\n\n7.3 对比\n目的：测试共享指针彼此间的相等性\nTSharedPtr&lt;FTreeNode&gt; NodeA, NodeB;\nif (NodeA &#x3D;&#x3D; NodeB)\n&#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n\n\nIsValid 函数和 bool 运算符有助于判断共享指针是否引用了有效对象\n\n可以调用 Get，查看它是否返回有效的（非空）对象指针\nif (Node.IsValid())\n&#123;\n    &#x2F;&#x2F; ...\n&#125;\nif (Node)\n&#123;\n    &#x2F;&#x2F; ...\n&#125;\nif (Node.Get() !&#x3D; nullptr)\n&#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n7.4 解引用和访问说明：\n\n像使用普通C++指针那样解引用，调用方法和访问成员\n可以像使用其他C++指针那样，通过调用 IsValid 函数或使用重载的 bool 运算符，在取消引用之前执行空检查\n\n&#x2F;&#x2F; 在解引用前，检查节点是否引用了一个有效对象。\nif (Node)\n&#123;\n    &#x2F;&#x2F; 以下三行代码中的任意一行都能解引用节点，并且对它的对象调用ListChildren：\n    Node-&gt;ListChildren();\n    Node.Get()-&gt;ListChildren();\n    (*Node).ListChildren();\n&#125;\n\n\n\n\n\n\n\n7.5 自定义删除器\n说明：共享指针和共享引用支持对它们引用的对象使用自定义删除器\n\n如需运行自定义删除代码，请提供lambda函数，作为创建智能指针时使用的参数，就像这样：\nvoid DestroyMyObjectType(FMyObjectType* ObjectAboutToBeDeleted)\n&#123;\n    &#x2F;&#x2F; 此处添加删除代码。\n&#125;\n&#x2F;&#x2F; 这些函数使用自定义删除器创建指南指针。\nTSharedRef&lt;FMyObjectType&gt; NewReference(new FMyObjectType(), [](FMyObjectType* Obj)&#123; DestroyMyObjectType(Obj); &#125;);\nTSharedPtr&lt;FMyObjectType&gt; NewPointer(new FMyObjectType(), [](FMyObjectType* Obj)&#123; DestroyMyObjectType(Obj); &#125;);\n\n8. 共享引用\n不能为未初始化或分配为空的智能指针类型\n\n说明：\n\n共享引用 是一类强大且不可为空的 智能指针，其被用于引擎的 Uobject 系统外的数据对象\n此意味无法重置共享引用、向其指定空对象，或创建空白引用\n因此共享引用固定包含有效对象，甚至未拥有 IsValid 方法\n在共享引用和 [共享指针]（Shared Pointers） 间选择时，除非需要空白或可为空的对象，否则共享引用为优先选项\n如需可能空白或可为空的引用，则应使用共享指针\n\n注意：与标准的C++引用不同，可在创建后将共享引用重新指定到另一对象\n8.1 声明和初始化\n共享引用不可为空，因此初始化需要数据对象\n\n在无有效对象的情况下尝试创建的共享引用将不会编译，并尝试将共享引用初始化为空指针变量\n&#x2F;&#x2F;创建新节点的共享引用\nTSharedRef&lt;FMyObjectType&gt; NewReference &#x3D; MakeShared&lt;FMyObjectType&gt;();\n\n\n\n在无有效对象的情况下尝试创建的共享引用将不会编译：\n&#x2F;&#x2F;以下两者均不会编译：\nTSharedRef&lt;FMyObjectType&gt; UnassignedReference;\nTSharedRef&lt;FMyObjectType&gt; NullAssignedReference &#x3D; nullptr;\n&#x2F;&#x2F;以下会编译，但如NullObject实际为空则断言。\nTSharedRef&lt;FMyObjectType&gt; NullAssignedReference &#x3D; NullObject;\n\n8.2 共享指针与引用转换说明：共享引用会隐式转换为共享指针，并为新共享指针引用有效对象提供额外保证\n\n使用普通语法处理转换：\nTSharedPtr&lt;FMyObjectType&gt; MySharedPointer &#x3D; MySharedReference;\n\n\n\n如共享指针引用非空对象，即可使用 共享指针 函数 ToSharedRef，在共享指针中创建共享引用\n\n尝试在空共享指针中创建共享引用，将导致程序断言\n&#x2F;&#x2F;在取消引用前，确保共享指针为有效，避免潜在断言。\nIf (MySharedPointer.IsValid())\n&#123;\n    MySharedReference &#x3D; MySharedPointer.ToSharedRef();\n&#125;\n\n8.3 对比\n可测试共享引用彼此是否相等。在此情况下，相等表示引用相同对象\nTSharedRef&lt;FMyObjectType&gt; ReferenceA, ReferenceB;\nif (ReferenceA &#x3D;&#x3D; ReferenceB)\n&#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n9. 弱指针\n存储弱引用且不阻止其对象被销毁的智能指针\n\n说明：\n\n弱指针 存储对象的弱引用\n\n与 共享指针 或 共享引用 不同，弱指针不会阻止其引用的对象被销毁\n\n在访问弱指针引用的对象前，应使用 Pin 函数生成共享指针\n\n此操作确保使用该对象时其将继续存在\n\n如只需要确定弱指针是否引用对象，可将其与 nullptr 比较，或在之上调用 IsValid\n\n\n注意：\n\n弱指针的使用有助于授予意图——弱指针表明对引用对象的观察，而无需所有权，同时不控制其生命周期\n\n9.1 声明初始化和分配\n可创建空白弱指针，或在共享引用、共享指针或其他弱指针中进行\n&#x2F;&#x2F;分配新的数据对象，并创建对其的强引用。\nTSharedRef&lt;FMyObjectType&gt; ObjectOwner &#x3D; MakeShared&lt;FMyObjectType&gt;();\n&#x2F;&#x2F;创建指向新数据对象的弱指针。\nTWeakPtr&lt;FMyObjectType&gt; ObjectObserver(ObjectOwner);\n\n\n\n弱指针不会阻止对象被销毁\n\n无论 ObjectOwner 是否在范围内，重置 ObjectOwner 都将销毁对象：\n&#x2F;&#x2F;假设ObjectOwner是其对象的唯一拥有者，ObjectOwner停止引用该对象时，该对象将被销毁。\nObjectOwner.Reset();\n&#x2F;&#x2F;ObjectOwner引用空对象，因此Pin()生成的共享指针将也将为空。被视为布尔时，空白共享指针的值为false。\nif (ObjectObserver.Pin())\n&#123;\n    &#x2F;&#x2F;只当ObjectOwner非对象的唯一拥有者时，此代码才会运行。\n    check(false);\n&#125;\n\n\n\n与共享指针相同，弱指针是否引用有效对象，均可进行安全复制：\nTWeakPtr&lt;FMyObjectType&gt; AnotherObjectObserver &#x3D; ObjectObserver;\n\n\n\n使用完弱指针后，可进行重置\n&#x2F;&#x2F;可通过将弱指针设为nullptr进行重置。\nObjectObserver &#x3D; nullptr;\n&#x2F;&#x2F;也可使用重置函数。\nAnotherObjectObserver.Reset();\n\n9.2 转换为共享指针说明：\n\nPin 函数将创建指向弱指针对象的共享指针\n只要共享指针在范围内且引用对象，则该对象将持续有效\n此外，共享指针（包括由 Pin 函数返回的指针）可在条件句中作为 布尔 类型进行求值，其中 true 表示有效对象\n以下代码模式检查弱指针是否引用有效对象\n如是，至少在共享指针（由 Pin 函数创建）超出范围或被显式清除前，将保证其持续有效\n\n&#x2F;&#x2F;获取弱指针中的共享指针，并检查其是否引用有效对象。\nif (TSharedPtr&lt;FMyObjectType&gt; LockedObserver &#x3D; ObjectObserver.Pin())\n&#123;\n    &#x2F;&#x2F;共享指针仅在此范围内有效。\n    &#x2F;&#x2F;该对象已被验证为存在，而共享指针阻止其被删除。\n    LockedObserver-&gt;SomeFunction();\n&#125;\n\n\n\n\n\n\n\n9.3 取消引用和访问\n要访问弱指针的对象，首需使用 Pin 函数，将其提升为共享指针\n然后可通过共享指针或弱指针上的 Get 函数进行访问\n此方法可确保使用该对象时，其将持续有效\n\n9.4 打破引用循环\n两个或多个对象使用智能指针保持彼此间的强引用时，将出现引用循环\n在此类情况下，对象间会相互保护以免被删除\n各对象固定被另一对象引用，因此对象无法在另一对象存在时被删除\n如外部对象未对引用循环中对象进行引用，其实际上将出现泄漏\n弱指针不会保留自身引用的对象，因此其可中断此类引用循环\n要在未拥有对象时对其进行引用，并延长其寿命时，可使用软指针\n\n9.5 使用警告如不想保证数据对象会持续存在时，弱指针将非常有用，但该属性可能会变得异常危险\n在以下情况中请谨慎使用弱指针：\n\n在集或映射中用作键。弱指针可能会在未通知容器的情况下随时无效，因此共享指针或共享引用更适用于充当键，可安全地将弱指针用作数值\n虽然弱指针提供 IsValid 函数，但是检查 IsValid 无法保证对象在任何时间长度内均可持续有效\n线程安全共享指针可能会因另一线程上的活动而随时无效，因此使用线程安全共享指针应尤其注意\nPin 返回的共享指针将使对象在代码将其清除或其超出范围前保持活跃状态，因此 Pin 函数是用于检查的首选方法，此类检查会导致取消引用或访问存储对象\n\n","slug":"7_UE4智能指针_07","date":"2022-10-06T07:28:25.968Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"97e60817d770107d3926456a0105594d","title":"UE4 委托","content":"UE4 委托1. 委托定义介绍：在C++对象上引用和执行成员函数的数据类型\n定义：\n\n是一种泛型但类型安全的方式，可在C++对象上调用成员函数\n可使用委托动态绑定到任意对象的成员函数，之后在该对象上调用函数，即使调用程序不知对象类型也可进行操作\n复制委托对象很安全。你也可以利用值传递委托，但这样操作需要在堆上分配内存，因此通常并不推荐\n尽量通过引用传递委托\n\n种类：\n\n单点委托\n组播委托\n事件\n\n\n动态(UObject, serializable)\n\n2. 基本使用2.1 声明委托前提：\n\n根据与委托相绑定的函数（或多个函数）的函数签名来选择宏\n每个宏都为新的委托类型名称、函数返回类型（如果不是 void 函数）及其参数提供了参数\n\n提供的函数签名：\n\n返回一个值的函数\n声明为 const 函数\n最多4个”载荷”变量\n最多9个函数参数（可自定义）\n\n参照表格查找用于声明委托的生命宏：\n\n\n\n函数签名\n声明宏\n\n\n\nvoid Function()\nDECLARE_DELEGATE(DelegateName)\n\n\nvoid Function(Param1)\nDECLARE_DELEGATE_OneParam(DelegateName, Param1Type)\n\n\nvoid Function(Param1, Param2)\nDECLARE_DELEGATE_TwoParams(DelegateName, Param1Type, Param2Type)\n\n\nvoid Function(Param1, Param2, ...)\nDECLARE_DELEGATE_&lt;Num&gt;Params(DelegateName, Param1Type, Param2Type, ...)\n\n\n&lt;RetValType&gt; Function()\nDECLARE_DELEGATE_RetVal(RetValType, DelegateName)\n\n\n&lt;RetValType&gt; Function(Param1)\nDECLARE_DELEGATE_RetVal_OneParam(RetValType, DelegateName, Param1Type)\n\n\n&lt;RetValType&gt; Function(Param1, Param2)\nDECLARE_DELEGATE_RetVal_TwoParams(RetValType, DelegateName, Param1Type, Param2Type)\n\n\n&lt;RetValType&gt; Function(Param1, Param2, ...)\nDECLARE_DELEGATE_RetVal_&lt;Num&gt;Params(RetValType, DelegateName, Param1Type, Param2Type, ...)\n\n\n注意：\n\n委托函数支持与UFunctions的说明符相同，但使用UDELEGATE而不是宏UFUNCTION\n\n代码BlueprintAuthorityOnly说明添加到FInstigatedAnyDamageSignature委托符中\nUDELEGATE(BlueprintAuthorityOnly)\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FInstigatedAnyDamageSignature, float, Damage, const UDamageType*, DamageType, AActor*, DamagedActor, AActor*, DamageCauser);\n\n组播委托、动态委托和封装委托，上述宏的变体如下：\n\nDECLARE_MULTICAST_DELEGATE…\nDECLARE_DYNAMIC_DELEGATE…\nDECLARE_DYNAMIC_MULTICAST_DELEGATE…\nDECLARE_DYNAMIC_DELEGATE…\nDECLARE_DYNAMIC_MULTICAST_DELEGATE…\n\n委托签名声明可存在于全局范围内、命名空间内、甚至类声明内，此类声明可能不在于函数体内\n委托函数支持与UFunctions相同的说明符，但使用 UDELEGATE 宏而不是 UFUNCTION\n2.2 绑定委托委托系统理解某些类型的对象，使用此类对象时将启用附加功能\n将委托绑定到UObject或共享指针类的成员， 委托系统可保留对该对象的弱引用，因此对象在委托下方被销毁时，可通过调用 IsBound() 或 ExecuteIfBound() 函数进行处理\n注意各类受支持对象的特殊绑定语法：\n\n\n\n函数\n描述\n\n\n\nBind\n绑定到现有委托对象\n\n\nBindStatic\n绑定原始C++指针全局函数委托\n\n\nBindRaw\n绑定原始C++指针委托由于原始指针不使用任何类型的引用，因此在删除目标对象后调用Execute 或 ExecuteIfBound 会不安全\n\n\nBindLambda\n绑定一个函子这通常用于Lambda函数\n\n\nBindSP\n绑定基于指针的共享成员函数委托共享指针委托会保留对对象的弱引用可使用 ExecuteIfBound() 进行调用\n\n\nBindUObject\n绑定 UObject 的成员函数委托UObject 委托会保留对你的对象 UObject 的弱引用可使用 ExecuteIfBound() 进行调用\n\n\nUnBind\n取消绑定此委托\n\n\n参见 DelegateSignatureImpl.inl（位于 ..\\UE4\\Engine\\Source\\Runtime\\Core\\Public\\Templates\\），了解此类函数的变体、参数和实现\n2.3 载荷数据说明：\n\n绑定到委托时，可同时传递载荷数据\n其为调用时被直接传到绑定函数的任意变量\n此操作是为了使代码更安全，因为有时委托可能含有未初始化且被后续访问的返回值和输出参数\n执行未绑定的委托在某些情况下确实可能导致内存混乱\n\n使用：\n\n可调用 IsBound() 检查是否可安全执行委托\n同时，对于无返回值的委托，可调用 ExecuteIfBound()，但需注意输出参数可能未初始化\n\n注意输出参数可能未初始化：\n\n\n\n执行函数\n描述\n\n\n\nExecute\n不检查其绑定情况即执行一个委托\n\n\nExecuteIfBound\n检查一个委托是否已绑定，如是，则调用Execute\n\n\nIsBound\n检查一个委托是否已绑定，经常出现在包含 Execute 调用的代码前\n\n\n2.4 用法示例\n设类拥有可在任何地方随意调用的方法：\n\nclass FLogWriter\n&#123;\n    void WriteToLog(FString);\n&#125;;\n\n\n\n\n要调用WriteToLog函数，需创建该函数签名的委托类型：\n\nDECLARE_DELEGATE_OneParam(FStringDelegate, FString);\n\n&#x2F;&#x2F; 此将创建名为 FStringDelegate 的委托类型，该类型使用 FString 类型的单个参数\n\n\n\n\n在类中使用此 FStringDelegate 的方法范例：\n\nclass FMyClass\n&#123;\n    FStringDelegate WriteToLogDelegate;\n&#125;;\n\n\n利用此操作，类可保有指向任意类中的方法的指针\n该类唯一真正了解的信息就是，此委托是其的函数签名\n\n\n如要分配委托，现在只需创建委托类的实例，将拥有该方法的类作为模板参数传递\n同时还需传递对象的实例和方法的实际函数地址\n创建 FLogWriter 类的实例， 然后创建该对象实例 WriteToLog 方法的委托：\n\nTSharedRef&lt;FLogWriter&gt; LogWriter(new FLogWriter());\n\nWriteToLogDelegate.BindSP(LogWriter, &amp;FLogWriter::WriteToLog);\n\n\n此操作可将委托动态绑定到类的方法\n\n注意：\n\n绑定到的对象由共享指针拥有，因此 BindSP 的SP部分代表共享指针\n还有不同对象类型的版本，例如BindRaw()和BindUObject()\nFMyClass现在可调用 WriteToLog 方法，甚至无需了解 FLogWriter 类的任何信息\n\n\n要调用委托，只需使用 Execute() 方法：\n\nWriteToLogDelegate.Execute(TEXT(&quot;Delegates are great!&quot;));\n\n\n\n\n如将函数绑定到网络前调用Execute()，将触发断言，多数情况下，建议进行以下操作：\n\nWriteToLogDelegate.ExecuteIfBound(TEXT(&quot;Only executes if a function was bound!&quot;));\n\n\n\n\n\n\n\n3. 动态委托\n可序列化且支持反射的委托\n动态委托可序列化，其函数可按命名查找，但其执行速度比常规委托慢\n\n3.1 声明动态委托介绍：动态委托的声明方式与声明标准委托相同， 只是前者使用动态委托专属的宏变体\n\n\n\n声明宏\n描述\n\n\n\nDECLARE_DYNAMIC_DELEGATE[_RetVal, ...]( DelegateName )\n创建一个动态委托\n\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE[_RetVal, ...]( DelegateName )\n创建一个动态组播委托\n\n\n3.2 动态委托绑定\n\n\n辅助宏\n说明\n\n\n\nBindDynamic( UserObject, FuncName )\n用于在动态委托上调用BindDynamic()的辅助宏，自动生成函数命名字符串\n\n\nAddDynamic( UserObject, FuncName )\n用于在动态组播委托上调用AddDynamic()的辅助宏，自动生成函数命名字符串\n\n\nRemoveDynamic( UserObject, FuncName )\n用于在动态组播委托上调用RemoveDynamic()的辅助宏，自动生成函数命名字符串\n\n\n3.3 执行动态委托使用：通过调用委托的 Execute() 函数执行绑定到委托的函数\n注意：\n\n执行前须检查委托是否已绑定\n此操作是为了使代码更安全，因为有时委托可能含有未初始化且被后续访问的返回值和输出参数\n执行未绑定的委托在某些情况下确实可能导致内存混乱\n可调用 IsBound() 检查是否可安全执行委托\n同时，对于无返回值的委托，可调用 ExecuteIfBound()，但需注意输出参数可能未初始化\n\n\n\n\n执行函数\n描述\n\n\n\nExecute\n不检查其绑定情况即执行一个委托\n\n\nExecuteIfBound\n检查一个委托是否已绑定，如是，则调用Execute\n\n\nIsBound\n检查一个委托是否已绑定，经常出现在包含 Execute 调用的代码前\n\n\n4. 事件\n可绑定到多个函数并同时全部执行的委托\n\n说明：\n\n虽然任意类均可绑定事件，但只有声明事件的类可以调用事件 的 Broadcast、IsBound 和 Clear 函数\n意味着事件对象可在公共接口中公开，而无需让外部类访问这些敏感度函数\n\n事件使用情况有：\n\n在纯抽象类中包含回调、限制外部类调用 Broadcast、IsBound 和 Clear 函数\n\n4.1 声明事件\n事件的声明和 组播委托声明 方式几乎相同，唯一的区别是它们使用事件特有的宏变体\n\n\n\n\n声明宏\n描述\n\n\n\nDECLARE_EVENT( OwningType, EventName )\n创建一个事件\n\n\nDECLARE_EVENT_OneParam( OwningType, EventName, Param1Type )\n创建带一个参数的事件\n\n\nDECLARE_EVENT_TwoParams( OwningType, EventName, Param1Type, Param2Type )\n创建带两个参数的事件\n\n\nDECLARE_EVENT_&lt;Num&gt;Params( OwningType, EventName, Param1Type, Param2Type, ...)\n创建带 N 个参数的事件\n\n\n注意：DECLARE_EVENT 宏的首个参数是”拥有”此事件的类，因此可调用 Broadcast() 函数\n4.2 绑定事件\n事件绑定与 组播委托绑定 方式相同\n\n4.3 事件执行说明：\n\n事件允许附带多个函数委托，然后调用事件的 Broadcast() 函数将它们一次性全部执行\n事件签名不允许使用返回值。对于事件而言，只有定义事件的类才能调用 Broadcast() 函数\n\n使用：\n\n即使不存在绑定，在事件上调用 Broadcast() 也是安全操作\n唯一需要注意的情况是使用事件初始化输出变量，通常不建议执行此操作\n\n注意：\n\n调用 Broadcast() 函数时，被绑定函数的执行顺序尚未定义\n有可能不按照函数的添加顺序执行\n\n\n\n\n函数\n描述\n\n\n\nBroadcast()\n将此事件广播到所有绑定对象，已失效的对象除外\n\n\n4.4 实现范例4.4.1 简单事件public:\n&#x2F;** Broadcasts whenever the layer changes *&#x2F;\nDECLARE_EVENT( FLayerViewModel, FChangedEvent )\nFChangedEvent&amp; OnChanged() &#123; return ChangedEvent; &#125;\n\nprivate:\n&#x2F;** Broadcasts whenever the layer changes *&#x2F;\nFChangedEvent ChangedEvent;\n\n\n\n注意：事件的访问器应该依照 OnXXX 模式，而非常规的 GetXXX 模式\n4.4.2 继承的抽象事件基础类实现\n&#x2F;** Register&#x2F;Unregister a callback for when assets are added to the registry *&#x2F;\nDECLARE_EVENT_OneParam( IAssetRegistry, FAssetAddedEvent, const FAssetData&amp;);\nvirtual FAseetAddedEvent&amp; OnAssetAdded() &#x3D; 0;\n\n\n\n派生类实现\nDECLARE_DERIVED_EVENT( FAssetRegistry, IAssetRegistry::FAssetAddedEvent, FAssetAddedEvent);\nvirtual FassetAddedEvent&amp; OnAssetAdded() override &#123; return AssetAddedEvent; &#125;\n\n\n\n注意：\n\n在派生类中声明一个派生事件时，不要在 DECLARE_DERIVED_EVENT 宏中重复函数签名\n此外，DECLARE_DERIVED_EVENT 宏的最后一个参数是事件的新命名，通常与基础类型相同\n\n4.4.3 继承事件\n派生类不会继承对基础类敏感事件成员的访问\n允许派生类广播其事件的基础类需要公开事件受保护的广播函数\n\n基础类\npublic:\n&#x2F;** Broadcasts whenever the layer changes *&#x2F;\nDECLARE_EVENT( FLayerViewModel, FChangedEvent )\nFChangedEvent&amp; OnChanged() &#123; return ChangedEvent; &#125;\n\nprotected:\nvoid BroadcastChanged()\n&#123;\n    ChangedEvent.Broadcast();\n&#125;\n\nprivate:\n&#x2F;** Broadcasts whenever the layer changes *&#x2F;\nFChangedEvent ChangedEvent;\n\n\n\n\n\n\n\n5. 多播委托说明：\n\n可以绑定到多个函数并一次性同时执行它们的委托\n\n功能：\n\n多播委托拥有大部分与单播委托相同的功能\n它们只拥有对对象的弱引用，可以与结构体一起使用，可以四处轻松复制\n\n注意：\n\n像常规委托一样，多播委托可以远程加载&#x2F;保存和触发；但多播委托函数不能使用返回值\n它们最适合用来 四处轻松传递一组委托\n事件是一种特殊类型的多播委托，它在访问Broadcast()、IsBound()和Clear()函数时会受到限制\n\n5.1 声明多播委托多播委托在声明方式上与声明标准委托相同，只是前者使用特定于多播委托的宏变体。\n\n\n\n声明宏\n说明\n\n\n\nDECLARE_MULTICAST_DELEGATE[_RetVal, ...]( DelegateName )\n创建一个多播委托。\n\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE[_RetVal, ...]( DelegateName )\n创建一个动态多播委托。\n\n\n5.2 绑定多播委托\n多播委托可以绑定多个函数，当委托触发时，将调用所有这些函数\n因此，绑定函数在语义上与数组更加类似\n\n\n\n\n函数\n说明\n\n\n\n“Add()”\n将函数委托添加到该多播委托的调用列表中\n\n\n“AddStatic()”\n添加原始C++指针全局函数委托\n\n\n“AddRaw()”\n添加原始C++指针委托原始指针不使用任何类型的引用，因此如果从委托下面删除了对象，则调用此函数可能不安全调用Execute()时请小心！\n\n\n“AddSP()”\n添加基于共享指针的（快速、非线程安全）成员函数委托共享指针委托保留对对象的弱引用\n\n\n“AddUObject()”\n添加基于UObject的成员函数委托UObject委托保留对对象的弱引用\n\n\n“Remove()”\n从该多播委托的调用列表中删除函数（性能为O(N)）注意，委托的顺序可能不会被保留\n\n\n“RemoveAll()”\n从该多播委托的调用列表中删除绑定到指定UserObject的所有函数注意，委托的顺序可能不会被保留\n\n\n注意：\n\n“RemoveAll()”将删除绑定到所提供指针的所有已注册委托\n未绑定到对象指针的原始委托不会被该函数所删除\n\n参阅”DelegateSignatureImpl.inl”（位于”..\\UE4\\Engine\\Source\\Runtime\\Core\\Public\\Delegates&quot;中）了解这些函数的变体、参数和实现\n5.3 多播执行说明：\n\n多播委托允许您附加多个函数委托，然后通过调用多播委托的”Broadcast()”函数一次性同时执行它们\n多播委托签名不得使用返回值\n\n注意：\n\n在多播委托上调用”Broadcast()”总是安全的，即使是在没有任何绑定时也是如此\n唯一需要注意的是，如果您使用委托来初始化输出变量，通常会带来非常不利的后果\n调用”Broadcast()”时绑定函数的执行顺序尚未定义\n执行顺序可能与函数的添加顺序不相同\n\n\n\n\n函数\n说明\n\n\n\n“Broadcast()”\n将该委托广播给所有绑定的对象，但可能已过期的对象除外\n\n\n6. 委托示例6.1 单播委托定义单播委托\n\n新建一个测试类MyActor\n\nMyActor.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;Actor.h&quot;\n#include &quot;MyActor.generated.h&quot;\n\n&#x2F;*\n * 定义单播委托\n *&#x2F;\n&#x2F;&#x2F; 无返回值，无参数\nDECLARE_DELEGATE(FTestDelegateNoParam);\n\n&#x2F;&#x2F; 无返回值，一个参数\nDECLARE_DELEGATE_OneParam(FTestDelegateOneParam, float);\n\n&#x2F;&#x2F; 无返回值，多个参数（两个参数为例）\nDECLARE_DELEGATE_TwoParams(FTestDelegateTwoParams, float, const FString&amp;);\n\n&#x2F;&#x2F; 有返回值，多个参数（两个参数为例）\nDECLARE_DELEGATE_RetVal_TwoParams(int32, FTestDelegateRetValTwoParams, float, const FString&amp;);\n\nUCLASS()\nclass A_03_DELEGATE_API AMyActor : public AActor\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n&#x2F;*\n * 声明委托，定义函数，绑定委托\n *&#x2F;\nprotected:\n\t&#x2F;&#x2F; 声明委托\n\tFTestDelegateRetValTwoParams DelegateRetValTwoParams;\n\t\npublic:\n\t&#x2F;&#x2F; 测试单播委托，有返回值，两个参数\n\tUFUNCTION()\n\tint32 Func(float a, const FString&amp; s);\n\n    &#x2F;&#x2F; 测试单播委托，绑定静态函数\n\tUFUNCTION()\n\tstatic int32 Func_Static(float a, const FString &amp;s);\n&#125;;\n\nMyActor.cpp\n#include &quot;MyActor.h&quot;\n\nclass FTest\n&#123;\npublic:\n\tint32 Func(float a, const FString &amp;s)\n\t&#123;\n\t\treturn 1;\n\t&#125;\n&#125;;\n\nAMyActor::AMyActor()&#123;&#125;\n\nvoid AMyActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\t&#x2F;&#x2F; 委托-通过对象-绑定函数\n\tDelegateRetValTwoParams.BindUObject(this, &amp;AMyActor::Func);\n\t\n\t&#x2F;&#x2F; 委托-直接绑定Lambda函数\n\tDelegateRetValTwoParams.BindLambda([this](float a, const FString &amp;s)-&gt;int32\n\t&#123;\n\t\treturn 1;\n\t&#125;);\n\n\t&#x2F;&#x2F; 委托-通过原生Cpp类-绑定函数\n\tFTest TestA;\n\tDelegateRetValTwoParams.BindRaw(&amp;TestA, &amp;FTest::Func);\n\n\t&#x2F;&#x2F; 委托-通过共享指针-绑定函数\n\tconst TSharedPtr&lt;FTest&gt; TestB &#x3D; MakeShareable(new FTest);\n\tDelegateRetValTwoParams.BindSP(TestB.ToSharedRef(), &amp;FTest::Func);\n\n\t&#x2F;&#x2F; 委托-绑定静态函数\n\tDelegateRetValTwoParams.BindStatic(&amp;Func_Static);\n\n\t&#x2F;&#x2F; 委托-通过线程安全共享指针-绑定函数\n\tconst TSharedPtr&lt;FTest, ESPMode::ThreadSafe&gt; TestC &#x3D; MakeShareable(new FTest);\n\tDelegateRetValTwoParams.BindThreadSafeSP(TestC.ToSharedRef(), &amp;FTest::Func);\n\n\t&#x2F;&#x2F; 委托-通过函数名称的反射-绑定UFUNCTION()修饰的函数\n\tDelegateRetValTwoParams.BindUFunction(this, &quot;Func&quot;);\n\n\t&#x2F;&#x2F; 顺手通过委托调用绑定的函数\n\tif (DelegateRetValTwoParams.IsBound())\n\t&#123;\n\t\t&#x2F;&#x2F; ExecuteIfBound 是无参委托的调用方法\n\t\tint a &#x3D; DelegateRetValTwoParams.Execute(24.f, &quot;FTestDelegateRetValTwoParams&quot;);\n\t&#125;\n&#125;\n\n&#x2F;* My Code *&#x2F;\nint32 AMyActor::Func(float a, const FString &amp;s)\n&#123;\n\treturn 1;\n&#125;\n\nint32 AMyActor::Func_Static(float a, const FString&amp; s)\n&#123;\n\treturn 1;\n&#125;\n\n6.2 多播委托定义多播委托\n\nMyActor.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;Actor.h&quot;\n#include &quot;MyActor.generated.h&quot;\n\n&#x2F;*\n * 定义多播委托，绑定多个形式相同的函数，同时执行（顺序随机）\n * 无返回值类型\n *&#x2F;\n&#x2F;&#x2F; 无返回值，无参数\nDECLARE_MULTICAST_DELEGATE(FTestMulDelegateNoParam);\n\n&#x2F;&#x2F; 无返回值，一个或多个参数（两个参数为例）\nDECLARE_MULTICAST_DELEGATE_TwoParams(FTestMulDelegateTwoParams, float, const FString &amp;);\n\nUCLASS()\nclass A_03_DELEGATE_API AMyActor : public AActor\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n&#x2F;*\n * 声明委托，定义函数，绑定委托\n *&#x2F;\nprotected:\n\t&#x2F;&#x2F; 声明委托\n\tFTestMulDelegateTwoParams MulDelegateTwoParams;\n\t\npublic:\n\t&#x2F;&#x2F; 测试多播委托，无返回值，两个参数\n\tUFUNCTION()\n\tvoid Func_Mul(float a, const FString &amp;s);\n&#125;;\n\nMyActor.cpp\n#include &quot;MyActor.h&quot;\n\nAMyActor::AMyActor()&#123;&#125;\n\nvoid AMyActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\t&#x2F;*\n\t * 多播委托\n\t *&#x2F;\n    &#x2F;&#x2F; 多播委托-通过对象-绑定函数\n\tMulDelegateTwoParams.AddUObject(this, &amp;AMyActor::Func_Mul);\n    \n    &#x2F;&#x2F; 调用函数\n\tMulDelegateTwoParams.Broadcast(24.f, &quot;FTestMulDelegateTwoParams&quot;);\n&#125;\n\n&#x2F;* My Code *&#x2F;\nvoid AMyActor::Func_Mul(float a, const FString&amp; s)\n&#123;\n&#125;\n\n6.3 动态委托6.3.1 动态单播委托定义动态单播委托\n\nMyActor.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;Actor.h&quot;\n#include &quot;MyActor.generated.h&quot;\n\n&#x2F;*\n * 定义动态单播委托\n * 可以用于蓝图中\n * 所以定义时，参数列表中的参数类型后要跟上参数名\n *&#x2F;\n&#x2F;&#x2F; 无返回值，无参数\nDECLARE_DYNAMIC_DELEGATE(FTestDynamicDelegateNoParam);\n\n&#x2F;&#x2F; 无返回值，有参数（一个参数为例）\nDECLARE_DYNAMIC_DELEGATE_OneParam(FTestDynamicDelegateOneParam, int32, a);\n\n&#x2F;&#x2F; 有返回值，有参数（一个参数为例）\nDECLARE_DYNAMIC_DELEGATE_RetVal_OneParam(int32, FTestDynamicDelegateRetValOneParam, int32, a);\n\nUCLASS()\nclass A_03_DELEGATE_API AMyActor : public AActor\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n&#x2F;*\n * 声明委托，定义函数，绑定委托\n *&#x2F;\nprotected:\n\t&#x2F;&#x2F; 声明委托\n\tFTestDynamicDelegateRetValOneParam DynamicDelegateRetValOneParam;\n    \npublic:\n\t&#x2F;&#x2F; 测试动态单播委托，蓝图中使用\n\tUFUNCTION(BlueprintCallable)\n\tvoid Func_Dynamic(FTestDynamicDelegateRetValOneParam DynamicDelegateRetValOneParam);\n\n\t&#x2F;&#x2F; 测试动态单播委托，cpp使用\n\tUFUNCTION()\n\tint32 Func_DynamicCpp(int32 a);\n&#125;;\n\nMyActor.cpp\n#include &quot;MyActor.h&quot;\n\nAMyActor::AMyActor()&#123;&#125;\n\nvoid AMyActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\t&#x2F;*\n\t * 动态单播委托\n\t *&#x2F;\n\tDynamicDelegateRetValOneParam.BindDynamic(this, &amp;AMyActor::Func_DynamicCpp);\n\tint32 b &#x3D; DynamicDelegateRetValOneParam.Execute(24);\n&#125;\n\n&#x2F;* My Code *&#x2F;\nvoid AMyActor::Func_Dynamic(FTestDynamicDelegateRetValOneParam DynamicDelegateRetValOneParam)\n&#123;\n&#125;\n\nint32 AMyActor::Func_DynamicCpp(int32 a)\n&#123;\n\treturn 1;\n&#125;\n\n6.3.2 动态多播委托定义动态多播委托\n\nMyActor.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;Actor.h&quot;\n#include &quot;MyActor.generated.h&quot;\n\n&#x2F;*\n * 动态多播委托\n * 可以用于蓝图中\n * 等同于蓝图中的事件调度器\n * 多播委托没有返回值\n *&#x2F;\n&#x2F;&#x2F; 无返回值，无参数\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FTestDynamicMulDelegate);\n\n&#x2F;&#x2F; 无返回值，有参数（一个参数为例）\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FTestDynamicMulDelegateOnParam, int32, a);\n\nUCLASS()\nclass A_03_DELEGATE_API AMyActor : public AActor\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n&#x2F;*\n * 声明委托，定义函数，绑定委托\n *&#x2F;\nprotected:\n\t&#x2F;&#x2F; 声明委托\n\tUPROPERTY(BlueprintAssignable)\n\tFTestDynamicMulDelegate DynamicMulDelegate;\n\n\tFTestDynamicMulDelegateOnParam DynamicMulDelegateOnParam;\n\t\npublic:\n\t&#x2F;&#x2F; 测试动态多播委托，cpp使用\n\tUFUNCTION()\n\tvoid Func_DynamicMulCpp();\n\n\t&#x2F;&#x2F; 测试动态多播委托，有参数，cpp使用\n\tUFUNCTION()\n\tvoid Func_DynamicMul_One(int32 a);\n&#125;;\n\nMyActor.cpp\n#include &quot;MyActor.h&quot;\n\nAMyActor::AMyActor()&#123;&#125;\n\nvoid AMyActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\t&#x2F;*\n\t * 动态多播委托\n\t *&#x2F;\n\t&#x2F;&#x2F; 无参数\n\tDynamicMulDelegate.AddDynamic(this, &amp;AMyActor::Func_DynamicMulCpp);\n\tDynamicMulDelegate.Broadcast();\n\n\t&#x2F;&#x2F; 有参数\n\tDynamicMulDelegateOnParam.AddDynamic(this, &amp;AMyActor::Func_DynamicMul_One);\n\tDynamicMulDelegateOnParam.Broadcast(24);\n&#125;\n\n&#x2F;* My Code *&#x2F;\nvoid AMyActor::Func_DynamicMulCpp()\n&#123;\n&#125;\n\nvoid AMyActor::Func_DynamicMul_One(int32 a)\n&#123;\n&#125;\n\n7. 原生Cpp委托Delegate.cpp单播\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\n&#x2F;&#x2F; 函数指针的两种定义方式\ntypedef int (*FuncMethod)(int, int);\n&#x2F;&#x2F; using FuncMethod &#x3D; int(*)(int, int);\n\nclass TestA\n&#123;\npublic:\n    int TestAddNum(int a, int b)\n    &#123;\n        const int c &#x3D; a + b;\n        std::cout &lt;&lt; c &lt;&lt; std::endl;\n        return c;\n    &#125;\n&#125;;\ntypedef int (TestA::*TestFuncMethod)(int , int);\n\n&#x2F;&#x2F;using TestFuncMethod &#x3D; int(TestA::*)(int, int);\n\n\n&#x2F;&#x2F; 单播代理\nclass FDelegateTwoParams\n&#123;\nprivate:\n    std::function&lt;int()&gt; Func;\n\npublic:\n    void BindGlobalFunc(FuncMethod FuncPtr, int a, int b)\n    &#123;\n        Func &#x3D; std::bind(FuncPtr, a, b);\n    &#125;\n\n    void BindRaw(TestA *UserClass, TestFuncMethod FuncPtr, int a, int b)\n    &#123;\n        Func &#x3D; std::bind(FuncPtr, UserClass, a, b);\n    &#125;\n\n    bool IsBound() const\n    &#123;\n        return Func ? true : false;\n    &#125;\n\n    void Execute()\n    &#123;\n        Func();\n    &#125;\n\n    bool ExecuteIfBound()\n    &#123;\n        if (IsBound())\n        &#123;\n            Execute();\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\nint AddNum(int a, int b)\n&#123;\n    const int c &#x3D; a + b;\n    std::cout &lt;&lt; c &lt;&lt; std::endl;\n    return c;\n&#125;\n\nvoid DelegateDemo()\n&#123;\n    FDelegateTwoParams Delegate;\n    Delegate.BindGlobalFunc(&amp;AddNum, 10, 20);\n    Delegate.Execute();\n&#125;\n\nvoid DelegateDemo2()\n&#123;\n    TestA *testA &#x3D; new TestA;\n    FDelegateTwoParams Delegate;\n    Delegate.BindRaw(testA, &amp;TestA::TestAddNum, 20, 30);\n    Delegate.Execute();\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; &#x2F;&#x2F; 函数指针调用函数\n    &#x2F;&#x2F; FuncMethod FuncPtr &#x3D; &amp;AddNum;\n    &#x2F;&#x2F; FuncPtr(1, 2);\n\n    &#x2F;&#x2F; &#x2F;&#x2F; 全局绑定调用函数\n    &#x2F;&#x2F; std::function&lt;int()&gt; FuncPtr2 &#x3D; std::bind(&amp;AddNum, 2, 3);\n    &#x2F;&#x2F; FuncPtr2();\n\n    DelegateDemo();\n    DelegateDemo2();\n\n    return 0;\n&#125;\n\n\n\n\n\nDelegateMul.cpp多播\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n\n&#x2F;&#x2F; 函数指针的两种定义方式\ntypedef int (*FuncMethod)(int, int);\n\nclass TestA\n&#123;\npublic:\n    int TestAddNum(int a, int b)\n    &#123;\n        const int c &#x3D; a + b;\n        std::cout &lt;&lt; c &lt;&lt; std::endl;\n        return c;\n    &#125;\n&#125;;\ntypedef int (TestA::*TestFuncMethod)(int , int);\n\n\n&#x2F;&#x2F; 多播代理\nclass FDelegateTwoParams\n&#123;\npublic:\n    void BindGlobalFunc(FuncMethod FuncPtr, int a, int b)\n    &#123;\n        FuncArray.push_back(std::bind(FuncPtr, a, b));\n    &#125;\n\n    void BindRaw(TestA *UserClass, TestFuncMethod FuncPtr, int a, int b)\n    &#123;\n        FuncArray.push_back(std::bind(FuncPtr, UserClass, a, b));\n    &#125;\n\n    void BroadCast()\n    &#123;\n        for (std::vector&lt;std::function&lt;int()&gt;&gt;::iterator itr &#x3D; FuncArray.begin();\n              itr !&#x3D; FuncArray.end(); ++itr)\n        &#123;\n            (*itr)();\n        &#125;\n        \n    &#125;\n\nprivate:\n    std::vector&lt;std::function&lt;int()&gt;&gt; FuncArray;\n&#125;;\n\nint AddNum(int a, int b)\n&#123;\n    const int c &#x3D; a + b;\n    std::cout &lt;&lt; c &lt;&lt; std::endl;\n    return c;\n&#125;\n\nvoid DelegateDemo()\n&#123;\n    TestA *testA &#x3D; new TestA;\n    FDelegateTwoParams Delegate;\n    Delegate.BindRaw(testA, &amp;TestA::TestAddNum, 10, 20);\n    Delegate.BindRaw(testA, &amp;TestA::TestAddNum, 20, 30);\n    Delegate.BroadCast();\n&#125;\n\nint main()\n&#123;\n    DelegateDemo();\n\n    return 0;\n&#125;\n\n\n\n\n\nDelegateMarco.cpp\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nclass TestA\n&#123;\npublic:\n    void FuncNoParam()\n    &#123;\n        std::cout &lt;&lt; &quot;FuncNoParamDelegate&quot; &lt;&lt; std::endl;\n    &#125;\n    \n    void FuncTwoParam(int a, int b)\n    &#123;\n        const int c &#x3D; a + b;\n        std::cout &lt;&lt; &quot;FuncTwoParam : &quot; &lt;&lt; c &lt;&lt; std::endl;\n    &#125;\n&#125;;\n&#x2F;&#x2F; 定义类 作用域下的函数指针\ntypedef void (TestA::*FuncMethodNoParam)(void);\ntypedef void (TestA::*FuncMethodTwoParam)(int, int);\n\n&#x2F;&#x2F; 宏定义 代理\n&#x2F;&#x2F; 无参数，无返回值\n#define DECLARE_DELEGATE(DelegateName)\\\nclass My##DelegateName\\\n&#123;\\\npublic:\\\n    void BindRaw(TestA *UserClass, FuncMethodNoParam FuncPtr)\\\n    &#123;\\\n        Func &#x3D; std::bind(FuncPtr, UserClass);\\\n    &#125;\\\n    bool IsBound() const\\\n    &#123;\\\n        return Func ? true : false;\\\n    &#125;\\\n    void Execute()\\\n    &#123;\\\n        Func();\\\n    &#125;\\\n    bool ExecuteIfBound()\\\n    &#123;\\\n        if (IsBound())\\\n        &#123;\\\n            Execute();\\\n            return true;\\\n        &#125;\\\n        return false;\\\n    &#125;\\\nprivate:\\\n    std::function&lt;void()&gt; Func;\\\n&#125;;\n\n&#x2F;&#x2F; 有参数，无返回值\n#define DECLARE_DELEGATE_TWO_PARAM(DelegateName, TypeParam1, TypeParam2)\\\nclass My##DelegateName\\\n&#123;\\\npublic:\\\n    void BindRaw(TestA *UserClass, FuncMethodTwoParam FuncPtr, TypeParam1 p1, TypeParam2 p2)\\\n    &#123;\\\n        Func &#x3D; std::bind(FuncPtr, UserClass, p1, p2);\\\n    &#125;\\\n    bool IsBound() const\\\n    &#123;\\\n        return Func ? true : false;\\\n    &#125;\\\n    void Execute()\\\n    &#123;\\\n        Func();\\\n    &#125;\\\n    bool ExecuteIfBound()\\\n    &#123;\\\n        if (IsBound())\\\n        &#123;\\\n            Execute();\\\n            return true;\\\n        &#125;\\\n        return false;\\\n    &#125;\\\nprivate:\\\n    std::function&lt;void()&gt; Func;\\\n&#125;;\n\n&#x2F;&#x2F; 创建自定义宏代理\nDECLARE_DELEGATE(TestDelegateNoParam);\nDECLARE_DELEGATE_TWO_PARAM(TestDelegateTwoParam, int, int);\n\nvoid DelegateDemo()\n&#123;\n    TestA testA;\n    MyTestDelegateNoParam Delegate;\n    Delegate.BindRaw(&amp;testA, &amp;TestA::FuncNoParam);\n    Delegate.Execute();\n&#125;\n\nvoid DelegateDemo2()\n&#123;\n    TestA testB;\n    MyTestDelegateTwoParam Delegate;\n    Delegate.BindRaw(&amp;testB, &amp;TestA::FuncTwoParam, 10, 20);\n    Delegate.Execute();\n&#125;\n\nint main()\n&#123;\n    DelegateDemo();\n    DelegateDemo2();\n    return 0;\n&#125;\n\n\n\n\n\nDelegateTemplate.cpp\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\ntemplate&lt;typename Class, typename FuncType&gt;\nstruct TMemFuncPtrType;\n\ntemplate&lt;typename Class, typename RetType, typename... ArgTypes&gt;\nstruct TMemFuncPtrType&lt;Class, RetType(ArgTypes...)&gt;\n&#123;\n    typedef RetType(Class::*Type)(ArgTypes...);\n&#125;;\n\n\n&#x2F;&#x2F; 定义一个模板代理\ntemplate &lt;typename RetValType, typename... ParamTypes&gt;\nclass TBaseDelegate\n&#123;\nprivate:\n    std::function&lt;RetValType()&gt; Func;\n\npublic:\n    template&lt;typename UserClass&gt;\n    void BindRaw(UserClass *MyUserClass, \n            typename TMemFuncPtrType&lt;UserClass, RetValType(ParamTypes...)&gt;::Type FuncPtr, \n            ParamTypes... Vars)\n    &#123;\n        Func &#x3D; std::bind(FuncPtr, MyUserClass, Vars...);\n    &#125;\n\n    bool IsBound() const\n    &#123;\n        return Func ? true : false;\n    &#125;\n\n    void Execute()\n    &#123;\n        Func();\n    &#125;\n\n    bool ExecuteIfBound()\n    &#123;\n        if (IsBound())\n        &#123;\n            Execute();\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n#define DECLARE_DELEGATE(DelegateName) class DelegateName : public TBaseDelegate&lt;void&gt;&#123;&#125;;\n#define DECLARE_DELEGATE_TWO_PARAMS(DelegateName, ParamType1, ParamType2) class DelegateName : public TBaseDelegate&lt;void, ParamType1, ParamType2&gt;&#123;&#125;;\n#define DECLARE_DELEGATE_RETVAL_TWO_PARAMS(RetType, DelegateName, ParamType1, ParamType2) class DelegateName : public TBaseDelegate&lt;RetType, ParamType1, ParamType2&gt;&#123;&#125;;\n\n\nDECLARE_DELEGATE(TestDelegate);\nDECLARE_DELEGATE_TWO_PARAMS(TestDelegateTwoParams, int, int);\nDECLARE_DELEGATE_RETVAL_TWO_PARAMS(int, TestDelegateRetValTwoParams, int, int);\n\nclass TestA\n&#123;\npublic:\n    void Print()\n    &#123;\n        std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;\n    &#125;\n\n    void Print2(int a, int b)\n    &#123;\n        const int c &#x3D; a + b;\n        std::cout &lt;&lt; c &lt;&lt; std::endl;\n    &#125;\n\n    int Print3(int a, int b)\n    &#123;\n        const int c &#x3D; a + b;\n        std::cout &lt;&lt; c &lt;&lt; std::endl;\n        return c;\n    &#125;\n&#125;;\n \nvoid DelegateDemo()\n&#123;\n    TestDelegate TD;\n    TestA testA;\n    TD.BindRaw(&amp;testA, &amp;TestA::Print);\n    TD.Execute();\n&#125;\n\nvoid DelegateDemo2()\n&#123;\n    TestDelegateTwoParams TDTwoParams;\n    TestA testB;\n    TDTwoParams.BindRaw(&amp;testB, &amp;TestA::Print2, 10, 20);\n    TDTwoParams.Execute();\n&#125;\n\nvoid DelegateDemo3()\n&#123;\n    TestDelegateRetValTwoParams TDRTwoParams;\n    TestA testC;\n    TDRTwoParams.BindRaw(&amp;testC, &amp;TestA::Print3, 99, 100);\n    TDRTwoParams.Execute();\n&#125;\n\nint main()\n&#123;\n    DelegateDemo();\n    DelegateDemo2();\n    DelegateDemo3();\n    return 0;\n&#125;\n\n","slug":"7_UE4委托_06","date":"2022-10-06T07:28:25.965Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"d2dc88f9aa1b74a2f377fe04af877f8c","title":"UE4 联网和多人游戏","content":"UE4 联网和多人游戏复制Replication：在客户端服务器间同步数据和调用程序的过程\n1. 网络概述1.1 尽早规划多人游戏\n若项目可能需要多人游戏功能，则从项目开始阶段起，构建所有gameplay时都应将多人游戏功能考虑在内，便于进行调试和维护，且支持单人\n若是单人游戏改为多人，重构无网络情况下编译的基本代码需要梳理整个项目，几乎所有gameplay都需要重新编写\n\n1.2 客户端-服务器模型\n单人游戏或本地多人游戏：\n\n游戏在 独立游戏上本地运行。玩家将输入连接到一台计算机，直接控制其上所有内容，而包括Actor、场景和各玩家的用户界面在内的所有游戏项目均存在于这台本地机器上\n\n\n网络多人游戏：\n\n虚幻引擎使用 客户端-服务器模型\n\n网络中的一台计算机作为 服务器 主持多人游戏会话，而所有其他玩家的计算机作为 客户端 连接到该服务器。然后，服务器与连接的客户端分享游戏状态信息，并提供一种客户端之间通信的方法\n客户端和服务端：\n\n在网络多人游戏中，游戏将在服务器（1）与多个与之连接的客户端（2）之间进行。服务器处理gameplay，客户端向用户显示游戏\n服务器是多人游戏实际发生的地方\n客户端会远程控制其在服务器上各自拥有的 Pawn， 发送过程调用以使其执行游戏操作\n服务器不会将视觉效果直接流送至客户端显示器。服务器会将游戏状态信息 复制 到各客户端，告知应存在的Actor、此类Actor的行为，以及不同变量应拥有的值\n客户端使用此信息，对服务器上正在发生的情况进行高度模拟\n\n\n\n\n\n1.2.1 客户端-服务器游戏范例\n分别以本地游戏和多人游戏为范例，说明GamePlay的处理逻辑\n本地游戏：玩家1\n多人游戏：玩家2\n\n\n\n\n本地游戏\n网络游戏\n\n\n\n\n\n\n\n玩家1按下输入以发射武器玩家1的Pawn将发射其当前武器以响应此操作。玩家1的武器生成发射物，并播放附带音效和视觉效果。\n玩家1在本地机器上按下输入以发射武器玩家1的本地Pawn将武器发射命令传送给服务器上对应的Pawn。玩家1在服务器上的武器生成发射物。服务器告知所有连接的客户端各自生成玩家1发射物的副本。玩家1在服务器上的武器告知所有客户端播放武器发射音效和视觉效果。\n\n\n玩家1的发射物从武器中射出并前移\n玩家1的发射物从在服务器上的武器中射出并前移此时，服务器告知所有客户端复制玩家1发射物发生的移动，因此各客户端上的玩家1发射物便相应移动。\n\n\n玩家1的发射物撞击玩家2的Pawn碰撞将触发摧毁玩家1发射物的函数，对玩家2的Pawn造成伤害，并播放附带音效和视觉效果。玩家2播放画面效果，作为对伤害的响应。\n玩家1在服务器上的发射物撞击玩家2的Pawn碰撞触发摧毁服务器上玩家1发射物的函数。服务器自动告知所有客户端各自摧毁玩家1发射物副本。碰撞触发告知所有客户端播放附带碰撞音效和视觉效果的函数。玩家2在服务器上的Pawn承受发射物碰撞造成的伤害。玩家2在服务器上的Pawn告知玩家2客户端播放画面效果，作为对伤害的响应。\n\n\n\n网络游戏中：\n此类交互发生在多个不同场景，这一过程将在基础游戏交互（碰撞、移动、伤害）、美化效果（视觉效果和音效）和私人玩家信息（HUD更新）间进行划分。这三者各自与网络中的特定机器或机组关联\n此信息的复制过程并非完全自动，游戏编程时须指定要复制的信息和接收副本的机器\n主要的难点在于选择应复制的信息及方式，以向所有玩家提供一致的游戏体验，同时需最小化信息复制量，尽可能减少网络带宽占用率\n\n\n\n1.3 基本网络概念1.3.1 网络模式和服务器类型\n网络模式：\n描述了计算机与网络多人游戏会话的关系\n游戏实例可采用以下任意网络模式\n\n\n\n\n\n\n网络模式\n说明\n\n\n\n独立\n游戏作为服务器运行，不接受远程客户端连接参与游戏的玩家必须为本地玩家此模式用于单人游戏和本地多人游戏其将运行本地玩家适用的服务器逻辑和客户端逻辑\n\n\n客户端\n游戏作为网络多人游戏会话中与服务器连接的客户端运行其不会运行服务器逻辑\n\n\n聆听服务器\n游戏作为主持网络多人游戏会话的服务器运行其接受远程客户端中的连接，且直接在服务器上拥有本地玩家此模式通常用于临时合作和竞技多人游戏\n\n\n专属服务器\n游戏作为主持网络多人游戏会话的服务器运行其接受远程客户端中的连接，但无本地玩家，因此为了高效运行，其将废弃图形、音效、输入和其他面向玩家的功能此模式常用于需要更固定、安全和大型多人功能的游戏\n\n\n\n独立游戏服务器可同时作为服务器和客户端，为多人游戏创建的逻辑可在无需额外工作的情况下，在单人游戏中运行\n\n1.3.2 Actor复制\n描述：\n复制是指在网络会话中的不同机器间复制游戏状态信息\n若正确设置复制，将可同步不同机器的游戏实例\n在C++ Actor类中设置 bReplicates 变量，或将Actor蓝图的 复制（Replicates）设置设为 true，可启用给定类的Actor复制\n\n\n\n1.3.2.1 常见复制功能\n\n\n复制功能\n说明\n\n\n\n创建和销毁\n服务器上生成复制Actor的授权版本时，其会在所有连接客户端上自动生成远程代理。其之后会将信息复制到这些远程代理。若销毁授权Actor，则将自动销毁所有连接客户端上的远程代理。\n\n\n移动复制\n若授权Actor启用了 复制移动，或将C++中的 bReplicateMovement 设为 true，其将自动复制位置、旋转和速度。\n\n\n变量复制\n在指定为复制变量的值变更时，其将自动从授权Actor复制到其远程代理。\n\n\n组件复制\nActor组件复制为其所属Actor的一部分。组件内指定为复制变量将复制，而组件内调用的RPC将与Actor类中调用的RPC保持一致。\n\n\n远程过程调用（RPC）\nRPC是传输到网络游戏中特定机器的特殊函数。无论初始调用RPC的是哪台机器，其的实现仅在目标机器上运行。此类RPC可指定为服务器（仅在服务器上运行）、客户端（仅在Actor的拥有客户端上运行）或NetMulticast（在连接会话的所有机器上运行，包括服务器）。\n\n\n\n虽然创建、销毁和移动等常见使用可自动处理，但即使启用复制，其他所有gameplay功能也不会默认自动复制\n必须根据游戏的需求明确指定要复制的变量和函数\n\nActor、Pawn和角色的部分常用功能不会复制：\n\n骨架网格体 和 静态网格体 组件\n材质\n动画蓝图\n粒子系统\n音效发射器\n物理对象\n\n1.3.2.2 网络角色和授权\n描述：\nActor的 网络角色 将决定网络游戏期间控制Actor的机器\n授权 Actor被认为可控制Actor的状态，并可将信息复制到网络多人游戏会话中的其他机器上\n远程代理 是该Actor在远程机器上的副本，其将接收授权Actor中的复制信息，由 Local Role 和 Remote Role 变量进行追踪\n\n\n\n\n\n\n网络角色\n说明\n\n\n\n无\nActor在网络游戏中无角色，不会复制。\n\n\n授权\nActor为授权状态，会将其信息复制到其他机器上的远程代理。\n\n\n模拟代理\nActor为远程代理，由另一台机器上的授权Actor完全控制。网络游戏中如拾取物、发射物或交互对象等多数Actor将在远程客户端上显示为模拟代理。\n\n\n自主代理\nActor为远程代理，能够本地执行部分功能，但会接收授权Actor中的矫正。自主代理通常为玩家直接控制的actor所保留，如pawn。\n\n\n\n虚幻引擎使用的默认模型是 服务器授权，意味着服务器对游戏状态固定具有权限，而信息固定从服务器复制到客户端\n服务器上的Actor应具有授权的本地角色，而其在远程客户端上的对应Actor应具有模拟或自主代理的本地角色\n\n1.3.2.3 客户端拥有权\n特定客户端机器上的 PlayerController 拥有网络游戏中的pawn\nPawn调用纯客户端函数时，其将无视调用函数的机器，而仅指向拥有玩家的机器\n将Actor的 Owner 变量设为特定Pawn，则通关关联，该Actor属于该Pawn的拥有客户端，并将纯客户端函数指向其拥有者的机器\nC++中的 IsLocallyControlled 函数，或蓝图中的 Is Locally Controlled 节点，以决定Pawn是否在其拥有客户端上\n由于构造期间Pawn可能未指定控制器，因此避免在自定义Pawn类的构造函数中使用 IsLocallyControlled\n\n1.3.2.4 相关性和优先级\n相关性：用于决定是否需要在多人游戏期间复制Actor\n\n复制期间将剔除被认为不相关的actor，此操作可节约带宽，以便相关Actor可更加高效地复制\n若Actor未被玩家拥有，且不在玩家附近，将其被视为不相关，而不会进行复制\n不相关Actor会存在于服务器上，且会影响授权游戏状态，但在玩家靠近前不会向客户端发送信息\n覆盖 IsNetRelevantFor 函数以手动控制相关性，并可使用 NetCullDistanceSquared 属性决定成为相关Actor所需距离\n\n\n优先级：有时在游戏单帧内，没有足够带宽供复制所有相关Actor，因此，Actor拥有 优先级(Priority) 值，用于决定优先复制的Actor\n\nPawn和PlayerController的 NetPriority 默认为 3.0，从而使其成为游戏中最高优先级的Actor，基础Actor的 NetPriority 为 1.0\nActor在被复制前经历的时间越久，每次成功通过时所处的优先级便越高\n\n\n\n1.3.3 变量复制\n描述：授权Actor上复制变量的值变更时，其信息将自动从授权Actor发送到连接会话的远程代理\n\nC++中使用对应 UPROPERTY 宏内的 Replicated 或 ReplicateUsing 说明符\n\n蓝图的细节面板中将它们指定为已复制，可将复制添加到变量和对象引用\n\n\n\n\n1.3.3.1 RepNotify\n描述：可指定在Actor成功接收特定变量的复制信息时要调用的 RepNotify 函数\n\nRepNotify仅在变量更新时本地触发\n触发gameplay逻辑响应授权Actor上的变量更改时，使用RepNotify可减少开销\n在C++中使用变量的 UPROPERTY 宏的 ReplicatedUsing 说明符可访问此功能\n蓝图中变量的复制设置以使用RepNotify\n\n\n补充：由于RepNotify可添加到需复制的变量中，而无需考虑其他gameplay功能，创建额外网络调用时刻节约大量带宽，因此RepNotify比RPC或复制函数更加好用\n\n\n1.3.4 远程过程调用(RPC)\n描述：远程过程调用也称为复制函数\n可在任何机器上进行调用，但会指示其的实现在与网络会话连接的特定机器上发生\n有三种类型的RPC\n\n\n\n\n\n\nRPC类型\n说明\n\n\n\nServer\n仅在主持游戏的服务器上调用。\n\n\nClient\n仅在拥有该函数所属Actor的客户端上调用。若Actor无拥有连接，将不会执行此逻辑。\n\n\nNetMulticast\n在与服务器连接的所有客户端及服务器本身上调用。\n\n\n蓝图：\n\nCustomEvent 的 Replicates 选项设置为其中一个\nRun On Server\nRun On Owning Client\nNet MultiCast\n\n\n要勾选Reliable\n\nC++：\n\n将一个自定义的函数声明为RPC，需要添加反射UFUNCTION()\n\nServer\nClient\nNetMultiCast\n\n\n额外添加Reliable\n\n其代码将在代码实现中使用后缀 _Implementation\n\nExampleClass.h\n&#x2F;&#x2F;服务器RPC MyFunction的声明。\nUFUNCTION(Server, Reliable, WithValidation)\nvoid MyFunction(int myInt);\n\nExampleClass.cpp\n&#x2F;&#x2F;服务器RPC MyFunction的实现。\nvoid AExampleClass::MyFunction_Implementation(int myInt)\n&#123;\n    &#x2F;&#x2F;游戏代码在此。\n&#125;\n\n1.3.4.1 可靠性\n描述：必须将RPC指定为 可靠 或 不可靠\n\n不可靠：\n\n不可靠RPC无法保证必会到达预定目的地，但其发送速度和频率高于可靠的RPC\n最适用于对gameplay而言不重要或经常调用的函数\n例如，由于Actor移动每帧都可能变换，因此使用不可靠RPC复制该Actor移动\n\n\n可靠：\n\n可靠的RPC保证到达预定目的地，并在成功接收之前一直保留在队列中\n最适合用于对gameplay很关键或者不经常调用的函数\n相关例子包括碰撞事件、武器发射的开始或结束，或生成Actor\n\n\n\n\n注意：\n\n滥用可靠函数可能导致其队列溢出，此操作将强制断开连接\n若逐帧调用复制函数，应将其设为不可靠\n若拥有与玩家输入绑定的可靠函数，应限制玩家调用该函数的频率\n\n\n\n1.3.4.2 验证\n描述：WithValidation 说明符表明除函数的实现外，还有可验证传入函数调用的数据的函数\n\n此验证函数与其负责的函数使用同一签名，但其将返回布尔而非原本返回值\n若返回 true，则其允许执行RPC的 Implementation；若返回 false，则防止执行\n\n\nExampleClass.cpp\n&#x2F;&#x2F;服务器RPC MyFunction的验证\nbool AExampleClass::MyFunction_Validation(int myInt)\n&#123;\n    &#x2F;* \n        若myInt的值为负，建议不允许运行MyFunction_Implementation。 \n        因此仅在myInt大于零时返回true。\n    *&#x2F;\n    return myInt &gt;&#x3D; 0;\n&#125;\n\n2. 提示和深入阅读\n描述：戏中实现高效、稳定多人游戏系统的基本指南\n\n2.1 基本复制Actor清单\n将Actor的复制设置设为True\n若复制Actor需要移动，将复制移动（Replicates Movement）设为True\n生成或销毁复制Actor时，确保在服务器上执行该操作\n设置必须在机器间共享的变量，以便进行复制。这通常适用于以gameplay为基础的变量\n尽量使用虚幻引擎的预制移动组件，其已针对复制进行构建\n若使用服务器授权模型，需确保玩家可执行的新操作均由服务器函数触发\n\n2.2 网络提示\n尽可能少用RPC或复制蓝图函数。在合适情况下改用RepNotify\n组播函数会导致会话中各连接客户端的额外网络流量，需尤其少用\n若能保证非复制函数仅在服务器上执行，则服务器RPC中无需包含纯服务器逻辑\n将可靠RPC绑定到玩家输入时需谨慎。玩家可能会快速反复点击按钮，导致可靠RPC队列溢出。应采取措施限制玩家激活此项的频率\n若游戏频繁调用RPC或复制函数，如tick时，则应将其设为不可靠\n部分函数可重复使用。调用其响应游戏逻辑，然后调用其响应RepNotify，确保客户端和服务器拥有并列执行即可\n检查Actor的网络角色可查看其是否为 ROLE_Authority。此方法适用于过滤函数中的执行，该函数同时在服务器和客户端上激活\n使用C++中的 IsLocallyControlled 函数或蓝图中的Is Locally Controlled函数，可检查Pawn是否受本地控制。基于执行是否与拥有客户端相关来过滤函数时，此方法十分有用\n构造期间Pawn可能未被指定控制器，因此避免在构造函数脚本中使用 IsLocallyControlled\n\n3. Actor 复制Actor 主要通过两种方式进行更新：\n\n属性更新\nRPC （远程过程调用）\n属性更新和 RPC 的主要区别在于，属性可以在发生变化时随时自动更新，而 RPC 只能在被执行时获得调用更新\n\n复制例子：Actor 的健康值\n\n当健康值发生变化时，您通常都希望告知客户端。如果健康值没有变化，则不会发送任何数据\n即使这个属性没有变化（因此不消耗任何带宽），它仍然会消耗 CPU 资源来判断这个值是否发生变化\n适合那些经常变化的属性\n\nRPC例子：同一场爆炸\n\n可以以位置和半径为参数的 RPC 函数，同时在每次发生爆炸时调用它\n也可以将此存储为一组属性，通过同步的方式将其传达给客户端\n这种做法会损失一些效率，因为爆炸出现的频繁度也许不会高得有必要将它们作为属性\n\n3.1 组件复制3.1.1 组件复制介绍介绍：\n\n虚幻引擎 4 支持组件复制\n大多数组件都不会复制\n多数游戏逻辑都是在 Actor 类和组件中完成，而它们 通常只代表了构成 Actor 的零散部分\n实际复制的是 Actor 中的游戏逻辑，而这样做的结果，有时会调用&#x2F;更改组件\n有些情况下，组件本身的属性或事件必须要直接复制\n一旦复制了 Actor，它就可以复制自身组件\n这些组件 可以按 Actor 的方式复制属性和 RPC\n组件必须以 Actor 的方式实施 ::GetLifetimeReplicatedProps (...) 函数\n\n组件复制涉及两大类组件：\n\n静态组件：一种是随 Actor 一起创建的组件\n\n在客户端或服务器上生成 所属 Actor 时，这些组件也会同时生成，与组件是否被复制无关\n服务器不会告知客户端显式生成这些组件\n静态组件无需通过复制存在于客户端\n只有在属性或事件需要在服务器和客户端之间自动同步时，才需要进行复制\n\n\n动态组件：运行时在服务器上生成的组件种，其创建和删除操作也将被复制到客户端\n\n运行方式与 Actor 极为一致\n动态组件需通过复制的方式存在于所有客户端\n客户端可以生成自己的本地非复制组件，当那些在服务器上触发的 属性或事件需要自动同步到客户端时，才会出现复制行为\n\n\n\n3.1.2 使用方式\n在组件上设置属性和 RPC 的过程与 Actor 并无区别\n\n将一个类设置为具有复本后，这些组件的实际实例也必须经过设置后才能复制\n\nC++\n\n调用 AActorComponent::SetIsReplicated(true) 即可\n\n如果组件是一个默认子对象，就应当在生成组件之后通过类构造函数来完成此调用\n\n示例：\nACharacter::ACharacter()\n&#123;\n    &#x2F;&#x2F; Etc...\n\n    CharacterMovement &#x3D; CreateDefaultSubobject&lt;UMovementComp_Character&gt;(TEXT(&quot;CharMoveComp&quot;));\n    if (CharacterMovement)\n    &#123;\n        CharacterMovement-&gt;UpdatedComponent &#x3D; CapsuleComponent;\n\n        CharacterMovement-&gt;GetNavAgentProperties()-&gt;bCanJump &#x3D; true;\n        CharacterMovement-&gt;GetNavAgentProperties()-&gt;bCanWalk &#x3D; true;\n        CharacterMovement-&gt;SetJumpAllowed(true);\n        CharacterMovement-&gt;SetNetAddressable(); &#x2F;&#x2F; Make DSO components net addressable\n        CharacterMovement-&gt;SetIsReplicated(true); &#x2F;&#x2F; Enable replication by default\n\n    &#125;\n&#125;\n\n\n\n蓝图\n\n要进行静态蓝图组件复制，只需在组件默认设置中切换 Replicates 布尔变量\n\n静态组件需要在客户端和服务器上隐式创建\n\n并非所有组件都会如此显示，必须要支持某种复制形式才会显示\n\n\n通过动态生成的组件来实现这一点，可以调用 SetIsReplicated 函数\n\n\n\n3.1.3 时间轴\n时间轴必须通过其属性中的 Replicated 选项来启用复制\n会将服务器控制的运行位置、速率和方向复制到客户端\n大多数时间轴都无需复制\n时间轴复本只应当在服务器上直接 操作 (start&#x2F;stop etc)\n客户端只应当查看运行位置的复本，而不应尝试改变时间轴本身\n在进行复制更新的间歇，客户端将推测 运行位置\n\n3.1.4 带宽开销\n复制组件时的资源开销是比较低的\n复制的 Actor 中的每个组件都需要添加一个额外的 NetGUID（4 字节）”标头”和一个大约 1 字节的”标脚”（footer） 及其属性\n在 CPU 层面上，基于 Actor 的属性复制与基于组件的复制之间应当有一个最小差异\n\n3.1.5 一般性子对象复制\n所有 Actor 子对象都可以复制，而不只限于组件\n\n对于希望复制非 ActorComponent 子对象的类，应当实施三种方法\n&#x2F;** FActory 方法，用于对模板化 TobjectReplicator 类进行实例化，以便实现子对象复制 *&#x2F;\nvirtual class FObjectReplicatorBase * InstantiateReplicatorForSubObject(UClass *SubobjClass);\n\n&#x2F;** 能让 Actor 在其 Actor 通道上复制子对象的方法 *&#x2F;\nvirtual bool ReplicateSubobjects(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags);\n\n&#x2F;** 通过复制来动态创建新的子对象时，在 Actor 上进行调用 *&#x2F;\nvirtual void OnSubobjectCreatedFromReplication(UObject *NewSubobject);\n\n3.1.5.1 使用情形\n能在 Actor 通道的层面上使用 UObject 和多态（polymorphism）\n之前用于复杂数据结构的复制方法只适合那些 在 Actor 类中对类型进行静态定义的结构\n利用子对象复制，建立一个道具栏系统，使其中的每个物品作为一个从基本道具栏类扩展而来的类， 也可以进行完整复制，同时无需让这些项成为 Actor（资源负担太大）\n\n3.1.5.2 优化\n有很多子对象需要复制，Actor 只需了解哪些子对象（如存在）最近发生过变化且需要复制，从而节省了大量时间\n\n通过访问器（accessor）函数来持续跟踪子对象的更改情况\n\n所用的接口位于 UActorChannel 中\nbool KeyNeedsToReplicate(int32 ObjID, int32 RepKey);\n\n该函数应当由 Actor 在其 ::ReplicateSubobjects 实施中调用\n\nActor 类可以设置一个任意的对象 ID 和复制键，供复制系统跟踪每个客户端\n\n对象 ID 和复制键完全是任意指定的\n\n对象 ID 仅用于引用”事情”\n\n可以是整个子对象列表、部分列表或单个对象\n\n\n复制键同样可以任意指定\n\n可以是一个在对象 ID 跟踪变化时递增的计数器\n\n\n\n3.2 Actor及其所属连接3.2.1 连接\n每个连接都有一个专门为其创建的 PlayerController\n确定一个 actor 是否归某一连接所有，您可以查询这个 actor 最外围的所有者\n所有者是一个 PlayerController，则这个 actor 同样归属于拥有 PlayerController 的那个连接\n\n3.2.2 确定连接\n在确定所属连接方面，组件有一些特殊之处\n首先确定组件所有者，方法是遍历组件的”外链”，直到找出所属的 actor\n确定这个 actor 的所属连接，像上面那样继续下去\n连接所有权是以下情形中的重要因素：\nRPC 需要确定哪个客户端将执行运行于客户端的 RPC\nActor 复制与连接相关性\n在涉及所有者时的 Actor 属性复制条件\n\n\n\n\n\n3.2.3 连接的作用\n连接所有权对于 RPC 这样的机制至关重要，因为当您在 actor 上调用 RPC 函数时\n\n除非 RPC 被标记为多播，否则就需要知道要在哪个客户端上执行该 RPC\n\n它可以查找所属连接来确定将 RPC 发送到哪条连接\n\n连接所有权会在 actor 复制期间使用，用于确定各个 actor 上有哪些连接获得了更新\n\n对于那些将 bOnlyRelevantToOwner 设置为 true 的 actor，只有拥有此 actor 的连接才会接收这个 actor 的属性更新\n\n默认情况下，所有 PlayerController 都设置了此标志，正因如此，客户端才只会收到它们拥有的 PlayerController 的更新\n\n最主要的是防止玩家作弊和提高效率\n\n对于那些要用到所有者的 需要复制属性的情形 来说，连接所有权具有重要意义：\n\n当使用 COND_OnlyOwner 时，只有此 actor 的所有者才会收到这些属性更新\n\n\n所属连接对那些作为自治代理的 actor（角色为 ROLE_AutonomousProxy）来说也很重要\n\n这些 actor 的角色会降级为 ROLE_SimulatedProxy，其属性则被复制到不拥有这些 actor 的连接中\n\n\n\n3.3 Actor相关性与优先级3.3.1 相关性前提：\n\n场景的规模可能非常大，在特定时刻某个玩家只能看到关卡中的一小部分 Actor\n场景中的其他大多数 Actor 都不会被看到和听到， 对玩家也不会产生显著的影响\n被服务器认为可见或能够影响客户端的 Actor 组会被视为该客户端的相关 Actor 组\n\n虚幻引擎的网络代码中包含一处重要的带宽优化：\n\n服务器只会让客户端知道其相关组内的 Actor\n\n参照以下规则确定玩家的相关 Actor 组：在虚拟函数 AActor::IsNetRelevantFor() 中实施\n\n如果 Actor 是 bAlwaysRelevant、归属于 Pawn 或 PlayerController、本身为 Pawn 或者 Pawn 是某些行为（如噪音或伤害）的发起者，则其具有相关性\n如果 Actor 是 bNetUseOwnerRelevancy 且拥有一个所有者，则使用所有者的相关性\n如果 Actor 是 bOnlyRelevantToOwner 且没有通过第一轮检查，则不具有相关性\n如果 Actor 被附加到另一个 Actor 的骨架模型，它的相关性将取决于其所在基础的相关性\n如果 Actor 是不可见的 (bHidden &#x3D;&#x3D; true) 并且它的 Root Component 并没有碰撞，那么则不具有相关性\n如果没有 Root Component 的话，AActor::IsNetRelevantFor() 会记录一条警告，提示是否要将它设置为 bAlwaysRelevant&#x3D;true\n\n\n如果 AGameNetworkManager 被设置为使用基于距离的相关性，则只要 Actor 低于净剔除距离，即被视为具有相关性\n\n注意：\n\nPawn 和 PlayerController 将覆盖 AActor::IsNetRelevantFor() 并最终具有不同的相关性条件\n\n缺点：\n\n距离检查在遇到大型 Actor 时可能会出现漏报（尽管我们用了一些启发式方法来应对），也不能处理环境声音的吸收\n相对于互联网的延迟和数据包丢失这些网络环境所固有的问题来说，这种近似法产生的错误就不那么明显了\n\n3.3.2 优先级设定介绍：虚幻引擎采用了负载平衡技术来安排所有 Actor 的优先级，并根据它们对游戏的重要性为其分别提供一个公平的带宽份额\n原理：\n\n每个 Actor 都有一个名为 NetPriority 的浮点变量\n变量的数值越大，Actor 相对于其他”同伴”的带宽就越多\n和优先级为 1.0 的 Actor 相比，优先级是 2.0 的 Actor 可以得到两倍的更新频度\n唯一影响优先顺序的就是它们的比值\n所以无法通过提高所有优先级的数值来增加虚幻引擎的网络性能\n\n例子：\n\nActor &#x3D; 1.0\nMatinee &#x3D; 2.7\nPawn &#x3D; 3.0\nPlayerController &#x3D; 3.0\n\n使用：\n\n计算 Actor 的当前优先级时使用了虚拟函数 AActor::GetNetPriority()\n为避免出现饥荒（starvation），AActor::GetNetPriority() 使用 Actor 上次复制后经过的时间 去乘以 NetPriority\n同时，GetNetPriority 函数还考虑了 Actor 与观察者的相对位置以及两者之间的距离\n\n3.4 Actor复制流程详述介绍：\n\n大多数 actor 复制操作都发生在 UNetDriver::ServerReplicateActors 内\n服务器将收集所有被认定与各个客户端相关的 actor，并发送那些自上次（已连接的）客户端更新后出现变化的所有属性\n\n3.4.1 复制流程复制连接流程：指定了 actor 的更新方式、要调用的特定框架回调，以及在此过程中使用的特定属性\n\nAActor::NetUpdateFrequency - 用于确定 actor 的复制频度\nAActor::PreReplication - 在复制发生前调用\nAActor::bOnlyRelevantToOwner - 如果此 actor 仅复制到所有者，则值为 true\nAActor::IsRelevancyOwnerFor - 用于确定 bOnlyRelevantToOwner 为 true 时的相关性\nAActor::IsNetRelevantFor - 用于确定 bOnlyRelevantToOwner 为 false 时的相关性\n\n高级流程：\n\n循环每一个主动复制的 actor（AActor::SetReplicates( true )）\n\n确定这个 actor 是否在一开始出现休眠（DORM_Initial），如果是这样，则立即跳过\n通过检查 NetUpdateFrequency 的值来确定 actor 是否需要更新，如果不需要就跳过\n如果 AActor::bOnlyRelevantToOwner 为 true，则检查此 actor 的所属连接以寻找相关性（对所属连接的观察者调用 AActor::IsRelevancyOwnerFor），如果相关，则添加到此连接的已有相关列表\n此时，这个 actor 只会发送到单个连接\n\n\n对于任何通过这些初始检查的 actor，都将调用 AActor::PreReplication\nPreReplication 可以让您决定是否针对连接来复制属性，这时要使用 DOREPLIFETIME_ACTIVE_OVERRIDE\n\n\n如果同过了以上步骤，则添加到所考虑的列表\n\n\n对于每个连接：\n\n对于每个所考虑的上述 actor\n确定是否休眠\n是否还没有通道\n确定客户端是否加载了 actor 所处的场景\n如未加载则跳过\n\n\n针对连接调用 AActor::IsNetRelevantFor，以确定 actor 是否相关\n如不相关则跳过\n\n\n\n\n\n\n在归连接所有的相关列表上添加上述任意 actor\n这时，我们拥有了一个针对此连接的相关 actor 列表\n按照优先级对 actor 排序\n对于每个排序的 actor：\n如果连接没有加载此 actor 所在的关卡，则关闭通道（如存在）并继续\n每 1 秒钟调用一次 AActor::IsNetRelevantFor，确定 actor 是否与连接相关\n如果不相关的时间达到 5 秒钟，则关闭通道\n如果相关且没有通道打开，则立即打开一个通道\n如果此连接出现饱和\n对于剩下的 actor\n如果保持相关的时间不到 1 秒，则强制在下一时钟单位进行更新\n如果保持相关的时间超过 1 秒，则调用 AActor::IsNetRelevantFor 以确定是否应当在下一时钟单位更新\n\n\n\n\n对于通过了以上这几点的 actor，将调用 UChannel::ReplicateActor 将其复制到连接\n\n\n\n\n\n3.4.2 Actor复制到连接流程：UChannel::ReplicateActor 将负责把 actor 及其所有组件复制到连接中\n\n确定这是不是此 actor 通道打开后的第一次更新\n如果是，则将所需的特定信息（初始方位、旋转等）序列化\n\n\n确定该连接是否拥有这个 actor\n如果没有，而且这个 actor 的角色是 ROLE_AutonomousProxy，则降级为 ROLE_SimulatedProxy\n\n\n复制这个 actor 中已更改的属性\n复制每个组件中已更改的属性\n对于已经删除的组件，发送专门的删除命令\n\n3.5 Role和RemoteRole介绍： Actor 的复制过程中，有两个属性扮演了重要角色，分别是 Role 和 RemoteRole\n作用：有了这两个属性，可以知道\n\n谁拥有 actor 的主控权\nactor 是否被复制\n复制模式\n\n前提：\n\n首先一件要确定的事，就是谁拥有特定 actor 的主控权\n确定当前运行的引擎实例是否有主控者，需要查看 Role 属性是否为 ROLE_Authority\n如果是，就表明这个运行中的引擎实例负责掌管此 actor（决定其是否被复制）\n如果 Role 是 ROLE_Authority，RemoteRole 是 ROLE_SimulatedProxy 或 ROLE_AutonomousProxy\n就说明这个引擎实例负责将此 actor 复制到远程连接\n\n\n\n注意：\n\n只有服务器能够向已连接的客户端同步 Actor （客户端永远都不能向服务器同步）\n只有 服务器才能看到 Role == ROLE_Authority 和 RemoteRole == ROLE_SimulatedProxy 或者 ROLE_AutonomousProxy\n\n3.5.1 Role&#x2F;RemoteRole对调对于不同的数值观察者，它们的 Role 和 RemoteRole 值可能发生对调\n例子：\n\n服务器上有这样的配置：\n\nRole == ROLE_Authority\nRemoteRole == ROLE_SimulatedProxy\n\n\n客户端会将其识别为以下形式：\n\nRole == ROLE_SimulatedProxy\nRemoteRole == ROLE_Authority\n\n\n这种情况是正常的，因为服务器要负责掌管 actor 并将其复制到客户端\n\n而客户端只是接收更新，并在更新的间歇模拟 actor\n\n\n3.5.2 复制模式前提：\n\n服务器不会在每次更新时复制 actor\n会消耗太多的带宽和 CPU 资源\n服务器会按照 AActor::NetUpdateFrequency 属性指定的频度来复制 actor\n因此在 actor 更新的间歇，会有一些时间数据被传递到客户端\n会导致 actor 呈现出断续、不连贯的移动\n弥补这个缺陷，客户端将在更新的间歇中模拟 actor\n\n两种模拟：\n\nROLE_SimulatedProxy\n\n标准的模拟途径，通常是根据上次获得的速率对移动进行推算\n服务器为特定的 actor 发送更新时，客户端将向着新的方位调整其位置，然后利用更新的间歇，根据由服务器发送的最近的速率值来继续移动 actor\n\n\nROLE_AutonomousProxy\n\n这种模拟通常只用于 PlayerController 所拥有的 actor\n说明此 actor 会接收来自真人控制者的输入，所以在我们进行推算时，我们会有更多一些的信息，而且能使用真人输入内容来补足缺失的信息（而不是根据上次获得的速率来进行推算）\n\n\n\n3.6 RPC简介：\n\nRPC （远程过程调用）是在本地调用但在其他机器（不同于执行调用的机器）上远程执行的函数\n允许客户端或服务器通过网络连接相互发送消息\n\n作用：\n\n执行那些不可靠的暂时性&#x2F;修饰性游戏事件\n包括播放声音、生成粒子或产生其他临时效果 之类的事件，它们对于 Actor 的正常运作并不重要\n在此之前，这些类型的事件往往要通过 Actor 属性进行复制\n\n3.6.1 使用RPC\n声明：将一个函数声明为 RPC，您只需将 Server、Client 或 NetMulticast 关键字添加到 UFUNCTION 声明\n\n例子1：要将某个函数声明为一个要在服务器上调用、但需要在客户端上执行的 RPC\nUFUNCTION( Client )\nvoid ClientRPCFunction();\n\n\n\n例子2：将某个函数声明为一个要在客户端上调用、但需要在服务器上执行的 RPC，您可以采取类似的方法，但需要使用 Server 关键字\nUFUNCTION( Server )\nvoid ServerRPCFunction();\n\n\n\n例子3：多播 RPC 可以从服务器调用，然后在服务器和当前连接的所有客户端上执行，需使用 NetMulticast 关键字\nUFUNCTION( NetMulticast )\nvoid MulticastRPCFunction();\n\n注：多播 RPC 还可以从客户端调用，但这时就只能在本地执行\n\n\n3.6.2 快速提示\n在函数的开头预置 Client、Server 或 Multicast 关键字\n这是我们在内部所做的一个约定，用来告诉程序员所用的函数将分别在客户端、服务器或所有客户端上调用\n事先确定该函数将在多人游戏会话期间被哪些机器调用\n\n3.6.3 要求和注意事项前提：\n\n它们必须从 Actor 上调用\nActor 必须被复制\n如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数\n如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor\n多播 RPC 则是个例外：\n如果它们是从服务器调用，服务器将在本地和所有已连接的客户端上执行它们\n如果它们是从客户端调用，则只在本地而非服务器上执行\n有一个简单的多播事件限制机制：在特定 Actor 的网络更新期内，多播函数将不会复制两次以上\n\n\n\n3.6.3.1 从服务器调用的RPC\n\n\nActor 所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nClient-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在 actor 的所属客户端上运行\n\n\nServer-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\nUnowned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n3.6.3.2 从客户端调用的RPC\n\n\nActor 所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nOwned by invoking client\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n在服务器上运行\n在执行调用的客户端上运行\n\n\nOwned by a different client\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nServer-owned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nUnowned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\n3.6.4 可靠性\n默认情况下，RPC 并不可靠\n\n要确保在远程机器上执行 RPC 调用，可以指定 Reliable 关键字\nUFUNCTION( Client, Reliable )\nvoid ClientRPCFunction();\n\n3.6.5 蓝图前提：\n\n如果被标记为 RPC 的函数是从蓝图中调用，它们也会被复制\n它们将遵循相同的规则，就像是从 C++ 调用一样\n在此情况下，无法将函数动态标记为蓝图的 RPC\n自定义事件可以从蓝图编辑器内部被标记为复制\n\n使用：\n\n使用此功能，您需要在您的事件图表中新建一个自定义事件\n\n单击自定义事件并在详细信息视图中编辑复制设置\n\n\n\n3.6.6 验证使用验证的原因：\n\n作为检测错误数据&#x2F;输入的一个手段\n如果 RPC 的验证函数检测到任何 参数存在问题，就会通知系统将发起 RPC 调用的客户端&#x2F;服务器断开\n会通知系统将发起 RPC 调用的客户端&#x2F;服务器断开\n\n例：\n\n要为 RPC 声明一个验证函数，只需将 WithValidation 关键字添加到 UFUNCTION 声明语句\nUFUNCTION( Server, WithValidation )\nvoid SomeRPCFunction( int32 AddHealth );\n\n然后在实施函数旁边加入验证函数\nbool SomeRPCFunction_Validate( int32 AddHealth )\n&#123;\n    if ( AddHealth &gt; MAX_ADD_HEALTH )\n    &#123;\n        return false;                       &#x2F;&#x2F; This will disconnect the caller\n    &#125;\nreturn true;                              &#x2F;&#x2F; This will allow the RPC to be called\n&#125;\n\nvoid SomeRPCFunction_Implementation( int32 AddHealth )\n&#123;\n    Health +&#x3D; AddHealth;\n&#125;\n\n\n\n注：\n\n被添加到 UHT，以便要求客户端 -&gt; 服务器 RPC 具有一个 _Validate 函数\n鼓励使用安全的服务器 RPC 函数，同时尽可能方便其他人 添加代码以检查所有参数，确保其符合所有已知的输入限制\n\n\n\n3.7 属性复制说明：\n\n每个Actor维护一个全属性列表，其中包含Replicated 说明符\n每当复制的属性值发生变化时，服务器会向所有客户端发送更新\n客户端会将其应用到Actor的本地版本上\n这些更新只会来自服务器，客户端永远不会向服务器或其他客户端发送属性更新\n\n注意：\n\n不推荐在客户端上更改复制的变量值\n该值将始终与服务器端的值不一致，直到服务器下一次侦测到变更并发送更新为止\n如果服务器版本的属性不是经常更新，那客户端就需要等待很长时间才能被纠正\n\nTips：\n\nActor属性复制可靠\n\n意味着，Actor的客户端版本的属性最终将反映服务器上的值，但客户端不必接受服务器上某个属性的每一个单独变更\n\n例：\n\n如果一个整数属性的值快速从100变成200，然后又变成了300\n客户端将最终接受一个值为300的变更，但客户端不一定会知道这个值曾经变成过200\n\n\n\n3.7.1 设置要复制的属性\n复制属性：在定义属性的Actor类标头处，您需要确保replicated关键字作为UPROPERTY声明的参数之一\nclass ENGINE_API AActor : public UObject\n&#123;\n    UPROPERTY( replicated )\n    AActor * Owner;\n&#125;;\n\n\n\n在Actor类的实现过程中，需要实现GetLifetimeReplicatedProps函数\nvoid AActor::GetLifetimeReplicatedProps( TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps ) const\n&#123;\n    DOREPLIFETIME( AActor, Owner );\n&#125;\n\n\n\n在Actor的构造函数中，确保将bReplicates标记设置为true\nAActor::AActor( const class FPostConstructInitializeProperties &amp; PCIP ) : Super( PCIP )\n&#123; \n    bReplicates &#x3D; true;\n&#125;\n\n注：对于当前实例化的Actor类型的每个副本，成员变量”Owner”现在将同步到所有连接的客户端（在本例中为基础Actor类）\n\n\n3.7.2 网络更新优化3.7.2.1 数据驱动型网络更新频率\nActor将观察在其NetUpdateFrequency变量中设置的最大更新频率\n通过在不太重要或不太频繁变化的Actor上降低该变量，网络更新可以变得更高效，同时在有限带宽的场景中可能会带来更流畅的游戏体验\n常见的更新频率值为：\n重要且不可预知的Actor：射击游戏中由玩家控制的角色，为10（每0.1秒更新一次）\n对于行动缓慢的角色：\n合作类游戏中由AI控制的怪物，为5（每0.2秒更新一次）\n对于游戏进程不是很重要但仍通过网络同步的以及&#x2F;或者由服务器端逻辑控制因而需要复制的后台Actor，为2（每0.5秒更新一次）\n\n\n\n\n\n3.7.2.2 自适应型网络更新频率Tips：\n\n在默认情况下，该功能是关闭的\n将控制台变量 net.UseAdaptiveNetUpdateFrequency 设置到 1 可以将其激活\n\n作用：\n\n节省CPU周期，这些CPU周期通常会在没有任何实际更改的情况下多次尝试复制Actor而浪费掉\n\n启用了该功能时，系统将根据各个Actor的更新是否有意义，动态调整其更新频率\n\n有意义：\n\n初始化了Actor、添加或删除了子对象（即拥有的组件）\n更改了Actor上或其任何子对象上复制字段值的任何更新\n\n\n每个Actor可能的更新速率范围由Actor本身的两个变量决定：NetUpdateFrequency和MinNetUpdateFrequency\n\nNetUpdateFrequency表示Actor每秒尝试更新自己的最大次数，而MinNetUpdateFrequency表示每秒尝试更新的最小次数\n\n使用该功能可以大大提高复制性能\n\n\n3.7.2.3 更新频率降低算法\n在更新尝试期间，Actor将确定最近一次有意义的更新发送到现在有多长时间，如果它们发送了有意义的更新，将记录新的时间\n例1：\n进行更新的Actor超过2秒没有发送有意义的更新，那么它将开始降低更新频率\n在没有发送有意义的更新的情况下，更新频率将在7秒后达到最小\n\n\n例2：\n更新延迟在0.1秒到0.6秒之间的Actor在3秒内没有任何有意义的更新\n那么它将在0.2秒内尝试下一次更新\n\n\n\n3.7.2.4 更新频率增加算法\n在发送一个有意义的更新之后，Actor将安排下一个更新发生的时间，使其比前两次有意义的更新之间的时间短30%，并且处于最小更新频率与最大更新频率之间\n\n如果Actor在两次有意义的更新之间恰好间隔了一秒，那么它会将下一次更新尝试安排在未来0.7秒\n\n或者接近指定的最小与最大更新频率的时间\n\n接下来每次有意义的更新，都将重复该计算，如果Actor开始频繁地进行数据或子对象更改，将快速缩短更新之间的时间\n\n\n3.8 条件属性复制前提：\n\n当属性被注册进行复制后，您将无法再取消注册（涉及到生存期）\n因为要预制尽可能多的信息，以便针对同一组属性将某一工作分担给多个连接\n可以节省大量的计算时间\n\n说明：\n\n默认情况下，每个复制属性都有一个内置条件：如果不发生变化就不会进行复制\n\n为了加强对属性复制的控制，使用一个专门的宏来添加附加条件\n\n这个宏被称为 DOREPLIFETIME_CONDITION\n\nvoid AActor::GetLifetimeReplicatedProps( TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps ) const\n&#123;\n    DOREPLIFETIME_CONDITION( AActor, ReplicatedMovement, COND_SimulatedOnly );\n&#125;\n\n传递给条件宏的 COND_SimulatedOnly 标志甚至可以在考虑复制属性前执行一次额外检查\n\n这时，它只会复制到拥有此 actor 模拟复本的客户端\n\n\n作用：\n\n最明显的好处在于节省带宽\n因为我们确信拥有此 actor 的自治代理版本的客户端无需了解这个属性\n例：\n该客户端为了进行预测而直接设置了这一属性\n对于不接收该属性的客户端而言，服务器无需干涉这个客户端的本地复本\n\n\n\n使用：\n\n目前支持的条件，在 Engine\\Source\\Runtime\\CoreUObject\\Public\\UObject\\CoreNet.h 的 ELifetimeCondition 枚举中指定\n\n\n\n\n条件\n说明\n\n\n\nCOND_InitialOnly\n该属性仅在初始数据组尝试发送\n\n\nCOND_OwnerOnly\n该属性仅发送至 actor 的所有者\n\n\nCOND_SkipOwner\n该属性将发送至除所有者之外的每个连接\n\n\nCOND_SimulatedOnly\n该属性仅发送至模拟 actor\n\n\nCOND_AutonomousOnly\n该属性仅发送给自治 actor\n\n\nCOND_SimulatedOrPhysics\n该属性将发送至模拟或 bRepPhysics actor\n\n\nCOND_InitialOrOwner\n该属性将发送初始数据包，或者发送至 actor 所有者\n\n\nCOND_Custom\n该属性没有特定条件，但需要通过 SetCustomIsActiveOverride 得到开启&#x2F;关闭能力\n\n\n补充：\n\n有一个名叫 DOREPLIFETIME_ACTIVE_OVERRIDE 的宏可以进行全面控制\n\n利用任何定制条件来决定何时复制&#x2F;不复制某个属性\n\n需要注意的是：\n\n这种控制需针对每个 actor（而不是每条连接）逐一进行\n在定制条件中使用一个可根据连接而发生变化的状态，会存在一定的安全风险\n\nvoid AActor::PreReplication( IRepChangedPropertyTracker &amp; ChangedPropertyTracker )\n&#123;\n    DOREPLIFETIME_ACTIVE_OVERRIDE( AActor, ReplicatedMovement, bReplicateMovement );\n&#125;\n\n现在 ReplicatedMovement 属性只会在 bReplicateMovement 为 true 时复制\n\n不使用这个宏的原因：\n\n如果定制条件的值变化太大，这种做法会降低执行速度\n您不能使用根据连接而变化的条件（此时不检查 RemoteRole）\n\n\n\n条件属性复制的好处：\n\n属性复制条件可以很好的实现控制力与性能之间的平衡\n可以使引擎以更快的速度针对多条连接检查并发送属性\n同时让程序员对复制属性的方式和时机进行精细控制\n\n3.9 复制对象引用前提：\n\n一般而言，对象引用会在 UE4 多人游戏架构中自动处理\n一个已经复制的 UObject 属性，该对象的引用将作为服务器分配的专门 ID 通过网络进行发送\n这个专门 id 是一个 FNetworkGUID\n服务器将负责分配此 id，然后向所有已连接的客户端告知这一分配\n\n使用：\n\n需将一个 UObject 属性标记为已复制\nclass ENGINE_API AActor : public UObject\n&#123;\n    UPROPERTY( replicated )\n    AActor * Owner;\n&#125;;\n\nOwner 属性将作为其引用的 actor 的一个复制引用\n\n注意：\n\n通过网络合法引用的对象，必须对其提供支持以保证网络连接\n要进行检查，可以调用 UObject::IsSupportedForNetworking()\n这是一个底层函数，所以一般不需要在游戏代码中对其进行检查\n\n\n\n其他方式：\n\n任何复制的 actor 都可以复制为一个引用\n任何未复制的 actor 都必须有可靠命名（直接从数据包加载）\n任何复制的组件都可以复制为一个引用\n任何未复制的组件都必须有可靠命名。\n其他所有 UObject（非 actor 或组件）必须由加载的数据包直接提供\n\n3.9.1 拥有可靠命名的对象说明：\n\n拥有可靠命名的对象指的是存在于服务器和客户端上的同名对象\n如果 Actor 是从数据包直接加载（并非在游戏期间生成），它们就被认为是拥有可靠命名\n\n方式：\n\n从数据包直接加载\n通过简单构建脚本添加\n采用手动标记（通过 UActorComponent::SetNetAddressable 进行）\n只有当您知道要手动命名组件以便其在服务器和客户端上具有相同名称时，才应当使用这种方法\n（最好的例子就是 AActor C++ 构造函数中添加的组件）\n\n\n\n3.10 蓝图使用RPC远程调用函数主要包括 3 种类型：\n\nMulticast 广播：广播函数在服务器上调用和执行，然后自动转发给客户端\nServer的函数，Server调用，Server执行，复制给所有在场的Actor\n\n\nRun on Server 在服务端执行：在服务端执行的函数由客户端调用，然后仅在服务器上执行\nServer的函数，Client调用，Server执行\n\n\nRun on owning Client 在客户端执行：在客户端执行的函数由服务器调用，然后仅在自有客户端上执行\nClient的函数，Server调用，Client执行\n\n\n\n3.10.1 Multicast广播\n自定义事件\n\n然后在 Details 面板中将 Replicates 下拉菜单设置为 Multicast\n\n\n从 Space Bar 按键事件连出来，搜索并添加调用函数MulticastSpawn\n\n\n编译 并 保存，关闭蓝图，然后单击 运行 按钮在编辑器中开始游戏\n\n在游戏中，定位服务器所在的窗口，然后按 Space Bar 跳转\n\n\n服务器上的玩家按跳转时，服务器和所有客户端上都将生成喷火效果\n\n其他玩家跳转仍只能在本地喷火，因为我们并未告知服务器客户端已生成该效果\n\n\n3.10.2 RunOnServer\n选择 MulticastSpawn 自定义事件，然后将 Replicates 下拉选项更改为 Run on Server\n\n\n编译 并 保存，关闭蓝图，然后单击 运行 按钮在编辑器中开始游戏\n\n在游戏中，定位非服务器的任何游戏窗口，然后按 Space Bar 跳转\n\n\n注意，喷火效果只在服务器上生成，无论哪个玩家跳转，其他玩家都看不到，只有服务器端才能看到\n\n我们需确保该效果已设置为复制，以便其传递给所有客户端和服务器\n\n在 Content&#x2F;StarterContent&#x2F;Blueprints 文件夹中，打开 Blueprint_Effect_Fire 蓝图\n\n从主工具栏中选择 Class Defaults 后，在 Details 面板中，选中 Replicates 复选框\n\n\n编译 并 保存，关闭蓝图，然后单击 运行 按钮在编辑器中开始游戏\n\n在游戏中，定位非服务器的任何游戏窗口，然后按 Space Bar 跳转\n\n\n向服务器发送消息，以在服务器运行部分脚本来生成 Actor，由于此 Actor 已设置为复制，因此我们可以在所有客户端上看到它\n\n\n3.10.3 RunOnOwningClient说明：在此示例中，我们要做到是创建一个发生服务器事件时仅在特定客户端上更新的变量\n步骤：设置 Run on owning Client 复制函数\n\n在 Content&#x2F;ThirdPersonBP&#x2F;Blueprints 文件夹中，打开 ThirdPersonCharacter 蓝图\n\n在 MyBlueprint 窗口中，创建新变量并将其命名为 Inventory，然后单击 Compile\n\n\n在此变量的 Details 面板中，将其设置为 String、Editable 和 Replicated，然后为 Default Value 输入 Empty\n\n\n将此变量设置为 Replicated 可确保其通过网络复制到所连接的机器上\n\n我们将使用此变量模拟人物在多人游戏中进入触发卷时收集道具，退出触发卷时删除道具\n\n\n\n添加一个与 Print String 连接的 P 按键事件，然后按住 Control 并拖入 Inventory 变量，并按所示方式连接\n\n\nCompile 并 Save，然后关闭 ThirdPersonCharacter 蓝图\n\n在 放置Actor（Place Actors） 的 基础（Basic） 选项卡中，将 盒体触发器（Box Trigger） 拖入你的关卡\n\n\n当玩家人物进入触发器时，我们将更新创建的变量，但仅在进入触发器盒的客户端上更新。\n\n\n在 Rendering 下 Box Trigger 的 Details 面板中，取消选中 Actor Hidden In Game。\n\n\n在编辑器中玩游戏时，这可让我们在关卡中看到此盒，使得测试更加轻松\n\n\n单击 Box Trigger 将其选中，然后从主工具栏打开Level Blueprint。\n\n\n在图表中 右键 ，然后搜索 Begin Overlap 并选择 Add On Actor Begin Overlap 事件\n\n\n重复上一步，但搜索并添加 Add On Actor End Overlap 事件\n\n将每个节点连接到 Switch Has Authority 节点\n\n\nSwitch Has Authority 节点用于检查当前正在运行的脚本正在从何处执行，然后基于脚本是在网络授权者（通常为服务器）还是远程机器（客户端）上运行将其分成两个不同的方向\n\n通常，你会对只希望在服务器上发生的事情使用授权者（这些通常为游戏关键性事件，例如调整玩家的生命值或赠送奖励或掠夺物品，因为你不想让客户端确定这些更改何时发生，以防作弊）\n\n在此示例中，我们将更新文本变量，此变量也完全可以是包含玩家生命值的变量，或所收集道具的变量\n\n\n\n在图表中 右键 并添加一个称作 Add Item 的 Custom Event 节点\n\n将 Replicates 选项设置为 Run on owning Client，并添加称作 Character 的输入，将其设置为 Actor\n\n\n创建另一个称作 Remove Item 的 Custom Event，其设置与 Add Item 事件的设置相同\n\n如下所示，从两个重叠事件连出来，接 Add Item 和 Remove Item 节点\n\n\n这里我们指的是，当重叠触发器时，如果重叠发生在服务器上，在服务器上运行 Add Item 事件，并将它复制到自有客户端（即重叠触发器的人物所在的客户端）\n“它”是指 Add Item 启动并仅在服务器上执行但复制到客户端时所调用的脚本\n当人物退出触发器盒时 — 这也由服务器决定，在服务器上运行 Remove Item 事件，并将其复制到自有客户端\n\n\n从 Add Item 事件连出来，添加 Print String （文本设置为 Item Added ），然后拖开 Character 和 Cast To ThirdPersonCharacter\n\n\n从 As Third Person Character 针连出来，搜索并添加 Set Inventory 节点，将文本设置为 Has the Item\n\n\n此处，我们选取的是在服务器上执行并复制到客户端的事件，此事件将在屏幕上显示item added\n然后将自有客户端的 Inventory 文本变量设置为Has the item\n\n\n在 Add Item 事件之后复制三个节点，并将其连接到 Remove Item 事件\n\n将 Print String 更改为 Item Removed，将 Inventory 文本变量更改为 Empty\n\n\n现在，当人物退出触发器时，文本变量将在服务器上更新并复制到自有客户端\n\n\n编译 并 保存，然后关闭 Level Blueprint 并在编辑器中开始游戏\n\n    \n    \n\n\n\n在以上视频中，当游戏启动时，按 P 可将文本变量打印到屏幕上，可对每个角色显示 “empty”\n但是，当其中一个角色退出触发器盒时，将显示文本 “item added”\n当人物按 P 时，文本将更改为 “has the item”，但其他人物仍显示 “empty”\n当人物退出触发器盒时，将显示文本 “item removed”，再次按 P 时，文本将更改回 “empty”\n\n\n\n4. 客户端-服务器模式说明：\n\nUE4 多人游戏基于客户端-服务器模式\n\n一个服务器担当游戏状态的主控者，而连接的客户端将保持近似复本\n\n\n作用：\n\n做出所有重要决定，包含所有的主控状态，处理客户端连接，转移到新的地图以及处理比赛开始&#x2F;结束时的总体游戏流程等\n\n4.1 启动服务器基本命令：\n\n\n\n类型\n命令\n\n\n\n监听服务器\nUE4Editor.exe ProjectName MapName?Listen -game\n\n\n专用服务器\nUE4Editor.exe ProjectName MapName -server -game -log\n\n\n客户端\nUE4Editor.exe ProjectName ServerIP -game\n\n\n注：\n\n专用服务器在默认情况下并不会显示窗口\n如果不使用 -log，您将不会看到任何呈现专用服务器的窗口\n\n4.2 服务器游戏流程说明：\n\n服务器的职责是在游戏开始&#x2F;结束以及 actor 复制更新等情况下通知客户端转移到新地图\n游戏状态和流程一般是通过 GameMode 这一 actor 来驱动\n只有服务器才包含此 actor 的有效复本（客户端不包含复本）\n要向客户端传达该状态，可以使用 GameState actor 显示 GameMode actor 的重要状态\n这个 GameState actor 被标记为复制到每个客户端\n客户端将包含此 GameState actor 的一个近似复本，而且能使用这个 actor 作为引用，用于了解游戏的一般状态\n\n4.3 连接过程前提：一个服务器需要从网络连接的角度实现某种目的，它就必须要有客户端连接\n说明：新的客户端初次连接时\n\n首先，客户端要向即将连接的服务器发送一个请求\n服务器将处理这条请求\n如果它不拒绝连接，服务器会向客户端发回一个包含了继续运行所需信息的响应\n\n主要步骤如下：\n\n客户端发送连接请求\n如果服务器接受连接，则发送当前地图\n服务器等待客户端加载此地图\n加载之后，服务器将在本地调用 AGameModeBase::PreLogin\n这样可以使 GameMode 有机会拒绝连接\n\n\n如果接受连接，服务器将调用 AGameModeBase::Login\n该函数的作用是创建一个 PlayerController，可用于在今后复制到新连接的客户端\n成功接收后，这个 PlayerController 将替代客户端的临时 PlayerController （之前被用作连接过程中的占位符）\n此时将调用 APlayerController::BeginPlay\n应当注意的是，在此 actor 上调用 RPC 函数尚存在安全风险。您应当等待 AGameModeBase::PostLogin 被调用完成\n\n\n如果一切顺利，AGameModeBase::PostLogin 将被调用\n这时，可以放心的让服务器在此 PlayerController 上开始调用 RPC 函数\n\n\n\n5. 角色移动组件说明：\n\n角色移动组件 是一种 Actor 组件，提供封装的移动系统和类人 角色 的常见移动模式，包括行走、跌倒、游泳和飞行\n角色移动组件还具备强大的网络gameplay整合\n默认移动模式全都默认用于复制，并提供框架来帮助开发者创建自定义的联网移动\n\n5.1 角色移动基础\nUCharacterMovementComponent前附于 ACharacterActor类及其派生的所有 蓝图\n\n\n在其 TickComponent 函数期间，UCharacterMovementComponent 将调用 PerformMovement\n\n基于当前所用 移动模式 以及玩家的输入变量来计算世界场景中所需的加速度\n\n通常在APlayerController中以 control input 变量表示\n\n一旦完成移动计算，UCharacterMovementComponent 将把最终移动应用于拥有的角色\n\n\n注：\n\n虽然 ACharacter 派生自APawn，但角色并不只是增加了角色移动组件的Pawn\nUCharacterMovementComponent 和 ACharacter 需要一同使用，因为 ACharacter 覆盖数个复制的变量和函数，专为在 UCharacterMovementComponent 中进行复制\n\n5.2 PerformMovement说明：\n\nPerformMovement 函数负责游戏世界场景中的角色物理移动\n在非联网游戏中，UCharacterMovementComponent 每次tick将直接调用一次 PerformMovement\n在联网游戏中，由专用函数为服务器和客户端调用 PerformMovement，在玩家的本地机器上执行初始移动，或在远程机器上再现移动\n\n作用：\n\n应用外部物理效果，例如脉冲、力和重力\n根据动画根运动和 根运动源 计算移动\n调用 StartNewPhysics，它基于角色使用的移动模式选择 Phys* 函数\n\n5.3 移动物理效果每个移动模式都有各自的 Phys* 函数，负责计算速度和加速度：\n\nPhysWalking 决定角色在地面上移动时的移动物理效果\nPhysFalling 决定在空中移动时的移动物理效果\n\n若移动模式在一个tick内发生变化（例如角色开始跌倒或撞到某个对象）：\n\nPhys* 函数会再次调用 StartNewPhysics，在新移动模式中继续角色的运动\nStartNewPhysics 和 Phys* 函数各自通过已发生的 StartNewPhysics 迭代的次数\n参数 MaxSimulationIterations 是此递归所允许的最大次数\n\n5.4 移动复制摘要UCharacterMovementComponent 使用其所有者的 网络角色 来确定移动的复制方式：\n\n\n\n网络角色\n说明\n\n\n\n自主代理（Autonomous Proxy）\n角色在其 所属客户端 机器上，由玩家本地控制\n\n\n权威（Authority）\n角色存在于建立游戏的服务器上\n\n\n模拟代理（Simulated Proxy）\n角色存在于可查看远程控制角色的其他客户端上，无论角色受服务器AI控制，还是由不同客户端上的自主代理控制\n\n\n\n复制进程遵循 TickComponent 函数中的循环，每tick重复一次\n角色执行移动时，为同步移动信息，网络游戏中所有不同机器上的副本会相互进行 **远程进程调用 (RPC)**，不同网络角色使用相应的不同执行路径\n\n下表逐步概述此进程中 UCharacterMovementComponent 在各个机器上所执行的操作：\n\n\n\n步骤\n说明\n\n\n\n自主代理（所属玩家的客户端）\n\n\n\n1\n所属客户端本地控制自主代理。PerformMovement 运行移动组件的物理移动逻辑\n\n\n2\n代理构建 FSavedMove_Character，其中包含其所做移动的相关数据，然后在 SavedMoves 中将其排入队列\n\n\n3\n类似的 FSavedMove 条目组合在一起。自主代理通过 ServerMove RPC将压缩版数据发送到服务器\n\n\n权威Actor（服务器）\n\n\n\n4\n服务器接收ServerMove并使用 PerformMovement 复制客户端移动\n\n\n5\n服务器检查其在ServerMove后的位置是否与客户端报告的最终位置匹配\n\n\n6\n若服务器和客户端的最终位置匹配，则向客户端发回信号，表示移动有效。否则将使用 ClientAdjustPosition RPC 发送矫正\n\n\n7\n服务器复制 ReplicatedMovement 结构，将其位置、旋转和当前状态发送到其他已连接客户端上的模拟代理\n\n\n自主代理（所属玩家的客户端）\n\n\n\n8\n若客户端收到ClientAdjustPosition，则复制服务器的移动，并使用它的 SavedMoves 队列重新追踪其步骤，以获得新的最终位置。成功解析移动后，从队列中移除已保存的移动\n\n\n模拟代理（所有其他客户端）\n\n\n\n9\n模拟代理直接应用复制的移动信息。网络平滑 提供最终运动的可视化清理\n\n\n5.5 复制角色移动详解5.5.1 所属客户端上的本地移动说明：自主代理在 TickComponent 中本地处理移动，予以记录，然后发送到服务器以授权方式再现和应用\n5.5.1.1 编译客户端预测数据说明：\n\n自主代理编译名为 ClientPredictionData 的 FNetworkPredictionData_Client_Character 对象\n其部分流程负责记录移动情况和处理来自服务器的矫正\n\n参数：\n\n客户端与服务器通信时的时间戳\n\n已保存或待定移动情况的列表\n\n来自服务器矫正的已保存信息\n\n指示如何应用矫正的标记\n\n决定平滑行为的参数\n\nClientPredictionData 还包括与这些参数交互的效用函数\n\n可在FNetworkPredictionData_Client_Character 的API参考中找到此对象信息和函数的完整列表\n\n客户端执行本地移动、准备要发送到服务器的移动并处理矫正时，它的参数将被频繁引用和更改\n\n\n5.5.1.2 复制服务器矫正\n处理玩家的输入或世界场景中的力之前，自主代理将调用 ClientUpdatePositionAfterServerUpdate\n这将检查服务器是否已向所属玩家发送矫正\n若是，ClientPredictionData 中的变量 bUpdatePosition 将为true，且该角色将再现服务器通过客户端矫正进程发送的移动\n\n5.5.1.3 执行和记录移动\n自主代理角色在 TickComponent 期间调用 ReplicateMoveToServer，而非直接调用 PerformMovement\n\n此函数围绕 PerformMovement 提供必要的逻辑，以便在角色执行它时记录移动，然后将移动提交到服务器\n\nFSavedMove_Character 结构记录自主代理在每个tick中如何开始和结束移动，之后通过ServerMove RPC将其数据的最小子集发送到服务器\n\n其参数包括：\n\n角色最终位置和旋转的相关信息\n\n已采集哪些移动输入\n\n角色拥有的速度和加速度\n\n从 AnimMontages 采集的根运动信息\n\n\n\n可在FSavedMove_Character 的API参考中查看此结构的完整参数列表\n\n此信息使服务器能够再现玩家执行的移动，然后检查客户端的最终位置\n\n处理 PerformMovement 之后，ReplicateMoveToServer 函数利用名为 NewMove 的 FSavedMove_Character 结构在客户端预测数据中记录角色移动的结果，然后将其添加到名为 SavedMoves 的缓冲\n\n此缓冲将保存的移动按最旧到最新的顺序排列，并用作队列，直至保存的移动可提交到服务器为止。提交之前，为缓解带宽压力，缓冲中的所有类似移动将合并成单个 FSavedMove_Character\n\n移动正等着与即将到来的移动相结合，那么参数 PendingMove 将用于存储移动\n\n当这些移动被确认或 ACK 后，会从缓冲中移除\n\n服务器可通过确认客户端位置有效来直接确认移动，客户端也可以在处理来自服务器的矫正时确认移动\n\n最新确认的移动保存在 LastAckedMove 中，以供处理未来的矫正时使用\n\n\n5.5.1.4 向服务器提交移动说明：\n\nReplicateMoveToServer 通过运行函数 CallServerMove 来完成，该函数接受队列中未获得服务器确认的最新和最旧移动\n这将执行向服务器提交移动的最后准备工作，先尝试提交旧移动（若适用），然后调用正确的ServerMove函数来提交新移动的最终移动\n最终ServerMove直接提交给 UCharacterMovementComponent 的所属角色，作为 不可靠的 服务器RPC\n\nServerMove函数不可靠的原因有二：\n\n正常游戏期间经常会调用ServerMove函数，如果它们被视为可靠，大量调用可靠函数可能会导致缓冲溢出，迫使所属玩家断开连接\n用于缓冲已保存移动的系统可确保传输进程中丢失的移动信息会被重新提交和计算，这为可靠函数提供了类似的安全保障，但却没有可靠RPC缓冲溢出的风险，并增加了一些规定来确保丢弃太旧的移动数据\n\n5.5.2 计算服务器上的移动说明：\n\n服务器不会定期tick移动来与游戏的tick循环同步，而是等待从自主代理处接收ServerMove调用\nServerMove_Implementation 处理服务器端的移动，重新构造客户端的移动并检查细微差异\n\n5.5.2.1 编译服务器预测数据\n角色移动组件的权威版本创建名为 ServerPredictionData 的 FNetworkPredictionData_Server_Character 对象，该对象在角色生命周期内存在\n在 ServerMove_Implementation 期间，此对象将存储信息，供以后的进程再现所属客户端的移动\n服务器接收数据时，此对象在后台被不断修改，参数包括：\n用于计算服务器差量时间的时间戳\n待定的客户端调整\n与解决时间差异相关的标记\n指示服务器确认还是矫正移动的标记\n\n\n可在FNetworkPredictionData_Server_Character 的API参考指南中查看它的参数和函数的完整列表\n\n5.5.2.2 验证客户端时间戳\n与ServerMove RPC一同发送的信息包括移动发生时的时间戳\n若服务器时间戳和客户端时间戳差异太大，客户端时间戳将视为已过期，移动将被丢弃\n否则该差异将标记为已解决，且 UCharacterMovementComponent 使用 ProcessClientTimeStampForTimeDiscrepancy 在下一步中创建差量时间的覆盖\n\n5.5.2.3 计算差量时间说明：\n\n差量时间通常是通过追踪当前tick与上一个tick之间经过的时间来获取\n但服务器上的角色并不使用 TickComponent 来计算移动\n\n原理：\n\nServerMove_Implementation 调用 GetServerMoveDeltaTime 并在收到ServerMove后计算移动\n若服务器预测数据被标记为尝试解决时间戳差异，它将使用 TimeDiscrepancyResolutionMoveDeltaOverride\n若无时间差异，则根据当前ServerMove RPC时间戳和最后一个ServerMove RPC时间戳之间的差异，使用服务器预测数据来创建差量时间\n为多一层安全，执行这些计算时多半使用服务器时间戳而非客户端时间戳，以防止客户端加快本地游戏时间进行速度作弊\n\n5.5.2.4 计算移动说明：\n\n服务器使用来自ServerMove RPC的数据重新构造所属玩家控制器的控制旋转\n然后调用函数 MoveAutonomous 来处理角色的加速、旋转和跳跃输入\n\n原理：\n\nMoveAutonomous 使用 PerformMovement 函数，根据之前重新构造的数据和上一步中提供的差量时间来模拟角色的移动物理效果\n服务器从获取ServerMove调用时自身角色副本所在的位置模拟运动，而非从客户端开始位置模拟\n\n注意：\n\n若角色正在计算来自动画的根运动，MoveAutonomous还会使用提供的差量时间tick角色的动画姿势\n所有动画事件都将相应触发。否则动画将正常tick\n\n5.5.3 处理客户端错误和矫正说明：\n\n服务器移动的工作原理是假设服务器和所属客户端在相同位置开始移动，且若服务器执行的移动与客户端报告的相同，则移动结束的位置也将相同\n若客户端的移动由于连接问题而丢失，或者客户端提交了错误数据，则两者的移动将在不同的位置结束，因此需要矫正\n函数 ServerMoveHandleClientError 负责这些操作\n\n5.5.3.1 确定是否需要调整说明：\n\n频繁发送矫正会导致带宽紧张，并导致客户端过于频繁地重新模拟大量已保存的移动\n因此要首先检查从 WithinUpdateDelayBounds 返回的值，查看移动间歇是否已超过最小时间量\n若返回 false，则不发出矫正，若返回true，则可运行其余进程\n\n原理：\n\n使用 ServerCheckClientError 查看服务器与客户端之间的误差是否大到需要矫正\n若返回true 或 bForceClientUpdate 因故被设为true而强制矫正，则 ServerMoveHandleClientError 将继续执行余下进程\n\n注：\n\n可在 BaseGame.ini 中找到用于调整这两个操作的参数，并可在 DefaultGame.ini 中提供项目特定的覆盖\n\nClientErrorUpdateRateLimit 值决定着服务器向客户端发送错误矫正的最小延迟（单位为秒）MAXPOSITIONERRORSQUARED 值是网络游戏中可接受未矫正最大位置误差的平方\n\n两者都可在配置文件的 [/Script/Engine.GameNetworkManager] 部分中找到\n\n若需要调整，服务器预测数据用从角色的服务器副本中采集的当前移动变量样本填充名为 PendingAdjustment 的 **FClientAdjustment**，包括位置、旋转、速度和可能充当角色移动基础的对象\n\n否则将 PendingAdjustment 的 bAckGoodMove 值设为 true，将客户端的移动标记为有效\n\n\n5.5.3.2 发送客户端调整或确认移动说明：\n\n确认到客户端的移动的最后一步由 SendClientAdjustment 完成\n此函数不作为 ServerMove_Implementation 的一部分，而是作为 UNetDriver::ServerReplicateActors 的一部分，在服务器端的tick结束时调用，并同样负责调用其他客户端调整RPC\n调用 SendClientAdjustment 时，操作方式将取决于之前步骤中编译的预测数据的标记方式\n\n作用：\n\n若服务器预测数据的 PendingAdjustment 的 bAckGoodMove 标记为 true，则将调用 ClientAckGoodMove RPC来确认移动，告知所属客户端机器上的自主代理该移动为有效\n这将从所属客户端的 SavedMoves 缓冲中移除原始移动，并将其记录为 LastAckedMove，用于编译未来的预测数据\n\n注：\n\n若 PendingAdjustment 的 bAckGoodMove 标记为false，则将调用客户端调整函数，将最终矫正发送到客户端\n\n5.5.3.3 自主代理接收客户端调整说明：\n\n客户端调整RPC包括 ClientAdjustPosition、ClientAdjustRotation、这两者在速度为零时发生的缩略版、以及这两者专用于根运动移动的版本\n作为 SendClientAdjustment 的一部分，服务器可调用多个此类函数，具体取决于待矫正内容的性质和严重程度\n每个此类函数都可告知 ClientPredictionData 在应用必要矫正后确认移动，且都会将 bUpdatePosition 标记为true\n\n注：\n\n然后在客户端的下一个 TickComponent 开始时使用 ClientUpdatePosition 应用最终矫正\n\n5.5.4 将移动复制到模拟代理说明：\n\n客户端机器上的角色（其所有者除外）为模拟代理，而非自主代理、\n由于模拟代理的唯一工作就是响应服务器，因此将移动从服务器复制到模拟代理的进程为高度简化\n从服务器接收移动更新时不会模拟运动物理效果，而是将其位置、旋转和速度设为服务器想要的值，并使用一些额外的进程让移动更流畅、更可信\n\n5.5.4.1 存储复制的移动信息说明：\n\nActor复制移动时，其不会直接复制自身的变换。所有Actor都维持名为 ReplicatedMovement 的复制变量，该变量使用结构FRepMovement\n\n作用：\n\n布尔 bReplicateMovement 由蓝图中的 Replicate Movement 变量表示，标记Actor将移动信息存储在此结构中，并将其复制到客户端\n\n客户端收到 ReplicatedMovement 的更新时，RepNotify 函数 OnRep_ReplicatedMovement 将解压缩存储的移动数据，并相应地更新Actor的位置和速度\n\n在蓝图中无法访问 ReplicatedMovement 或其 OnRep，但可在C++中覆盖 OnRep_ReplicatedMovement，还可在GetLifetimeReplicatedProps 中覆盖 ReplicatedMovement 的复制条件\n\n用户因此能够自定义移动复制在基于C++的Actor类中的行为\n\n在 ACharacter 中，仅为模拟代理复制 ReplicatedMovement 结构\n\n自主代理上会忽略此结构，而使用服务器移动和客户端调整RPC来处理移动\n\n\n注：\n\n若角色用另一个Actor作为基础，则将使用 ReplicatedBasedMovement，从而应用额外的逻辑来确保客户端是依据服务器而正确建立\n若角色使用根运动系统，则忽略所有这些进程，而倾向于使用 RepRootMotion\n\n5.5.4.2 在模拟代理上tick移动\n当 UCharacterMovementComponent 在模拟代理上运行 TickComponent 时，其将调用 SimulatedTick 来处理模拟移动的逻辑\n这不会执行上述复制移动。相反，SimulatedTick 会根据最近提供的复制移动数据继续移动\n执行标准移动物理效果时，调用 SimulateMovement 函数，然后使用 SmoothClientPosition 执行最终的验证和网络平滑\n\n5.5.4.3 执行模拟移动说明：\n\nSimulateMovement 函数负责移动模拟代理角色\n除了会被 SimulatedTick 调用，其还会被 OnRep_ReplicateMovement 调用\n此函数执行以下进程：\n调用所属角色的 GetReplicatedMovement 函数，以获取对 ReplicatedMovement 的引用\n执行安全检查，确保复制的移动数据有效，且客户端的基础被解析\n检查是否已收到网络更新\n从服务器应用通过 GetReplicatedMovementMode 获取的角色移动模式\n重置有关网络更新的所有标记\n基于当前 MovementMode 和角色的当前状态信息执行模拟移动的逻辑\n\n\n\n注：\n\n与标准运动物理效果相比，模拟运动的逻辑高度简化，因此主要包含在 SimulateMovement 函数本身中，不会分解成更小的函数\n但是，此函数仍负责更新角色的本地移动状态，包括应转换为哪个移动模式，角色是否已经降落至地面，以及应拥有的速度\n这些信息可确保角色正确更新动画，让动作看起来十分准确\n\n5.5.4.4 网络平滑说明：\n\n若单纯通过复制角色的位置和旋转来复制移动，则角色看起来每隔数分钟就会瞬移一次\n这是因为本地机器的渲染速率比网络发送数据速率更快\n举例而言，客户端可能以240 Hz刷新率渲染显示器，而复制的移动可能仅以30 Hz发送\n\n作用：\n\n网络平滑是使此运动平滑的进程，将角色从源位置逐渐向目标位置插入，而非立即将其对齐到目标位置\n源位置由角色当前位置提供，而目标位置由客户端预测数据提供\n内插本身在 SmoothClientPosition 中处理，使用NetworkSmoothingMode确定应使用的内插类型\n\n5.6 特殊移动情况\n包含常见特殊移动情况的信息，包括传送、自定义移动，以及可能在特殊技能中看到的代码驱动移动\n\n5.6.1 多人游戏中传送角色说明：可调用 SetLocation 函数或 Teleport 蓝图节点在网络游戏中传送角色\n\n必须在服务器上调用\n若使用 SetLocation 函数，将 bTeleport 变量设为true，使其将该移动视为传送\n\n\n\n若满足这些条件，移动会作为传送记录到服务器的预测数据和复制移动中，且所有客户端会将角色对齐到所需位置（而非应用平滑）来做出相应的响应\n\n5.6.2 自定义移动模式说明：移动模式 MOVE_Custom 会中止所有其他移动物理效果，可实现自定义移动逻辑，不受 UCharacterMovementComponent 正常进程的干扰\n作用：\n\nUCharacterMovementComponent 通常不可蓝图化，因此蓝图中的自定义移动通常是使用 UpdateCustomMovement 事件直接在角色内实现\n\n可使用 Custom Movement Mode 字节变量通过整数开关或自定义列举转换提供子模式\n\n\nUpdateCustomMovement 由 UCharacterMovementComponent 中的 PhysCustom 函数调用\n\n函数 StartNewPhysics、PhysCustom 和所有其他移动物理效果函数都是虚拟函数，因此若要在C++中创建自定义 UCharacterMovementComponent，可直接将其覆盖\n\n\n5.6.3 通根运动复制说明：\n\n有时需要在短时间内直接控制角色的移动，例如在使用 Gameplay Ability System 创建的技能发动期间、或在动画驱动操作发生期间\n虽然这在纯本地游戏中很容易做到，但复制的特殊移动情况需要使用根运动（通常指应用动画中的移动）\n根运动系统也已调整为允许代码驱动的特殊移动情况\n\n作用：\n\n无论 UCharacterMovementComponent 使用哪种运动模式，根运动始终优先于标准移动物理状态。完成根运动后将继续正常移动\n\n5.6.3.1 来自动画蒙太奇说明：\n\n根运动的大部分应用来自动画蒙太奇，而动画蒙太奇用于代码触发的一次性动画\n根运动的这种用法会中止角色正在执行的其他移动，直至动画结束\n角色从其骨架的根骨骼使用移动，并将其转换为场景空间的移动，使动画能够控制角色的移动方式\n完成这一步后，角色恢复使用普通物理效果\n\n注：\n\n若角色处于下落移动模式，即使角色正在执行根运动，重力仍将作用于角色的Z轴移动\n\n在上述复制进程中，根运动信息由 FSavedMove_Character 结构采集，包括作为其来源的动画蒙太奇、角色在蒙太奇中的轨迹位置，以及角色移动本身的参数\n\n\n服务器和所属客户端上的自主代理不会检查播放的动画是否相同，因为这通常被视为是一种装饰功能\n\n因此必须对游戏逻辑进行编程，确保所有动画蒙太奇都能在所有连接游戏的机器上正确触发\n但是模拟代理拥有上述进程的并行进程，用于同步基于根运动的移动\n\nGameplay Ability System插件将复制触发动画蒙太奇和根运动的技能，以此同步这些动画蒙太奇和根运动。\n5.6.3.2 来自根运动源说明：\n\n有时需要手动控制角色的位置来处理特殊情况\n举例而言，可能需要创造一种特殊技能，使角色跳到空中特定的高度，然后落到移动目标上\n\n原理：\n\n在standalone游戏中，可以用 SetLocation 和 SetRotation 手动控制角色，但在网络游戏中，上述复制进程无法捕捉此运动，因此服务器将把客户端的最终位置视为错误并发出矫正\n同时，来自动画蒙太奇的根运动仅遵循动画中预计算的运动\n这意味着根运动通常无法从游戏世界获取实时信息，比如其他角色的位置，而且也不能使用游戏变量进行轻松微调\n\n注：\n\n根运动源 为程序员提供了一种手动控制角色根运动的方法\n\n因此可以通过编程来控制角色的移动，同时还可以利用上述系统在联网期间处理根运动\n\n根运动源应应用于所属客户端上的自主代理\n\n\n使用：\n\n必须创建新的FRootMotionSource结构\n\n不同类型的移动对应不同的FRootMotionSource变体\n\n举例而言，FRootMotionSource_MoveToForce用于从开始位置到目标位置的直线移动，而FRootMotionSource_JumpForce遵循的是弹跳式弧线移动\n\n创建适当的根运动源后，可使用所需源位置、目标位置和移动行为相关参数将其属性初始化\n\n函数 UCharacterMovementComponent::ApplyRootMotionSource 将把根运动源应用于角色，并返回一个可供之后引用的柄\n\n根运动源本身不处理移动，而是由角色移动组件执行与所提供 FRootMotionSource 中参数一致的移动，以代替动画\n\n最终这将添加到 FSavedMove_Character 结构中的 SavedRootMotion，并在复制周期中采集，前提是 FRootMotionSource 应用于自主代理\n\n完成移动后，必须调用 UCharacterMovementComponent::RemoveRootMotionSource，使用从 ApplyRootMotionSource 返回的柄将其移除\n\n\nGameplay Ability System插件包含几个利用根运动源的技能任务，使技能可以执行复杂的程序化移动序列\n\n基础范例请参见 AbilityTask_ApplyRootMotionMoveToForce\n\n6. OnlineBeacon介绍：\n\nOnline Beacons 是一个特殊类型的 Actor，可提供一种简易的方式与服务器联络并进行交互（通过 RPC），而无需让普通游戏连接来执行此任务\n可以使用内置类，因为在一些情况下它们将被延展为自定义类，执行项目特定的交互、逻辑和信息请求\n\n6.1 OnlineBeacon 基类说明：\n\nBeacon 类执行的常规操作是请求服务质量信息\n在客户端需要加入的游戏中预留空位\n接收游戏中玩家名列表、\n获取正在进行的游戏中的得分和运行时间，等等\n\n6.1.1 AOnlineBeacon说明：\n\n这是 AOnlineBeaconClient 和 AOnlineBeaconHost 的基类\n它直接派生自 AActor\n\n6.1.2 AOnlineBeaconHost说明：\n\n此类使用其自身的 UNetDriver 获得来自远程客户端电脑的传入 Online Beacon 连接\n接收到连接时，它将在注册 AOnlineBeaconHostObject 实例列表中进行查找，找到与传入客户端匹配的实例并转交连接\n此类通常不需要被派生，因其只管理客户端和注册 AOnlineBeaconHostObject 之间的初始连接\n\n6.1.3 AOnlineBeaconClient说明：\n\n此类的子项连接到主机并执行实际的 RPC\n它们其中一个将在客户端电脑上生成，一个由正确的 AOnlineBeaconHostObject（注册到服务器的 AOnlineBeaconHost）在服务器上生成\nGetBeaconType 函数的输出（即为类名称）将用于对比此类的实例和正确主机对象类的注册实例\n\n注意：\n\n这和普通的 Actor 生成方式（服务器生成 Actor 然后复制到客户端）不同\n然而，客户端和服务器对象副本之间的连接建立后，对象复制将正常进行，任意一方均可向对方执行 RPC，而对象的服务器版本可对属性复制发送命令\n该基类实现 OnConnected 和 OnFailure 函数\n这两个函数可由子类覆盖，在连接时执行 RPC，或处理失败连接\n此类是 Online Beacon 系统的主力，将执行 Beacon 所需的客户端端的工作\n在成功连接事件中，服务器上将生成和源实例同步的另一个实例，此例也可执行服务器端的工作，通过客户端和服务器 RPC（或服务器到客户端的复制属性）进行协调和交流\n\n6.1.4 AOnlineBeaconHostObject说明：\n\n此类也应被覆盖，使其和覆盖的 AOnlineBeaconClient 类配对\n将客户端 GetBeaconType 的返回值和保存在 BeaconTypeName 成员变量中的值进行匹配即可完成配对\n服务器的 AOnlineBeaconHost 检测到传入 AOnlineBeaconClient 的配对 AOnlineBeaconHostObject 时，它将指示 AOnlineBeaconHostObject 通过虚拟 SpawnBeaconActor 函数生成 AOnlineBeaconClient 的本地副本\n此函数默认使用 ClientBeaconActorClass 成员变量确定要生成的 actor 类，此类应被设为配对的 AOnlineBeaconClient 类\n它还将在生成对象的服务器副本上调用 SetBeaconOwner，以便客户端对象的服务器端实例与主机对象进行交流\n此设置多数建立在基类中，无需被覆盖\n\n6.2 OnlineBeacon 范例说明：\n\n引擎中已自带大量预建 Beacon 类配对\n也可自行构建，Test Beacon 就是一个简单的好例子\nATestBeaconClient 派生自 AOnlineBeaconClient，ATestBeaconHost 派生自 AOnlineBeaconHostObject\n\n使用：Test Beacon 就是简单地在客户端和服务器之间来回执行重复的函数调用\n\n在 ATestBeaconHost 的构建函数中，ClientBeaconActorClass 设为 ATestBeaconClient 的类、BeaconTypeName 设为 ClientBeaconActorClass 的命名（调用 GetName 函数获得），这样可确保 AOnlineBeaconHost 将两个 Test Beacon 类正确配对\n客户端的 ATestBeaconClient 成功连上服务器时，服务器的 AOnlineBeaconHost 实例将指引注册 ATestBeaconHost 生成其自身的 ATestBeaconClient，并在服务器上将其和 ATestBeaconClient 关联， 这很重要，因为它使客户端和服务器 RPC 在两个 ATestBeaconClient 实例之间传递\n服务器的 ATestBeaconHost 将在它的 ATestBeaconClient 实例上调用 OnClientConnected（客户端 RPC）， 因为此函数为客户端 RPC，调用函数的命令将被传至客户端电脑，而不会在服务器上调用函数\nRPC 将在客户端的 ATestBeaconClient 实例上运行虚拟 OnConnected 函数，此函数已被覆盖，以便调用 ClientPing\nClientPing 将输出一些文本到调试日志，然后调用服务器 RPC ServerPong，它将在网络连接中传递，并在服务器的 ATestBeaconClient 实例上执行\nServerPong 将输出调试文本并调用 ClientPing，再触发对客户端联网 RPC 调用\n此过程将无限继续，这通常并非理想状态，尤其是这些 RPC 并未执行具体任务，它可用于记录相同 RPC 在两次分步运行之间的时间，以追踪服务器的 ping 时，因为可能存在延迟，所以这个 ping 检查不会按电脑和网络的最佳频率进行，或者客户端&#x2F;服务器可能直接在数次 ping 后直接停止返回 ping，其他的使用范例可能涉及到唯一的 RPC 回叫到客户端，而不是继续循环，如连续询问一连串的问题 该服务器的游戏使用的是哪张地图？或  这是一个夺旗服务器吗？，这些问题的内容视特定游戏或项目的相关信息而定\n\n7. 测试多人游戏介绍：\n\n更改编辑器的某些设置\n测试不同的多人场景\n\n7.1 设置玩家数量增加玩家数量\n\n单击 Play 按钮旁的下箭头，然后输入 Number of Players 的值\n\n\n默认情况下，服务器将使用 Selected Viewport 作为游戏窗口，并为添加的每位玩家创建新窗口\n\n\n\n7.2 调整游戏窗口为服务器调整窗口\n\n单击 Play 按钮旁的下箭头，然后选择 New Editor Window\n\n\n虽然模拟客户端拥有自己的窗口，但此设置还会模拟服务器创建独立窗口\n\n\n7.3 高级设置调整窗口大小\n\n单击 Play 按钮旁的下箭头，然后选择 Advanced Settings\n\n\n在 Play in New Window 部分下设置所需的窗口大小\n\n\nPlay in New Window 大小选项允许您设置所创建的窗口的大小和默认位置\n可以从若干预设窗口大小中选择或手动输入窗口大小（此例中，我们指定为 640x480)\n可以将所创建的窗口设置为 Left 和 Top 位置或单击 Always center window to screen 的复选框\n\n\n输入窗口大小后，当您在编辑器中玩游戏时，每个新窗口的大小相同。\n\n\n\n\n当在编辑器中使用每个游戏会话的新窗口玩游戏时，将注意到每个窗口顶部将显示玩家是服务器玩家还是客户端玩家\n同时，在 Play 模式下，移动窗口时，系统将为下次在编辑器会话中 Play 记住其位置（因此，无需一直移动窗口，这样使得更简单）\n\n7.4 多人选项Advanced Settings 中还包括用于设置附加多人选项的部分：\n\n\n\n\n选项\n说明\n\n\n\nNumber of Players\n此选项定义游戏启动时其中将生成的玩家数量编辑器和监听服务器均视为玩家，而专用服务器则不会客户端组成剩余玩家\n\n\nServer Game Options\n您可在此指定将作为 URL 参数传输到服务器的附加选项\n\n\nRun Dedicated Server\n如果选中，则将启动独立的专用服务器否则，第一个玩家将充当所有其他玩家均可连接的监听服务器\n\n\nRoute 1st Gamepad to 2nd Client\n在单个进程中运行多个玩家窗口时，此选项将决定游戏手柄输入的路由方式如果未选中（默认），第一个游戏手柄将连接到第一个窗口，第二个连接到第二个窗口，以此类推如果选中，则第一个游戏手柄将连接第二个窗口然后即可通过键盘&#x2F;鼠标控制第一个窗口，如果两人在同一台计算机上进行测试则十分便利\n\n\nUse Single Process\n此选项将在虚幻引擎 4 的单个实例中生成多个玩家窗口其加载速度更快，但也有存在更多问题的可能性。未选中此选项时，附加选项将可用\n\n\nCreate Audio Device for Every Player\n启用此选项将允许从每位玩家的角度渲染精确音频，但将占用更多 CPU 资源\n\n\nPlay In Editor Description\n此选项根据当前应用的多人设置说明玩游戏时将发生的事情\n\n\n\n当选中 Use Single Process 时，虚幻引擎 4 的单个实例中将生成多个窗口\n当未选中此选项时，将为分配的每位玩家启动多个 UE4 的实例，而且附加选项将可用：\n\n\n\n\n\n选项\n说明\n\n\n\nEditor Multiplayer Mode\n此选项是用于 Play In Editor（Play Offline、Play As Listen Server 或 Play As Client）的 NetMode\n\n\nCommand Line Arguments\n您可在此分配将传输到独立游戏实例的附加命令行选项\n\n\nMultiplayer Window Size (in pixels)\n定义生成附加独立游戏实例时所采用的宽度&#x2F;高度\n\n\n7.5 监听服务器与专用服务器介绍：启动多人游戏时，游戏托管方式有两种\n\n通过使用 Listen Server（默认设置），这表示拥有权限的机器也可以运行客户端，并可在为其他玩家托管时正常玩游戏\n通过使用 Dedicated Server，顾名思义，专用服务器仅专用于托管游戏，而没有本地玩家在此机器上玩游戏，因为连接的每位玩家均是客户端玩家\n\n\n通常情况下，相比作为监听服务器运行，作为专用服务器运行性能因为没有图像或输入而更优化\n默认情况下，在编辑器或独立游戏中玩游戏时，服务器类型设置为监听服务器\n\n使用：运行专用服务器\n\n单击 Play 按钮旁的下箭头，然后选中 Run Dedicated Server 复选框\n\n\n\n8. 蓝图中的多人功能8.1 Gameplay框架评估说明：要向游戏添加多人功能，必须理解引擎提供的主要Gameplay类的角色，以及它们彼此的协作关系，尤其是它们在多人情境下如何工作：\n\nGameInstance\nGameMode\nGameState\nPawn（以及从Pawn继承而来的Character）\nPlayerController\nPlayerState\n\n使用：参阅Gameplay框架文档以了解更多信息，但在设计多人游戏模式时，至少需要记住以下提示：\n\nGameInstance\n在引擎会话的持续时间内一直存在，意味着在引擎启动时创建，并在引擎关闭后才会销毁或更换\n服务器和每个客户端上都存在一个独立的GameInstance，这些实例彼此不通信\n由于GameInstance存在于游戏会话之外，并且是在关卡加载期间唯一存在的游戏结构体，因此非常适合于保存特定类型的持久数据，如终生玩家统计信息（如获胜总次数）、帐户信息（如特殊物品的锁定&#x2F;解锁状态），甚至在像《虚幻竞技场》等竞技游戏中，用来保存用来切换的地图列表\n\n\nGameMode\n对象仅存在于服务器上\n它通常存储客户端不需要明确知道的游戏信息\n例如，如果游戏有”仅火箭发射装置”等特殊规则，客户端或许不需要知道这条规则，但在地图上随机产生武器时，服务器需要知道仅从”火箭发射装置”类别中选取\n\n\nGameState\n存在于服务器和客户端上，因此服务器可以在GameState上使用复制变量让所有客户端保持最新的游戏数据\n与所有玩家和旁观者有关、而不是与任何一个特定玩家有关的信息最适合于GameState复制\n例如，棒球游戏可以通过GameState复制每个团队的分数和当前局次\n\n\nPlayerController\n每一台客户端上的每一个玩家存在一个PlayerController\n它们在服务器和关联的客户机之间进行复制，但不会复制到其他客户端，因此在服务器上每个玩家都有PlayerController，但本地客户端只有本地玩家的PlayerController\n客户端保持连接时存在PlayerController，PlayerController与Pawn关联，但不会像Pawn一样被销毁和重新产生\n它们非常适用于在客户端和服务器之间传达信息，而不必将该信息复制到其他客户端\n例如，服务器告知客户端对其迷你地图进行ping，以响应只有该玩家能检测到的游戏事件\n\n\nPlayerState\n服务器和客户端上存在与游戏相连的每个玩家的PlayerState\n这个类可以用于所有客户端感兴趣的复制属性，而不仅仅是所属客户端，如单个玩家在自由竞赛游戏中的当前分数\n与PlayerController类似，它们与单个Pawn关联，但不会像Pawn那样被销毁和重新产生\n\n\nPawn（包括Character）\n也存在于服务器和所有客户端上，可以包含复制变量和事件\n决定对特定变量或事件使用PlayerController、PlayerState还是Pawn取决于具体情况，但务必要记住的是，只要所属玩家保持与游戏相连，且游戏没有加载新关卡，则PlayerController和PlayerState就保持不变，而Pawn则不然\n例如，如果Pawn在游戏期间死亡，它通常会被销毁并替换为一个新Pawn，而PlayerController和PlayerState将持续存在，并在新Pawn产生后与新Pawn关联\n因此，Pawn的生命值将存储在Pawn自身上，因为该信息特定于该Pawn的实际实例，应在该Pawn替换为新Pawn时重置\n\n\n\n8.2 Actor复制\n\nUE4中的联网技术的核心是Actor复制\n“复制”标志设置为true的Actor将自动从服务器同步到与该服务器相连的客户端\n必须理解的一点是，Actor仅从服务器复制到客户端，而不能从客户端复制到服务器\n当然，客户端仍需要能够向服务器发送数据，它们通过复制的”在服务上运行”事件来实现\n\n请参阅概在蓝图中同步 Actor指南以了解具体示例的逐步演示，以及Actor 的复制文档\n8.2.1 权限\n对于场景中的每个Actor，会将其中一个连接的玩家视为拥有对该Actor的权限\n对于服务器上存在的每个Actor，服务器拥有对该Actor的权限，包括所有复制的Actor\n因此，拥有权限 函数在客户端上运行，而目标是复制到客户端的Actor时，将返回false\n你还可以使用 切换拥有权限 便捷宏，作为针对复制Actor中不同服务器和客户端行为进行分支的快捷方法\n\n\n8.2.2 变量\n在Actor上的变量的细节面板中，有一个 复制（Replication） 下拉列表，让你可以控制如何复制变量\n\n\n\n\n\n选项\n说明\n\n\n\n无（None）\n这是新变量的默认值，表示不通过网络向客户端发送值\n\n\n复制（Replicated）\n服务器复制该Actor时，它会将该变量发送到客户端。接收客户端上的变量值将自动更新，因此下一次访问该客户端时，它会反映服务器上的值当然，在真实网络上游戏时，更新会有所延迟，具体取决于网络的延迟时间请记住，复制的变量仅沿一个方向传递，从服务器到客户端！要从客户端向服务器发送数据，请参见”事件”部分\n\n\n复制通知（RepNotify）\n变量将按照”复制”（Replicated）选项进行复制，此外，还将在蓝图中创建OnRep_函数当该变量的值发生变化时，引擎会自动在客户端和服务器上调用该函数你可以根据游戏需要随意实现该函数 \n\n\n\n引擎内置类中的许多变量已经启用了复制，因此许多功能在多人情境下会自动工作\n\n请参阅概在蓝图中同步变量指南以了解具体变量复制示例的逐步演示，以及属性复制文档\n8.2.3 产生和销毁介绍：\n\n在服务器上产生复制的Actor时，这个信息会传达给客户端，他们也会自动产生该Actor的副本\n但总体而言，由于不会从客户端复制到服务器，因此如果在客户端上产生了复制的Actor，则该Actor只会存在于产生这个Actor的客户端上\n\n影响：\n\n服务器和任何其他客户端都不会收到该Actor的副本\n但产生客户端拥有对该Actor的权限\n这对于某些Actor还是十分有用的，比如对Gameplay没有实际影响的装饰Actor，但对于会影响Gameplay并应当复制的Actor，最好确保在服务器上产生这类Actor\n\n销毁复制的Actor也属于类似情况：\n\n如果服务器销毁一个复制的Actor，则所有客户端也会销毁相应的副本\n客户端可以随意销毁他们拥有权限的Actor，即，客户端自己产生的Actor，因为这些Actor不会复制到其他玩家，也不会影响其他玩家\n如果客户端尝试销毁没有权限的Actor，这个销毁请求会被忽略\n关键在于，产生Actor亦是如此：如果你需要销毁复制的Actor，则需要在服务器上销毁\n\n8.3 事件复制介绍：\n\n在蓝图中，除了复制Actor及其变量，还可以跨客户端和服务器运行事件\n\n请参阅在蓝图中使用远程调用函数指南以了解具体示例的逐步演示，以及RPC文档\n注：\n\n可能还会看到RPC（远程过程调用）一词\n如果看到，只需注意蓝图中的复制事件基本上编译到引擎中的RPC，这是C++中的常用说法\n\n8.3.1 所有权介绍：\n\n在使用多人时需要理解的一个重要概念是（尤其是在使用复制事件时），哪个连接被视为特定Actor或组件的所有者\n\n就我们的目的而言，需要知道”在服务器上运行”事件只会从客户端拥有的Actor（或其组件）调用\n\n通常，这表示只能从以下Actor或其中某个Actor的组件发送”在服务器上运行”事件：\n\n客户端本身的PlayerController\n\n客户端PlayerController支配的Pawn\n\n客户端的PlayerState\n\n\n\n\n注：\n\n同样，对于发送”在所属客户端上运行”事件的服务器，这些事件也应当在上述某个Actor上调用\n否则，服务器不知道要将事件发送到哪个客户端，这样就只会在服务器上运行\n\n8.3.2 事件\n在自定义事件的细节面板中，你可以设置如何复制事件\n\n\n\n\n\n选项\n说明\n\n\n\n不复制（Not Replicated）\n这是默认值，表示该事件不进行复制如果在客户端上调用，它仅在该客户端上运行，如果在服务器上调用，则仅在服务器上运行\n\n\n组播（Multicast）\n如果在服务器上调用组播事件，则该事件将复制到所有连接的客户端，无论拥有目标对象的是哪个连接如果客户端调用组播事件，该事件会被视为未复制，并仅在调用该事件的客户端上运行\n\n\n在服务器上运行（Run on Server）\n如果从服务器调用该事件，则仅在该服务器上运行如果从客户端调用，并且目标归该客户端所有，则事件将复制到服务器并在服务器上运行“在服务器上运行”事件是客户端向服务器发送数据的主要方法\n\n\n在所属客户端上运行（Run on Owning Client）\n如果从服务器调用，则该事件将在拥有目标Actor的客户端上运行由于服务器可以拥有Actor本身，因此”在所属客户端上运行”事件实际上可以在服务器上运行，而无论名称为何如果从客户端调用，该事件会被视为未复制，并仅在调用该事件的客户端上运行\n\n\n以下各表描述了不同复制模式根据调用方式对事件运行位置的影响\n\n如果事件从服务器调用，假设左列是目标，则运行位置将是…\n\n\n\n\n\n未复制\n组播\n在服务器上运行\n在所属客户端上运行\n\n\n\n客户端拥有目标\n服务器\n服务器和所有客户端\n服务器\n目标的所属客户端\n\n\n服务器拥有目标\n服务器\n服务器和所有客户端\n服务器\n服务器\n\n\n无主目标\n服务器\n服务器和所有客户端\n服务器\n服务器\n\n\n\n如果事件从客户端调用，假设左列是目标，则运行位置将是…\n\n\n\n\n\n未复制\n组播\n在服务器上运行\n在所属客户端上运行\n\n\n\n目标归调用客户端所有\n调用客户端\n调用客户端\n服务器\n调用客户端\n\n\n目标归其他客户端所有\n调用客户端\n调用客户端\n丢弃\n调用客户端\n\n\n服务器拥有目标\n调用客户端\n调用客户端\n丢弃\n调用客户端\n\n\n无主目标\n调用客户端\n调用客户端\n丢弃\n调用客户端\n\n\n\n从上表可见，任何从一个客户端调用并且没有设为”在服务器上运行”的事件都被视为没有复制\n\n注：\n\n从客户端向服务器发送复制的事件是唯一一种从客户端向服务器传达信息的方法，因为一般的Actor复制设计为仅从服务器到客户端\n\n此外，还需注意组播事件只能从服务器发送\n\n虚幻采用客户端-服务器模型，因此客户端不会直接连接任何其他客户端，它们只是连接到服务器\n\n因此，客户端无法直接向其他客户端发送组播事件，只能与服务器通信\n\n但你可以使用两个复制事件来模拟这种行为：一个”在服务器上运行”事件和一个”组播”事件\n\n“在服务器上运行”事件实现可以在需要时执行验证，然后调用组播事件\n\n“组播”事件实现将执行你想要对所有连接玩家运行的逻辑\n\n下图代表了不执行任何验证的示例：\n\n\n\n8.3.2.1 “进行中加入”注意事项说明：\n\n在使用复制事件以传达游戏状态更改时需要记住的一点是它们如何与支持”进行中加入”的游戏交互\n如果玩家在游戏进行期间加入游戏，则加入前发生的任何复制事件都不会对新玩家执行\n重点是，如果你希望游戏正确地支持”进行中加入”，通常最好通过复制的变量同步重要的Gameplay数据\n经常用的一种模式是客户端在场景中执行一些操作，通过”在服务器上运行”事件将操作通知给服务器，然后在该事件的实现中，服务器根据该操作更新一些复制的变量\n然后没有执行该操作的其他客户端仍会通过复制的变量看到操作结果\n此外，任何在操作发生后在进行期间加入的客户端仍会看到场景的正确状态，因为它们从服务器获得了最新的复制变量值\n如果服务器仅发送事件，则进行中加入的玩家不会知道之前执行的操作\n\n8.3.2.2 可靠性介绍：\n\n对于任何复制的事件，你可以选择是 可靠 还是 不可靠\n\n可靠事件：\n\n可靠事件保证可到达目标（假设遵守上述所有权规则），但为了兑现这个承诺，它们会使用更多带宽，还可能会存在延迟\n尽可能频繁地尝试避免发送可靠事件，例如每个tick事件，因为引擎的内部可靠事件缓冲区可能会溢出，如果溢出，则关联的玩家会断开连接\n\n不可靠事件：\n\n不可靠事件顾名思义，它们不能到达目标，比如网络上丢包，或者引擎确定有许多更高优先级的流量需要发送\n因此，不可靠事件使用的带宽低于可靠事件，你可以更频繁地安全调用此类事件\n\n9. Replication Graph介绍：\n\n概述Replication Graph功能\nReplication Graph节点\n\n说明：\n\nReplication Graph 插件是一个用于多人游戏的网络复制系统，它的设计可以很好地适应大量玩家和复制Actor\n例如，Epic自己的Fortnite Battle Royale从一开始就支持每场比赛100名玩家，包含大约50,000个复制的Actor\n标准的网络复制策略（要求每个复制的Actor决定是否应该向每个连接的客户端发送更新）在这种情况下表现很差，并且会限制服务器的CPU\n像将Actor划分为交错的组，或者只是降低更新频率，这样的解决方案可能会缓解这个问题，但降低更新频率也会降低客户端体验\nReplication Graph消除了Actor单独评估每个连接的客户端的需要，同时在不牺牲客户端体验的情况下，解决了CPU性能问题\n\n9.1 结构介绍：\n\nReplication Graph包含一系列 Replication Graph节点，它们负责按需创建要复制到每个客户端的Actor列表\n由于此系统是由持久对象构建的，而不是仅仅由复制的Actor自己处理函数调用，因此数据可以跨多个帧存储并在客户端连接之间共享\n这种持久、共享的数据减少了Replication Graph系统为每个客户端生成复制列表所需的时间\n\n说明：\n\nReplication Graph节点（我们简称为”节点”）执行以下实际工作：确定哪些Actor可能需要更新、将它们分组、存储要发送到客户端的预计算列表等\n它们的最终任务是，尽可能快地为每个客户端连接按需提供Actor”复制列表”，以便服务器在每个Actor、每个客户端上花费尽可能少的CPU周期\n每个节点都可以以一种独特的方式运行，鼓励开发者根据需要为自己的游戏编写自定义节点\n节点可能与游戏无关，也可能利用特定于游戏的信息\n根据Actor在游戏中的角色将它们放到不同的节点中，可以让你更好地控制它们复制的方式和时间\n构建新节点，并根据Actor在游戏中的行为方式使用Replication Graph将Actor分配到最佳节点，这将极大地减少服务器CPU为准备网络复制列表所花费的时间\n\n9.2 启用此系统你可以通过以下两种方式之一，配置你的项目使用自定义 Replication Driver（Replication Graph的父类）：\n\n在”DefaultEngine.ini”文件中指定Replication Driver类\n将返回Replication Driver类实例的函数绑定到Replication Driver的默认创建委托\n\n注：\n\nShooterGame项目是如何设置和实现Replication Graph的一个很好的示例\n但是，请注意Replication Graph在控制台版本中是禁用的，因为它目前不适用于分屏游戏\n\n9.2.1 配置(.ini)文件使用：\n\n要配置引擎的默认Replication Driver\n\n打开项目的”DefaultEngine.ini”文件\n\n找到（或添加）[/Script/OnlineSubsystemUtils.IpNetDriver]部分，并设置（或添加）”ReplicationDriverClassName”条目，以便它指示希望使用的Replication Driver（或Replication Graph）类的名称\n\n这应该大致如下所示，用实际项目的名称替换”ProjectName”，用自定义类名称替换”ClassName”：\n[&#x2F;Script&#x2F;OnlineSubsystemUtils.IpNetDriver]\nReplicationDriverClassName&#x3D;&quot;&#x2F;Script&#x2F;ProjectName.ClassName&quot;\n\n\n\n9.2.2 在代码中绑定使用：\n\n如果你的项目有多个游戏模式或地图，而这些模式或地图的网络要求有很大的不同，那么绑定到委托将使你能够在代码中为当前游戏模式或地图创建适当的Replication Driver\n\n要使用此方法，将一个函数绑定到名为CreateReplicationDriverDelegate的UReplicationDriver函数\n\n绑定函数必须返回所需Replication Driver类的一个有效实例，就像下面的lambda函数示例所做的：\nUReplicationDriver::CreateReplicationDriverDelegate().BindLambda([](UNetDriver* ForNetDriver, const FURL&amp; URL, UWorld* World) -&gt; UReplicationDriver*\n&#123;\n\treturn NewObject&lt;UMyReplicationDriverClass&gt;(GetTransientPackage());\n&#125;);\n\n9.3 高级示例说明：\n\n对于具有大量连接客户端甚至更多同步Actor的游戏而言，根据不同节点的类型和状态分配Actor的Replication Graph可以节省大量CPU时间\n\n这使得构建传统复制方法无法实现的游戏成为可能\n\n在概念层面上，这种规模的游戏可以构建具有以下功能的Replication Graph和Replication Graph节点，以处理数量庞大的复制Actor和连接客户端：\n\n根据位置将Actor分组\n\n场景可以划分为游戏的网格空间（在大逃杀、MOBA或MMORPG流派游戏中），预定义房间或区域（对于地牢爬行游戏或走廊风格的第一人称或第三人称射击游戏），或任何适合你游戏空间的方法\n将Actor添加到每个网格单元或房间中，以便可以从其中潜在地看到或听到Actor，这将加快客户端的更新速度，因为节点可以简单地为客户端摄像机所在的任何网格单元或房间内，向客户端提供持久性Actor列表\n\n\n确定”休眠”放置的Actor，并将它们放在单独的列表中\n\n虽然一些Actor，比如那些表示玩家或由AI控制角色的Actor，可能需要频繁的更新，但也有许多Actor可能是预先放置在关卡中的，在玩家与它们交互之前，它们是不会自己移动或改变状态的\n这些Actor可能会维持很长时间（可能是整个游戏会话），而无需发送网络更新\n例如，在Fortnite Battle Royale中，玩家和发射物可能会不断地更新，直到从游戏中移除为止\n另一方面，树可能会休眠很长时间，无需对任何客户端进行更新\n当树被损坏时，任何能够看到树的客户端都会需要接收关于此树的更新\n最后，当树被销毁时，任何接收描述树被销毁更新的客户端都不需要接收关于此树的任何进一步更新\n\n\n如果你游戏中的角色 能够拾取并携带物品，随物品的携带者一起更新这些物品\n\n当一个玩家取出一个物品或者武器并携带它，或者穿一件衣服或盔甲时，将表示该物品的Actor（假设这是一个单独的Actor，而不仅仅是一个组件）添加到一个特殊组，该组始终在拥有玩家更新时进行更新，否则绝不进行更新\n\n\n制定所有客户端始终已知的特殊Actor的列表\n\n特殊Actor始终通过与每个玩家相关，并且可以放在一个简单的节点中来跟踪这些Actor，这样就可以将它们排除在其他列表之外，它们可能会占用CPU周期来进行不必要的计算\n\n\n制定始终（或从不）与特定客户端相关的特殊Actor的列表\n\n可以为单个玩家或玩家团队创建一个类似的始终相关的列表节点\n这对于类似以下情况特别有用：确保玩家的队友始终更新，或者通过特殊的游戏内检测能力”暴露”对手，使对手对玩家的整个团队都是可见。如果”暴露”到期，可以将这些Actor添加回它们的默认节点\n\n\n\n\n\n注：\n\n构建一个Replication Graph，并根据对Actor在游戏中角色的了解，明智地将Actor分配到不同的节点，这可以充分利用服务器的CPU时间\n最终的结果是为游戏提供稳定的服务器性能，否则游戏将无法在当前硬件上运行\nReplication Graph插件包含几个Replication Graph节点类，你可以在大型在线游戏中使用它们\n此外，鼓励开发者基于对特定游戏内部工作原理的了解来构建自定义节点类\n\n10. 多人游戏中的关卡切换10.1 无缝与非无缝切换介绍：\n\nUE4 中主要有两种转移方式：\n无缝和非无缝方式\n两者的主要区别在于，无缝转移是一种非阻塞（non-blocking）操作，而非无缝转移则是一种阻塞（blocking）操作\n\n\n当客户端执行非无缝转移时，客户端将与服务器断开连接，然后重新连接到同一服务器，而服务器将准备新的地图以供加载\n\n建议：\n\nUE4 多人模式游戏尽量采用无缝转移\n这样做通常可以提供更流畅的体验，同时避免重新连接过程中可能出现的问题\n\n有三种情形中必然产生非无缝转移：\n\n初次加载地图时\n初次作为客户端连接服务器时\n想要终止一个多人模式游戏并启动新游戏时\n\n有三个用来驱动转移的主要函数：UEngine::Browse、UWorld::ServerTravel 和 APlayerController::ClientTravel\n在确定使用哪个函数时，您可能会感到有些困惑，所以请遵循下面的准则：\n详细：\nUEngine::Browse\n\n就像是加载新地图时的硬重置\n将始终导致非无缝切换\n将导致服务器在切换到目标地图前与当前客户端断开连接\n客户端将与当前服务器断开连接\n专用服务器无法切换至其他服务器，因此地图必须存储在本地（不能是 URL）\n\nUWorld::ServerTravel\n\n仅适用于服务器\n会将服务器跳转到新的世界&#x2F;场景\n所有连接的客户端都会跟随\n这就是多人游戏在地图之间转移时所用的方法，而服务器将负责调用此函数\n服务器将为所有已连接的客户端玩家调用 APlayerController::ClientTravel\n\nAPlayerController::ClientTravel\n\n如果从客户端调用，则转移到新的服务器\n如果从服务器调用，则要求特定客户端转移到新地图（但仍然连接到当前服务器）\n\n10.2 启用无缝切换前提：启用无缝切换，您需要设置一个过渡地图\n\n需要通过 UGameMapsSettings::TransitionMap 属性进行配置\n该属性默认为空，如果您的游戏保持这一默认状态，就会为过渡地图创建一个空地图\n\n原理：\n\n因为必须始终有一个被加载的世界（用于存放地图），所以在加载新地图之前，我们不能释放原有的地图\n由于地图可能会非常大，因此让新旧地图同时存放在存储器内绝对是个坏主意，这时就需要过渡地图来帮忙了\n\n好处：由于过渡地图非常小，因此在”中转”当前地图和最终地图时不会造成太大的资源消耗\n注意：设置好过渡地图后，您需要将 AGameModeBase::bUseSeamlessTravel 设置为 true，这样就可以实现无缝切换了\n10.3 无缝切换流程下面是执行无缝切换时的一般流程：\n\n标记出要在过渡关卡中存留的 actor（更多信息请见下面）\n转移到过渡关卡\n标记出要在最终关卡中存留的 actor（更多信息请见下面）\n转移到最终关卡\n\n10.4 无缝切换中的存留 Actor介绍：\n\n在使用无缝切换时，可以将（存留） actor 从当前关卡带到新的关卡\n\n这适用于一些特定的 actor，如道具栏物品和玩家等\n\n\n默认情况下，这些 actor 将自动存留：\n\nGameMode actor（仅限服务器）\n通过 AGameModeBase::GetSeamlessTravelActorList 额外添加的任何 actor\n\n\n拥有一个有效的 PlayerState （仅限服务器）的所有控制器\n所有 PlayerControllers （仅限服务器）\n所有本地 PlayerControllers （服务器和客户端）\n通过 APlayerController::GetSeamlessTravelActorList （在本地PlayerControllers上调用）额外添加的任何 actor\n\n\n\n11. 网络性能分析工具介绍：\n\nNetwork Profiler 是一款独立工具，可用于显示网络流量和性能信息，上述信息可在游戏运行时由引擎捕捉\n它是一种极其有效的方式，可识别多人游戏中占用极高带宽的区域，因为您可以查看各个 actor、PRC 和属性在总带宽中的占比\n\n11.1 录制分析会话前提：\n\n在使用 network profiler 之前，您必须录制相同的数据才能进行分析\n\n为此，您需要使用启用了进程状态跟踪功能的引擎，通常这说明是个调试 build、用于非调试配置或编辑器 build（更具体地来说，对引擎进行编译时，STATS 宏已定义为非零值）\n\n还可以在引擎启动的时候增加 “networkprofiler&#x3D;true” 命令行参数，以便于引擎已启动就能够开始记录，也可以用以下这些命令行指令在运行时控制是否要记录网络数据：\n\nnetprofile：切换录制的开启和关闭\n\nnetprofile enable：如果尚未录制，则开始录制\n\nnetprofile disable：如果当前在录制，则停止录制\n\n\n\n\n使用：\n\n数据将被保存至 &lt;project directory&gt;/Saved/Profiling/&lt;project name&gt;-&lt;timestamp&gt;.nprof\n如果您在相同文件夹中看到一个名为 NetworkProfiling.tmp 的文件，这只是引擎在收集数据时使用的临时文件\n当前分析会话停止时，该文件将根据以上方案进行重命名，然后即可在独立工具中打开它\n\n11.2 查看分析会话Chart, Filters, Details选项卡\n\n默认条件下，选定的是 “Chart, Filters, Details（图表、筛选器和详细信息）” 选项卡\n下文将对此选项卡的不同区域进行介绍\n\n\n\n图表视图\n统计数据列表\n汇总视图\n帧详细信息\n筛选器\n性能视图\n\n图表视图\n\n这是主图表视图。它类似于其他分析应用程序中的图表，可显示随时间推移已启用统计数据的图表\n单击特定帧可使用该帧相关数据填充其他视图，也可在图表上点击并拖动以放大相应区域，并查看该时间范围内的汇总情况。\n\n统计数据列表\n\n该列表中包含了 network profiler 所跟踪的所有统计数据\n切换复选框将显示或隐藏图表中的特定统计数据。对于大多数统计数据，您可选择原始计数、每秒计数、字节数或每秒字节数\n\n汇总视图\n\n该视图中显示图表中所选时间范围内的数据汇总\n其中显示了原始总数以及每秒信息\n注意，”Outgoing bandwidth（输出带宽）” 将大于 “Game socket send size（游戏套接字发送大小）”，因为 “Outgoing bandwidth（输出带宽）” 也包括了 IP 和 UDP 标头大小的近似值\n\n帧详细信息\n\n该视图对当前选定帧所发送的数据进行了分类统计\n可以查看发送了哪些 actor、属性和远程函数，以及各项分别占到多少字节\n注意，数据组中包括了 actor 和 PRC，因此 “SEND BUNCH” 部分中的 “NumBytes” 字段中包含了 “SEND RPC” 和 “REPLICATE ACTOR” 部分的字节\n最后，”SOCKET SEND TO” 条目将精确显示引擎发送到输出套接字的字节数\n注意，此处不包含标准 UDP 数据包资源消耗\n\n筛选器\n\n可为 actor、属性和 RPC 输入筛选器，在单击 “Apply Filters（应用筛选器）” 按钮后，图表将更新为只显示包含筛选器字段中输入文本的相关 actor、属性和 RPC\n在应用了筛选器之后，选择图表中的单个帧或一系列帧也将相应地筛选汇总和帧详细信息视图中的数据\n\n性能视图\n\n选择了图表中的单个帧时，该视图将显示该帧内复制的 actor 类型列表，并按照 CPU 复制它们所需的时间排序\n如果某个 actor 具有相关的复制属性，则展开该 actor 的树形视图将显示各属性\n在 actor 选项卡中，第一栏数值表示 CPU 复制该 actor 所花费的时间（以毫秒计）\n第二栏是用于表示数据包中 actor 的字节数，第三栏是当前帧中复制的指定类型的 actor 数\n在属性行中，第一列是用于属性的字节数，第二列表示为 actor 复制了多少具有指定名称的属性\n\n&quot;Actors&quot; 选项卡、&quot;Properties（属性）&quot; 选项卡和 &quot;RPCs&quot; 选项卡\n\n\n每个选项卡都显示了整个分析会话中各复制数据的汇总情况\n注意，这些选项卡中显示的数据不受 “Chart, Filters, Details” 选项卡的图表中选定的当前帧或时间范围的影响\n选项卡上分别显示了 actor、属性或 PRC 的列表\n“Total Size（总体大小）” 和 “Average Size（平均大小）” 列显示了特定项需要多少带宽，”Count（计数）” 列表示在分析会话期间复制了多少次特定项。单击各列的表头，可在升序或降序之间切换\n\n11.3 服务器和客户端\n从客户端和服务器都可录制分析数据\n但是，请注意，由于只有服务器复制 actor 及其属性，因此在查看客户端上录制的分析数据时，只能看到从该客户端发送的 RPC 的详细数据\n\n12. 性能与带宽提示介绍：\n\n复制 actor 是一件耗费时间的工作\n\n引擎会尽量让这个过程变得更有效率，但您也可以做一些额外的工作来简化这个过程\n\n\n使用：在收集 actor 用于复制时，服务器将检查一些事项，如相关性、更新频度、休眠情况等。您可以调整这些检查项以改善性能\n要最大限度提升这一过程的效率，最好是遵循以下优先顺序：\n\n关闭复制（AActor::SetReplicates( false )）\n当 actor 未进行复制时，它最初不会出现在列表中，我们可以充分利用这一点，确保那些无需复制的 actor 会有相应标记\n\n\n减少 NetUpdateFrequency 值\nactor 的更新次数越少，更新所用的时间就越短\n最好是尽量压低这个数值。该数值代表了这个 actor 每秒复制到客户端的频度\n\n\n休眠情况\n相关性\nNetClientTicksPerSecond\n\n注：\n\n如果属性并非是绝对必需，则不要将其标记为复制\n\n如果可以，最好能尝试从现有的已复制属性中派生状态\n\n尝试利用已有的量化函数，如 FVector_NetQuantize\n\n这样能大大减少向客户端复制此状态时所需的大小，如果使用得当，就不会导致任何明显的偏差\n\nFName 一般不会被压缩，所以在使用它们作为 RPC 的参数时，请记住它们通常会向字符串发送所有调用\n\n这会产生很大的资源消耗\n\n\n","slug":"7_UE4联网和多人游戏_05","date":"2022-10-06T07:28:25.963Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"8d0c33a1aee99d366309310c2d2adece","title":"UE4 功能整理","content":"UE4 功能整理1. SpawnActor情景：\n\n我有一个Cpp类\n这个Cpp类要生成一个其他Cpp或蓝图类\n可以使用TSubclassOf&lt;&gt;\n\n示例：\n\n定义\nprivate:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;AActor&gt; SpawnActorTest;\n\n实现\nvoid AActor_SpawnTest::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tFActorSpawnParameters SpawnParameters;\n\tSpawnParameters.Name &#x3D; FName(&quot;SpawnActorTest&quot;);\n\tSpawnParameters.Owner &#x3D; this;\n\tSpawnParameters.Instigator &#x3D; nullptr;\n    \n\tGetWorld()-&gt;SpawnActor&lt;AActor&gt;(SpawnActorTest, GetActorTransform(), SpawnParameters);\n&#125;\n\n说明：\n\n定义中的SpawnActorTest是私有变量，若要保持私有，其蓝图可以Get, Set和参数列表中显示继承中：\n\nUPOPERTY()中加入BlueprintReadWrite，meta=(AllowPrivateAccess=true)\n\n\nFActorSpawnParameters是可以自定义生成参数，默认可以不写\n\nGetActorTransform()可以是GetActorLocation和GetActorRotation\n\n\n2. LineTrace\nTrace模式\nTraceSingle 单个结果\nTraceMulti 多个结果\n\n\nTrace 的检测依据\nByChanne\nByObjectType\nByProfile\n\n\n\n2.1 UWorldLineTraceSingleByChannel\n情景：\n\n场景中的某个Actor需要发射检测射线\n可以直接在Actor上写，也可以通过组件SceneComponent，ActorComponent\n示例采用SceneComponent\n\nSyntax：\nbool LineTraceSingleByChannel(\n\tstruct FHitResult&amp; OutHit,\n\tconst FVector&amp; Start,\n\tconst FVector&amp; End,\n\tECollisionChannel TraceChannel,\n\tconst FCollisionQueryParams&amp; Params &#x3D; FCollisionQueryParams::DefaultQueryParam,\n\tconst FCollisionResponseParams&amp; ResponseParam &#x3D; FCollisionResponseParams::DefaultResponseParam\n) const;\n\n\n\n示例：\n\n定义\nprivate:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Trace&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceDistance;\n\n实现\nconst FVector Start &#x3D; GetOwner()-&gt;GetActorLocation();\nconst FVector End &#x3D; Start + (GetForwardVector() * TraceDistance);\n\nFHitResult HitResult;\nconst bool IsHit &#x3D; GetWorld()-&gt;LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility);\n\nDrawDebugLine(GetWorld(), Start, End, FColor::Red, false, 0.5f);\n\nif (!IsHit)&#123;return;&#125;\nGEngine-&gt;AddOnScreenDebugMessage(-1, 1.f, FColor::Green,\n\t\tFString::Printf(TEXT(&quot;Trace Hit: %s&quot;), *HitResult.GetActor()-&gt;GetName()));\n\n说明：\n\nHitResult会包含射线检测到的Actor的信息\n\n2.2 Kismet2.2.1 LineTraceSingle情景：\n\n根据 Channel 检测单个物体\n\nSyntax：\nstatic bool LineTraceSingle(\n\tconst UObject* WorldContextObject,\n\tconst FVector Start,\n\tconst FVector End, \n\tETraceTypeQuery TraceChannel, \n\tbool bTraceComplex, \n\tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore, \n\tEDrawDebugTrace::Type DrawDebugType,\n\tFHitResult&amp; OutHit, \n\tbool bIgnoreSelf, \n\tFLinearColor TraceColor &#x3D; FLinearColor::Red, \n\tFLinearColor TraceHitColor &#x3D; FLinearColor::Green, \n\tfloat DrawTime &#x3D; 5.0f\n);\n\n\n\n示例：\n\n定义：\nprivate:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Trace&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceDistance;\n\n\n\n实现：\nconst FVector Start &#x3D; GetOwner()-&gt;GetActorLocation();\nconst FVector End &#x3D; Start + (GetForwardVector() * TraceDistance);\n\nFHitResult HitResult;\nconst TArray&lt;AActor*&gt; ActorsToIgnore;\nconst bool IsHit &#x3D; UKismetSystemLibrary::LineTraceSingle(\n\t\tthis, Start, End, TraceTypeQuery1,\n\t\tfalse, ActorsToIgnore, EDrawDebugTrace::ForDuration, HitResult, true,\n\t\tFLinearColor::Red, FLinearColor::Green, 1.f);\n\nif (!IsHit)&#123;return;&#125;\nGEngine-&gt;AddOnScreenDebugMessage(-1, 1.f, FColor::Green,\n\t\tFString::Printf(TEXT(&quot;Trace Hit: %s&quot;), *HitResult.GetActor()-&gt;GetName()));\n\n说明：\n\nETraceTypeQuery 说明\n默认 TraceTypeQuery1 —— Visibility\n默认 TraceTypeQuery2 —— Camera\n可在 ProjectSettings-&gt;Engine-&gt;Collision-&gt;Trace Channels 添加自定义\n\n\n\n2.2.2 LineTraceSingleForObjects情景：\n\n根据 Object Type 检测单个物体\n\nSyntax\nstatic bool LineTraceSingleForObjects(\n\tconst UObject* WorldContextObject,\n\tconst FVector Start,\n\tconst FVector End,\n\tconst TArray&lt;TEnumAsByte&lt;EObjectTypeQuery&gt; &gt; &amp; ObjectTypes,\n\tbool bTraceComplex,\n\tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore,\n\tEDrawDebugTrace::Type DrawDebugType,\n\tFHitResult&amp; OutHit,\n\tbool bIgnoreSelf,\n\tFLinearColor TraceColor &#x3D; FLinearColor::Red,\n\tFLinearColor TraceHitColor &#x3D; FLinearColor::Green,\n\tfloat DrawTime &#x3D; 5.0f \n);\n\n\n\n示例：\n\n实现：\n&#x2F;&#x2F; 设置要检测的 Object Type\nTArray&lt;TEnumAsByte&lt;EObjectTypeQuery&gt; &gt; ObjectTypes;\nObjectTypes.Add(EObjectTypeQuery::ObjectTypeQuery1);\n\n&#x2F;&#x2F;开始检测\nbool bIsHit &#x3D; UKismetSystemLibrary::LineTraceSingleForObjects(GetWorld(), BeginLoc, EndLoc, ObjectTypes, false, IgnoreActors, EDrawDebugTrace::ForDuration, HitResult, true);\nif (bIsHit)\n&#123;\n\tUKismetSystemLibrary::PrintString(GetWorld(), HitResult.GetActor()-&gt;GetName());\n&#125;\n\n说明：\n\nEObjectTypeQuery 对应 ObjectType\n默认 ObjectTypeQuery1 —— WorldStatic\n默认 ObjectTypeQuery2 —— WorldDynamic\n默认 ObjectTypeQuery3 —— Oawn\n默认 ObjectTypeQuery4 —— PhysicasBody\n默认 ObjectTypeQuery5 —— Vehicle\n默认 ObjectTypeQuery6 —— Destructible\n可以再 ProjectSettings-&gt;Engine-&gt;Collision-&gt;Object Channels 添加自定义\n\n\n\n2.2.3 LineTraceSingleByProfile情景：\n\n根据 Collision Preset 检测单个物体\n\nSyntax\nstatic bool LineTraceSingleByProfile(\n\tconst UObject* WorldContextObject,\n\tconst FVector Start, \n\tconst FVector End, \n\tFName ProfileName,\n\tbool bTraceComplex,\n\tconst TArray&lt;AActor*&gt;&amp; ActorsToIgnore,\n\tEDrawDebugTrace::Type DrawDebugType,\n\tFHitResult&amp; OutHit,\n\tbool bIgnoreSelf,\n\tFLinearColor TraceColor &#x3D; FLinearColor::Red,\n\tFLinearColor TraceHitColor &#x3D; FLinearColor::Green,\n\tfloat DrawTime &#x3D; 5.0f\n);\n\n\n\n示例：\n\n实现：\nbool bIsHit &#x3D; UKismetSystemLibrary::LineTraceSingleByProfile(\n    GetWorld(), BeginLoc, EndLoc,TEXT(&quot;BlockAll&quot;), \n    false, IgnoreActors, EDrawDebugTrace::ForDuration, \n    HitResult, true);\n\nif (bIsHit)\n&#123;\n\tUKismetSystemLibrary::PrintString(GetWorld(), HitResult.GetActor()-&gt;GetName());\n&#125;\n\n说明：\n\nProfileName 对应 Collision Preset 的名称\n\n3. SweepTrace情景：\n\n使用UWorld生成\n\n生成一个范围检测周边的Actor\n\n\n示例：\n\n定义：\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category&#x3D;&quot;Trace&quot;, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceRadius;\n\n\n\n实现：\nTArray&lt;FHitResult&gt; HitResults;\nconst FVector Start, End &#x3D; GetOwner()-&gt;GetActorLocation();\nconst FCollisionShape CollisionShape &#x3D; FCollisionShape::MakeSphere(TraceRadius);\n\nconst bool IsHit &#x3D; GetWorld()-&gt;SweepMultiByChannel(\n\t\t\tHitResults, Start, End, FQuat::Identity,\n\t\t\tECC_Visibility, CollisionShape);\n\nDrawDebugSphere(GetWorld(), Start, TraceRadius, 50, FColor::Green, true);\n\nif (!IsHit)&#123;return;&#125;\nfor (const auto &amp;result : HitResults)\n&#123;\n\tGEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green,\n\t\tFString::Printf(TEXT(&quot;Hit: %s&quot;), *result.GetActor()-&gt;GetName()));\n&#125;\n\n说明：\n\nFQuat四元数\nIndentity：无旋转\n\n\n\n4. SphereTrace情景：\n\n使用Kismet生成\n生成一个范围检测周边的Actor\n\n示例：\n\n定义：\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category&#x3D;&quot;Trace&quot;, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceRadius;\n\n\n\n实现：\nconst FVector Start, End &#x3D; GetOwner()-&gt;GetActorLocation();\nTArray&lt;AActor*&gt; ActorsToIgnore;\nActorsToIgnore.Add(GetOwner());\nTArray&lt;FHitResult&gt; HitResults;\n\t\nconst bool IsHit &#x3D; UKismetSystemLibrary::SphereTraceMulti(\n\t\tthis,\n\t\tStart,\n\t\tEnd,\n\t\tTraceRadius,\n\t\tTraceTypeQuery1, \n\t\tfalse,\n\t\tActorsToIgnore,\n\t\tEDrawDebugTrace::ForDuration,\n\t\tHitResults,\n\t\ttrue,\n\t\tFLinearColor::Green,\n\t\tFLinearColor::Red,\n\t\t60.f);\n\t\nif (!IsHit)&#123;return;&#125;\nfor (const auto &amp;result : HitResults)\n&#123;\n\tGEngine-&gt;AddOnScreenDebugMessage(\n        -1, 60.f, FColor::Green,\n\t\tFString::Printf(TEXT(&quot;Hit: %s&quot;), \n        *result.GetActor()-&gt;GetName()));\n&#125;\n\n5. Character情景：\n\n第三人称\n自由视角\n角色朝向鼠标输入和控制器指向\n\n示例：\n\n准备：\n\n编辑 &gt;&gt; 项目设置 &gt;&gt; 引擎 &gt;&gt; 输入\n添加操作映射\nJump &#x3D;&#x3D; 空格键\n\n\n添加轴映射\nMoveForward\nW &#x3D;&#x3D; 1.0\nS &#x3D;&#x3D; -1.0\n\n\nMoveRight\nD &#x3D;&#x3D; 1.0\nA &#x3D;&#x3D; -1.0\n\n\nPitchCamera\n鼠标Y &#x3D;&#x3D; -1.0\n\n\nYawCamera\n鼠标X &#x3D;&#x3D; 1.0\n\n\n\n\n\n\n定义：\nclass USpringArmComponent;\nclass UCameraComponent;\n\nprivate:\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Player&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUSpringArmComponent *PlayerSpringArmComponent;\n\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Player&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUCameraComponent *PlayerCameraComponent;\n\t\npublic:\n\tUFUNCTION()\n\tvoid MoveForward(float Value);\n\n\tUFUNCTION()\n\tvoid MoveRight(float Value);\n\n\n\n实现：\nACharacterBase::ACharacterBase()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; true;\n\n\tGetCapsuleComponent()-&gt;InitCapsuleSize(36.f, 92.f);\n\t\n\tPlayerSpringArmComponent &#x3D; CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT(&quot;SpringArm&quot;));\n\tPlayerSpringArmComponent-&gt;SetupAttachment(RootComponent);\n    PlayerSpringArmComponent-&gt;bUsePawnControlRotation &#x3D; true;\n    &#x2F;&#x2F; 以下是详细配置\n\tPlayerSpringArmComponent-&gt;SetRelativeLocation(FVector(0.f, 0.f, 90.f));\n\tPlayerSpringArmComponent-&gt;TargetArmLength &#x3D; 300.f;\n\tPlayerSpringArmComponent-&gt;bEnableCameraLag &#x3D; true;\n\tPlayerSpringArmComponent-&gt;bEnableCameraRotationLag &#x3D; true;\n\tPlayerSpringArmComponent-&gt;CameraLagSpeed &#x3D; 10.f;\n\tPlayerSpringArmComponent-&gt;CameraRotationLagSpeed &#x3D; 10.f;\n\tPlayerSpringArmComponent-&gt;CameraLagMaxDistance &#x3D; 100.f;\n\n\tPlayerCameraComponent &#x3D; CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;Camera&quot;));\n\tPlayerCameraComponent-&gt;SetupAttachment(PlayerSpringArmComponent, USpringArmComponent::SocketName);\n\tPlayerCameraComponent-&gt;bUsePawnControlRotation &#x3D; false;\n\n\tGetCharacterMovement()-&gt;bOrientRotationToMovement &#x3D; true;\n    &#x2F;&#x2F; 以下是详细配置\n\tGetCharacterMovement()-&gt;RotationRate &#x3D; FRotator(0.f, 90.f, 0.f);\n\tGetCharacterMovement()-&gt;GravityScale &#x3D; 1.5f;\n\tGetCharacterMovement()-&gt;MaxAcceleration &#x3D; 980.f;\n\tGetCharacterMovement()-&gt;JumpZVelocity &#x3D; 600.f;\n\tGetCharacterMovement()-&gt;AirControl &#x3D; 0.2f;\n\n\tbUseControllerRotationPitch &#x3D; false;\n\tbUseControllerRotationRoll &#x3D; false;\n\tbUseControllerRotationYaw &#x3D; false;\n&#125;\n\nvoid ACharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n&#123;\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t&#x2F;&#x2F; Bind Axis &#x3D;&gt; MoveForward, MoveRight\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveForward&quot;), this, &amp;ACharacterBase::MoveForward);\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveRight&quot;), this, &amp;ACharacterBase::MoveRight);\n    &#x2F;&#x2F; Pawn, Character 已经写好了内部的鼠标输入\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;PitchCamera&quot;), this, &amp;ACharacter::AddControllerPitchInput);\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;YawCamera&quot;), this, &amp;ACharacter::AddControllerYawInput);\n\n\t&#x2F;&#x2F; Bind Action &#x3D;&gt; Jump\n\tPlayerInputComponent-&gt;BindAction(TEXT(&quot;Jump&quot;), IE_Pressed, this, &amp;ACharacter::Jump);\n\tPlayerInputComponent-&gt;BindAction(TEXT(&quot;Jump&quot;), IE_Released, this, &amp;ACharacter::StopJumping);\n&#125;\n\nvoid ACharacterBase::MoveForward(float Value)\n&#123;\n    &#x2F;&#x2F; 这种方法有问题：人物应用摄像机旋转，摄像机应用控制器旋转时，鼠标完全朝上或朝下，将无法正常行走\n\t&#x2F;&#x2F;const FVector Direction &#x3D; FRotationMatrix(GetController()-&gt;GetControlRotation()).GetScaledAxis(EAxis::X);\n    \n    &#x2F;&#x2F; 这个方法简单，通用\n    const FVector Direction &#x3D; GetActorForwardVector();\n\tAddMovementInput(Direction, Value);\n    \n    ###### 官方写法 ######\n\tif ((Controller !&#x3D; nullptr) &amp;&amp; (Value !&#x3D; 0.0f))\n\t&#123;\n\t\t&#x2F;&#x2F; find out which way is forward\n\t\tconst FRotator Rotation &#x3D; Controller-&gt;GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t&#x2F;&#x2F; get forward vector\n\t\tconst FVector Direction &#x3D; FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\t\tAddMovementInput(Direction, Value);\n\t&#125;\n&#125;\n\nvoid ACharacterBase::MoveRight(float Value)\n&#123;\n\t&#x2F;&#x2F; const FVector Direction &#x3D; FRotationMatrix(GetController()-&gt;GetControlRotation()).GetScaledAxis(EAxis::Y);\n    \n    const FVector Direction &#x3D; GetActorRightVector();\n\tAddMovementInput(Direction, Value);\n    \n    ###### 官方写法 ######\n    if ( (Controller !&#x3D; nullptr) &amp;&amp; (Value !&#x3D; 0.0f) )\n\t&#123;\n\t\t&#x2F;&#x2F; find out which way is right\n\t\tconst FRotator Rotation &#x3D; Controller-&gt;GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\t\n\t\t&#x2F;&#x2F; get right vector \n\t\tconst FVector Direction &#x3D; FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\t\t&#x2F;&#x2F; add movement in that direction\n\t\tAddMovementInput(Direction, Value);\n\t&#125;\n&#125;\n\n6. Pawn情景：\n\n使用Pawn去写非人型\n\n示例：\n\n定义：\nprivate:\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category&#x3D;&quot;Pawn&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFVector MovementDirection;\n\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category&#x3D;&quot;Pawn&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat MovementSpeed;\n\t\npublic:\n\tUFUNCTION()\n\tvoid MoveForward(float Value);\n\n\tUFUNCTION()\n\tvoid MoveRight(float Value);\n\n\n\n实现：\nvoid APawnBase::Tick(float DeltaTime)\n&#123;\n\tSuper::Tick(DeltaTime);\n\n\tif (!MovementDirection.IsZero())\n\t&#123;\n\t\tconst FVector NewLocation &#x3D; GetActorLocation() + (MovementDirection * DeltaTime * MovementSpeed);\n\t\tSetActorLocation(NewLocation);\n\t&#125;\n&#125;\n\nvoid APawnBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n&#123;\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t&#x2F;&#x2F; Bind Axis &#x3D;&gt; MoveForward, MoveRight\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveForward&quot;), this, &amp;APawnBase::MoveForward);\n\tPlayerInputComponent-&gt;BindAxis(TEXT(&quot;MoveRight&quot;), this, &amp;APawnBase::MoveRight);\n&#125;\n\nvoid APawnBase::MoveForward(float Value)\n&#123;\n\tMovementDirection.X &#x3D; FMath::Clamp(Value, -1.f, 1.f);\n&#125;\n\nvoid APawnBase::MoveRight(float Value)\n&#123;\n\tMovementDirection.Y &#x3D; FMath::Clamp(Value, -1.f, 1.f);\n&#125;\n\n7. Impulse Force情景：\n\n反射一条射线，朝向可移动，开启模拟物理的Actor\n使得Actor往射线方向添加脉冲力\n\n示例：\n\n定义：\nprivate:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TraceDistance;\n\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat ImpulseForce;\n\n\n\n实现：\nFHitResult HitResult;\nconst FVector Start &#x3D; GetComponentLocation();\nconst FVector End &#x3D; Start + (GetComponentRotation().Vector() * TraceDistance);\n\nconst bool IsHit &#x3D; GetWorld()-&gt;LineTraceSingleByChannel(\n\tHitResult,\n\tStart,\n\tEnd,\n\tECC_Visibility);\n\nif (!IsHit)&#123;return;&#125;\nDrawDebugLine(GetWorld(), Start, End, FColor::Green, false, 0.1f);\nUStaticMeshComponent *StaticMeshComponent &#x3D; Cast&lt;UStaticMeshComponent&gt;(HitResult.GetActor()-&gt;GetRootComponent());\n\nif (!StaticMeshComponent || !HitResult.GetActor()-&gt;IsRootComponentMovable())&#123;return;&#125;\nStaticMeshComponent-&gt;AddImpulse(GetForwardVector() * ImpulseForce * StaticMeshComponent-&gt;GetMass());\n\n说明：\n\nHitResult.GetActor()-&gt;GetRootComponent()是针对根组件是UStaticMeshComponent\n最好改为HitResult.GetActor()-&gt;GetStaticMeshComponent()\n目的确保任意可移动，模拟物理的Actor都能收到影响\nGetStaticMeshComponent()可在任意Actor内实现此函数，返回UStaticMeshComponent*\n\n8. Add Force情景：\n\n不发射射线\n给可以模拟物理的Actor添加力\n\n示例：\n\n定义：\nclass UStaticMeshComponent;\n\nprivate:\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent *StaticMeshComponent;\n\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat Force;\n\n\n\n实现：\nvoid UAddForce_SComp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tStaticMeshComponent &#x3D; Cast&lt;UStaticMeshComponent&gt;(GetOwner()-&gt;GetRootComponent());\n&#125;\n\nvoid UAddForce_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n&#123;\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tconst FVector UpForce &#x3D; GetUpVector();\n\tStaticMeshComponent-&gt;AddForce(UpForce * Force * StaticMeshComponent-&gt;GetMass());\n&#125;\n\n9. Radia Impulse Force情景：\n\n实现爆炸力\n\n示例：\n\n定义：\nprivate:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat ImpulseRadius;\n\t\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat ImpulseForceStrength;\n\n\n\n实现：\nvoid URadiaImpulse_SComp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tTArray&lt;FHitResult&gt; HitResults;\n\tconst FVector Start, End &#x3D; GetComponentLocation();\n\n\tconst bool IsHit &#x3D; GetWorld()-&gt;SweepMultiByChannel(\n\t\tHitResults,\n\t\tStart,\n\t\tEnd,\n\t\tFQuat::Identity,\n\t\tECC_WorldStatic,\n\t\tFCollisionShape::MakeSphere(ImpulseRadius));\n\n\tDrawDebugSphere(\n\t\tGetWorld(),\n\t\tStart,\n\t\tImpulseRadius,\n\t\t50,\n\t\tFColor::Green,\n\t\ttrue);\n\t\n\tif (!IsHit)&#123;return;&#125;\n\tfor (const auto &amp;result : HitResults)\n\t&#123;\n\t\tUStaticMeshComponent *MeshComponent &#x3D; Cast&lt;UStaticMeshComponent&gt;(result.GetActor()-&gt;GetRootComponent());\n\t\tif (!MeshComponent)&#123;continue;&#125;\n\t\tMeshComponent-&gt;AddRadialImpulse(\n\t\t\tStart,\n\t\t\tImpulseRadius,\n\t\t\tImpulseForceStrength,\n\t\t\tRIF_Linear,\n\t\t\ttrue);\n\t&#125;\n&#125;\n\n10. TimerHandle情景：\n\n需要使用定时器\n\n示例：\n\n定义：\n#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tint32 CallTracker;\n\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFTimerHandle TimerHandle;\n\t\npublic:\n\tUFUNCTION()\n\tvoid TimerFunction();\n\n\n\n实现：\nvoid ATimerHandle_Actor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(\n\t\tTimerHandle,\n\t\tthis,\n\t\t&amp;ATimerHandle_Actor::TimerFunction,\n\t\t1.f,\n\t\ttrue,\n\t\t1.f);\n&#125;\n\nvoid ATimerHandle_Actor::TimerFunction()\n&#123;\n\tCallTracker &#x3D;&#x3D; 0 ?\n\t\tPrintScreen(&quot;Timer End&quot;), GetWorldTimerManager().ClearTimer(TimerHandle) :\n\t\tPrintScreen(FString::Printf(TEXT(&quot;Timer: %d&quot;), CallTracker));\n\n\t--CallTracker;\n&#125;\n\n\n\n注意：\n\n但类作为父类时，要使子类也可使用TimerHandle，需要用protected修饰\n\n\n\n11. Disable Actor情景：\n\n编辑场景中的Actor\n不希望直接从场景中删除\n可以在生成的实例编辑中关闭\n不消耗性能\n\n示例：\n\n定义：\n#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool isOverrideTick &#x3D; false;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool isAutoDisable &#x3D; false;\n\npublic:\n\tUFUNCTION()\n\tvoid SetActive(bool isActive);\n\n\n\n实现：\nADisableActor::ADisableActor()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; true;\n\n&#125;\n\nvoid ADisableActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tisOverrideTick &#x3D; !PrimaryActorTick.bCanEverTick;\n\tif (isAutoDisable)&#123;SetActive(false);&#125;\n&#125;\n\nvoid ADisableActor::Tick(float DeltaSeconds)\n&#123;\n\tSuper::Tick(DeltaSeconds);\n\n\tPrintScreen(&quot;Tick&quot;);\n&#125;\n\nvoid ADisableActor::SetActive(bool isActive)\n&#123;\n\tif (isOverrideTick)\n\t&#123;\n\t\tSetActorTickEnabled(false);\n\t&#125;\n\telse\n\t&#123;\n\t\tSetActorTickEnabled(isActive);\n\t&#125;\n\n\tSetActorHiddenInGame(!isActive);\n\tSetActorEnableCollision(isActive);\n&#125;\n\n说明：\n\n在场景中，只需要实例中的isAutoDisable进行勾选\n重新运行，Actor将会被禁用，不会作用于场景中\n\n12. Hit Event情景：\n\n通过一个Actor和场景中的其他Actor碰撞\n产生碰撞事件\n\n示例：\n\n定义：\n#define PrintScreen(String) GEngine-&gt;AddOnScreenDebugMessage(-1, 10.f, FColor::Green, String)\n\nclass UBoxComponent;\n\nprivate:\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUBoxComponent *HitBox;\n\npublic:\n\tUFUNCTION()\n\tvoid OnHitComp(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n\t\tFVector NormalImpulse, const FHitResult&amp; Hit);\n\n\n\n实现：\nAHitEventActor::AHitEventActor()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n\tHitBox &#x3D; CreateDefaultSubobject&lt;UBoxComponent&gt;(TEXT(&quot;Hit Box&quot;));\n&#125;\n\nvoid AHitEventActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tHitBox-&gt;OnComponentHit.AddDynamic(this, &amp;AHitEventActor::OnHitComp);\n&#125;\n\nvoid AHitEventActor::OnHitComp(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n\tFVector NormalImpulse, const FHitResult&amp; Hit)\n&#123;\n\tPrintScreen(FString::Printf(TEXT(&quot;Hit: %s&quot;), *OtherActor-&gt;GetName()));\n&#125;\n\n说明：\n\nHitBox需要些设置，碰撞事件才能生效\n配置：\n方便查看：\n设置形状\n设置渲染\n\n\n产生事件：设置碰撞\n打开模拟生成命中事件\n设置碰撞预设\n\n\n\n\n\n13. Set Material情景：\n\n材质的创建\n材质的使用\n\n示例：\n\n定义：\nclass UStaticMeshComponent;\nclass UMaterialInterface;\nclass UMaterial;\nclass UMaterialInstance;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent *Mesh;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInterface *MaterialOne;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInterface *MaterialTwo;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterial *Material;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInstance *MaterialInstance;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool IsChooseOne &#x3D; true;\n\n\n\n实现：\nASetMaterial::ASetMaterial()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n\tMesh &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;Mesh_Comp&quot;));\n\tRootComponent &#x3D; Mesh;\n\n\tMaterialOne &#x3D; CreateDefaultSubobject&lt;UMaterialInterface&gt;(TEXT(&quot;Material_One&quot;));\n\tMaterialTwo &#x3D; CreateDefaultSubobject&lt;UMaterialInterface&gt;(TEXT(&quot;Material_Two&quot;));\n&#125;\n\nvoid ASetMaterial::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tMesh-&gt;SetMaterial(0, IsChooseOne ? MaterialOne : MaterialTwo);\n&#125;\n\n14. Dynamic Material情景：\n\n有一个基本的材质\n通过创建材质实例\n对其中的ScaleParam，VectorParam进行动态修改\n\n示例：\n\n定义：\nclass UStaticMeshComponent;\nclass UMaterialInterface;\nclass UMaterialInstanceDynamic;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent *Mesh;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInterface *MaterialInterface;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInstanceDynamic *DynamicInstance;\n\n\n\n实现：\nADynamicMaterial::ADynamicMaterial()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n\tMesh &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));\n\tRootComponent &#x3D; Mesh;\n&#125;\n\nvoid ADynamicMaterial::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tMaterialInterface &#x3D; Mesh-&gt;GetMaterial(0);\n\tDynamicInstance &#x3D; UMaterialInstanceDynamic::Create(MaterialInterface, this);\n\t\n\tMesh-&gt;SetMaterial(0, DynamicInstance);\n\n\tDynamicInstance-&gt;SetScalarParameterValue(TEXT(&quot;EmissiveStrength&quot;), 50.f);\n\tDynamicInstance-&gt;SetVectorParameterValue(TEXT(&quot;Color&quot;), FLinearColor::Yellow);\n&#125;\n\n15. Interp Target情景：\n\n指定Actor插值移动到Target\n\n示例：\n\n定义：\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tAActor *Origin &#x3D; nullptr;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tAActor *Target;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat InterpSpeed &#x3D; 3.f;\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat WaitTime &#x3D; 1.f;\n\n\n\n实现：\nvoid UInterpTarget_SComp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\t\n\tOrigin &#x3D; GetOwner();\n&#125;\n\nvoid UInterpTarget_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n&#123;\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (WaitTime &gt; 0)\n\t&#123;\n\t\tWaitTime -&#x3D; DeltaTime;\n\t\treturn;\n\t&#125;\n\n\tif (!Target || !Origin)&#123;return;&#125;\n\t\n\tOrigin-&gt;SetActorLocation(\n\t\tFMath::VInterpTo(\n\t\t\tOrigin-&gt;GetActorLocation(),\n\t\t\tTarget-&gt;GetActorLocation(),\n\t\t\tDeltaTime,\n\t\t\tInterpSpeed));\n&#125;\n\n说明：\n\nOrigin = GetOwner();写在构造函数里无效\n\n16. Lerp情景：\n\n需要使用Lerp\n修改Actor的位置和材质\n\n示例：\n\n定义：\nclass UMaterialInterface;\nclass UMaterialInstanceDynamic;\nclass UStaticMeshComponent;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInterface *MaterialInter;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUMaterialInstanceDynamic *InstanceDynamic;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tAActor *OriginActor &#x3D; nullptr;\n\n\tUPROPERTY(VisibleDefaultsOnly, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent *Mesh;\n\t\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFVector StartLocation;\n\n\tUPROPERTY(EditAnywhere, meta&#x3D;(MakeEditWidget&#x3D;true))\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat TimeElapsed &#x3D; 0;\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat LerpDuration &#x3D; 3.f;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat WaitTime &#x3D; 1.f;\n\n\n\n实现：\n#include &quot;Lerp_SComp.h&quot;\n\nULerp_SComp::ULerp_SComp()\n&#123;\n\tPrimaryComponentTick.bCanEverTick &#x3D; true;\n\n\tMesh &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));\n&#125;\n\nvoid ULerp_SComp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tOriginActor &#x3D; GetOwner();\n\tStartLocation &#x3D; GetComponentLocation();\n\tMaterialInter &#x3D; Mesh-&gt;GetMaterial(0);\n\tInstanceDynamic &#x3D; UMaterialInstanceDynamic::Create(MaterialInter, this);\n\tMesh-&gt;SetMaterial(0, InstanceDynamic);\n\tInstanceDynamic-&gt;SetVectorParameterValue(TEXT(&quot;Color&quot;), FLinearColor::Blue);\n&#125;\n\nvoid ULerp_SComp::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n&#123;\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!OriginActor)&#123;return;&#125;\n\n\tif (WaitTime &gt; 0)&#123;WaitTime -&#x3D; DeltaTime; return;&#125;\n\n\tif (TimeElapsed &lt; LerpDuration)\n\t&#123;\n\t\tOriginActor-&gt;SetActorLocation(\n\t\t\tFMath::Lerp(\n\t\t\t\tStartLocation,\n\t\t\t\tTargetLocation,\n\t\t\t\tTimeElapsed &#x2F; LerpDuration));\n\n\t\tInstanceDynamic-&gt;SetVectorParameterValue(\n\t\t\tTEXT(&quot;Color&quot;),\n\t\t\tFMath::Lerp(\n\t\t\t\tFLinearColor::Blue,\n\t\t\t\tFLinearColor::Red,\n\t\t\t\tTimeElapsed &#x2F; LerpDuration));\n\n\t\tTimeElapsed +&#x3D; DeltaTime;\n\t&#125;\n&#125;\n\n18. 黑洞情景：\n\n一个球，可以在一定范围内吸引开启模拟物理的Actor\n吸到黑洞的Actor会被销毁\n\n示例：\n\n简单的材质\n黑洞要黑，不能反光\n创建材质Mat_BlackHole\n创建节点VectorParameter，设置RGBA(0, 0, 0, 1)，连接基础颜色\n创建常量节点，设置为0， 连接其余的选项\n\n定义：\nBlackHole_Actor.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;Actor.h&quot;\n#include &quot;BlackHole_Actor.generated.h&quot;\n\nclass UStaticMeshComponent;\nclass USphereComponent;\nstruct FTimerHandle;\n\nUCLASS()\nclass FPSGAME_API ABlackHole_Actor : public AActor\n&#123;\n\tGENERATED_BODY()\n\t\npublic:\n\tABlackHole_Actor();\n\tvirtual void BeginPlay() override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;BlackHole&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat BlackHoleActionRate;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;BlackHole&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat BlackHoleStrength;\n\t\npublic:\n\tFTimerHandle BlackHoleActionHandle;\n\t\n\t&#x2F;&#x2F; Component\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;A_Hole&quot;)\n\tUStaticMeshComponent *BlackHoleStaticMeshComp;\n\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;A_Hole&quot;)\n\tUSphereComponent *InnerSphereComp;\n\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;A_Hole&quot;)\n\tUSphereComponent *OuterSphereComp;\n\npublic:\n\tUFUNCTION()\n\tvoid OverlapInnerSphere(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\t\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult &amp;SweepResult);\n\n\tUFUNCTION()\n\tvoid OnBlackHoleAction();\n&#125;;\n\n\n\n实现\nBlackHole_Actor.cpp\n#include &quot;BlackHole_Actor.h&quot;\n#include &quot;Components&#x2F;SphereComponent.h&quot;\n\nABlackHole_Actor::ABlackHole_Actor()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n\tBlackHoleActionRate &#x3D; 0.05f;\n\tBlackHoleStrength &#x3D; 10000.f;\n\n\tBlackHoleStaticMeshComp &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;BlackStaticMesh&quot;));\n\tBlackHoleStaticMeshComp-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\tBlackHoleStaticMeshComp-&gt;CastShadow &#x3D; false;\n\tRootComponent &#x3D; BlackHoleStaticMeshComp;\n\n\tInnerSphereComp &#x3D; CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;InnerSphereComp&quot;));\n\tInnerSphereComp-&gt;SetSphereRadius(100.f);\n\tInnerSphereComp-&gt;SetupAttachment(BlackHoleStaticMeshComp);\n\t\n\tOuterSphereComp &#x3D; CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;OuterSphereComp&quot;));\n\tOuterSphereComp-&gt;SetSphereRadius(3000.f);\n\tOuterSphereComp-&gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tOuterSphereComp-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\n\tOuterSphereComp-&gt;SetupAttachment(BlackHoleStaticMeshComp);\n&#125;\n\nvoid ABlackHole_Actor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tcheck(InnerSphereComp);\n\tcheck(OuterSphereComp);\n\t\n\tif (InnerSphereComp)\n\t&#123;\n\t\tInnerSphereComp-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;ABlackHole_Actor::OverlapInnerSphere);\n\t&#125;\n\n\tif (GetWorld())\n\t&#123;\n\t\tGetWorldTimerManager().SetTimer(\n\t\t\tBlackHoleActionHandle,\n\t\t\tthis,\n\t\t\t&amp;ABlackHole_Actor::OnBlackHoleAction,\n\t\t\tBlackHoleActionRate,\n\t\t\ttrue\n\t\t\t);\n\t&#125;\n&#125;\n\nvoid ABlackHole_Actor::OverlapInnerSphere(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&amp; SweepResult)\n&#123;\n\tif (!OtherActor)&#123;return;&#125;\n\tOtherActor-&gt;Destroy();\n&#125;\n\nvoid ABlackHole_Actor::OnBlackHoleAction()\n&#123;\n\tTArray&lt;UPrimitiveComponent*&gt; OverlappingComp;\n\n\tif (!OuterSphereComp)&#123;return;&#125;\n\tOuterSphereComp-&gt;GetOverlappingComponents(OverlappingComp);\n\n\tfor (int i &#x3D; 0; i &lt; OverlappingComp.Num(); ++i)\n\t&#123;\n\t\tif (OverlappingComp[i] &amp;&amp; OverlappingComp[i]-&gt;IsSimulatingPhysics())\n\t\t&#123;\n\t\t\tconst float SphereRadius &#x3D; OuterSphereComp-&gt;GetScaledSphereRadius();\n\t\t\tOverlappingComp[i]-&gt;AddRadialForce(\n\t\t\t\tGetActorLocation(),\n\t\t\t\tSphereRadius,\n\t\t\t\t-BlackHoleStrength,\n\t\t\t\tRIF_Constant,\n\t\t\t\ttrue);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n19. 玩家死亡后进入观察情景：\n\n但玩家死亡后\n播放死亡动画\n禁用玩家输入\n控制器切换控制到Spectator\n玩家不与其他玩家产生碰撞\n玩家外的胶囊体组件无碰撞\n死亡动画播放带有布娃娃效果\n一定时间后销毁\n\n示例：\n\n前提：\n\n将死亡动画创建为蒙太奇动画\n设置蒙太奇的启用自动混出为false\n\n\n代码：\n\n定义\nclass UAnimMontage;\n\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Montage&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nUAnimMontage *AnimMontage_Death;\n\nUFUNCTION()\nvoid OnDead();\n\n\n\n实现\nvoid ASTUCharacterBase::OnDead()\n&#123;\n\tif (!AnimMontage_Death)&#123;return;&#125;\n\tPlayAnimMontage(AnimMontage_Death);\n\tGetCharacterMovement()-&gt;DisableMovement();\n\n\tif (GetController())\n\t&#123;\n\t\tGetController()-&gt;ChangeState(NAME_Spectating);\n\t&#125;\n\tGetCapsuleComponent()-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);\n\tSetLifeSpan(5.0f);\n\n\tGetMesh()-&gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tGetMesh()-&gt;SetSimulatePhysics(true);\n&#125;\n\n\n\n20. 高处坠落伤害情景：\n\n高处下落的速度达到指定值\n玩家受到相应的伤害\n使用ACharacter自带的功能实现\nvirtual void Landed(const FHitResult&amp; Hit);\nFLandedSignature LandedDelegate;\n\n\n\n示例：\n\n介绍：\nACharacter.h\n\t&#x2F;**\n\t * Called upon landing when falling, to perform actions based on the Hit result. Triggers the OnLanded event.\n\t * Note that movement mode is still &quot;Falling&quot; during this event. Current Velocity value is the velocity at the time of landing.\n\t * Consider OnMovementModeChanged() as well, as that can be used once the movement mode changes to the new mode (most likely Walking).\n\t *\n\t * @param Hit Result describing the landing that resulted in a valid landing spot.\n\t * @see OnMovementModeChanged()\n\t *&#x2F;\n\tvirtual void Landed(const FHitResult&amp; Hit);\n\n&#x2F;**\n* 落地时调用，根据命中结果执行动作。 触发 OnLanded 事件。\n* 请注意，此活动期间移动模式仍为“下降”。 当前速度值是着陆时的速度。\n* 还要考虑 OnMovementModeChanged()，因为一旦移动模式更改为新模式（很可能是步行），就可以使用它。\n*\n* @param Hit Result 描述了导致有效着陆点的着陆。\n* @see OnMovementModeChanged()\n*&#x2F;\n\tFLandedSignature LandedDelegate;\t\n\n\n\n定义：\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;FallingDamage&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nFVector2D LandedDamageVelocity;\n\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;FallingDamage&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nFVector2D LandedDamage;\n\nUFUNCTION()\nvoid OnGroundLanded(const FHitResult&amp; HitResult);\n\n\n\n实现：\nvoid ASTUCharacterBase::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tLandedDelegate.AddDynamic(this, &amp;ASTUCharacterBase::OnGroundLanded);\n&#125;\n\nvoid ASTUCharacterBase::OnGroundLanded(const FHitResult&amp; HitResult)\n&#123;\n\tconst float FallVelocityZ &#x3D; -GetVelocity().Z;\n\n\tif (FallVelocityZ &lt; LandedDamageVelocity.X)&#123;return;&#125;\n\tconst float FinalDamage &#x3D; FMath::GetMappedRangeValueClamped(LandedDamageVelocity,\n\t\tLandedDamage, FallVelocityZ);\n\tTakeDamage(FinalDamage, FDamageEvent&#123;&#125;, nullptr, nullptr);\n&#125;\n\n\n# FMath::GetMappedRangeValueClamped() --&gt; UnrealMathUtility.h\n&#x2F;&#x2F; For the given Value clamped to the [Input:Range] inclusive, returns the corresponding percentage in [Output:Range] Inclusive\n&#x2F;&#x2F; 对于钳制到 [Input:Range] 的给定值，返回 [Output:Range] 包含的相应百分比\n\n21. FindAnimNotifyByClass情景：\n\n按类型UAnimSequenceBase中查找FAnimNotifyEvent\n再绑定对应的通知事件\n\n示例：\n\n前提：\n创建AnimNotifyEventUntility.h\n#pragma once\n\nclass AnimNotifyEventUntility\n&#123;\npublic:\n\ttemplate&lt;typename T&gt;\n\tstatic T* FindNotifyByClass(UAnimSequenceBase* AnimSequenceBase)\n\t&#123;\n\t\tif (!AnimSequenceBase)&#123;return nullptr;&#125;\n\n\t\tconst auto NotifyEvents &#x3D; AnimSequenceBase-&gt;Notifies;\n\t\tfor (const auto&amp; NotifyEvent : NotifyEvents)\n\t\t&#123;\n\t\t\tif (const auto AnimNotify &#x3D; Cast&lt;T&gt;(NotifyEvent.Notify))\n\t\t\t&#123;\n\t\t\t\treturn AnimNotify;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn nullptr;\n\t&#125;\n&#125;;\n\n\n\n创建AnimNotifyBase.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Animation&#x2F;AnimNotifies&#x2F;AnimNotify.h&quot;\n#include &quot;STUAnimNotifyBase.generated.h&quot;\n\nclass USkeletalMeshComponent;\n\nDECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifySignature, USkeletalMeshComponent*)\n\nUCLASS()\nclass B_01_TPS_API UAnimNotifyBase : public UAnimNotify\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tvirtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation) override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\n\tFOnNotifySignature OnNotify;\t\n&#125;;\n\n# Notify\n&#x2F;&#x2F; 是 AnimNotify 自带的函数，同时不建议 UE5 使用\n\n\n\n实现AnimNotifyBase.cpp\n#include &quot;AnimNotifyBase.h&quot;\n\nvoid USTUAnimNotifyBase::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation)\n&#123;\n\tSuper::Notify(MeshComp, Animation);\n\n\tOnNotify.Broadcast(MeshComp);\n&#125;\n\n\n\n\n\n定义：\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nUAnimMontage *EquipAnimMontage;\n\nUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\nbool IsEquipAnimInProgress;\n\nUFUNCTION()\nvoid InitAnimations();\n\nUFUNCTION()\nvoid OnEquipFinished(USkeletalMeshComponent* SkeletalMeshComponent);\n\n\n\n实现：\n#include &quot;AnimNotify&#x2F;AnimNotifyEventUntility.h&quot;\n\nvoid USTUWeaponActorComponent::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tInitAnimations();\n&#125;\n\nvoid USTUWeaponActorComponent::InitAnimations()\n&#123;\n\tif (const auto EquipFinishedNotify &#x3D; \n        AnimUtils::FindNotifyByClass&lt;USTUAnimNotifyEquipFinished&gt;(EquipAnimMontage))\n\t&#123;\n\t\tEquipFinishedNotify-&gt;OnNotify.AddUObject(this, &amp;USTUWeaponActorComponent::OnEquipFinished);\n\t&#125;\n\telse\n\t&#123;\n\t\tcheckNoEntry();\n\t&#125;\n&#125;\n\nvoid USTUWeaponActorComponent::OnEquipFinished(USkeletalMeshComponent* SkeletalMeshComponent)\n&#123;\n\tconst ASTUCharacterBase *Character &#x3D; Cast&lt;ASTUCharacterBase&gt;(GetOwner());\n\n\tif (!Character || !(Character-&gt;GetMesh() &#x3D;&#x3D; SkeletalMeshComponent))&#123;return;&#125;\n\tIsEquipAnimInProgress &#x3D; false;\n&#125;\n\n# USTUAnimNotifyEquipFinished\n&#x2F;&#x2F; 是AnimNotifyBase的子类\n&#x2F;&#x2F; 里面不用写东西\n&#x2F;&#x2F; 主要是用来：修改备注名，修改颜色，绑定事件\n\n22. 类生成附加到插槽情景：\n\n用指定的组件开始生成\n\nBeginPlay()时开始\n\n指定要生成的class\n\n以有需要附加的插槽&#96;&#96;\n\n将生成的对象附加到插槽上，并应用插槽的transform\n\nEndPlay()结束后，生成的Actor也要销毁\n\n\n示例：\n\n定义：UWeaponActorComponent.h\nUCLASS( ClassGroup&#x3D;(Custom), meta&#x3D;(BlueprintSpawnableComponent) )\nclass B_01_TPS_API USTUWeaponActorComponent : public UActorComponent\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUSTUWeaponActorComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\t\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;ASTUWeaponBase&gt; WeaponClass;\n    \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFName WeaponEquipSocketName;\n    \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Weapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tASTUWeaponBase *CurrentWeapon;\n    \n    &#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tvoid SpawnWeapons();\n    \n    UFUNCTION()\n\tvoid AttachWeaponToSocket(ASTUWeaponBase* Weapon, USceneComponent* SceneComponent, const FName&amp; SocketName);\n&#125;\n\n\n\n实现：\nUSTUWeaponActorComponent::USTUWeaponActorComponent()\n&#123;\n\tPrimaryComponentTick.bCanEverTick &#x3D; false;\n\n\tWeaponEquipSocketName &#x3D; TEXT(&quot;WeaponSocket&quot;);\n    WeaponClass &#x3D; nullptr\n\tCurrentWeapon &#x3D; nullptr;\n&#125;\n\nvoid USTUWeaponActorComponent::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tSpawnWeapons();\n&#125;\n\nvoid USTUWeaponActorComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)\n&#123;\n\tCurrentWeapon-&gt;DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);\n\tCurrentWeapon-&gt;Destroy();\n    CurrentWeapon &#x3D; nullptr;\n\n\tSuper::EndPlay(EndPlayReason);\n&#125;\n\nvoid USTUWeaponActorComponent::SpawnWeapons()\n&#123;\n\tif (!GetWorld())&#123;return;&#125;\n\tASTUCharacterBase *Character &#x3D; Cast&lt;ASTUCharacterBase&gt;(GetOwner());\n\n\tif (!Character)&#123;return;&#125;\n    const auto Weapon &#x3D; GetWorld()-&gt;SpawnActor&lt;ASTUWeaponBase&gt;(WeaponClass);\n    \n\tif (!Weapon)&#123;continue;&#125;\n    CurrentWeapon &#x3D; Weapon;\n    \n    &#x2F;&#x2F; 此处留一个伏笔，当前武器指定了 Onwer 是当前的玩家\n\tCurrentWeapon-&gt;SetOwner(Character);\n    \n\tAttachWeaponToSocket(CurrentWeapon, Character-&gt;GetMesh(), WeaponEquipSocketName);\n&#125;\n\nvoid USTUWeaponActorComponent::AttachWeaponToSocket(ASTUWeaponBase* Weapon, USceneComponent* SceneComponent,\n                                                    const FName&amp; SocketName)\n&#123;\n\tif (!Weapon || !SceneComponent)&#123;return;&#125;\n\tconst FAttachmentTransformRules AttachmentTransformRules(EAttachmentRule::SnapToTarget, false);\n\tWeapon-&gt;AttachToComponent(SceneComponent, AttachmentTransformRules, SocketName);\n&#125;\n\n23. CameraShake情景：\n\n在UHealthActorComponent中实现CameraShake\n\n示例：\n\n定义：\npublic:\n\tUSTUHealthActorComponent();\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Camera&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;UCameraShakeBase&gt; CameraShake;\n\npublic:\n\tUFUNCTION()\n\tvoid PlayCameraShake();\n\n\n\n实现：\n#include &quot;STUHealthActorComponent.h&quot;\n\nUSTUHealthActorComponent::USTUHealthActorComponent()\n&#123;\n\tPrimaryComponentTick.bCanEverTick &#x3D; false;\n\n\tCameraShake &#x3D; nullptr;\n&#125;\n\nvoid USTUHealthActorComponent::PlayCameraShake()\n&#123;\n\tconst auto Player &#x3D; Cast&lt;APawn&gt;(GetOwner());\n\n\tif (!Player)&#123;return;&#125;\n\tconst auto Controller &#x3D; Player-&gt;GetController&lt;APlayerController&gt;();\n\n\tif (!Controller || !Controller-&gt;PlayerCameraManager)&#123;return;&#125;\n\tController-&gt;PlayerCameraManager-&gt;StartCameraShake(CameraShake);\n&#125;\n\n24. HealthComponent情景：\n\n设计一个角色的生命组件\n有生命值\n有伤害处理\n呼吸回血效果\n有处理玩家死亡效果\n\n前提：\n\n定义玩家类：ACharacterBase\n定义生命组件类：UHealthComponent\n\n结构分析：\n\n玩家类中的OnDead效果对应于生命组件类中的OnDead\n生命组件类：\n可以通过蓝图获得CurrentHP，MaxHP，IsDead\n通过TimerHandle实现呼吸回血效果\n\n\n\n示例：\n\n生命组件类\n\n定义：\nDECLARE_MULTICAST_DELEGATE(FOnDead);\nDECLARE_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float);\n\nstruct FTimerHandle;\n\nUCLASS( ClassGroup&#x3D;(Custom), meta&#x3D;(BlueprintSpawnableComponent) )\nclass B_01_TPS_API USTUHealthActorComponent : public UActorComponent\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUSTUHealthActorComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat MaxHealth;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Heal&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool IsAutoHeal;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Heal&quot;,\n\t\tmeta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;IsAutoHeal&quot;))\n\tfloat HealUpdateTime;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Heal&quot;,\n\tmeta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;IsAutoHeal&quot;))\n\tfloat HealDelayTime;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;HPComp|Heal&quot;,\n\tmeta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;IsAutoHeal&quot;))\n\tfloat HealModifierValue;\n\t\npublic:\n\tFTimerHandle HealTimerHandle;\n\tFOnDead OnDead;\n\tFOnHealthChanged OnHealthChanged;\n\t\n\t&#x2F;&#x2F; Function\t\npublic:\n\tUFUNCTION(BlueprintCallable)\n\tFORCEINLINE float GetHP() const &#123;return Health;&#125;\n\t\n\tUFUNCTION()\n\tvoid OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType,\n\t\tclass AController* InstigatedBy, AActor* DamageCauser);\n\t\n\tUFUNCTION(BlueprintCallable)\n\tbool IsDead() const &#123;return FMath::IsNearlyZero(Health);&#125;\n\n\tUFUNCTION()\n\tvoid HealUpdate();\n    \n\tUFUNCTION()\n\tvoid SetHealth(float NewHealth);\n&#125;;\n\n\n\n实现：\n#include &quot;STUHealthActorComponent.h&quot;\n\nUSTUHealthActorComponent::USTUHealthActorComponent()\n&#123;\n\tPrimaryComponentTick.bCanEverTick &#x3D; false;\n\n\tHealth &#x3D; 0.f;\n\tMaxHealth &#x3D; 100.f;\n\n\tIsAutoHeal &#x3D; true;\n\tHealUpdateTime &#x3D; 1.f;\n\tHealDelayTime &#x3D; 4.f;\n\tHealModifierValue &#x3D; 10.f;\n&#125;\n\nvoid USTUHealthActorComponent::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n    SetHealth(MaxHealth);\n\n\tif (GetOwner())\n\t&#123;\n\t\tGetOwner()-&gt;OnTakeAnyDamage.AddDynamic(this, &amp;USTUHealthActorComponent::OnTakeAnyDamage);\n\t&#125;\n&#125;\n\n&#x2F;* My Code *&#x2F;\nvoid USTUHealthActorComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType,\n\tAController* InstigatedBy, AActor* DamageCauser)\n&#123;\n\tif (Health &lt;&#x3D; 0.f || IsDead() || !GetWorld())&#123;return;&#125;\n\tSetHealth(Health -  Damage);\n\n\tif (IsDead())\n\t&#123;\n\t\tOnDead.Broadcast();\n\t&#125;\n\telse if (IsAutoHeal)\n\t&#123;\n\t\tGetWorld()-&gt;GetTimerManager().SetTimer(HealTimerHandle, this, &amp;USTUHealthActorComponent::HealUpdate,\n\t\t\tHealUpdateTime, IsAutoHeal, HealDelayTime);\n\t&#125;\n&#125;\n\nvoid USTUHealthActorComponent::HealUpdate()\n&#123;\n\tSetHealth(Health +&#x3D; HealModifierValue);\n\n\tif (!FMath::IsNearlyEqual(Health, MaxHealth) || !GetWorld())&#123;return;&#125;\n\tGetWorld()-&gt;GetTimerManager().ClearTimer(HealTimerHandle);\n&#125;\n\nvoid USTUHealthActorComponent::SetHealth(float NewHealth)\n&#123;\n\tHealth &#x3D; FMath::Clamp(NewHealth, 0.f, MaxHealth);\n&#125;\n\n\n\n玩家类\n\n定义：\nclass USTUHealthActorComponent;\n\npublic:\n\tASTUCharacterBase();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Component\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Component&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUSTUHealthActorComponent *HealthActorComponent;\n\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tvoid OnDead();\n\n\n\n实现：\n#include &quot;STUHealthActorComponent.h&quot;\n\nASTUCharacterBase::ASTUCharacterBase()\n&#123;\n    PrimaryActorTick.bCanEverTick &#x3D; false;\n    \n    HealthActorComponent &#x3D; CreateDefaultSubobject&lt;USTUHealthActorComponent&gt;(TEXT(&quot;HPComp&quot;));\n&#125;\n\nvoid ASTUCharacterBase::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tcheck(HealthActorComponent);\n\tHealthActorComponent-&gt;OnDead.AddUObject(this, &amp;ASTUCharacterBase::OnDead);\n&#125;\n\nvoid ASTUCharacterBase::OnDead()\n&#123;\n    &#x2F;&#x2F; OnDead Event\n&#125;\n\n25. GetActorComponent情景：\n\n需要通过已有的Actor获得其已添加的Component\n将这个方法提取成一个模板工具类\n\n示例：\n\n定义：\n#pragma once\n\nclass FH_Utility\n&#123;\npublic:\n\ttemplate&lt;typename T&gt;\n\tFORCEINLINE static T* GetActorComponent(const AActor* Actor)\n\t&#123;\n\t\tif (!Actor)&#123;return nullptr;&#125;\n\t\tconst auto Component &#x3D; Actor-&gt;GetComponentByClass(T::StaticClass());\n\t\tT* ResultComponent &#x3D; Cast&lt;T&gt;(Component);\n\n\t\tif (!ResultComponent)&#123;return nullptr;&#125;\n\t\treturn ResultComponent;\n\t&#125;\n&#125;;\n\n26. 设计结构体和委托情景：\n\n将一类结构体或Delegate写进单独的类中\n便于管理\n\n示例：\n\n定义：FH_CoreType.h\n#pragma once\n\n#include &quot;FH_CoreType.generated.h&quot; &#x2F;&#x2F; 因为使用了Delegate 和 USTRUCT，这里要手动加入\n\nclass ASTUWeaponBase;\nclass UAnimMontage;\n\n&#x2F;&#x2F; Delegate 的定义可以写在这里\nDECLARE_MULTICAST_DELEGATE(FOnDead);\nDECLARE_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float);\n\n&#x2F;&#x2F; 可以定义结构体，USTRCUT() 内加入 BlueprintType, 蓝图就可以或这个结构体\nUSTRUCT(BlueprintType)\nstruct FAmmoData\n&#123;\n\tGENERATED_USTRUCT_BODY() &#x2F;&#x2F; 原：GENERATED_BODY() 需改为 GENERATED_USTRUCT_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Ammo&quot;,  meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tint32 Bullets &#x3D; 0;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Ammo&quot;,\n\t\t\t  meta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;!IsInfinity&quot;))\n\tint32 Clips &#x3D; 0;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Ammo&quot;,  meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool IsInfinity &#x3D; false;\n&#125;;\n\nUSTRUCT(BlueprintType)\nstruct FWeaponData\n&#123;\n\tGENERATED_USTRUCT_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;ReloadWeapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;ASTUWeaponBase&gt; WeaponClass &#x3D; nullptr;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;ReloadWeapon&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUAnimMontage* ReloadAnimMontage &#x3D; nullptr;\n&#125;;\n\n27. AIPerception获得最近Actor情景：\n\nAI绑定了AIPerceptionComponent\n设置AISense：例如–目光UAISense_Sight\n利用GetCurrentlyPerceivedActors获得目光内的有效Actor\n通过Actor获得其前面HealthComponent，判断Actor是否符合需求\n最后通过算法，求得并返回离AI最近的Actor\n\n示例：\n\n定义：\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Perception&#x2F;AIPerceptionComponent.h&quot;\n#include &quot;STUAIPerceptionComponent.generated.h&quot;\n\nUCLASS()\nclass B_01_TPS_API USTUAIPerceptionComponent : public UAIPerceptionComponent\n&#123;\n\tGENERATED_BODY()\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tAActor* GetClosetActor() const;\n&#125;;\n\n\n\n实现：\n#include &quot;STUAIPerceptionComponent.h&quot;\n#include &quot;AIController.h&quot;\n#include &quot;STUHealthActorComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Dev&#x2F;STUUtils.h&quot;\n#include &quot;Perception&#x2F;AISense_Sight.h&quot;\n\nAActor* USTUAIPerceptionComponent::GetClosetActor() const\n&#123;\n\tTArray&lt;AActor*&gt; PerceptionActors;\n    \n    &#x2F;&#x2F; AIPerceptionComponent自带的函数，获得所有已经被感知的Actor\n\tGetCurrentlyPerceivedActors(UAISense_Sight::StaticClass(), PerceptionActors);\n\n    &#x2F;&#x2F; 判断组件的拥有AI是否有AIController\n\tif (PerceptionActors.Num() &lt;&#x3D; 0)&#123;return nullptr;&#125;\n\tconst auto Controller &#x3D; Cast&lt;AAIController&gt;(GetOwner());\n\n    &#x2F;&#x2F; 判断当前AI是否有效\n\tif (!Controller)&#123;return nullptr;&#125;\n\tconst auto Pawn &#x3D; Controller-&gt;GetPawn();\n\n    &#x2F;&#x2F; 开始计算最近的Actor\n\tif (!Pawn)&#123;return nullptr;&#125;\n    \n    &#x2F;&#x2F; MAX_FLT 是 UnrealEngine 自带的 UrealMathUtility 中的 宏\n    &#x2F;&#x2F; #define MAX_FLT 3.402823466e+38F\n    &#x2F;&#x2F; 表示可虚幻引擎可表达的 最大浮点数\n\tfloat NealDistance &#x3D; MAX_FLT;\n\tAActor* NealPawn &#x3D; nullptr;\n\tfor (const auto&amp; PerceptionActor : PerceptionActors)\n\t&#123;\n        &#x2F;&#x2F; 此处使用了前面创建的 HealthComponent 和 FH_Utility\n        &#x2F;&#x2F; 判断 感知到的Actor是否有生命组件，是否还活着\n\t\tconst auto HealthComp &#x3D; STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(PerceptionActor);\n\t\t\n        if (!HealthComp || HealthComp-&gt;IsDead())&#123;return nullptr;&#125;\n        const auto CurrentDistance &#x3D; (PerceptionActor-&gt;GetActorLocation() - Pawn-&gt;GetActorLocation()).Size();\n\t\t\n        &#x2F;&#x2F; 找出最近距离的Actor\n        if (CurrentDistance &lt; NealDistance)\n\t\t&#123;\n\t\t\tNealDistance &#x3D; CurrentDistance;\n\t\t\tNealPawn &#x3D; PerceptionActor;\n\t\t&#125;\n\t&#125;\n\treturn NealPawn;\n&#125;\n\n28. GameMode情景：\n\n通过GameModeBase进行初始化\n\n示例：\n\n实现：\nASTUGameModeBase::ASTUGameModeBase()\n&#123;\n\tDefaultPawnClass &#x3D; ASTUCharacterBase::StaticClass();\n\tPlayerControllerClass &#x3D; ASTUPlayerController::StaticClass();\n\tHUDClass &#x3D; ASTUGameHUD::StaticClass();\n&#125;\n\n29. 拾取物-PickUp情景：\n\n创建PickUpBase\n可被放置在场景中\n可以Actor重叠检查\n不与Actor产生BlockHit\n拾取后不销毁，隐藏起来，一段时间重生，TimerHandle\n物品默认旋转，拾取后关闭旋转，重生后开启旋转，TimerHandle\n被拾取后，让拾取的Actor执行指定的GivePickUpTo，Virtual Function\n具体执行的功能，通过子类去实现\n\n示例：\n\n定义：\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;Actor.h&quot;\n#include &quot;STUBasePickUp.generated.h&quot;\n\nclass USphereComponent;\nclass UStaticMeshComponent;\nstruct FTimerHandle;\n\nUCLASS()\nclass B_01_TPS_API ASTUBasePickUp : public AActor\n&#123;\n\tGENERATED_BODY()\n\t\npublic:\n\tASTUBasePickUp();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void NotifyActorBeginOverlap(AActor* OtherActor) override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;PickUp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat RespawnTime;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;PickUp&quot;, meta&#x3D;(ClampMin&#x3D;0.0333, ClampMax&#x3D;0.0083))\n\tfloat RotationYawRate;\n    \n    FTimerHandle RespawnHandle;\n\n\tFTimerHandle RotationYawHandle;\n\t\n\t&#x2F;&#x2F; Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;PickUp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUSphereComponent* CollisionComponent;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;PickUp&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tvoid PickUpWasTaken();\n\n\tUFUNCTION()\n\tvoid Respawn();\n\n\tUFUNCTION()\n\tvoid LoopRotationYawHandle();\n\n\tUFUNCTION()\n\tvoid BeginRotationYaw();\n\n\tUFUNCTION()\n\tvirtual bool GivePickUpTo(APawn* PlayerPawn) &#123; return false; &#125;\n&#125;;\n\n# NotifyActorBeginOverlap(AActor* OtherActor)\n\t&#x2F;** \n\t *\tEvent when this actor overlaps another actor, for example a player walking into a trigger.\n\t *\tFor events when objects have a blocking collision, for example a player hitting a wall, see &#39;Hit&#39; events.\n\t *\t@note Components on both this and the other Actor must have bGenerateOverlapEvents set to true to generate overlap events.\n\t *&#x2F;\n\n\n\n实现：\n#include &quot;STUBasePickUp.h&quot;\n#include &quot;Components&#x2F;SphereComponent.h&quot;\n\nASTUBasePickUp::ASTUBasePickUp()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; false;\n\n    RespawnTime &#x3D; 5.0f;\n\tRotationYawRate &#x3D; 0.0333f;\n    \n    CollisionComponent &#x3D; CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;CollisionComp&quot;));\n\tRootComponent &#x3D; CollisionComponent;\n\tCollisionComponent-&gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\n\tCollisionComponent-&gt;InitSphereRadius(50.f);\n\n\tStaticMeshComponent &#x3D; CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;MeshComp&quot;));\n\tStaticMeshComponent-&gt;SetupAttachment(RootComponent);\n\tStaticMeshComponent-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\tStaticMeshComponent-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);\n&#125;\n\nvoid ASTUBasePickUp::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tcheck(CollisionComponent);\n\tcheck(StaticMeshComponent);\n\n\tLoopRotationYawHandle();\n&#125;\n\nvoid ASTUBasePickUp::NotifyActorBeginOverlap(AActor* OtherActor)\n&#123;\n\tSuper::NotifyActorBeginOverlap(OtherActor);\n\n\tconst auto Player &#x3D; Cast&lt;APawn&gt;(OtherActor);\n\t\n\tif (!GivePickUpTo(Player))&#123;return;&#125;\n\tPickUpWasTaken();\n&#125;\n\n&#x2F;* My Code *&#x2F;\nvoid ASTUBasePickUp::PickUpWasTaken()\n&#123;\n\tif (!GetRootComponent())&#123;return;&#125;\n\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Ignore);\n\tGetRootComponent()-&gt;SetVisibility(false, true);\n    \n\tGetWorldTimerManager().SetTimer(RespawnHandle, this, &amp;ASTUBasePickUp::Respawn, RespawnTime, false);\n\tGetWorldTimerManager().ClearTimer(RotationYawHandle);\n&#125;\n\nvoid ASTUBasePickUp::Respawn()\n&#123;\n\tif (!GetRootComponent())&#123;return;&#125;\n\tCollisionComponent-&gt;SetCollisionResponseToAllChannels(ECR_Overlap);\n\tGetRootComponent()-&gt;SetVisibility(true, true);\n    \n\tGetWorldTimerManager().ClearTimer(RespawnHandle);\n\tLoopRotationYawHandle();\n&#125;\n\nvoid ASTUBasePickUp::LoopRotationYawHandle()\n&#123;\n\tif (!StaticMeshComponent &amp;&amp; !RespawnHandle.IsValid())&#123;return;&#125;\n\tGetWorldTimerManager().SetTimer(\n        RotationYawHandle, \n        this, \n        &amp;ASTUBasePickUp::BeginRotationYaw, \n        RotationYawRate, \n        true);\n&#125;\n\nvoid ASTUBasePickUp::BeginRotationYaw()\n&#123;\n\tStaticMeshComponent-&gt;AddRelativeRotation(FRotator(0, 1.f, 0.f));\n&#125;\n\n\n\n注意：\n# 示例中是通过 AActor 自带的 NotifyActorBeginOverlap(AActor* OtherActor) 实现交互\n# 也可以通过 USphereComponent-&gt;UShapeComponent-&gt;UPrimitiveComponent 内的 FComponentHitSignature OnComponentHit; 实现交互\n\n################## 委托名称 ###############\n&#x2F;** \n\t *\tEvent called when a component hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with &#39;sweep&#39; enabled, or physics simulation.\n\t *\tFor events when objects overlap (e.g. walking into a trigger) see the &#39;Overlap&#39; event.\n\t *\n\t *\t@note For collisions during physics simulation to generate hit events, &#39;Simulation Generates Hit Events&#39; must be enabled for this component.\n\t *\t@note When receiving a hit from another object&#39;s movement, the directions of &#39;Hit.Normal&#39; and &#39;Hit.ImpactNormal&#39;\n\t *\twill be adjusted to indicate force from the other object against this object.\n\t *\t@note NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions.\n\t *&#x2F;\n\tUPROPERTY(BlueprintAssignable, Category&#x3D;&quot;Collision&quot;)\n\tFComponentHitSignature OnComponentHit;\n\n################### 委托绑定的函数参数列表 ##################\n\n&#x2F;**\n * Delegate for notification of blocking collision against a specific component.  \n * NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions. \n *&#x2F;\nDECLARE_DYNAMIC_MULTICAST_SPARSE_DELEGATE_FiveParams( FComponentHitSignature, UPrimitiveComponent, OnComponentHit, UPrimitiveComponent*, HitComponent, AActor*, OtherActor, UPrimitiveComponent*, OtherComp, FVector, NormalImpulse, const FHitResult&amp;, Hit );\n\n30. AIController情景：\n\n与前面AIPerception获得最近Actor想关联\n利用AIPerceptionComponent获取最近的Actor\n通过TimerHandle控制检测频率\n通过获得黑板组件，获得设置的最近的Actor\n让AIControlller控制AI面向最近的Actor\nAIController获得自己绑定的AI，执行有效的BehaviorTree\n通过FName手动指定获得黑板组件中指定的Key\n\n示例：\n\n定义：\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;AIController.h&quot;\n#include &quot;STUAIController.generated.h&quot;\n\nclass USTUAIPerceptionComponent;\nstruct FTimerHandle;\n\nUCLASS()\nclass B_01_TPS_API ASTUAIController : public AAIController\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tASTUAIController();\n\t\nprotected:\n\tvirtual void OnPossess(APawn* InPawn) override;\n\tvirtual void BeginPlay() override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY()\n\tbool IsRunBehavior;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat CheckRate;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFName FocusOnKeyName;\n\t\npublic:\n\tFTimerHandle CheckClosetEnemyTimerHandle;\n\t\n\t&#x2F;&#x2F; Component\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUSTUAIPerceptionComponent* AIPerceptionComponent;\n\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION()\n\tvoid OnCheckClosetEnemy();\n\n\tUFUNCTION()\n\tAActor* GetFocusOnActor() const;\n&#125;;\n\n\n\n实现：\n#include &quot;STUAIController.h&quot;\n#include &quot;STUAI.h&quot;\n#include &quot;BehaviorTree&#x2F;BlackboardComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUAIPerceptionComponent.h&quot;\n\nASTUAIController::ASTUAIController()\n&#123;\n\tIsRunBehavior &#x3D; false;\n\tCheckRate &#x3D; 0.1f;\n    \n    &#x2F;&#x2F; 此处指定要访问 黑板组件 的 keyName\n\tFocusOnKeyName &#x3D; &quot;EnemyActor&quot;;\n\t\n    &#x2F;&#x2F; 此处指定初始化 AIPerceptionComponent\n\tAIPerceptionComponent &#x3D; CreateDefaultSubobject&lt;USTUAIPerceptionComponent&gt;(TEXT(&quot;AIPerceptionComp&quot;));\n\tif (AIPerceptionComponent)&#123;SetPerceptionComponent(*AIPerceptionComponent);&#125;\n&#125;\n\nvoid ASTUAIController::OnPossess(APawn* InPawn)\n&#123;\n\tSuper::OnPossess(InPawn);\n\n\tconst auto STUCharacter &#x3D; Cast&lt;ASTUAI&gt;(InPawn);\n\n    &#x2F;&#x2F; 此处执行 AI绑定的 BehaviorTree\n\tif (!STUCharacter || !STUCharacter-&gt;GetBehaviorTreeAsset())&#123;return;&#125;\n\tIsRunBehavior &#x3D; RunBehaviorTree(STUCharacter-&gt;GetBehaviorTreeAsset());\n&#125;\n\nvoid ASTUAIController::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n    &#x2F;&#x2F; 开始按频率 检测最近的Actor\n\tif (GetWorld() &amp;&amp; IsRunBehavior)\n\t&#123;\n\t\tGetWorldTimerManager().SetTimer(\n\t\t\tCheckClosetEnemyTimerHandle,\n\t\t\tthis,\n\t\t\t&amp;ASTUAIController::OnCheckClosetEnemy,\n\t\t\tCheckRate,\n\t\t\ttrue);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 设置 AI面向 最近的 Actor\nvoid ASTUAIController::OnCheckClosetEnemy()\n&#123;\n\tconst auto AimActor &#x3D; GetFocusOnActor();\n\tSetFocus(AimActor);\n&#125;\n\n&#x2F;&#x2F; 在黑板组件的指定key中 拿到以设置的 最近的Actor\nAActor* ASTUAIController::GetFocusOnActor() const\n&#123;\n\tif (!GetBlackboardComponent())&#123;return nullptr;&#125;\n\treturn Cast&lt;AActor&gt;(GetBlackboardComponent()-&gt;GetValueAsObject(FocusOnKeyName));\n&#125;\n\n31. AI初始化和过渡旋转情景：\n\n初始化一个基本的AI\n通过前面的AIController已经可以面向最近的Actor，但旋转没有过渡，需要实现过渡\n关联相应的BehaviorTree\n有Dead相关函数，方便通过AIcontroller停止AI的行为\n\n示例：\n\n定义：\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;B_01_TPS&#x2F;Player&#x2F;STUCharacterBase.h&quot;\n#include &quot;STUAI.generated.h&quot;\n\nclass UBehaviorTree;\n\nUCLASS()\nclass B_01_TPS_API ASTUAI : public ASTUCharacterBase\n&#123;\n\tGENERATED_BODY()\n\nprotected:\n\tASTUAI(const FObjectInitializer&amp; ObjectInit);\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tUBehaviorTree* BehaviorTreeAsset;\n\npublic:\n\tUFUNCTION()\n\tFORCEINLINE UBehaviorTree* GetBehaviorTreeAsset() const &#123;return BehaviorTreeAsset;&#125;\n\n\tvirtual void OnDead() override;\n&#125;;\n\n\n\n实现：\n#include &quot;STUAI.h&quot;\n#include &quot;BrainComponent.h&quot;\n#include &quot;STUAIController.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUAIWeaponActorComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUCharacterMovementComponent.h&quot;\n\nASTUAI::ASTUAI(const FObjectInitializer&amp; ObjectInit) :\nSuper(ObjectInit.SetDefaultSubobjectClass&lt;USTUAIWeaponActorComponent&gt;(&quot;WeaponActorComponent&quot;))\n&#123;\n    &#x2F;&#x2F; 初始化 AI 和 AIController\n\tAutoPossessAI &#x3D; EAutoPossessAI::PlacedInWorldOrSpawned;\n\tAIControllerClass &#x3D; ASTUAIController::StaticClass();\n\t\n    &#x2F;&#x2F; 利用 CharacterMovementComponent 设置 AI 旋转面向 最近Actor 的过渡效果\n\tif (GetCharacterMovement())\n\t&#123;\n\t\tbUseControllerRotationYaw &#x3D; false;\n\t\tGetCharacterMovement()-&gt;bUseControllerDesiredRotation &#x3D; true;\n\t\tGetCharacterMovement()-&gt;RotationRate &#x3D; FRotator(0.f, 200.f, 0.f);\n\t&#125;\n&#125;\n\nvoid ASTUAI::OnDead()\n&#123;\n\tSuper::OnDead();\n\n    &#x2F;&#x2F; 通知 AIController 停止 AI行为\n\tconst auto STUController &#x3D; Cast&lt;AAIController&gt;(Controller);\n\tif (STUController &amp;&amp; STUController-&gt;BrainComponent)\n\t&#123;\n\t\tSTUController-&gt;BrainComponent-&gt;Cleanup();\n\t&#125;\n&#125;\n\n32. BeHaviorTree Task情景：\n\nAI Task的关键信息是AIController和BlackBoardComp\n通过AIController获得绑定的AI Pawn\n通过UNavigationSystemV1获得场景的NavMesh导航\n利用BlackBoardComp获得和设置Key值\n以玩家随机进入下一个场景随机点为例\n\n示例：\n\n定义：\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;BehaviorTree&#x2F;BTTaskNode.h&quot;\n#include &quot;STUNextLocationTask.generated.h&quot;\n\nstruct FBlackboardKeySelector;\n\nUCLASS()\nclass B_01_TPS_API USTUNextLocationTask : public UBTTaskNode\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUSTUNextLocationTask();\n\nprotected:\n\tvirtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI|Task&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tfloat Radius;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI|Task&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFBlackboardKeySelector AimLocationKey;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI|Task&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tbool IsSelfCenter;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI|Task&quot;,\n\t\tmeta&#x3D;(AllowPrivateAccess&#x3D;true, EditCondition&#x3D;&quot;!IsSelfCenter&quot;))\n\tFBlackboardKeySelector CenterActorKey;\n&#125;;\n\n\n\n实现：\n#include &quot;STUNextLocationTask.h&quot;\n\n#include &quot;AIController.h&quot;\n#include &quot;NavigationSystem.h&quot;\n#include &quot;BehaviorTree&#x2F;BlackboardComponent.h&quot;\n\nUSTUNextLocationTask::USTUNextLocationTask()\n&#123;\n\tRadius &#x3D; 1000.f;\n\tNodeName &#x3D; &quot;Next Location&quot;;\n\tIsSelfCenter &#x3D; true;\n&#125;\n\nEBTNodeResult::Type USTUNextLocationTask::ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)\n&#123;\n    &#x2F;&#x2F; 获得 AIController 和 BlackBoardComp\n\tconst auto Controller &#x3D; OwnerComp.GetAIOwner();\n\tconst auto BlackBoard &#x3D; OwnerComp.GetBlackboardComponent();\n\n    &#x2F;&#x2F; 通过 AIController 获得 AI Pawn\n\tif (!Controller || !BlackBoard)&#123;return EBTNodeResult::Failed;&#125;\n\tconst auto Pawn &#x3D; Controller-&gt;GetPawn();\n\n    &#x2F;&#x2F; 获得场景中的 NavMeshSystem\n\tif (!Pawn)&#123;return EBTNodeResult::Failed;&#125;\n\tconst auto NavSys &#x3D; UNavigationSystemV1::GetCurrent(Pawn);\n\n    &#x2F;&#x2F; 先获得 AI 当前的位置\n\tif (!NavSys)&#123;return EBTNodeResult::Failed;&#125;\n\tFNavLocation NavLocation;\n\tauto Location &#x3D; Pawn-&gt;GetActorLocation();\n\n    &#x2F;&#x2F; 判断 AI 是否已经到达 随机的位置\n    &#x2F;&#x2F; 通过 黑板组件获得 指定位置的 AI 的 key值\n\tif (IsSelfCenter)&#123;return EBTNodeResult::Failed;&#125;\n\tconst auto CenterActor &#x3D; Cast&lt;AActor&gt;(BlackBoard-&gt;GetValueAsObject(CenterActorKey.SelectedKeyName));\n\n    &#x2F;&#x2F; 但 AI到达随机位置，设置下个随机点的 位置\n\tif (!CenterActor)&#123;return EBTNodeResult::Failed;&#125;\n\tLocation &#x3D; CenterActor-&gt;GetActorLocation();\n\tconst bool IsFound &#x3D; NavSys-&gt;GetRandomReachablePointInRadius(Location, Radius, NavLocation);\n\n    &#x2F;&#x2F; 设定好下个 随机位置，需要用 黑板组件 设置 新的位置 key值\n\tif (!IsFound)&#123;return EBTNodeResult::Failed;&#125;\n\tBlackBoard-&gt;SetValueAsVector(AimLocationKey.SelectedKeyName, NavLocation.Location);\n\treturn EBTNodeResult::Succeeded;\n&#125;\n\n33. BehaviorTree Service情景：\n\n利用前面AIPerceptionComponent，设置新的目标Actor\n以通过AIPerceptionComponent获得新目标，设置黑板组件为例\n\n示例：\n\n定义：\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;BehaviorTree&#x2F;BTService.h&quot;\n#include &quot;STUFindEnemyBTService.generated.h&quot;\n\nstruct FBlackboardKeySelector;\n\nUCLASS()\nclass B_01_TPS_API USTUFindEnemyBTService : public UBTService\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUSTUFindEnemyBTService();\n\nprotected:\n\tvirtual void TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Property\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;AI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tFBlackboardKeySelector EnemyActorKey;\n&#125;;\n\n\n\n实现：\n#include &quot;STUFindEnemyBTService.h&quot;\n#include &quot;AIController.h&quot;\n#include &quot;BehaviorTree&#x2F;BlackboardComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUAIPerceptionComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Dev&#x2F;STUUtils.h&quot;\n\nUSTUFindEnemyBTService::USTUFindEnemyBTService()\n&#123;\n\tNodeName &#x3D; &quot;Find Enemy&quot;;\n&#125;\n\nvoid USTUFindEnemyBTService::TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds)\n&#123;\n\tSuper::TickNode(OwnerComp, NodeMemory, DeltaSeconds);\n\n    &#x2F;&#x2F; 获得 黑板 和 AIController\n\tconst auto BlackBoard &#x3D; OwnerComp.GetBlackboardComponent();\n\n\tif (!BlackBoard)&#123;return;&#125;\n\tconst auto Controller &#x3D; OwnerComp.GetAIOwner();\n\n    &#x2F;&#x2F; 获得 PerceptionComponent\n\tif (!Controller)&#123;return;&#125;\n\tconst auto PerceptionComponent &#x3D; STUUtils::GetSTUPlayerComponent&lt;USTUAIPerceptionComponent&gt;(Controller);\n\n    &#x2F;&#x2F; 从 PerceptionComponent 得到新的 Actort 设置到 黑板 的 key值\n\tif (!PerceptionComponent)&#123;return;&#125;\n\tBlackBoard-&gt;SetValueAsObject(EnemyActorKey.SelectedKeyName, PerceptionComponent-&gt;GetClosetEnemy());\n&#125;\n\n34. HUD生成Widget情景：\n\n设置自己的HUD生成指定Widget\n\n示例：\n\n定义：\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;HUD.h&quot;\n#include &quot;STUGameHUD.generated.h&quot;\n\nUCLASS()\nclass B_01_TPS_API ASTUGameHUD : public AHUD\n&#123;\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void BeginPlay() override;\n\t\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Function\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;UI&quot;, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\tTSubclassOf&lt;UUserWidget&gt; PlayerHUDWidgetClass;\n&#125;;\n\n\n\n实现：\n#include &quot;STUGameHUD.h&quot;\n#include &quot;Blueprint&#x2F;UserWidget.h&quot;\n#include &quot;Engine&#x2F;Canvas.h&quot;\n\nvoid ASTUGameHUD::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n\n\tconst auto PlayerHUDWidget &#x3D; CreateWidget&lt;UUserWidget&gt;(GetWorld(), PlayerHUDWidgetClass);\n\n\tif (!PlayerHUDWidget)&#123;return;&#125;\n\tPlayerHUDWidget-&gt;AddToViewport();\n&#125;\n\n35. HUD绘制准星情景：\n\n直接通过HUD生成静态准星\n\n示例：\n\n定义：\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;HUD.h&quot;\n#include &quot;STUGameHUD.generated.h&quot;\n\nUCLASS()\nclass B_01_TPS_API ASTUGameHUD : public AHUD\n&#123;\n\tGENERATED_BODY()\n\nprotected:\n\tvirtual void DrawHUD() override;\npublic:\n\tUFUNCTION()\n\tvoid DrawCrossHair();\n&#125;;\n\n\n\n实现：\n#include &quot;STUGameHUD.h&quot;\n#include &quot;Blueprint&#x2F;UserWidget.h&quot;\n#include &quot;Engine&#x2F;Canvas.h&quot;\n\nvoid ASTUGameHUD::DrawHUD()\n&#123;\n\tSuper::DrawHUD();\n\n\tDrawCrossHair();\n&#125;\n\nvoid ASTUGameHUD::DrawCrossHair()\n&#123;\n\tconst TInterval&lt;float&gt; Center(Canvas-&gt;SizeX * 0.5f, Canvas-&gt;SizeY * 0.5f);\n\tconstexpr float HalfLineSize &#x3D; 10.f;\n\tconstexpr float LineThickness &#x3D; 2.f;\n\tconst FColor LineColor &#x3D; FColor::Green;\n\n\tDrawLine(\n\t\tCenter.Min - HalfLineSize,\n\t\tCenter.Max,\n\t\tCenter.Min + HalfLineSize,\n\t\tCenter.Max,\n\t\tLineColor,\n\t\tLineThickness);\n\tDrawLine(\n\t\tCenter.Min,\n\t\tCenter.Max - HalfLineSize,\n\t\tCenter.Min,\n\t\tCenter.Max + HalfLineSize,\n\t\tLineColor,\n\t\tLineThickness);\n&#125;\n\n36. Widget创建蓝图可用函数情景：\n\nC++创建的Widget\n创建蓝图可调用函数\n\n示例：\n\n定义：\nUCLASS()\nclass B_01_TPS_API USTUPlayerHUDWidget : public UUserWidget\n&#123;\n\tGENERATED_BODY()\n\n&#x2F;* My Code *&#x2F;\n\t&#x2F;&#x2F; Function\npublic:\n\tUFUNCTION(BlueprintCallable)\n\tfloat GetHealthPercent() const;\n\n\tUFUNCTION(BlueprintCallable)\n\tbool IsPlayerAlive() const;\n\n\tUFUNCTION(BlueprintCallable)\n\tbool IsPlayerSpectating() const;\n&#125;;\n\n\n\n实现：\n#include &quot;STUPlayerHUDWidget.h&quot;\n#include &quot;B_01_TPS&#x2F;Dev&#x2F;STUUtils.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUHealthActorComponent.h&quot;\n#include &quot;B_01_TPS&#x2F;Component&#x2F;STUWeaponActorComponent.h&quot;\n\nfloat USTUPlayerHUDWidget::GetHealthPercent() const\n&#123;\n\tconst auto HealthComp &#x3D; STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(GetOwningPlayerPawn());\n\tif (!HealthComp)&#123;return 0.f;&#125;\n\treturn HealthComp-&gt;GetHPPercent();\n&#125;\n\nbool USTUPlayerHUDWidget::IsPlayerSpectating() const\n&#123;\n\tconst auto Controller &#x3D; GetOwningPlayer();\n\treturn Controller &amp;&amp; Controller-&gt;GetStateName() &#x3D;&#x3D; NAME_Spectating;\n&#125;\n\nbool USTUPlayerHUDWidget::IsPlayerAlive() const\n&#123;\n\tconst auto HealthComp &#x3D; STUUtils::GetSTUPlayerComponent&lt;USTUHealthActorComponent&gt;(GetOwningPlayerPawn());\n\treturn HealthComp &amp;&amp; !HealthComp-&gt;IsDead();\n&#125;\n\n37. UPROPERTY()情景：\n\n\n\n\n\n\n\n\n\nprivate：需要在蓝图中可读可写，任意处编辑\n\nUPROPERTY(EditAnywhere, BlueprintReadWrite, meta&#x3D;(AllowPrivateAccess&#x3D;true))\n\n\n\n\n\n\n\n\n\n\n以 bool IsTrue;为判断标准，为false时，编辑器处为不可编辑状态\n\nUPROPERTY(EditAnywhere, meta&#x3D;(EditCondition&#x3D;”IsTrue”))\n\n\n\n\n\n\n\n\n\n\nfloat HP;为例，在编辑器中设置的值要符合一个固定的范围\n\nUPROPERTY(EditAnywhere, meta&#x3D;(ClampMin&#x3D;0, ClampMax&#x3D;100))\n\n38. check-checkf-checkNoEntry情景：\n\n需要在BeginPlay()检测组件是否有效\ncheck(GetMesh());：如果GetMesh()无效，程序会中断\n\n还需要通过条件判断是否有效，同时打印指定语句到日志\n\n以float HP;为例，默认BeginPlay()时，HP应该大于0\ncheckf(HP &gt; 0.f, TEXT(&quot;HP Shound Great 0&quot;));\n\n应用于不可到达的代码片段，当出现不应该出现的情况时，程序中断\nvoid Function(AActor* Actor)\n&#123;\n    if (Actor)\n    &#123;\n        ....\n    &#125;\n    else\n    &#123;\n        checkNoEntry();\n    &#125;\n&#125;\n\n","slug":"7_UE4功能整理_09","date":"2022-10-06T07:28:25.960Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"cde83abaa86ff43674449a34230233bc","title":"UE4 反射编程","content":"UE4 反射编程1. 准备工作\n新建空白ue4 cpp项目：Reflective\n\n打开ReflectiveGameModeBase.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework&#x2F;GameModeBase.h&quot;\n#include &quot;ReflectiveGameModeBase.generated.h&quot;\n\nUCLASS()\nclass REFLECTIVE_API ReflectiveGameModeBase : public AGameModeBase\n&#123;\n\tGENERATED_UCLASS_BODY()\n\t\n&#125;;\n\n修改ReflectiveGameModeBase.cpp，创建构造函数\n#include &quot;ReflectiveGameModeBase.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Reflection Succeed\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Hello Reflective ]&quot;));\n&#125;\n\n编译运行：\nLogTemp: [ Hello Reflective ]\n\n2. 获取类名\n创建UE4 None类型 cpp文件：Student\n\nStudent.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n\nclass REFLECTIVE_API Student\n&#123;\npublic:\n\tStudent();\n    ~Student();\n&#125;\n\nStudent.cpp\n#include &quot;Student.h&quot;\n\nStudent::Student()\n&#123;\n&#125;\n\nStudent::~Student()\n&#123;\n&#125;\n\n需要进行修改，才能拥有虚幻的反射功能\n\nStudent.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Student.generated.h&quot; &#x2F;&#x2F; 1. #include &quot;文件名.generated.h&quot;\n\nUCLASS() &#x2F;&#x2F; 2. UCLASS() 是虚幻提供的类反射\nclass REFLECTIVE_API UStudent : public UObject &#x2F;&#x2F; 3. 需要继承UObject才能使用UCALSS(), 类名前面要加U\n&#123;\n\tGENERATED_BODY() &#x2F;&#x2F; 4. 要加入 GENERATED_BODY()\npublic:\n\tUStudent(); &#x2F;&#x2F; 5. 类名前要统一加U\n    &#x2F;&#x2F; 6. 因为继承UObject，不需要考虑垃圾回收，~Student()不需要\n&#125;;\n\nStudent.cpp\n#include &quot;Student.h&quot;\n\nUStudent::UStudent() &#x2F;&#x2F; 1. 类名前加 U\n&#123;\n&#125;\n\n&#x2F;&#x2F; 2. 不需要 Student::~Student()&#123;&#125;\n\n开始获取类型\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Get Class Name By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Name ]&quot;));\n\tUStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n\tconst FName StudentName &#x3D; StudentClass-&gt;GetFName();\n\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Name: %s --&gt;&quot;), *StudentName.ToString());\n&#125;\n\n打印结果：\nLogTemp: [ Get Class Name ]\nLogTemp: Warning: &lt;-- Class Name: Student --&gt;\n\n3. 获取类标签\nStudent.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Student.generated.h&quot;\n\nUCLASS(BlueprintType) &#x2F;&#x2F; 此次填入 BlueprintType\nclass REFLECTIVE_API UStudent : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\tUStudent();\n&#125;;\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n    UStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n\tconst FName StudentName &#x3D; StudentClass-&gt;GetFName();\n\n\t&#x2F;&#x2F; Get Class Flags By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Flags ]&quot;));\n\tEClassFlags StudentClassFlags &#x3D; StudentClass-&gt;ClassFlags;\n\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Name: %s, Class Flags: %x --&gt;&quot;),\n\t\t*StudentName.ToString(), StudentClassFlags);\n&#125;\n\n打印结果\nLogTemp: [ Get Class Flags ]\nLogTemp: Warning: &lt;-- Class Name: Student, Class Flags: 305000a0 --&gt;\n\n4. 获取类属性\nStudent.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Student.generated.h&quot;\n\nUCLASS(BlueprintType)\nclass REFLECTIVE_API UStudent : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\tUStudent();\n    \nprivate: &#x2F;&#x2F; 添加属性，要加入UPROPERTY()，否则无法参与反射\n\tUPROPERTY()\n\tFString Name;\n\n\tUPROPERTY()\n\tFString Country;\n&#125;;\n\nStudent.cpp\n#include &quot;Student.h&quot;\n\nUStudent::UStudent()\n&#123;\n\tName &#x3D; &quot;FHang&quot;;\n\tCountry &#x3D; &quot;China&quot;;\n&#125;\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n    UStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n\n\t&#x2F;&#x2F; Get Class Property Value By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Property Value ]&quot;))\n\tfor (FProperty *Property &#x3D; StudentClass-&gt;PropertyLink; Property; Property &#x3D; Property-&gt;PropertyLinkNext)\n\t&#123;\n\t\tFString PropertyName &#x3D; Property-&gt;GetName();\n\t\tFString PropertyType &#x3D; Property-&gt;GetCPPType();\n\t\t\n\t\tif (PropertyType &#x3D;&#x3D; &quot;FString&quot;)\n\t\t&#123;\n\t\t\tconst FStrProperty *StringProperty &#x3D; CastField&lt;FStrProperty&gt;(Property);\n\t\t\tvoid *Address &#x3D; StringProperty-&gt;ContainerPtrToValuePtr&lt;void&gt;(Student);\n\t\t\tFString PropertyValue &#x3D; StringProperty-&gt;GetPropertyValue(Address);\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Property: %s, Type: %s, Value: %s--&gt;&quot;),\n\t\t\t\t*PropertyName, *PropertyType, *PropertyValue);\n\t\t&#125;\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Class Property Value ]\nLogTemp: Warning: &lt;-- Class Property: Name, Type: FString, Value: FHang --&gt;\nLogTemp: Warning: &lt;-- Class Property: Country, Type: FString, Value: China --&gt;\n\n5. 获取类属性元数据\nStudent.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Student.generated.h&quot;\n\nUCLASS(BlueprintType)\nclass REFLECTIVE_API UStudent : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\tUStudent();\n    \nprivate:\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;Info&quot;) &#x2F;&#x2F; 添加元数据\n\tFString Name;\n\n\tUPROPERTY()\n\tFString Country;\n&#125;;\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n    UStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n\n\t&#x2F;&#x2F; Get Class Property Value By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Property Value ]&quot;))\n\tfor (FProperty *Property &#x3D; StudentClass-&gt;PropertyLink; Property; Property &#x3D; Property-&gt;PropertyLinkNext)\n\t&#123;\n        &#x2F;&#x2F; Get Class Property Meta By Reflection\n\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Property Meta ]&quot;))\n\t\tFString PropertyMeta &#x3D; Property-&gt;GetMetaData(TEXT(&quot;Category&quot;));\n\t\t\n\t\tif (PropertyType &#x3D;&#x3D; &quot;FString&quot;)\n\t\t&#123;\n\t\t\tconst FStrProperty *StringProperty &#x3D; CastField&lt;FStrProperty&gt;(Property);\n\t\t\tvoid *Address &#x3D; StringProperty-&gt;ContainerPtrToValuePtr&lt;void&gt;(Student);\n\t\t\tFString PropertyValue &#x3D; StringProperty-&gt;GetPropertyValue(Address);\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Property Meta: %s --&gt;&quot;), *PropertyMeta);\n\t\t&#125;\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Class Property Value ]\nLogTemp: [ Get Class Property Meta ]\nLogTemp: Warning: &lt;-- Class Property Meta: Info --&gt;\nLogTemp: Warning: &lt;-- Class Property Meta:  --&gt;\n\n6. 设置类属性值\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n    UStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n\n\t&#x2F;&#x2F; Get Class Property Value By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Property Value ]&quot;))\n\tfor (FProperty *Property &#x3D; StudentClass-&gt;PropertyLink; Property; Property &#x3D; Property-&gt;PropertyLinkNext)\n\t&#123;\n\t\tFString PropertyName &#x3D; Property-&gt;GetName();\n\t\tFString PropertyType &#x3D; Property-&gt;GetCPPType();\n\t\t\n\t\tif (PropertyType &#x3D;&#x3D; &quot;FString&quot;)\n\t\t&#123;\n\t\t\tconst FStrProperty *StringProperty &#x3D; CastField&lt;FStrProperty&gt;(Property);\n\t\t\tvoid *Address &#x3D; StringProperty-&gt;ContainerPtrToValuePtr&lt;void&gt;(Student);\n\t\t\tFString PropertyValue &#x3D; StringProperty-&gt;GetPropertyValue(Address);\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Property: %s, Type: %s, Value: %s --&gt;&quot;),\n\t\t\t\t*PropertyName, *PropertyType, *PropertyValue);\n\t\t\t\n\t\t\t&#x2F;&#x2F; Set Class Property Value By Reflection\n\t\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Set Class Property Value ]&quot;))\n\t\t\tStringProperty-&gt;SetPropertyValue(Address, &quot;XXXX&quot;);\n\t\t\tFString NewStringProperty &#x3D; StringProperty-&gt;GetPropertyValue(Address);\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class Property: %s, Type: %s, Value: %s --&gt;&quot;),\n\t\t\t\t*PropertyName, *PropertyType, *NewStringProperty);\n\t\t&#125;\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Class Property Value ]\nLogTemp: Warning: &lt;-- Class Property: Name, Type: FString, Value: FHang --&gt;\nLogTemp: [ Set Class Property Value ]\nLogTemp: Warning: &lt;-- Class Property: Name, Type: FString, Value: XXXX --&gt;\nLogTemp: Warning: &lt;-- Class Property: Country, Type: FString, Value: China --&gt;\nLogTemp: [ Set Class Property Value ]\nLogTemp: Warning: &lt;-- Class Property: Country, Type: FString, Value: XXXX --&gt;\n\n7. 获得类函数名\nStudent.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Student.generated.h&quot;\n\nUCLASS(BlueprintType)\nclass REFLECTIVE_API UStudent : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\tUStudent();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;Info&quot;)\n\tFString Name;\n\n\tUPROPERTY()\n\tFString Country;\n\npublic:\n\tUFUNCTION(BlueprintCallable)\n\tvoid Study()&#123;&#125;;\n\n\tUFUNCTION()\n\tvoid Demo01(int a, bool isA)&#123;&#125;;\n&#125;;\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n    UStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n    const FName StudentName &#x3D; StudentClass-&gt;GetFName();\n\t\n    &#x2F;&#x2F; Get Class Function Name By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function ]&quot;));\n\tfor (TFieldIterator&lt;UFunction&gt; IteratorOfFunction(StudentClass); IteratorOfFunction; ++IteratorOfFunction)\n\t&#123;\n\t\tconst UFunction *Function &#x3D; *IteratorOfFunction;\n\t\tFString FunctionName &#x3D; Function-&gt;GetName();\n\t\tif (FunctionName &#x3D;&#x3D; &quot;ExecuteUbergraph&quot;)&#123;continue;&#125;\n\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class: %s, Function: %s --&gt;&quot;), *StudentName.ToString(),\n\t\t\t*FunctionName);\n    &#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Class Function ]\nLogTemp: Warning: &lt;-- Class: Student, Function: Study --&gt;\nLogTemp: Warning: &lt;-- Class: Student, Function: Demo01 --&gt;\n\n8. 获取类函数标签\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n    UStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n    const FName StudentName &#x3D; StudentClass-&gt;GetFName();\n\t\n    &#x2F;&#x2F; Get Class Function Name By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function ]&quot;));\n\tfor (TFieldIterator&lt;UFunction&gt; IteratorOfFunction(StudentClass); IteratorOfFunction; ++IteratorOfFunction)\n\t&#123;\n\t\tconst UFunction *Function &#x3D; *IteratorOfFunction;\n\t\tFString FunctionName &#x3D; Function-&gt;GetName();\n\t\tif (FunctionName &#x3D;&#x3D; &quot;ExecuteUbergraph&quot;)&#123;continue;&#125;\n        \t\t\n        &#x2F;&#x2F; Get Class Function Flags\n\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function Flags ]&quot;))\n\t\tEFunctionFlags FunctionFlags &#x3D; Function-&gt;FunctionFlags;\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class: %s, Function: %s, Flags: %x --&gt;&quot;), *StudentName.ToString(),\n\t\t\t*FunctionName, FunctionFlags);\n    &#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Class Function ]\nLogTemp: [ Get Class Function Flags ]\nLogTemp: Warning: &lt;-- Class: Student, Function: Study, Flags: 4020401 --&gt;\nLogTemp: [ Get Class Function Flags ]\nLogTemp: Warning: &lt;-- Class: Student, Function: Demo01, Flags: 20401 --&gt;\n\n9. 获取类函数参数\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n    UStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n\t\n    &#x2F;&#x2F; Get Class Function Name By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function ]&quot;));\n\tfor (TFieldIterator&lt;UFunction&gt; IteratorOfFunction(StudentClass); IteratorOfFunction; ++IteratorOfFunction)\n\t&#123;\n\t\tconst UFunction *Function &#x3D; *IteratorOfFunction;\n\t\tFString FunctionName &#x3D; Function-&gt;GetName();\n\t\tif (FunctionName &#x3D;&#x3D; &quot;ExecuteUbergraph&quot;)&#123;continue;&#125;\n        \t\t\n        &#x2F;&#x2F; Get Class Function Params By Reflection\n\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Function Params ]&quot;));\n\t\tfor (TFieldIterator&lt;FProperty&gt; IteratorOfParams(Function); IteratorOfParams; ++IteratorOfParams)\n\t\t&#123;\n\t\t\tconst FProperty *Param &#x3D; *IteratorOfParams;\n\t\t\tFString ParamType &#x3D; Param-&gt;GetCPPType();\n\t\t\tFString ParamName &#x3D; Param-&gt;GetName();\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Function: %s, ParamType: %s, ParamName: %s --&gt;&quot;),\n\t\t\t\t*FunctionName, *ParamType, *ParamName);\n\t\t&#125;\n    &#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Class Function ]\nLogTemp: [ Get Function Params ]\nLogTemp: Warning: &lt;-- Function: Demo01, ParamType: int32, ParamName: a --&gt;\nLogTemp: Warning: &lt;-- Function: Demo01, ParamType: bool, ParamName: isA --&gt;\n\n10. 获取类函数参数标签\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n    UStudent *Student &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *StudentClass &#x3D; Student-&gt;GetClass();\n\t\n    &#x2F;&#x2F; Get Class Function Name By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Class Function ]&quot;));\n\tfor (TFieldIterator&lt;UFunction&gt; IteratorOfFunction(StudentClass); IteratorOfFunction; ++IteratorOfFunction)\n\t&#123;\n\t\tconst UFunction *Function &#x3D; *IteratorOfFunction;\n\t\tFString FunctionName &#x3D; Function-&gt;GetName();\n\t\tif (FunctionName &#x3D;&#x3D; &quot;ExecuteUbergraph&quot;)&#123;continue;&#125;\n        \t\t\n        &#x2F;&#x2F; Get Class Function Params By Reflection\n\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Function Params ]&quot;));\n\t\tfor (TFieldIterator&lt;FProperty&gt; IteratorOfParams(Function); IteratorOfParams; ++IteratorOfParams)\n\t\t&#123;\n\t\t\tconst FProperty *Param &#x3D; *IteratorOfParams;\n\n            &#x2F;&#x2F; Get Function Params Flags By Reflection\n\t\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Params Flags ]&quot;));\n\t\t\tEPropertyFlags ParamFlag &#x3D; Param-&gt;GetPropertyFlags();\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Function: %s, Flags: %x --&gt;&quot;),\n\t\t\t\t*FunctionName, ParamFlag);\n\t\t&#125;\n    &#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Class Function ]\nLogTemp: [ Get Function Params ]\nLogTemp: [ Get Params Flags ]\nLogTemp: Warning: &lt;-- Function: Demo01, ParamType: int32, ParamName: a, Flags: 40000280 --&gt;\nLogTemp: [ Get Params Flags ]\nLogTemp: Warning: &lt;-- Function: Demo01, ParamType: bool, ParamName: isA, Flags: 40000280 --&gt;\n\n11. 获取父类\n新建Student子类SubStudent\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;SubStudent.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Get SubClass FatherClass By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get FatherClass ]&quot;));\n\tconst USubStudent *SubStudent &#x3D; NewObject&lt;USubStudent&gt;();\n\tconst UClass *FatherClass &#x3D; SubStudent-&gt;GetClass()-&gt;GetSuperClass();\n\tconst FString SubClassName &#x3D; SubStudent-&gt;GetClass()-&gt;GetName();\n\tconst FString FatherClassName &#x3D; FatherClass-&gt;GetName();\n\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SubClass: %s, SuperClass: %s --&gt;&quot;), *SubClassName, *FatherClassName);\n&#125;\n\n打印结果：\nLogTemp: [ Get FatherClass ]\nLogTemp: Warning: &lt;-- SubClass: SubStudent, SuperClass: Student --&gt;\n\n12. 判断是否是子类\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n#include &quot;SubStudent.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Determine if the current class is a subclass of another class By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Determine Is SubClass ]&quot;));\n\tconst UClass *Class1 &#x3D; UStudent::StaticClass();\n\tconst UClass *Class2 &#x3D; USubStudent::StaticClass();\n\tconst UClass *Class3 &#x3D; AActor::StaticClass();\n\tif (Class2-&gt;IsChildOf(Class1))\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s Is %s SubClass --&gt;&quot;), \n\t\t\t*Class2-&gt;GetName(), *Class1-&gt;GetName());\n\t&#125;\n\tif (!Class3-&gt;IsChildOf(Class1))\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s Is Not %s SubClass --&gt;&quot;),\n\t\t\t*Class3-&gt;GetName(), *Class1-&gt;GetName());\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Determine Is SubClass ]\nLogTemp: Warning: &lt;-- SubStudent Is Student SubClass --&gt;\nLogTemp: Warning: &lt;-- Actor Is Not Student SubClass --&gt;\n\n13. 查找类的所有子类\n新建Student子类Sub1Student\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\tconst *NewStudent &#x3D; NewObject&lt;UStudent&gt;();\n\tconst UClass *FatherClass &#x3D; NewStudent-&gt;GetClass();\n\t\n\t&#x2F;&#x2F; Find Current Class All Of SubClass By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Current Class All Of SubClass ]&quot;));\n\tTArray&lt;UClass*&gt; ClassArray;\n\tGetDerivedClasses(FatherClass, ClassArray, false);\n\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SuperClass: %s --&gt;&quot;), *FatherClassName);\n\tfor (const auto &amp;Elem : ClassArray)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SubClass: %s --&gt;&quot;), *Elem-&gt;GetName());\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Current Class All Of SubClass ]\nLogTemp: Warning: &lt;-- SuperClass: Student --&gt;\nLogTemp: Warning: &lt;-- SubClass: Sub1Student --&gt;\nLogTemp: Warning: &lt;-- SubClass: SubStudent --&gt;\n\n14. 查找类生成的所有对象\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;Sub1Student.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Get Current Class Generated Objects By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Current Class Generated Objects ]&quot;));\n\tTArray&lt;UObject*&gt; ObjectsArray;\n\tUSub1Student *Sub1Student &#x3D; NewObject&lt;USub1Student&gt;(this, FName(&quot;Sub1Student&quot;));\n\tUSub1Student *Sub1 &#x3D; NewObject&lt;USub1Student&gt;(this, FName(&quot;Sub1&quot;));\n\tGetObjectsOfClass(USub1Student::StaticClass(), ObjectsArray, false);\n\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Current Class: %s --&gt;&quot;), *Sub1Student-&gt;GetName());\n\tfor (const auto &amp;Elem : ObjectsArray)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Object: %s --&gt;&quot;), *Elem-&gt;GetName());\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Current Class Generated Objects ]\nLogTemp: Warning: &lt;-- Current Class: Sub1Student --&gt;\nLogTemp: Warning: &lt;-- Object: Sub1Student --&gt;\nLogTemp: Warning: &lt;-- Object: Sub1 --&gt;\n\n15. 通过字符串查找类\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Use String Find Class By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Class ]&quot;));\n\tUClass *FindedClass &#x3D; FindObject&lt;UClass&gt;(ANY_PACKAGE, *FString(&quot;Student&quot;), true);\n\tif (FindedClass)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Find %s Succeed --&gt;&quot;), *FindedClass-&gt;GetName());\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Use String Find Class ]\nLogTemp: Warning: &lt;-- Find Student Succeed --&gt;\n\n16. 通过字符查找枚举\nStudent.h中定义EStudentType枚举\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Student.generated.h&quot;\n\nUENUM()\nenum class EStudentType : uint8\n&#123;\n\tE_GOOD UMETA(DisplayName &#x3D; &quot;GOOD&quot;),\n\tE_BAD UMETA(DisplayName &#x3D; &quot;BAD&quot;)\n&#125;;\n\nUCLASS(BlueprintType)\nclass REFLECTIVE_API UStudent : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\tUStudent();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category&#x3D;&quot;Info&quot;)\n\tFString Name;\n\n\tUPROPERTY()\n\tFString Country;\n\npublic:\n\tUFUNCTION(BlueprintCallable)\n\tvoid Study()&#123;&#125;;\n\n\tUFUNCTION()\n\tvoid Demo01(int a, bool isA)&#123;&#125;;\n&#125;;\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Use String Find Enum By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Enum ]&quot;));\n\tUEnum *FindedEnum &#x3D; FindObject&lt;UEnum&gt;(ANY_PACKAGE, *FString(&quot;EStudentType&quot;), true);\n\tif (FindedEnum)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Find %s Succeed --&gt;&quot;), *FindedEnum-&gt;GetName());\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Use String Find Enum ]\nLogTemp: Warning: &lt;-- Find EStudentType Succeed --&gt;\n\n17. 获得枚举的所有项\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Use String Find Enum By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Enum ]&quot;));\n\tUEnum *FindedEnum &#x3D; FindObject&lt;UEnum&gt;(ANY_PACKAGE, *FString(&quot;EStudentType&quot;), true);\n\tif (FindedEnum)\n\t&#123;        \t\t\n        &#x2F;&#x2F; Get Current Enum All Of Elements By Reflection\n\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get Current Enum All Of Elements ]&quot;));\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Enum: %s --&gt;&quot;), *FindedEnum-&gt;GetName());\n\t\tfor (int8 Index &#x3D; 0; Index &lt; FindedEnum-&gt;NumEnums(); ++Index)\n\t\t&#123;\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;Elem: %s&quot;), *FindedEnum-&gt;GetNameStringByIndex(Index));\n\t\t&#125;\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get Current Enum All Of Elements ]\nLogTemp: Warning: &lt;-- Enum: EStudentType --&gt;\nLogTemp: Warning: Elem: E_GOOD\nLogTemp: Warning: Elem: E_BAD\nLogTemp: Warning: Elem: E_MAX\n\n18. 通过字符串查找蓝图类\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Use String Find Blueprint Class\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Blueprint Class ]&quot;));\n\tUBlueprint *FindedBlueprint &#x3D; FindObject&lt;UBlueprint&gt;(ANY_PACKAGE, *FString(&quot;BP_Student&quot;));\n\tif (FindedBlueprint)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Find %s Succeed --&gt;&quot;), *FindedBlueprint-&gt;GetName());\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Use String Find Blueprint Class ]\nLogTemp: &lt;-- Find BP_Student Succeed --&gt;\n\n19. 判断蓝图是否是Native\n在UE中通过Student.cpp类新建BP_Student蓝图类\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Use String Find Blueprint Class\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Blueprint Class ]&quot;));\n\tUBlueprint *FindedBlueprint &#x3D; FindObject&lt;UBlueprint&gt;(ANY_PACKAGE, *FString(&quot;BP_Student&quot;));\n\tif (FindedBlueprint)\n\t&#123;\n\t\t&#x2F;&#x2F; Determine Is BlueprintClass Or Native(Cpp) Class By Reflection\n\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Determine Is BlueprintClass Or Native ]&quot;));\n\t\tif (!FindedBlueprint-&gt;IsNative())\n\t\t&#123;\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s Is Blueprint Class --&gt;&quot;), *FindedBlueprint-&gt;GetName());\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s Is Native Class --&gt;&quot;), *FindedBlueprint-&gt;GetName());\n\t\t&#125;\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Use String Find Blueprint Class ]\nLogTemp: [ Determine Is BlueprintClass Or Native ]\nLogTemp: &lt;-- BP_Student Is Blueprint Class --&gt;\n\n20. 获取所有类\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Get All Class By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Get All Class ]&quot;));\n\tTArray&lt;FString&gt; AllClassNames;\n\tfor (TObjectIterator&lt;UClass&gt; ClassIt; ClassIt; ++ClassIt)\n\t&#123;\n\t\tFString ClassName &#x3D; ClassIt-&gt;GetName();\n\t\tAllClassNames.Emplace(ClassName);\n\t&#125;\n\tfor (const auto &amp;Elem : AllClassNames)\n\t&#123;\n\t\tif (Elem &#x3D;&#x3D; &quot;Student&quot;)\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- %s --&gt;&quot;), *Elem);\n\t&#125;\n&#125;\n\n打印结果：\nLogTemp: [ Get All Class ]\nLogTemp: Warning: &lt;-- Student --&gt;\n\n21. 通过字符串查找类函数\nSubStudent.h定义函数\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Student.h&quot;\n#include &quot;SubStudent.generated.h&quot;\n\nUCLASS()\nclass REFLECTIVE_API USubStudent : public UStudent\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION()\n\tvoid PlayGame(FString GameName);\n\n\tUFUNCTION()\n\tint IsBoy();\n&#125;;\n\nSubStudent.cpp实现函数\n#include &quot;SubStudent.h&quot;\n\nvoid USubStudent::PlayGame(FString GameName)\n&#123;\n\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SubStudent::PlayGame(FString)&gt;&gt; Play %s --&gt;&quot;), *GameName);\n&#125;\n\nint USubStudent::IsBoy()\n&#123;\n\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- SubStudent::IsBoy&gt;&gt; Is Boy --&gt;&quot;));\n\treturn 1;\n&#125;\n\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;USubStudent.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Use String Find Class Function By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Class Function ]&quot;));\n\tUSubStudent *SubStudent01 &#x3D; NewObject&lt;USubStudent&gt;();\n\tif (UClass *SubStudent01Class &#x3D; SubStudent01-&gt;GetClass())\n\t&#123;\n\t\tUFunction *SubStudent01Function &#x3D; SubStudent01Class-&gt;FindFunctionByName(\n\t\t\tTEXT(&quot;PlayGame&quot;), EIncludeSuperFlag::ExcludeSuper);\n\t\tif (SubStudent01Function)\n\t\t&#123;\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Class: %s, Function: %s --&gt;&quot;),\n\t\t\t\t*SubStudent01-&gt;GetClass()-&gt;GetName(), *SubStudent01Function-&gt;GetName());\n\t\t&#125;\n    &#125;\n&#125;\n\n打印结果：\nLogTemp: [ Use String Find Class Function ]\nLogTemp: Warning: &lt;-- Class: SubStudent, Function: PlayGame --&gt;\n\n22. ProcessEvent调用类函数\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;USubStudent.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Use String Find Class Function By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Class Function ]&quot;));\n\tUSubStudent *SubStudent01 &#x3D; NewObject&lt;USubStudent&gt;();\n\tif (UClass *SubStudent01Class &#x3D; SubStudent01-&gt;GetClass())\n\t&#123;\n\t\tUFunction *SubStudent01Function &#x3D; SubStudent01Class-&gt;FindFunctionByName(\n\t\t\tTEXT(&quot;PlayGame&quot;), EIncludeSuperFlag::ExcludeSuper);\n\t\tif (!SubStudent01Function)&#123;break;&#125;\n        \n\t\t&#x2F;&#x2F; ProcessEvent Transfer Class Function By Reflection\n\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ ProcessEvent Transfer Class Function ]&quot;));\n        \n\t\t&#x2F;&#x2F; 1.Allocate Space For Parameters\n\t\tuint16 *AllParamMemory &#x3D; static_cast&lt;uint16*&gt;FMemory_Alloca(SubStudent01Function-&gt;ParmsSize);\n\t\tFMemory::Memzero(AllParamMemory, SubStudent01Function-&gt;ParmsSize);\n\t\t\n\t\t&#x2F;&#x2F; 2.Parameter assignment\n\t\tfor (TFieldIterator&lt;FProperty&gt; IteratorOfParams(SubStudent01Function); IteratorOfParams; ++IteratorOfParams)\n\t\t&#123;\n\t\t\tconst FProperty *Param &#x3D; *IteratorOfParams;\n\t\t\tFString ParamName &#x3D; Param-&gt;GetName();\n\t\t\tif (ParamName &#x3D;&#x3D; FString(&quot;GameName&quot;))\n\t\t\t&#123;\n\t\t\t\t*Param-&gt;ContainerPtrToValuePtr&lt;FString&gt;(AllParamMemory) &#x3D; &quot;CSGO&quot;;\n\t\t\t&#125;\n\t\t&#125;\n        \t\t\n        &#x2F;&#x2F; 3.Call Function(Method)\n\t\tSubStudent01-&gt;ProcessEvent(SubStudent01Function, AllParamMemory);\n    &#125;\n&#125;\n\n打印结果：\nLogTemp: [ Use String Find Class Function ]\nLogTemp: [ ProcessEvent Transfer Class Function ]\nLogTemp: Warning: &lt;-- SubStudent::PlayGame(FString)&gt;&gt; Play CSGO --&gt;\n\n23. Invoke调用类函数\nReflectiveGameModeBase.cpp\n#include &quot;ReflectiveGameModeBase.h&quot;\n#include &quot;USubStudent.h&quot;\n\nReflectiveGameModeBase::ReflectiveGameModeBase(const FObjectInitializer&amp; ObjectInitializer)\n\t:AGameModeBase(ObjectInitializer)\n&#123;\n\t&#x2F;&#x2F; Use String Find Class Function By Reflection\n\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Use String Find Class Function ]&quot;));\n\tUSubStudent *SubStudent01 &#x3D; NewObject&lt;USubStudent&gt;();\n\tif (UClass *SubStudent01Class &#x3D; SubStudent01-&gt;GetClass())\n\t&#123;   \n\t\t&#x2F;&#x2F; \tInvoke Transfer Class Function By Reflection\n\t\tUE_LOG(LogTemp, Log, TEXT(&quot;[ Invoke Transfer Class Function ]&quot;));\n\t\tif (UFunction *SubStudent02Function &#x3D; SubStudent01Class-&gt;FindFunctionByName(\n\t\t\tTEXT(&quot;IsBoy&quot;), EIncludeSuperFlag::ExcludeSuper))\n\t\t&#123;\n\n\t\t\t&#x2F;&#x2F; 1.Allocate Space For Parameters\n\t\t\tuint16 *AllParamMemory02 &#x3D; static_cast&lt;uint16*&gt;FMemory_Alloca(SubStudent02Function-&gt;ParmsSize);\n\t\t\tFMemory::Memzero(AllParamMemory02, SubStudent02Function-&gt;ParmsSize);\n\n\t\t\t&#x2F;&#x2F; 2.Create FFrame\n\t\t\tFFrame Frame(nullptr, SubStudent02Function, &amp;AllParamMemory02);\n\n\t\t\t&#x2F;&#x2F; 3.Invoke Function\n\t\t\tSubStudent02Function-&gt;Invoke(SubStudent02Function, Frame,\n\t\t\t\t&amp;AllParamMemory02 + SubStudent02Function-&gt;ReturnValueOffset);\n\n\t\t\t&#x2F;&#x2F; 4. Get Function Return Value\n\t\t\tint *ReturnValue &#x3D; reinterpret_cast&lt;int*&gt;(&amp;AllParamMemory02 + SubStudent02Function-&gt;ReturnValueOffset);\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;&lt;-- Return Value: %d --&gt;&quot;), *ReturnValue);\n\t\t&#125;\n    &#125;\n&#125;\n\n打印结果：\nLogTemp: [ Invoke Transfer Class Function ]\nLogTemp: Warning: &lt;-- SubStudent::IsBoy&gt;&gt; Is Boy --&gt;\nLogTemp: Warning: &lt;-- Return Value: 1 --&gt;\n\n","slug":"7_UE4反射编程_08","date":"2022-10-06T07:28:25.958Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"c7d8b276a0f55310d3a5259cec001a89","title":"UE4初始设置及个人使用崩溃记录","content":"日志：1.第一次记录：2020.2.05 版本：4.24.2\n\nUnrealEngine的初始设置1.在Epic中下载UnrealEngine4之后1-1. 首先：启动-选项\n1-2. 接着\t：（勾选）输入调试用符号-应用以后出现新的崩溃问题，方便查看详细原因\n2.进行UE4相关的文件配置2-1. 删除C盘中的缓存及修改UE4缓存地址问项目地址参照内容来源于CSDN博客文章：https://blog.csdn.net/cc13813194235/article/details/53424866同时本人以\tUE4_4.24.2版本\t亲测有效\n1.首先随便创建一个游戏项目，选择自己的项目目录\n2.创建完成后关闭UE4\n找到UE4的项目缓存目录\nC:\\Users\\用户名\\AppData\\Local\\UnrealEngine\\Common\\DerivedDataCache\n删除DerivedDataCache\n\n3.找到安装UE4的目录4.在 UE_4.24&#x2F;Engine&#x2F;Config 中找到 BaseEngine.ini 文件，直接用记事本打开\n5.编辑——查找——在查找框中输入 [InstalledDerivedDataBackendGraph]\n6.将 [InstalledDerivedDataBackendGraph] 下面的内容进行修改\n1 Local=(Type=FileSystem, ReadOnly=false,Clean=false, Flush=false, PurgeTransient=true, DeleteUnused=true,UnusedFileAge=34, FoldersToClean=-1, Path=&quot;%ENGINEVERSIONAGNOSTICUSERDIR%DerivedDataCache&quot;)\n\n修改为：\n1 Local=(Type=FileSystem, ReadOnly=false,Clean=false, Flush=false, PurgeTransient=true, DeleteUnused=true,UnusedFileAge=34, FoldersToClean=-1,Path=&quot;%GAMEDIR%DerivedDataCache&quot;)\n\n7.修改后进行验证是否修改成功    1.在BaseEngine.ini 文件中，在查找框中输入 [DerivedDataBackendGraph]        2.找到图中选中的文本，即修改成功，项目缓存路径以及改到项目文件夹内    \n2-2. 删除联机构建SwarmAgent程序的缓存缓存目录：C:\\Users\\用户名\\AppData\\Local\\UnrealEngine\\4.24\\Saved\\Swarm\\SwarmCache删除 SwarmCache\n3. UE4的相关设置3-1. 设置UE4启动时不编译蓝图参照内容来源于知乎文章：https://zhuanlan.zhihu.com/p/104097525\n1.找到配置文件路径：C:\\Users\\用户名\\AppData\\Local\\UnrealEngine\\4.24\\Saved\\Config\\Windows\\Engine.ini\n2.打开Engine.ini文件\n3.文本内容中添加\n[/Script/Engine.Blueprint]\nbRecompileOnLoad=False\n\n[/Script/Engine.LevelScriptBlueprint]\nbRecompileOnLoad=False\n\n[/Script/Engine.AnimBlueprint]\nbRecompileOnLoad=False\n\n4.保存，重启\n3-2. 设置仅编译成功时保存1.在随便打开一个蓝图，在编译的旁边有个倒三角，如图\n3-3. 显示编辑器实时信息1.编辑-编辑器偏好设置-通用-性能-勾选显示帧率和实时信息\n崩溃日志UE4崩溃日志（1）参照内容来源于虚幻4官方文档：https://docs.unrealengine.com/zh-CN/GettingStarted/RecommendedSpecifications/index.html里面有虚幻4的硬件配置要求，配套软件版本的需求，以及显卡驱动的需求\n因显卡驱动程序原因导致崩溃关键字：D3D11RHI、Rendering、Building\nD3D11 为Direct3D11（渲染管线），RHI 为Render hardware interface 渲染硬件层接口，d3d11.dll 为动态链接库Dynamic Link Library\n\n如图所示：解决方法：\n1.首先进入 NVIDIA GeForce Experience\n2.检查更新文件（旁边的三个点）-选择首选项-Studio驱动程序-检查更新文件（如图）3.检查到更新文件后，下载最新的驱动，自定义安装，勾选恢复默认设置\n4.重启电脑（最好重启一下）\nUE4崩溃日志（2）参考内容来源于知乎文章：https://zhuanlan.zhihu.com/p/45508890该知乎作者写了很多UE4的Bug以及部分崩溃解决方案\n虚幻4官方文档内容参考：https://docs.unrealengine.com/zh-CN/Engine/Rendering/Nvidia/NVIDIAAftermath/index.html\n因NVIDIA Aftermath 崩溃关键字：Aftermath、D3D11Query.cpp] [Line: 111] 、GPU has crashed\nAftermath 是一个轻量化的实用工具，可减轻部分调试工具对性能历史记录的要求。实际上，它相当轻量化，甚至可以包含在发布的游戏中，提供开发者需要的用户电脑数据。程序员可利用 Aftermath 在代码中插入标记，帮助追踪崩溃发生的根源。\n\n解决方法：    1.找到 ConsoleVariables.ini ，路径：安装的磁盘：UE_4.24\\Engine\\Config\\ConsoleVariables.ini    2.找到 [Startup]    3.在该区域文本内容下添加        r.DX11NVAfterMathEnabled&#x3D;0        r.GPUCrashDebugging&#x3D;0        如图：                4.保存，重启UE4\n","slug":"7_UE4初始设置及个人使用崩溃记录_01","date":"2022-10-06T07:28:25.955Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"01b2c0831f95e39e5fd56ec4f69b86cb","title":"UE4 RPC","content":"UE4 RPC1. RPC 架构1.1 架构简介\n一个服务器， 一个或多个客户端\n不能信任客户端，所有重要信息都需要通过服务器验证\nListen Server监听服务器和Dedicated Server专有服务器\n\n1.2 基本GamePlay结构\nServer\nGameMode 仅存在于Server\nGameState 同时存在与Server和Client\nPawn_Server, Pawn_A, Pawn_B 同时存在与Server和Client\nPlayerState_Server, PlayerState_A, PlayerState_B 同时存在与Server和Client\nPlayerController_Server 仅存在于Server\nPlayerController_A, PlayerController_B 同时存在与Server和各自所拥有的Client\nGameInstance, UI 同时存在与Server和各自所拥有的Client\n\n\nClient\n每个客户端都有独立的PlayerController和UI\n其余与Server同时拥有\n\n\n\n2. Listen Server2.1 Replication\n说明：\n信息从服务端同步到客户端(单向)\nActor及其派生类才有Replication的能力\n\n\n\n2.2 Replication类型\n类型：\n\nActor Replication\nProperty Replication\nComponent Replication\n\n\n在服务端进行操作：\nif (HasAuthority())\n&#123;\n\tTestNum &#x3D; 999.f;\n&#125;\n\n2.2.1 Actor Replication\n两层意义：\n\n服务端生成，客户端也跟着生成(在服务端生成一个replication对象)\n当前Actor的所有属性复制，组件复制，RPC的总开关\n\n\n开启Replication\n\n蓝图：勾选Replicates\n\nC++：在构造函数中实现\nbReplicates &#x3D; true;\nSetReplicates(true);\n\n其中Set要慢一点\n\n\n\n2.2.2 Property Replication\n开启方式：\n\n前提：Actor Replication是true\n\n蓝图：Replication设置为Replicated\n\nC++：\nUPROPERTY(Replicated)\nfloat TestNum;\n\n#include &quot;Net&#x2F;UnrealNetwork.h&quot;\n\nvoid AMyActor::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n&#123;\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\t\n\tDOREPLIFETIME(AMyActor, TestNum);\n&#125;\n\nAMyActor是需要复制属性的类\n\nTestNum是待复制的属性\n\n\n\n\n2.2.3 Rep Notify\n说明：变量设为Rep_Notify，当变量发生复制时，服务端和收到的客户端都可以调用一个自定义的函数\n\n注意：C++中，自定义函数仅在客户端中调用\n\n设置方式：\n\n蓝图：Replication设置为RepNotify，会自动生成OnRep_属性()函数\n\nC++：\nUPROPERTY(ReplicatedUsing&#x3D;OnRep_TestNum, BlueprintReadWrite)\nint TestNum;\n\nUFUNCTION()\nvoid OnRep_TestNum();\n\n#include &quot;MyActor.h&quot;\n#include &quot;Kismet&#x2F;KismetSystemLibrary.h&quot;\n#include &quot;Net&#x2F;UnrealNetwork.h&quot;\n\nAMyActor::AMyActor()\n&#123;\n\tPrimaryActorTick.bCanEverTick &#x3D; true;\n\n\tbReplicates &#x3D; true;\n&#125;\n\nvoid AMyActor::BeginPlay()\n&#123;\n\tSuper::BeginPlay();\n&#125;\n\nvoid AMyActor::Tick(float DeltaTime)\n&#123;\n\tSuper::Tick(DeltaTime);\n\n\tif (HasAuthority())\n\t&#123;\n\t\t++TestNum;\n\t&#125;\n&#125;\n\nvoid AMyActor::OnRep_TestNum()\n&#123;\n\tif (HasAuthority())\n\t&#123;\n\t\tUKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT(&quot;%d&quot;), TestNum));\n\t&#125;\n\telse\n\t&#123;\n\t\tUKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT(&quot;%d&quot;), TestNum));\n\t&#125;\n&#125;\n\nvoid AMyActor::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n&#123;\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AMyActor, TestNum);\n&#125;\n\n\n\n2.3 OwnerShip\n作用：\n\nRPC需要确定哪个客户端将执行于客户端的RPC\n\nActor复制与连接相关性\n\n在涉及所有者时的Actor属性复制条件\n\n说明：\n\n当 Pawn Actor 被 PlayerController 拥有时，它们的所有者将是它们所拥有的 PlayerController。\n在此期间，它们归 PlayerController 的连接所有。\nPawn 仅在同时由 PlayerController 拥有&#x2F;拥有时由该连接拥有。\n因此，一旦 PlayerController 不再拥有 Pawn，Pawn 就不再由连接拥有。\n\n\n注意：\n\n连接所有权对于 RPC 之类的东西很重要，因为当在 Actor 上调用 RPC 函数时，除非 RPC 被标记为多播，否则它需要知道在哪个客户端上执行该 RPC。\n它通过查找拥有的连接来确定将 RPC 发送到的连接。\n\n\n使用：\n\n蓝图\n\n设置\nSpawnActor中又Owner可以引用\nSetOwner\n\n\n改变\nPossess(OnPossess &gt; PossessedBy &gt; SetOwner), UnPossess\n\n\n获得\nGetOwner\n\n\n\n\nC++\n\n设置\n&#x2F;&#x2F;SpawnParameters 内可以设置 Onwer\nGetWorld()-&gt;SpawnActor(Class, const* UserTransformPtr, const SpawnParameters);\n\t\n&#x2F;&#x2F; SetOwner\nSetOwner(NewOwner);\n\n获取\nGetOwner();\n\n\n\n\n\n2.4 Actor Role\n分类：\n\nAuthority 权威\nSimulated Proxy 模拟代理\nAutonomous Proxy 自主代理\n\n\n基本结构：A， B， C A为房主\n\nServerA：A, B, C Authority\nClientB：A, C Simulated, B Autonomous\nClentC: A, B Simulated, C Autonomous\n\n\n说明：当涉及到复制时，actor 有两个很重要的属性。Role和RemoteRole。\n\n作用：\n\n谁对演员有权力\n演员是否被复制\n复制模式\n\n\n服务器复制到客户端的条件：Role == ROLE_Authorityand RemoteRole == ROLE_SimulatedProxyor ROLE_AutonomousProxy\n\n\n3. RPC介绍\n类似于函数调用，不过不一定是在本地执行\n\n可以实现：\n\n客户端调用，服务端执行\n服务端调用，客户端执行\n\n\n不可以有返回值\n\n默认不可靠（可以设置成Reliable）\n\n\n3.1 RPC设置蓝图：\n\nCustomEvent 的 Replicates 选项设置为其中一个\nRun On Server\nRun On Owning Client\nNet MultiCast\n\n\n要勾选Reliable\n\nC++：\n\n将一个自定义的函数声明为RPC，需要添加反射UFUNCTION()\nServer\nClient\nNetMultiCast\n\n\n额外添加Reliable\n\n3.2 RPC要求和注意要使 RPC 完全正常运行，需要满足一些要求：\n\n它们必须从 Actors 中调用\n必须复制 Actor\n如果从服务器调用 RPC 以在客户端上执行，则只有实际拥有该 Actor 的客户端将执行该函数\n如果从客户端调用 RPC 以在服务器上执行，则客户端必须拥有正在调用 RPC 的 Actor\n多播 RPC 是一个例外：\n如果从服务器调用它们，服务器将在本地执行它们以及在所有当前连接的客户端上执行它们\n如果从客户端调用，它们只会在本地执行，不会在服务器上执行\n目前，我们有一个简单的多播事件限制机制：多播函数在给定 Actor 的网络更新周期内不会复制超过两次。从长远来看，我们希望对此进行改进，并为跨渠道流量管理和节流提供更好的支持\n\n\n\n​\t\n从Server调用RPC\n\n\n\n演员所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\n客户拥有的演员\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在演员拥有的客户端上运行\n\n\n服务器拥有的演员\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n无名演员\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n从Client调用RPC\n\n\n\n演员所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\n由调用客户端拥有\n在调用客户端时运行\n在调用客户端时运行\n在服务器上运行\n在调用客户端时运行\n\n\n由不同的客户拥有\n在调用客户端时运行\n在调用客户端时运行\n掉落\n在调用客户端时运行\n\n\n服务器拥有的演员\n在调用客户端时运行\n在调用客户端时运行\n掉落\n在调用客户端时运行\n\n\n无名演员\n在调用客户端时运行\n在调用客户端时运行\n掉落\n在调用客户端时运行\n\n\n","slug":"7_UE4_RPC_04","date":"2022-10-06T07:28:25.953Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"392fe5e03b8c7afffa5955ae17305c17","title":"UE4 MySQL插件使用","content":"UE4 MySQL插件使用1. 插件获取MySQL Plugin 提取码:17um\n2. 插件安装\n新建UE4项目，类型随意\n在项目根目录中新建文件夹Plugins\n将FH_MySQL复制到Plugins中\n重新打开UE4项目\n\n3. 插件API3.1 连接数据库\n返回一个MySQL Connector\n&#x2F;*\n * Connection &#x3D;&#x3D; MySQL Object\n * @return *UFH_ConnectionObject &#x3D;&#x3D; MySQL Connector\n*&#x2F;\nUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic UFH_ConnectionObject *ConnectToMySQL(FString Host, FString UserName, FString PassWord, FString DBName,\n                                            int32 Port, FString &amp;ConnectMessage);\n\n3.2 获得连接状态\n返回bool，正在连接返回true\n&#x2F;*\n * ConnectionObject &#x3D;&#x3D; MySQL Object\n * @return bool &#x3D;&#x3D; ConnectionState\n*&#x2F;\nUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic bool GetConnectionState(UFH_ConnectionObject *ConnectionObject);\n\n3.3 关闭数据库连接\n肯定会关掉，默认返回true\n&#x2F;*\n * ConnectionObject &#x3D;&#x3D; MySQL Object\n * @return bool &#x3D;&#x3D; ConnectionState\n*&#x2F;\nUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic bool CloseConnection(UFH_ConnectionObject *ConnectionObject);\n\n3.4 增-删-改处理\n实现增删改的处理，具体执行程序依据传入格式化SqlQuery\n\nInsert，Delete，Update\n&#x2F;*\n * ConnectionObject &#x3D;&#x3D; MySQL Object\n * @return bool &#x3D;&#x3D; Insert, Update, Delete Data Is Succeed Or Failed\n*&#x2F;\nUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic bool ActionOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery);\n\n3.4.1 Insert Format SqlQuery\n通用的 INSERT INTO TableName VALUES(InsertValues);格式化插入语句\n&#x2F;*\n * TableName &#x3D; DataBase TableName\n * InsertValues &#x3D; MySQL Insert Values to Table\n * @return FString &#x3D; MySQL Insert Query -&gt; Insert\n*&#x2F;\nUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic FString InsertFormatSqlQuery(FString TableName, FString InsertValues);\n\n3.4.2 Update Format SqlQuery\n更新所有字段的值UPDATE TableName SET RowName = UpdateValue;格式化更新语句\n&#x2F;*\n * TableName &#x3D; DataBase TableName\n * RowName &#x3D; Need Update Row\n * @return FString &#x3D; MySQL Update Query -&gt; Update\n*&#x2F;\t\nUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic FString UpdateAllFormatSqlQuery(FString TableName, FString RowName, FString UpdateValue);\n\n\n\n依据条件更新字段值UPDATE TableName SET UpdateRowName = UpdateValue WHERE WhereName = WhereValue;格式化更新语句\n&#x2F;*\n * TableName &#x3D; DataBase TableName\n * RowName &#x3D; Need Update Row\n * WhereName &#x3D; Update Where\n * WhereSymbol &#x3D; Operator Or Symbol\n * WhereValue &#x3D; Condition Name\n * UpdateValue &#x3D; Need Update Date Value\n * @return FString &#x3D; MySQL Update Query -&gt; Update\n*&#x2F;\t\nUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic FString UpdateByWhereFormatSqlQuery(FString TableName, FString RowName, FString WhereName, \n                                           FString WhereSymbol, FString WhereValue, FString UpdateValue);\n\n3.4.3 Delete Format SqlQuery\n删除整个表DELETE FROM TableName;格式化删除语句\n&#x2F;*\n * TableName &#x3D; DataBase TableName\n * @return FString &#x3D; MySQL Delete Query -&gt; Delete\n*&#x2F;\nUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic FString DeleteAllFormatSqlQuery(FString TableName);\n\n\n\n依据条件删除整行数据DELETE FROM TableName WHERE WhereName=‘WhereValue’;格式化删除语句\n&#x2F;*\n * TableName &#x3D; DataBase TableName\n * WhereName &#x3D; Update Where\n * WhereSymbol &#x3D; Operator Or Symbol\n * WhereValue &#x3D; Condition Name\n * @return FString &#x3D; MySQL Delete Query -&gt; Delete\n*&#x2F;\nUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic FString DeleteByWhereFormatSqlQuery(FString TableName, FString WhereName, FString WhereSymbol, \n                                           FString WhereValue);\n\n3.5 查询语句处理\n实现基本常用的查询语句：\n\nSELECT * FROM TableName;\nSELECT Columns1, Columns2, Country FROM TableName;\n获得指定行的整行数据\n\n\n处理查询语句的通用，具体执行程序依据传入格式化SqlQuery\n\n函数公开生成并返回struct类型：\n\nResultRows整个表的数据\nResultRow整行的数据\nRowValue整行内字段名的数据\n\n&#x2F;*\n * ConnectionObject &#x3D;&#x3D; MySQL Object\n * @return bool &#x3D;&#x3D; Select Data Is Succeed Or Failed\n*&#x2F;\t\nUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic bool SelectOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery, \n                              FQueryResultRows &amp;ResultRows);\n\n3.5.1 Select All Format SqlQuery\n查询整个表的数据SELECT * FROM TableName;格式化查询语句\n&#x2F;*\n * TableName &#x3D; DataBase TableName\n * @return FString &#x3D; MySQL Select Query -&gt; Select\n*&#x2F;\nUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic FString SelectAllFormatSqlQuery(FString TableName);\n\n3.5.2 Select Columns By Conditions\n依据条件查询表内数据SELECT Columns1, Columns2, Country FROM TableName;格式化查询语句\n&#x2F;*\n * TableName &#x3D; DataBase TableName\n * @return FString &#x3D; MySQL Select Query -&gt; Select\n*&#x2F;\t\nUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic FString SelectByColumnsFormatSqlQuery(FString TableName, FString Columns);\n\n3.5.3 Select Get RowValues By Index\n指定表面和表内的行号，查询数据\n&#x2F;*\n * TableName &#x3D; DataBase TableName\n * @return TArray&lt;FString&gt; &#x3D; Get All Rows -&gt; In All Columns Values\n*&#x2F;\t\t\nUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\nstatic FQueryResultRow GetRowByIndex(const FQueryResultRows &amp;ResultRows, int32 RowIndex);\n\n","slug":"7_MySQL插件使用_03","date":"2022-10-06T07:28:25.950Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"ab5a123ef13f06a2127802a636203336","title":"UE4 MySQL插件开发","content":"UE4 MySQL插件开发1. 项目简介\n个人UrealEngine MySQL Plugin开发流程\n方便UnrealEngine项目链接和操作MySQL数据库\n\n2. 项目环境IDE -&gt; JetBrains Rider 2022.1 EAP7 内部版本号 221.4906.10\nUnrealEngine -&gt; 4.27.2\nCompiler Environment -&gt; Visual Studio 2022 提供编译组件\nMySQL -&gt; 8.0.28 MySQL Community Server - GPL\n\n\n\n\n\n3. 项目资源3.1 资源文件结构ConnectorLibs\n\t- ConnectorLibs\n\t\t+ include\n\t\t+ lib\n\t- ConnectorLibs.Build.cs\n\n\n\n\n\n3.2 资源链接「ConnectorLibs」https://www.aliyundrive.com/s/wTrvzpVdfxU 提取码: 0be0\n4. 项目创建4.1 创建UE4项目\n默认选择游戏项目\n默认选择空项目\n创建C++项目，包含初学者内容包\n选择项目的创建目录\n创建项目名FH_TestMySQL\n\n4.2 创建新插件\n找到Edit或Settings\n选择plugins进入插件界面\n选择New Plugin\n选择Blank\n设置插件名称FH_MySQL\nDescriptor Data随意填写\nCreate Plugin\n\n4.3 创建MySQL C++类4.3.1 FH_ConnectionObject\n创建ObjectC++类，类名FH_ConnectionObject\n选择添加到插件目录FH_MySQL(Runtime)，默认public .h，private .cpp\nCreate Class\n会弹出一个Message窗口，内容大致为创建成功，但需要重新编译，选择No\n\n4.3.2 BPFuncLib_FHSQL\n创建Blueprint Function LibraryC++类，类名BPFuncLib_FHSQL\n剩下步骤同上\n\n5. 项目配置5.1 引入MySQL环境库5.1.1 导入环境库\n准备好ConnectorLibs\n来到FH_TestMySQL\\Plugins\\FH_MySQL\\Source目录下\n创建目录ThirdParty\n将ConnectorLibs放入ThirdParty内\n\n5.1.2 配置项目属性\nRider打开创建好的UE4 C++项目\n在资源栏内找到项目名FH_TestMySQL，在Games目录下\n右键，选择Properties\n在Configurations内选择Development_Editor | x64\n选择VC++目录\n在包含目录(include)中填入绝对路径项目文件路径\\FH_TestMySQL\\Plugins\\FH_MySQL\\Source\\ThirdParty\\ConnectorLibs\\include\n在库目录(lib)中填入绝对路径项目文件路径\\FH_TestMySQL\\Plugins\\FH_MySQL\\Source\\ThirdParty\\ConnectorLibs\\lib\nOK\n\n5.1.3 配置项目文件\n修改FH_MySQL.uplugin，文件位置项目文件路径\\FH_TestMySQL\\Plugins\\FH_MySQL，只需要添加&quot;WhitelistPlatforms&quot;: [&quot;Win64&quot;]\n&#123;\n\t&quot;FileVersion&quot;: 3,\n\t&quot;Version&quot;: 1,\n\t&quot;VersionName&quot;: &quot;1.0&quot;,\n\t&quot;FriendlyName&quot;: &quot;FH_MySQL&quot;,\n\t&quot;Description&quot;: &quot;Using UE4 Connecting MySQL Plugin&quot;,\n\t&quot;Category&quot;: &quot;FhPlugin&quot;,\n\t&quot;CreatedBy&quot;: &quot;FangH&quot;,\n\t&quot;CreatedByURL&quot;: &quot;https:&#x2F;&#x2F;fhangh.gitee.io&#x2F;&quot;,\n\t&quot;DocsURL&quot;: &quot;&quot;,\n\t&quot;MarketplaceURL&quot;: &quot;&quot;,\n\t&quot;SupportURL&quot;: &quot;&quot;,\n\t&quot;CanContainContent&quot;: true,\n\t&quot;IsBetaVersion&quot;: true,\n\t&quot;IsExperimentalVersion&quot;: false,\n\t&quot;Installed&quot;: false,\n\t&quot;Modules&quot;: [\n\t\t&#123;\n\t\t\t&quot;Name&quot;: &quot;FH_MySQL&quot;,\n\t\t\t&quot;Type&quot;: &quot;Runtime&quot;,\n\t\t\t&quot;LoadingPhase&quot;: &quot;Default&quot;,\n\t\t\t&quot;WhitelistPlatforms&quot;: [&quot;Win64&quot;]\n\t\t&#125;\n\t]\n&#125;\n\n修改FH_MySQL.Build.cs，文件位置项目文件路径\\FH_TestMySQL\\Plugins\\FH_MySQL\\Source\\FH_MySQL，修改如下内容\nPublicDependencyModuleNames.AddRange(\n\tnew string[]\n    &#123;\n\t\t&quot;Core&quot;,\n\t\t&quot;ConnectorLibs&quot;,\n\t\t&#x2F;&#x2F; ... add other public dependencies that you statically link with here ...\n\t&#125;\n);\n\n6. MySQL C++文件6.1 MySQL连接对象\nFH_ConnectionObject.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;UObject&#x2F;NoExportTypes.h&quot;\n#include &quot;mysql.h&quot;\n#include &quot;FH_ConnectionObject.generated.h&quot;\n\nUCLASS(BlueprintType)\nclass FH_MYSQL_API UFH_ConnectionObject : public UObject\n&#123;\n\tGENERATED_BODY()\n\nprivate:\n\tUFH_ConnectionObject();\n\npublic:\n\tMYSQL *Fh_ConnMysql;\n&#125;;\n\nFH_ConnectionObject.cpp\n#include &quot;FH_ConnectionObject.h&quot;\n\nUFH_ConnectionObject::UFH_ConnectionObject()\n&#123;\n\tFh_ConnMysql &#x3D; nullptr;\n&#125;\n\n6.2 MySQL函数工具库\nBPFuncLib_FHSQL.h\n#pragma once\n\n#include &quot;CoreMinimal.h&quot;\n#include &quot;Kismet&#x2F;BlueprintFunctionLibrary.h&quot;\n#include &quot;FH_ConnectionObject.h&quot;\n#include &quot;BPFuncLib_FHSQL.generated.h&quot;\n\nUSTRUCT(BlueprintType)\nstruct FQueryResultRow\n&#123;\n\tGENERATED_BODY()\n\n\tUPROPERTY(BlueprintReadWrite, Category&#x3D;&quot;MySQL|Result Row Value&quot;)\n\tTArray&lt;FString&gt; RowValue;\n&#125;;\n\nUSTRUCT(BlueprintType)\nstruct FQueryResultRows\n&#123;\n\tGENERATED_BODY()\n\n\tUPROPERTY(BlueprintReadWrite, Category&#x3D;&quot;MySQL|Result Rows Value&quot;)\n\tTArray&lt;FQueryResultRow&gt; RowsValue;\n&#125;;\n\nUCLASS(BlueprintType)\nclass FH_MYSQL_API UBPFuncLib_FHSQL : public UBlueprintFunctionLibrary\n&#123;\n\tGENERATED_BODY()\n\npublic:\n\t&#x2F;*\n\t * Connection &#x3D;&#x3D; MySQL Object\n\t * @return *UFH_ConnectionObject &#x3D;&#x3D; MySQL Connector\n\t *&#x2F;\n\tUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic UFH_ConnectionObject *ConnectToMySQL(FString Host, FString UserName, FString PassWord, FString DBName,\n\t\t\t\t\t\t\t\t\t\t\t\tint32 Port, FString &amp;ConnectMessage);\n\n\t&#x2F;*\n\t * ConnectionObject &#x3D;&#x3D; MySQL Object\n\t * @return bool &#x3D;&#x3D; ConnectionState\n\t *&#x2F;\n\tUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic bool GetConnectionState(UFH_ConnectionObject *ConnectionObject);\n\n\t&#x2F;*\n\t * ConnectionObject &#x3D;&#x3D; MySQL Object\n\t * @return bool &#x3D;&#x3D; ConnectionState\n\t *&#x2F;\n\tUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic bool CloseConnection(UFH_ConnectionObject *ConnectionObject);\n\n\t&#x2F;*\n\t * ConnectionObject &#x3D;&#x3D; MySQL Object\n\t * @return bool &#x3D;&#x3D; Insert, Update, Delete Data Is Succeed Or Failed\n\t *&#x2F;\n\tUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic bool ActionOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery);\n\t\n\t&#x2F;*\n\t * TableName &#x3D; DataBase TableName\n\t * InsertValues &#x3D; MySQL Insert Values to Table\n\t * @return FString &#x3D; MySQL Insert Query -&gt; Insert\n\t *&#x2F;\n\tUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic FString InsertFormatSqlQuery(FString TableName, FString InsertValues);\n\n\t&#x2F;*\n\t * TableName &#x3D; DataBase TableName\n\t * RowName &#x3D; Need Update Row\n\t * @return FString &#x3D; MySQL Update Query -&gt; Update\n\t *&#x2F;\t\n\tUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic FString UpdateAllFormatSqlQuery(FString TableName, FString RowName, FString UpdateValue);\n\n\t&#x2F;*\n\t * TableName &#x3D; DataBase TableName\n\t * RowName &#x3D; Need Update Row\n\t * WhereName &#x3D; Update Where\n\t * WhereSymbol &#x3D; Operator Or Symbol\n\t * WhereValue &#x3D; Condition Name\n\t * UpdateValue &#x3D; Need Update Date Value\n\t * @return FString &#x3D; MySQL Update Query -&gt; Update\n\t *&#x2F;\t\n\tUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic FString UpdateByWhereFormatSqlQuery(FString TableName, FString RowName, FString WhereName, FString WhereSymbol, FString WhereValue, FString UpdateValue);\n\n\t&#x2F;*\n\t * TableName &#x3D; DataBase TableName\n\t * @return FString &#x3D; MySQL Delete Query -&gt; Delete\n\t *&#x2F;\n\tUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic FString DeleteAllFormatSqlQuery(FString TableName);\n\n\t&#x2F;*\n\t * TableName &#x3D; DataBase TableName\n\t * WhereName &#x3D; Update Where\n\t * WhereSymbol &#x3D; Operator Or Symbol\n\t * WhereValue &#x3D; Condition Name\n\t * @return FString &#x3D; MySQL Delete Query -&gt; Delete\n\t *&#x2F;\n\tUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic FString DeleteByWhereFormatSqlQuery(FString TableName, FString WhereName, FString WhereSymbol, FString WhereValue);\n\n\t&#x2F;*\n\t * ConnectionObject &#x3D;&#x3D; MySQL Object\n\t * @return bool &#x3D;&#x3D; Select Data Is Succeed Or Failed\n\t *&#x2F;\t\n\tUFUNCTION(BlueprintCallable, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic bool SelectOnTableData(UFH_ConnectionObject *ConnectionObject, FString SqlQuery, FQueryResultRows &amp;ResultRows);\n\t\n\t&#x2F;*\n\t * TableName &#x3D; DataBase TableName\n\t * @return FString &#x3D; MySQL Select Query -&gt; Select\n\t *&#x2F;\n\tUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic FString SelectAllFormatSqlQuery(FString TableName);\n\n\t&#x2F;*\n\t * TableName &#x3D; DataBase TableName\n\t * @return FString &#x3D; MySQL Select Query -&gt; Select\n\t *&#x2F;\t\n\tUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic FString SelectByColumnsFormatSqlQuery(FString TableName, FString Columns);\n\n\t&#x2F;*\n\t * TableName &#x3D; DataBase TableName\n\t * @return TArray&lt;FString&gt; &#x3D; Get All Rows -&gt; In All Columns Values\n\t *&#x2F;\t\t\n\tUFUNCTION(BlueprintPure, Category&#x3D;&quot;MySQL|Utils&quot;)\n\tstatic FQueryResultRow GetRowByIndex(const FQueryResultRows &amp;ResultRows, int32 RowIndex);\n&#125;;\n\nBPFuncLib_FHSQL.cpp\n#include &quot;BPFuncLib_FHSQL.h&quot;\n#include &quot;mysql.h&quot;\n#include &lt;string&gt;\n\nUFH_ConnectionObject* UBPFuncLib_FHSQL::ConnectToMySQL(FString Host, FString UserName, FString PassWord, FString DBName,\n\tint32 Port, FString &amp;ConnectMessage)\n&#123;\n\tconst std::string m_Host(TCHAR_TO_UTF8(*Host));\n\tconst std::string m_UserName(TCHAR_TO_UTF8(*UserName));\n\tconst std::string m_PassWord(TCHAR_TO_UTF8(*PassWord));\n\tconst std::string m_DBName(TCHAR_TO_UTF8(*DBName));\n\tconst uint32 m_Port &#x3D; Port; \n\n\t&#x2F;&#x2F; Create MySQL Connection Object\n\tUFH_ConnectionObject *ConnectionObject &#x3D; NewObject&lt;UFH_ConnectionObject&gt;();\n\t&#x2F;&#x2F; Init DataBase Connection Object\n\tConnectionObject-&gt;Fh_ConnMysql &#x3D; mysql_init(nullptr);\n\n\t&#x2F;&#x2F; Judge Connection Status And Return ConnectMessage\n\tif (mysql_real_connect(ConnectionObject-&gt;Fh_ConnMysql, m_Host.c_str(), m_UserName.c_str(), m_PassWord.c_str(),\n\t                       m_DBName.c_str(), m_Port, nullptr, 0))\n\t&#123;\n\t\tConnectMessage &#x3D; TEXT(&quot;Connect Succeed&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tConnectMessage &#x3D; TEXT(&quot;Connect Failed&quot;);\n\t&#125;\n\n\t&#x2F;&#x2F; Return MySQL Connection Object\n\treturn ConnectionObject;\n&#125;\n\nbool UBPFuncLib_FHSQL::GetConnectionState(UFH_ConnectionObject* ConnectionObject)\n&#123;\n\t&#x2F;&#x2F; Judge Current MySQL Connection State\n\tif (ConnectionObject)\n\t&#123;\n\t\tif (ConnectionObject-&gt;Fh_ConnMysql !&#x3D; nullptr)\n\t\t&#123;\n\t\t\treturn true;\n\t\t&#125;\n\t\treturn false;\n\t&#125;\n\treturn false;\n&#125;\n\nbool UBPFuncLib_FHSQL::CloseConnection(UFH_ConnectionObject* ConnectionObject)\n&#123;\n\t&#x2F;&#x2F; If MySQL Connected -&gt; Close MySQL Connection; Return True\n\t&#x2F;&#x2F; Else -&gt; Return True\n\tif (GetConnectionState(ConnectionObject))\n\t&#123;\n\t\tmysql_close(ConnectionObject-&gt;Fh_ConnMysql);\n\t\tConnectionObject-&gt;Fh_ConnMysql &#x3D; nullptr;\n\t\tConnectionObject &#x3D; nullptr;\n\t\treturn true;\n\t&#125;\n\treturn true;\n&#125;\n\nbool UBPFuncLib_FHSQL::ActionOnTableData(UFH_ConnectionObject* ConnectionObject, FString SqlQuery)\n&#123;\n\tconst std::string m_SqlQuery(TCHAR_TO_UTF8(*SqlQuery));\n\n\t&#x2F;&#x2F; Judge MySQL Is Connected\n\tif (!ConnectionObject)\n\t&#123;\n\t\treturn false;\n\t&#125;\n\t&#x2F;&#x2F; Judge SqlQuery Is Apply Succeed\n\tif (mysql_query(ConnectionObject-&gt;Fh_ConnMysql, m_SqlQuery.c_str()) &#x3D;&#x3D; 0)\n\t&#123;\n\t\treturn true;\n\t&#125;\n\treturn true;\n&#125;\n\nFString UBPFuncLib_FHSQL::InsertFormatSqlQuery(FString TableName, FString InsertValues)\n&#123;\n\t&#x2F;&#x2F; INSERT INTO TableName VALUES(InsertValues);\n\tFString SqlQuery &#x3D; &quot;INSERT INTO &quot; + TableName + &quot; VALUES(&quot; + InsertValues + &quot;);&quot;;\n\treturn SqlQuery;\n&#125;\n\nFString UBPFuncLib_FHSQL::UpdateAllFormatSqlQuery(FString TableName, FString UpdateRowName, FString UpdateValue)\n&#123;\t&#x2F;&#x2F; UPDATE TableName SET RowName&#x3D;UpdateValue;\n\tFString SqlQuery &#x3D; &quot;UPDATE &quot; + TableName + &quot; SET &quot; + UpdateRowName + &quot;&#x3D;&quot; + UpdateValue + &quot;;&quot;;\n\treturn SqlQuery;\n&#125;\n\nFString UBPFuncLib_FHSQL::UpdateByWhereFormatSqlQuery(FString TableName, FString UpdateRowName, FString WhereName, FString WhereSymbol, FString WhereValue, FString UpdateValue)\n&#123;\n\t&#x2F;&#x2F; UPDATE TableName SET UpdateRowName&#x3D;UpdateValue WHERE WhereName&#x3D;WhereValue;\n\tFString SqlQuery &#x3D; &quot;UPDATE &quot; + TableName + &quot; SET &quot; + UpdateRowName + &quot;&#x3D;&quot; + UpdateValue + &quot; WHERE &quot; + WhereName + WhereSymbol + WhereValue + &quot;;&quot;;\n\treturn SqlQuery;\n&#125;\n\nFString UBPFuncLib_FHSQL::DeleteAllFormatSqlQuery(FString TableName)\n&#123;\n\t&#x2F;&#x2F; DELETE FROM TableName;\n\tFString SqlQuery &#x3D; &quot;DELETE FROM &quot; + TableName + &quot;;&quot;;\n\treturn SqlQuery;\n&#125;\n\nFString UBPFuncLib_FHSQL::DeleteByWhereFormatSqlQuery(FString TableName, FString WhereName, FString WhereSymbol, FString WhereValue)\n&#123;\n\t&#x2F;&#x2F; DELETE FROM TableName WHERE WhereName&#x3D;‘WhereValue’;\n\tFString SqlQuery &#x3D; &quot;DELETE FROM &quot; + TableName + &quot; WHERE &quot; + WhereName + WhereSymbol + &quot;&#39;&quot; + WhereValue + &quot;&#39;;&quot;;\n\treturn SqlQuery;\n&#125;\n\nbool UBPFuncLib_FHSQL::SelectOnTableData(UFH_ConnectionObject* ConnectionObject, FString SqlQuery, FQueryResultRows &amp;ResultRows)\n&#123;\n\tMYSQL_RES *m_Res &#x3D; nullptr;\n\tMYSQL_ROW m_Column;\n\tTArray&lt;FString&gt; m_ColumnNames;\n\tFQueryResultRows m_Rows;\n\tconst std::string m_SqlQuery(TCHAR_TO_UTF8(*SqlQuery));\n\n\tif (!ConnectionObject)&#123;return false;&#125;\n\tif (!ConnectionObject-&gt;Fh_ConnMysql)&#123;return false;&#125;\n\n\tif (!mysql_query(ConnectionObject-&gt;Fh_ConnMysql, m_SqlQuery.c_str()))\n\t&#123;\n\t\tResultRows &#x3D; &#123;&#125;;\n\t\tm_Res &#x3D; mysql_store_result(ConnectionObject-&gt;Fh_ConnMysql);\n\t\tconst int m_Columns &#x3D; mysql_num_fields(m_Res);\n\n\t\twhile ((m_Column &#x3D; mysql_fetch_row(m_Res)) !&#x3D; nullptr)\n\t\t&#123;\n\t\t\tFQueryResultRow m_Row;\n\t\t\tfor (int i &#x3D; 0; i &lt; m_Columns; ++i)\n\t\t\t&#123;\n\t\t\t\tm_Row.RowValue.Add(UTF8_TO_TCHAR(m_Column[i]));\n\t\t\t&#125;\n\t\t\tResultRows.RowsValue.Add(m_Row);\n\t\t&#125;\n\t&#125;\n\t\n\tmysql_free_result(m_Res);\n\treturn true;\n&#125;\n\nFString UBPFuncLib_FHSQL::SelectAllFormatSqlQuery(FString TableName)\n&#123;\n\t&#x2F;&#x2F; SELECT * FROM TableName;\n\tFString SqlQuery &#x3D; &quot;SELECT * FROM &quot; + TableName + &quot;;&quot;;\n\treturn SqlQuery;\n&#125;\n\nFString UBPFuncLib_FHSQL::SelectByColumnsFormatSqlQuery(FString TableName, FString Columns)\n&#123;\n\t&#x2F;&#x2F; SELECT CustomerName, City, Country FROM Customers;\n\tFString SqlQuery &#x3D; &quot;SELECT &quot; + Columns + &quot; FROM &quot; + TableName + &quot;;&quot;;\n\treturn SqlQuery;\n&#125;\n\nFQueryResultRow UBPFuncLib_FHSQL::GetRowByIndex(const FQueryResultRows &amp;ResultRows, int32 RowIndex)\n&#123;\n\tconst FQueryResultRow m_Row &#x3D; ResultRows.RowsValue[RowIndex];\n\treturn m_Row;\n&#125;\n\n7. 编译项目\n在Rider内进行项目编译\n编译完成，可以在Rider内直接运行启动UE4项目\n\n8. 打包插件8.1 打包前设置编译工具\n前提：如果安装的Visual Studio 2017可能不需要进行这个步骤，直接进入下一步\n\n打包出现RunUAT相关错误信息，再进行此步骤\n\n如果使用的是Visual Studio 2019或Visual Studio 2022或其他版本\n\n找到RunUAT.bat文件，用记事本打开或编辑\n\n文件位置UE4引擎的安装目录\\UE_4.27\\Engine\\Build\\BatchFiles\n\n编辑 -&gt; 查找，%UATExecutable%\n\n%UATExecutable% %* %UATCompileArg%修改为%UATExecutable% %* -VS2019=true %UATCompileArg%\n\n我用的是 VS2022，修改成2022好像不行，但修改成2019就可以正常打包了\n\n\n8.2 打包MySQL插件\n找到Edit或Settings\n选择plugins进入插件界面\n找到插件FH_MySQL\n可选步骤Edit，进行插件的相关信息的编辑，包括插件的图标\n点击Package(打包)，选择打包目录自定义\n等待打包完成即可\n我自己的电脑上的环境打包，完全没有任何Warning和Error，所以理论上打包不存在问题（写这个插件的时候遇到了很多问题，但用我提供的环境库文件和配置步骤，问题都一个个解决了）\n\n","slug":"7_MySQL插件开发_02","date":"2022-10-06T07:28:25.948Z","categories_index":"UnrealEngine","tags_index":"UnrealEngine","author_index":"FangH"},{"id":"9bb1210f38db3e1f819e50bcd1059252","title":"Git个人使用","content":"Git个人使用&#x2F;&#x2F; 2021-02-19：苦于还是不记得git bash的使用，每次使用都要到网上找一会，太麻烦了，决定写成博客，记录一下个人的使用总结\n&#x2F;&#x2F; 开头从最开始的顺序来记录\n-----------------------------------------------------------------------------------------------------------------------\n&#x2F;&#x2F; 2021-02-20：又添加了 clone 的方法，修改完善了之前的内容\n\n1. 准备工作简单带过：\n\n注册Github账号\n下载Git，并安装\n\n2. 本地账号\n这一步是方便以后使用git时，跳过账号信息验证\n\n&#x2F;&#x2F; &quot;&quot; 里填 GitHub 账号的用户名\n$ git config --global user.name &quot;&quot;\n\n&#x2F;&#x2F; &quot;&quot; 里填 GitHub 账号的邮箱\n$ git config --global user.email &quot;&quot;\n\n&#x2F;&#x2F; 查看本地的用户信息配置\n$ git config --list\n&#x2F;&#x2F; 结果大概如下\nPS C:\\Windows\\System32&gt; git config --list\ndiff.astextplain.textconv&#x3D;astextplain\nfilter.lfs.clean&#x3D;git-lfs clean -- %f\nfilter.lfs.smudge&#x3D;git-lfs smudge -- %f\nfilter.lfs.process&#x3D;git-lfs filter-process\nfilter.lfs.required&#x3D;true\nhttp.sslbackend&#x3D;openssl\nhttp.sslcainfo&#x3D;E:&#x2F;Git&#x2F;Git&#x2F;mingw64&#x2F;ssl&#x2F;certs&#x2F;ca-bundle.crt\ncore.autocrlf&#x3D;true\ncore.fscache&#x3D;true\ncore.symlinks&#x3D;false\npull.rebase&#x3D;false\ncredential.helper&#x3D;manager\nuser.email&#x3D;752972182@qq.com\nuser.name&#x3D;FHangH\n\n\n\n3 Public SSH Key\n在 Github 中添加一个 Public SSH key 同时在本地也要有 Public SSH Key 的相关文件\ngit 上传和下载过程中需要密钥的验证，以保证安全性\n\n&#x2F;&#x2F; 首先验证是否本地存在 SSH Key\n$ ssh -T git@github.com\n\n&#x2F;&#x2F; 如果存在，大概结果如下（可以直接跳过生成本地 SSH Key 的步骤）\nPS C:\\Windows\\System32&gt; ssh -T git@github.com\nHi FHangH! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n\n&#x2F;&#x2F; 查看本地是否已经存在 Public SSH Key\n$ cd ~&#x2F;.ssh\n\n&#x2F;&#x2F; 查看文件列表\n$ ls\n\n&#x2F;&#x2F; 此时两种情况，一种是什么都没有\n&#x2F;&#x2F; 另一种是，差不多是存在以下文件，至少是有 id_rsa , id_rsa.pub 两个文件才行\n\nPS C:\\Users\\Admin\\.ssh&gt; ls\n    Directory: C:\\Users\\Admin\\.ssh\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a---           2021&#x2F;2&#x2F;17     9:18           2610 id_rsa\n-a---           2021&#x2F;2&#x2F;17     9:18            575 id_rsa.pub\n-a---           2021&#x2F;2&#x2F;19    16:05           1385 known_hosts\n\n&#x2F;&#x2F; 如果有，我们需要 id_rsa.pub 的内的key\n$ cat id_rsa.pub\n\n&#x2F;&#x2F; 出现类似一下内容（全文复制，后面要用）\nPS C:\\Users\\Admin\\.ssh&gt; cat .\\id_rsa.pub\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDdrPvLeNqhzEgVU8Ep&#x2F;9LiDvGpooO6UD8Tq5DM4CJzfiS+I95KjwwhxpQ7Et0pgfMt6ikRBXE1phgxoaK+tArSLcAOr1k8CgHazzB7D2j2X6v4x0Xmescq4dzB+R+6dtYGWhn5qwFjn2KljjYGVwitwdjyuqIqzS3vEpJaIpzI8nOnbGPR42a6t9FmBg3KhYyrcT5Z7DJgQvF1RkXmjeCjtHOOWL7xdDjI8iRwF3Kkiz78ovv2jr8MB2unrgPTNQ56ZPSi34gAGIDgt59VVM14P6GRxvRvtCG644QOEH&#x2F;4woOmADi28BD3Gkj2+1Z1tXTaj1WPOvyEorHAXVS4L9fDScvaRK3el1LKk1hX1&#x2F;dq3+ozN+Jpm8KWVtfLGfKxmKgQSJFX6qH49FuCBcD0Rpk3WnJInqz5+HLUlGqQypf0oTjQFpa+vY83&#x2F;Fa3WKpqAuJM136+3mxeZFv+YCJv7eql2FzNhUAMG6Zur4&#x2F;Kx5uMP1QFl0y9JYmH7WebS9MMzmE&#x3D; Admin@DESKTOP-EBFV026\n\n&#x2F;&#x2F; 如果没有，需要生成一个\n&#x2F;&#x2F; &quot;&quot; 内填写 Github 账号的注册邮箱\n$ ssh-keygen -t rsa -C &quot;&quot;\n\n&#x2F;&#x2F; 接下的步骤大概就是确认，填写密码之类的，回车键跳过（简单点）\n\n\n\n4. Github添加Key需要在Github账户内，将本地生成的 SSH key 添加进去，Git上传或下载时，才不会出现错误\n\n进入Github用户主页\n用户头像边上的倒三角\nSettings 进入设置页面\n在侧边栏内找到 SSH and GPG Keys\n在SSH Keys 内找到 New SSH Key\n跳转页面后，在Title页面里填写 Public SSH Key 名称（随意）\n在Key的文本框内，粘贴进之前在 复制的 id_rsa.pub 文件的内容\nAdd SSH Key\n\n5. Git仓库\n创建 Git 仓库 （这个也跳过，简单的创建一个公开的仓库）\n创建后，可以简单记录一下 SSH 的链接，比如：&#103;&#x69;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#111;&#109;:FHangH&#x2F;FHangBlogCDN_02.git\n\n6. 上传本地到Git\n首先是进入要上传的项目文件夹内\n\n&#x2F;&#x2F; 初始化本地仓库\n$ git init\n\n&#x2F;&#x2F; 将文件全部加入到缓存中\n$ git add .\n&#x2F;&#x2F; 或者在 add 后面跟上指定的文件或某种类型的文件\n$ git add \n\n&#x2F;&#x2F; 提交操作记录，&quot;&quot; 内随意填\n$ git commit -m &quot;&quot;\n\n&#x2F;&#x2F; 远程添加到源中，也就是git仓库\n$ git remote add origin git@github.com:用户名&#x2F;仓库名.git\n&#x2F;&#x2F; 有时候出现失败情况，就用下面这条命令，然后再重复上面的命令\n$ git remote rm origin\n\n&#x2F;&#x2F; 最后，将本地缓存中的文件上传的远程的git仓库中（有时候网络会抽风）\n$ git push origin master\n\n\n\n7. 从远程Git仓库拉到本地\n本地创建一个空的项目文件夹，在文件夹内进行\n\n&#x2F;&#x2F; 多种 clone 的方法\n$ git clone http[s]:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git\n$ git clone http:&#x2F;&#x2F;git.oschina.net&#x2F;yiibai&#x2F;sample.git\n$ git clone ssh:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git\n$ git clone git:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git &#x2F;&#x2F; 这个速度最快\n$ git clone &#x2F;opt&#x2F;git&#x2F;project.git \n$ git clone file:&#x2F;&#x2F;&#x2F;opt&#x2F;git&#x2F;project.git\n$ git clone ftp[s]:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git\n$ git clone rsync:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git\n\n&#x2F;&#x2F; 此处以 ssh 为例\n$ git clone git@github.com:FHangH&#x2F;Cpp-Learn-AddressBook_Clion.git\n\n&#x2F;&#x2F;运行结果（这样就 clone Git仓库到本地了）\nPS C:\\Users\\Admin\\Desktop\\Test&gt; git clone git@github.com:FHangH&#x2F;Cpp-Learn-AddressBook_Clion.git\nCloning into &#39;Cpp-Learn-AddressBook_Clion&#39;...\nremote: Enumerating objects: 65, done.\nReceiving objects:  10% (7&#x2F;65) (65&#x2F;65), done.\nremote: Compressing objects: 100% (55&#x2F;55), done.\nremote: Total 65 (delta 7), reused 65 (delta 7), pack-reused 0\nReceiving objects: 100% (65&#x2F;65), 739.90 KiB | 127.00 KiB&#x2F;s, done.\nResolving deltas: 100% (7&#x2F;7), done.\n\n\n\n8. gitignore文件\n用来上传本地项目到远程仓库时，过滤掉一些不需要上传的文件\n\n&#x2F;&#x2F; 生成 .gitignore 文件\n$ touch .gitignore\n\n&#x2F;&#x2F; powershell 里生成 .gitignore 的方法\n$ new-item .gitignore\n\n\n提供一个现成的 .gitignore 文件的开源库链接\n\n\n使用方法：\n\n确定自己上传的项目类型\n在上述开源链接中找到对应项目类型的 .gitignore 文件\n复制里面的内容\n粘贴到自己项目中创建的 .gitignore 文件中，保存\n\n\n\n8.1 个人常用的 .gitignore 文件8.1.1 UnrealEnigne.gitignore# Visual Studio 2015 user specific files\n.vs&#x2F;\n\n# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n*.dll\n\n# Fortran module files\n*.mod\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n*.lib\n\n# Executables\n*.exe\n*.out\n*.app\n*.ipa\n\n# These project files can be generated by the engine\n*.xcodeproj\n*.xcworkspace\n*.sln\n*.suo\n*.opensdf\n*.sdf\n*.VC.db\n*.VC.opendb\n\n# Precompiled Assets\nSourceArt&#x2F;**&#x2F;*.png\nSourceArt&#x2F;**&#x2F;*.tga\n\n# Binary Files\nBinaries&#x2F;*\nPlugins&#x2F;*&#x2F;Binaries&#x2F;*\n\n# Builds\nBuild&#x2F;*\n\n# Whitelist PakBlacklist-&lt;BuildConfiguration&gt;.txt files\n!Build&#x2F;*&#x2F;\nBuild&#x2F;*&#x2F;**\n!Build&#x2F;*&#x2F;PakBlacklist*.txt\n\n# Don&#39;t ignore icon files in Build\n!Build&#x2F;**&#x2F;*.ico\n\n# Built data for maps\n*_BuiltData.uasset\n\n# Configuration files generated by the Editor\nSaved&#x2F;*\n\n# Compiled source files for the engine to use\nIntermediate&#x2F;*\nPlugins&#x2F;*&#x2F;Intermediate&#x2F;*\n\n# Cache files for the editor to use\nDerivedDataCache&#x2F;*\n\n\n\n8.1.2 Unity.gitignore# This .gitignore file should be placed at the root of your Unity project directory\n#\n# Get latest from https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;gitignore&#x2F;blob&#x2F;master&#x2F;Unity.gitignore\n#\n&#x2F;[Ll]ibrary&#x2F;\n&#x2F;[Tt]emp&#x2F;\n&#x2F;[Oo]bj&#x2F;\n&#x2F;[Bb]uild&#x2F;\n&#x2F;[Bb]uilds&#x2F;\n&#x2F;[Ll]ogs&#x2F;\n&#x2F;[Uu]ser[Ss]ettings&#x2F;\n\n# MemoryCaptures can get excessive in size.\n# They also could contain extremely sensitive data\n&#x2F;[Mm]emoryCaptures&#x2F;\n\n# Asset meta data should only be ignored when the corresponding asset is also ignored\n!&#x2F;[Aa]ssets&#x2F;**&#x2F;*.meta\n\n# Uncomment this line if you wish to ignore the asset store tools plugin\n# &#x2F;[Aa]ssets&#x2F;AssetStoreTools*\n\n# Autogenerated Jetbrains Rider plugin\n&#x2F;[Aa]ssets&#x2F;Plugins&#x2F;Editor&#x2F;JetBrains*\n\n# Visual Studio cache directory\n.vs&#x2F;\n\n# Gradle cache directory\n.gradle&#x2F;\n\n# Autogenerated VS&#x2F;MD&#x2F;Consulo solution and project files\nExportedObj&#x2F;\n.consulo&#x2F;\n*.csproj\n*.unityproj\n*.sln\n*.suo\n*.tmp\n*.user\n*.userprefs\n*.pidb\n*.booproj\n*.svd\n*.pdb\n*.mdb\n*.opendb\n*.VC.db\n\n# Unity3D generated meta files\n*.pidb.meta\n*.pdb.meta\n*.mdb.meta\n\n# Unity3D generated file on crash reports\nsysinfo.txt\n\n# Builds\n*.apk\n*.aab\n*.unitypackage\n\n# Crashlytics generated file\ncrashlytics-build.properties\n\n# Packed Addressables\n&#x2F;[Aa]ssets&#x2F;[Aa]ddressable[Aa]ssets[Dd]ata&#x2F;*&#x2F;*.bin*\n\n# Temporary auto-generated Android Assets\n&#x2F;[Aa]ssets&#x2F;[Ss]treamingAssets&#x2F;aa.meta\n&#x2F;[Aa]ssets&#x2F;[Ss]treamingAssets&#x2F;aa&#x2F;*\n\n\n\n8.1.3 VisualStudio.gitignore## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;gitignore&#x2F;blob&#x2F;master&#x2F;VisualStudio.gitignore\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop&#x2F;Xamarin Studio)\n*.userprefs\n\n# Mono auto generated files\nmono_crash.*\n\n# Build results\n[Dd]ebug&#x2F;\n[Dd]ebugPublic&#x2F;\n[Rr]elease&#x2F;\n[Rr]eleases&#x2F;\nx64&#x2F;\nx86&#x2F;\n[Ww][Ii][Nn]32&#x2F;\n[Aa][Rr][Mm]&#x2F;\n[Aa][Rr][Mm]64&#x2F;\nbld&#x2F;\n[Bb]in&#x2F;\n[Oo]bj&#x2F;\n[Ll]og&#x2F;\n[Ll]ogs&#x2F;\n\n# Visual Studio 2015&#x2F;2017 cache&#x2F;options directory\n.vs&#x2F;\n# Uncomment if you have tasks that create the project&#39;s static files in wwwroot\n#wwwroot&#x2F;\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files&#x2F;\n\n# MSTest test Results\n[Tt]est[Rr]esult*&#x2F;\n[Bb]uild[Ll]og.*\n\n# NUnit\n*.VisualState.xml\nTestResult.xml\nnunit-*.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS&#x2F;\n[Rr]eleasePS&#x2F;\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts&#x2F;\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts&#x2F;\n\n# ASP.NET Scaffolding\nScaffoldingReadMe.txt\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch&#x2F;\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf&#x2F;\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*&#x2F;\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover&#x2F;*\n!.axoCover&#x2F;settings.json\n\n# Coverlet is a free, cross platform Code Coverage Tool\ncoverage*[.json, .xml, .info]\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net&#x2F;\n\n# Web workbench (sass)\n.sass-cache&#x2F;\n\n# Installshield output folder\n[Ee]xpress&#x2F;\n\n# DocProject is a documentation generator add-in\nDocProject&#x2F;buildhelp&#x2F;\nDocProject&#x2F;Help&#x2F;*.HxT\nDocProject&#x2F;Help&#x2F;*.HxC\nDocProject&#x2F;Help&#x2F;*.hhc\nDocProject&#x2F;Help&#x2F;*.hhk\nDocProject&#x2F;Help&#x2F;*.hhp\nDocProject&#x2F;Help&#x2F;Html2\nDocProject&#x2F;Help&#x2F;html\n\n# Click-Once directory\npublish&#x2F;\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts&#x2F;\n\n# NuGet Packages\n*.nupkg\n# NuGet Symbol Packages\n*.snupkg\n# The packages folder can be ignored because of Package Restore\n**&#x2F;[Pp]ackages&#x2F;*\n# except build&#x2F;, which is used as an MSBuild target.\n!**&#x2F;[Pp]ackages&#x2F;build&#x2F;\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**&#x2F;[Pp]ackages&#x2F;repositories.config\n# NuGet v3&#39;s project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx&#x2F;\n*.build.csdef\n\n# Microsoft Azure Emulator\necf&#x2F;\nrcf&#x2F;\n\n# Windows Store app package directories and files\nAppPackages&#x2F;\nBundleArtifacts&#x2F;\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n*.appxbundle\n*.appxupload\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!?*.[Cc]ache&#x2F;\n\n# Others\nClientBin&#x2F;\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;gitignore&#x2F;pull&#x2F;2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;gitignore&#x2F;pull&#x2F;1529#issuecomment-104372622)\n#bower_components&#x2F;\n\n# RIA&#x2F;Silverlight projects\nGenerated_Code&#x2F;\n\n# Backup &amp; report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files&#x2F;\nBackup*&#x2F;\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup&#x2F;\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n*- [Bb]ackup.rdl\n*- [Bb]ackup ([0-9]).rdl\n*- [Bb]ackup ([0-9][0-9]).rdl\n\n# Microsoft Fakes\nFakesAssemblies&#x2F;\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules&#x2F;\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**&#x2F;*.HTMLClient&#x2F;GeneratedArtifacts\n**&#x2F;*.DesktopClient&#x2F;GeneratedArtifacts\n**&#x2F;*.DesktopClient&#x2F;ModelManifest.xml\n**&#x2F;*.Server&#x2F;GeneratedArtifacts\n**&#x2F;*.Server&#x2F;ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket&#x2F;paket.exe\npaket-files&#x2F;\n\n# FAKE - F# Make\n.fake&#x2F;\n\n# CodeRush personal settings\n.cr&#x2F;personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__&#x2F;\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools&#x2F;**\n# !tools&#x2F;packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik&#39;s JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover&#x2F;\n\n# Azure Stream Analytics local run output\nASALocalRun&#x2F;\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor&#x2F;\n\n# Local History for Visual Studio\n.localhistory&#x2F;\n\n# BeatPulse healthcheck temp database\nhealthchecksdb\n\n# Backup folder for Package Reference Convert tool in Visual Studio 2017\nMigrationBackup&#x2F;\n\n# Ionide (cross platform F# VS Code tools) working folder\n.ionide&#x2F;\n\n# Fody - auto-generated XML schema\nFodyWeavers.xsd\n\n\n\n8.1.4 C++.gitignore# Prerequisites\n*.d\n\n# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n*.dll\n\n# Fortran module files\n*.mod\n*.smod\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n*.lib\n\n# Executables\n*.exe\n*.out\n*.app\n\n\n\n8.1.5 C.gitignore# Prerequisites\n*.d\n\n# Object files\n*.o\n*.ko\n*.obj\n*.elf\n\n# Linker output\n*.ilk\n*.map\n*.exp\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Libraries\n*.lib\n*.a\n*.la\n*.lo\n\n# Shared objects (inc. Windows DLLs)\n*.dll\n*.so\n*.so.*\n*.dylib\n\n# Executables\n*.exe\n*.out\n*.app\n*.i*86\n*.x86_64\n*.hex\n\n# Debug files\n*.dSYM&#x2F;\n*.su\n*.idb\n*.pdb\n\n# Kernel Module Compile Results\n*.mod*\n*.cmd\n.tmp_versions&#x2F;\nmodules.order\nModule.symvers\nMkfile.old\ndkms.conf\n\n\n\n8.1.6 CMake.gitignoreCMakeLists.txt.user\nCMakeCache.txt\nCMakeFiles\nCMakeScripts\nTesting\nMakefile\ncmake_install.cmake\ninstall_manifest.txt\ncompile_commands.json\nCTestTestfile.cmake\n_deps\n\n","slug":"6.Git个人使用","date":"2022-10-06T07:28:25.946Z","categories_index":"编程","tags_index":"Git","author_index":"FangH"},{"id":"fa71f19cd12c01c160b7bc498a3984ba","title":"C语言基础","content":"C语言基础1. 编译预处理命令三种：\n\n宏定义\n文件包含\n条件编译\n\n1.1 宏定义宏是根据一系列定义的规则替换一段文本的一种模式\n\n格式：#define 标识符 字符串\n\n标识符：宏名，大写书写（区别与普通变量名）\n\n字符串：宏体，赋值给标识符（编写时，直接写标识符，编译预处理时替换成字符串的值）\n\n宏展开：宏名置换成宏体\n\n\n定义宏（是否带参数）\n\n无参\n直接用宏名代替字符串，称为 符号常量\n\n有参\n替换宏名时，对参数进行转换\n\n\n1.2 文件包含命令将已有的源文件，通过文件包含引入其他程序中，后续编程直接引用文件包含所有的定义对象，提高代码复用性和编写效率\n2. 编译过程源文件 .c 编译后，得到目标代码文件 .obj （0 和1组成），经过链接（组装）成可执行文件 .exe\n3. 运算量表达式由运算量和运算符，正确使用运算量是正确编写表达式语句的前提\n运算量：\n\n常量\n变量\n函数\n\n3.1 常量分类：值常量，符号常量\n3.1.1 值常量\n整形常量\n\n实型常量\n\n字符常量\n字符型常量和对应的ASCII码通用，可以把A理解成65，参与算术运算\n\n\n3.1.2 符号常量用一个符号代替一个值常量，使用前，先用宏定义（无参宏）\n3.2 变量命名要求：\n\n标识符不能是关键字\n标识符只能是字母、数字、下划线组成\n标识符第一个字符必须是下划线或字母\n标识符区分大小写\n\n3.2.1 类型占内存大小\n整型\n\n\n\n\n数据类型\n占用空间\n取值范围\n\n\n\nshort（短整型）\n2字节\n（-2^15 - 2^15-1）\n\n\nint（整型）\n2字节\n（-2^31 - 2^31-1）\n\n\nlong（长整型）\nwindows为4字节，Linux为4字节（32位），8字节（64位）\n（-2^31 - 2^31-1）\n\n\nlong long（长长整型）\n8字节\n（-2^63 - 2^63-1）\n\n\n\n浮点型\n\n\n\n\n数据类型\n占用空间\n有效数字范围\n\n\n\nfloat\n4字节\n7位有效数字\n\n\ndouble\n8字节\n15 - 16位有效数字\n\n\n\n字符型\n\n作用：显示单个字符\n\n语法：char 变量名 &#x3D; ‘变量值’\n\n注意：char定义的变量只能用单引号；只能有一个字符\n\n占用：char占用1个字节；将字符对应的ASCII码放入存储单元\n\nASCII：\t\n0 - 31 分配个控制字符\n32 - 126 分配个键盘上能找到的字符\n\n\n3.3 函数和数学一样，返回数值的函数可以作为运算量参与表达式的运算\n需要加入头文件 math.h\n\nsqrt(x)：求x的平方根\nfabs(x)：求x的绝对值\nexp(x)：求e的x次方\n\n4. 运算符分类：\n\n算术运算符\n关系运算符\n逻辑运算符\n位运算符\n赋值运算符\n条件运算符\n求字节运算符\n逗号运算符\n指针运算符\n其他\n\n加减乘除运算为：二目运算符（目数取决于参与运算量的个数）\n% ：求余或求模，返回两个整形数的余数\n4.1 算术运算符的结合性当表达式中，所有运算符同级，从左往右算；否则，优先算高级。\n特点表达式，从右往左算\n自增（++），自减（–）：从右往左算 （只对变量做运算，不对表达式）\n++x：先改变量值，再参与表达式运算\nx++：先参与表达式运算，再改变量值\n参数求值顺序位：从右往左\n4.2 关系及逻辑运算符4.2.1 关系运算符实现同类型的运算量之间进行关系比较，用关系运算符连接的式子位关系表达式，值：逻辑真（1），逻辑假（0）\n4.2.2 逻辑运算符和表达式逻辑与（&amp;&amp;），逻辑或（||），逻辑非（！）\n4.3 赋值、逗号、求字节4.3.1 赋值形式：变量 &#x3D; 表达式；\n右结合性（14级）\n4.3.2 逗号形式：表达式1，表达式2，… ，表达式n；\n左结合性（最低优先级，15级）\n4.3.3 求字节形式：sizeof 变量名 或 sizeof(类型名)\n功能：求变量或数据类型内存空间占用的字节数\n运算结果：整型数；\n优先级：单目运算符，2级\n4.4 位运算表达式的值，转二进制，一位一位的逻辑运算\n\n按位与\n按位或\n按位异或（真 异或 ？&#x3D; ！？；假 异或 ？&#x3D; ？）\n按位取反\n\n\n\n\n\n\n\n\n\n5. 数据类型转换转换方式：\n\n赋值转换\n自动转换\n强制转换\n\n5.1 赋值转换赋值时，将右边的值的类型转换成左边变量类型一致的类型\n5.2 自动转换两种类型的数组在表达式中进行算术运算时，低精度会自动转成高精度\nfloat 转成 double\nchar 转成 string\nshort&#x2F;int 转成 long\n5.3 强制转换系统无法自动转换，又必须与另一个类型的数据进行计算，用户需要手动指定转换类型\n形式：（类型名）表达式；\n注意：强制转换是临时转换，变量值不变，只在需要转换的表达式中有效\n6. 算法\n概念\n为解决某一个具体问题采取明确，有限的操作步骤\n\n特性\n\n确定性：每一个步骤语义明确\n有穷性：任务可以复杂，多，但不能无限执行\n可行性：每一步都是C语言能够完成的\n输入：一个算法可以有0个或n个输入\n输出：一个算法至少有一个输出\n\n\n描述工具\n\n伪代码表示法\n传统流程图表示法\nN-S结构化表示法\n\n\n结构化思想\n\n顺序结构\n选择结构\n循环结构\n\n\n语句种类\n\n表达式语句\n空语句\n函数调用语句\n控制语句\n复核语句\n\n\n\n6.1 字符输入输出函数6.1.1 字符输入函数getchar()：从输入设备中，读入1个字符，返回字符的ASCII码，并通过程序流显示在屏幕上\n例：char a；a &#x3D; getchar()；\n注：getch() 后，无需回车键进入下一步\n6.1.2 字符输出函数putchar()：输出一个字符\n例：char ch &#x3D; ‘A’;\nputchar(ch);\nputchar(‘A’);\nputchar(65);\nputchar(‘\\101’);\nputchar(‘\\x41’);\n注：putch()：也只输出一个字符\n6.2 格式输入输出函数6.2.1 格式输出函数例：printf(“格式控制字符串”， 输出字符列表)；\n\n\n\n\n6.2.2 格式输入函数scanf(“格式控制字符”， 字符地址列表)；\n例：scanf(“a&#x3D;%d, b&#x3D;%d”, &amp;a, &amp;b);\n6.3 三目运算\n作用：通过三目运算符实现简单的判断\n语法：表达式a ？表达式b ：表达式c\n解释：\na为真，执行b，并返回b的结果；\na为假，执行c，并返回c的结果；\n\n\n\n#include &lt;stdio&gt;\n\nvoid main()\n&#123;\n\tint a &#x3D; 10, b &#x3D; 20;\n\tint c;\n\t\n\tc &#x3D; (a &gt; b ? a : b);\n\tcout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\t&#x2F;&#x2F;三目运算符表达式返回的是 变量，所以可以直接作为左值被赋值；\n\t(a &lt; b ? a : b) &#x3D; 100;\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n &#125;\n\n\n\n\n\n6.4 switch\n语法：\n\nswitch (表达式)\n&#123;\n    case 结果1:\n    执行语句;\n    break；\n    case 结果1:\n    执行语句;\n    break；\n    ...\n    default:\n    执行语句;\n    break；\n&#125;\n\n\n注意：\nswitch语句的表达式类型只能是整型或字符型；\ncase后没有break语句，程序会一直向下执行；\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint value;\n\n\tcout &lt;&lt; &quot;Enter int value : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; value;\n\n\tswitch (value)\n\t&#123;\n\tcase 10:\n\t\tcout &lt;&lt; &quot;Return S&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 9:\n\t\tcout &lt;&lt; &quot;Return A&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 8:\n\t\tcout &lt;&lt; &quot;Return A&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 7:\n\t\tcout &lt;&lt; &quot;Return B&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 6:\n\t\tcout &lt;&lt; &quot;Return B&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 5:\n\t\tcout &lt;&lt; &quot;Return C&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 4:\n\t\tcout &lt;&lt; &quot;Return C&quot; &lt;&lt; endl;\n\t\tbreak;\n\tdefault:\n\t\tcout &lt;&lt; &quot;Return D&quot; &lt;&lt; endl;\n\t\tbreak;\n\t&#125;\n&#125;\n\n\n\n\n\n7. 循环结构程序\nwhile\ndo-while\nfor\n\n7.1 while循环\n作用：满足判断条件，执行循环语句\n\n语法：\nwhile (判断条件)\n&#123;\n\t循环语句;\n&#125;\n\n案列：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint num &#x3D; 0;\n\n\twhile (num &lt; 10)\n\t&#123;\n\t\tcout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;\n\t\tnum++;\n\t&#125;\n&#125;\n\n7.2 do-while\n作用：先执行循环语句，再满足判断条件，执行循环语句\n\n注意：do…while 与 while的区别在于，do…while 先执行一次循环语句，再判断条件是否满足继续执行\n\n语法：\ndo\n&#123;\n    循环语句;\n&#125;while (循环条件);\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint num &#x3D; 0;\n\n\tdo\n\t&#123;\n\t\tcout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;\n\t\tnum++;\n\t&#125; while (num &lt; 10);\n&#125;\n\n\n水仙花案列\n\n说明：一个三位的整数满足每一位的三次方的和依旧等于这个三位数 （do … while）\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint dNum &#x3D; 100; &#x2F;&#x2F;最小的三位数\n\n\tdo\n\t&#123;\n\t\tdouble a, b, c, d; &#x2F;&#x2F; a为百位，b为十位，c为个位，d为 a b c三次方的和\n\n\t\t&#x2F;&#x2F;pow(x, y) &#x3D;&#x3D; x 的 y 次方\n\t\ta &#x3D; pow(dNum &#x2F; 100, 3);\n\t\tb &#x3D; pow(dNum &#x2F; 10 % 10, 3);\n\t\tc &#x3D; pow(dNum % 10, 3);\n\t\td &#x3D; a + b + c;\n\n\t\t&#x2F;&#x2F;判断当前的三位数是不是水仙花数\n\t\tif (d &#x3D;&#x3D; dNum)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;条件为真时 打印水仙花数\n\t\t\tcout &lt;&lt; dNum &lt;&lt; endl;\n\t\t&#125;\n\t\tdNum++; &#x2F;&#x2F;每当while条件满足都执行一遍\n\t&#125; while (dNum &lt; 1000); &#x2F;&#x2F;判断当前是否是三位数\n&#125;\n\n7.3 for\n作用：满足条件，执行语句\n\n语法：\nfor (起始表达式; 循环条件; 循环体)\n&#123;\n\t循环语句;\n&#125;\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tcout &lt;&lt; i &lt;&lt; endl;\n\t&#125;\n&#125;\n\nfor 循环案列-1\n\n说明：1 - 100 的区间数字，满足 各位 或 十位 或 倍数 与 7 有关，打印 yes，其余直接打印数字；\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#x2F;&#x2F;循环打印 1 - 100 \n\t&#123;\n\t\t&#x2F;&#x2F;判断遍历的数字是否满足条件\n\t\tif (i % 10 &#x3D;&#x3D; 7 || i &#x2F; 10 % 10 &#x3D;&#x3D; 7 || i % 7 &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#x2F;&#x2F;满足调件打印 yes\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tcout &lt;&lt; i &lt;&lt; endl; &#x2F;&#x2F;不满足条件打印 原数字\n\t\t&#125;\n\t&#125;\n&#125;\n\nfor 循环案列-2\n\n判断一个整数是否为素数（【2， n-1】内没有n的因子）\n#include &lt;stdio.h&gt;\n\n#define Log printf\n#define Enter scanf_s\n\nint main()\n&#123;\n    int a &#x3D; 0;  &#x2F;&#x2F; 素数的个数\n    int num &#x3D; 0;  &#x2F;&#x2F; 输入的整数\n\n    Log(&quot;输入一个整数：&quot;);\n    Enter(&quot;%d&quot;, &amp;num);\n\n    for (int i &#x3D; 2; i &lt; num; i++)\n    &#123;\n        if (num % i &#x3D;&#x3D; 0)\n        &#123;\n            a++;  &#x2F;&#x2F; 素数个数加1\n        &#125;\n    &#125;\n\n    if (a &#x3D;&#x3D; 0)\n    &#123;\n        Log(&quot;%d是素数。\\n&quot;, num);\n    &#125;\n    else\n    &#123;\n        Log(&quot;%d不是素数。\\n&quot;, num);\n    &#125;\n\n    return 1;\n&#125;\n\n7.4 goto\n作用：无条件跳转语句(转向语句)，控制程序流程无条件转移至“语句标号”所指定的语句，开始执行\n语法：goto 标记;\n解释：程序执行到goto时，如果标记存在，怎直接跳转到标记处，并继续执行\n缺点：功能太强，容易破坏程序\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tcout &lt;&lt; &quot;S&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;A&quot; &lt;&lt; endl;\n\n\tgoto GotoTarget; &#x2F;&#x2F;此处的 goto 语句标记为 GotoTarget\n\n\tcout &lt;&lt; &quot;B&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;C&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;D&quot; &lt;&lt; endl;\n\n\tGotoTarget: &#x2F;&#x2F;程序直接跳转至此处，并继续向下执行\n\tcout &lt;&lt; &quot;E&quot; &lt;&lt; endl;\n&#125;\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int n &#x3D; 1;\n    int sum &#x3D; 0;\n\n    NEXT:\n    sum &#x3D; sum + n;\n    n++;\n\n    if (sum &lt;&#x3D; 200)\n    &#123;\n        goto NEXT;\n    &#125;\n    printf(&quot;sum&#x3D;%d\\n&quot;, sum);\n&#125;\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int n &#x3D; 1;\n    int sum &#x3D; 0;\n\n    LOOP:\n    if (sum &gt;&#x3D; 200)\n    &#123;\n        goto END;\n    &#125;\n    else\n    &#123;\n        sum +&#x3D; n;\n        n++;\n        goto LOOP;\n    &#125;\n    END:\n    printf(&quot;sum&#x3D;%d\\n&quot;, sum);\n\n    return 0;\n&#125;\n\n\n\n\n\n7.5 break和continue7.5.1 break\n作用：用于跳出选择结构或者循环结构\n使用：\n出现在switch语句中，终止case并跳出switch；\n出现在循环语句中，跳出循环；\n出现在嵌套循环中，跳出内层循环；\n\n\n\n7.5.2 continue只能在循环体中使用\n\n作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一循环\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;从1 -100 遍历100次\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 100; i++)\n\t&#123;\n\t\t&#x2F;&#x2F;如果i 为偶数，则跳过当前循环，执行下一次遍历\n\t\tif (i % 2 &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tcout &lt;&lt; i &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n\n\n\n7.6 循环嵌套\n作用：在循环语句内再添加循环，解决实际问题\n\n注意：一定要确保被嵌套的循环结构完整的包含在外层循环的结构体中\n\n描述：打印 10*10 的矩阵\n #include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; 10; j++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;* &quot;;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n&#125;\n\n打印乘法表：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    for (int h &#x3D; 1; h &lt;&#x3D; 9; h++) &#x2F;&#x2F;行数\n    &#123;\n        for (int v &#x3D; 1; v &lt;&#x3D; h; v++) &#x2F;&#x2F;列数，但不超过行数\n        &#123;\n            printf(&quot;%d * %d &#x3D; %d   &quot;, v, h, v*h);&#x2F;&#x2F;结果为 列数*行数&#x3D;\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n    \n    return 0;\n&#125;\n\n\n\n打印菱形：\n#include &lt;stdio.h&gt;\n\n#define Log printf\n#define Enter scanf_s\n\nint main()\n&#123;\n    int enterNum &#x3D; 0;\n\n    Log(&quot;Enter Num :&quot;);\n    Enter(&quot;%d&quot;, &amp;enterNum);\n    Log(&quot;\\n&quot;);\n\n    for (int i &#x3D; 1; i &lt;&#x3D; enterNum; i++)\n    &#123;\n        for (int j &#x3D; 1; j &lt;&#x3D; enterNum - i; j++)\n        &#123;\n            Log(&quot; &quot;);\n        &#125;\n        for (int k &#x3D; 1; k &lt;&#x3D; 2 * i - 1; k++)\n        &#123;\n            Log(&quot;*&quot;);\n        &#125;\n        Log(&quot;\\n&quot;);\n    &#125;\n\n    for (int i &#x3D; enterNum - 1; i &gt;&#x3D; 1; i--)\n    &#123;\n        for (int j &#x3D; 1; j &lt;&#x3D; enterNum - i; j++)\n        &#123;\n            Log(&quot; &quot;);\n        &#125;\n        for (int k &#x3D; 1; k &lt;&#x3D; 2 * i - 1; k++)\n        &#123;\n            Log(&quot;*&quot;);\n        &#125;\n        Log(&quot;\\n&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n8. 数组8.1 一维数组8.1.1 一维数组的定义【存储类型】类型说明符 数组名 【常量表达式】\n\n数据类型 数组名[数组长度];\n\n数据类型 数组名[数组长度] &#x3D; {元素1，元素2，…..};\n\n数据类型 数组名[] &#x3D; {元素1，元素2，…..};\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;1. 数据类型 数组名[数组长度];\n\tcout &lt;&lt; &quot;数据类型 数组名[数组长度]&quot; &lt;&lt; endl;\n\n\tint arr1[3];\n\tarr1[0] &#x3D; 1;\n\tarr1[1] &#x3D; 2;\n\tarr1[2] &#x3D; 3;\n\t\n\tfor (int i &#x3D; 0; i &lt; 3; i++)\n\t&#123;\n\t\tcout &lt;&lt; arr1[i] &lt;&lt; &quot;  &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;2. 数据类型 数组名[数组长度] &#x3D; &#123;元素1，元素2，.....&#125;;\n\tcout &lt;&lt; &quot;数据类型 数组名[数组长度] &#x3D; &#123;元素1，元素2，.....&#125;&quot; &lt;&lt; endl;\n\n\tint arr2[3] &#x3D; &#123; 1, 2, 4 &#125;;\n\t\n\tfor (int j &#x3D; 0; j &lt; 3; j++)\n\t&#123;\n\t\tcout &lt;&lt; arr2[j] &lt;&lt; &quot;  &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;3. 数据类型 数组名[] &#x3D; &#123;元素1，元素2，.....&#125;;\n\tcout &lt;&lt; &quot;数据类型 数组名[] &#x3D; &#123;元素1，元素2，.....&#125;&quot; &lt;&lt; endl;\n\n\tint arr3[] &#x3D; &#123;1, 2, 3&#125;;\n\n\tfor (int k &#x3D; 0; k &lt; 3; k++)\n\t&#123;\n\t\tcout &lt;&lt; arr1[k] &lt;&lt; &quot;  &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\n8.1.2 一维数组名作用内存空间由数组的类型和元素的个数共同决定\nL &#x3D; 元素个数 * sizeof（类型名）\n作用：\n\n可以统计整个数组在内存中的长度\n\n可以获取数组在内存中的首地址\n\n可以获取数组元素的个数\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint arr[10] &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;\n\n\tcout &lt;&lt; &quot;arr数组占用的内存空间：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组单个元素占用空间：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组的元素个数：&quot; &lt;&lt; sizeof(arr)&#x2F;sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组的首地址：&quot; &lt;&lt; (int)arr &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组第一元素的地址：&quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组第二元素的地址：&quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组最后元素的地址：&quot; &lt;&lt; (int)&amp;arr[sizeof(arr) &#x2F; sizeof(arr[0])] &lt;&lt; endl;\n&#125;\n\n8.1.3 输入数字，按顺序输出#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    static int a[10];\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        printf(&quot;Enter Num to Array :&quot;);\n        scanf_s(&quot;%d&quot;, &amp;a[i]);\n    &#125;\n\n    for (int j &#x3D; 0; j &lt; 10; ++j)\n    &#123;\n        printf(&quot;%3d&quot;, a[j]);\n    &#125;\n\n    for (int k &#x3D; 9; k &gt;&#x3D; 0; --k)\n    &#123;\n        printf(&quot;%3d&quot;, a[k]);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n8.1.4 输入数字，输出最大值#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int maxNum &#x3D; 0;\n    static int a[10];\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        printf(&quot;Enter Num :&quot;);\n        scanf_s(&quot;%d&quot;, &amp;a[i]);\n    &#125;\n\n    for (int j &#x3D; 0; j &lt; 10; ++j)\n    &#123;\n        if (a[j] &gt; maxNum)\n        &#123;\n            maxNum &#x3D; a[j];\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n    printf(&quot;MaxNum is :%d&quot;, maxNum);\n\n    return 0;\n&#125;\n\n\n\n8.1.5 输入数字，求平均值使用一维数组循环\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    float sumNum &#x3D; 0, averageNum, enterNum;\n    static int a[5];\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        printf(&quot;Enter Num :&quot;);\n        scanf_s(&quot;%f&quot;, &amp;enterNum);\n        sumNum +&#x3D; enterNum;\n    &#125;\n\n    averageNum &#x3D; sumNum &#x2F; 5;\n    printf(&quot;AverageNum is :%.2f&quot;, averageNum);\n\n    return 0;\n&#125;\n\n不使用数组循环\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    float enterNum, sumNum &#x3D; 0, averageNum;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        printf(&quot;Enter Num :&quot;);\n        scanf_s(&quot;%f&quot;, &amp;enterNum);\n        sumNum +&#x3D; enterNum;\n    &#125;\n\n    averageNum &#x3D; sumNum &#x2F; 5;\n\n    printf(&quot;AverageNum is :%.2f&quot;, averageNum);\n\n    return 0;\n&#125;\n\n\n\n\n\n8.2 二维数组\n形式：【存储类型】类型说明符 数组名 【常量表达式1】【常量表达式2】；\n\n说明：二维数组元素在内存中排列顺序为按行为序排列\n\n初始化：\n\n\n\n\n- \n8.2.1 二维数组的定义四种定义方式：\n\n数据类型 数组名 [行数] [列数]；\n数据类型 数组名 [行数] [列数] &#x3D; ｛｛数据1，数据2｝，｛数据3，数据4｝｝；\n数据类型 数组名 [行数] [列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n数据类型 数组名 [] [列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n\n第二种更直观，可读性更高\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;1. 数据类型 数组名[行数][列数]；\n\tint arr1[2][3];\n\t\n\tarr1[0][0] &#x3D; 1;\n\tarr1[0][1] &#x3D; 2;\n\tarr1[0][2] &#x3D; 3;\n\tarr1[1][0] &#x3D; 4;\n\tarr1[1][1] &#x3D; 5;\n\tarr1[1][2] &#x3D; 6;\n\n\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数]------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\n\tfor (int a &#x3D; 0; a &lt; 2; a++)\n\t&#123;\n\t\tfor (int a1 &#x3D; 0; a1 &lt; 3; a1++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; arr1[a][a1] &lt;&lt; &quot; &quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;2. 数据类型 数组名[行数][列数] &#x3D; &#123;｛数据1，数据2｝，｛数据3，数据4｝&#125;；\n\tint arr2[2][3] &#x3D;\n\t&#123;\n\t\t&#123;1, 2, 3&#125;,\n\t\t&#123;4, 5, 6&#125;\n\t&#125;;\n\n\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数] &#x3D; &#123;｛数据1，数据2｝，｛数据3，数据4｝&#125;------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\n\tfor (int b &#x3D; 0; b &lt; 2; b++)\n\t&#123;\n\t\tfor (int b1 &#x3D; 0; b1 &lt; 3; b1++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; arr2[b][b1] &lt;&lt; &quot; &quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;3. 数据类型 数组名[行数][列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n\tint arr3[2][3] &#x3D; &#123; 1, 2, 3, 4, 5, 6 &#125;;\n\n\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数] &#x3D; ｛数据1，数据2，数据3，数据4｝------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\n\tfor (int c &#x3D; 0; c &lt; 2; c++)\n\t&#123;\n\t\tfor (int c1 &#x3D; 0; c1 &lt; 3; c1++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; arr3[c][c1] &lt;&lt; &quot; &quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;4. 数据类型 数组名[][列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n\tint arr4[][3] &#x3D; &#123; 1, 2, 3, 4, 5, 6 &#125;;\n\n\tcout &lt;&lt; &quot;------数据类型 数组名[][列数] &#x3D; ｛数据1，数据2，数据3，数据4｝------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\n\tfor (int d &#x3D; 0; d &lt; 2; d++)\n\t&#123;\n\t\tfor (int d1 &#x3D; 0; d1 &lt; 3; d1++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; arr4[d][d1] &lt;&lt; &quot; &quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\n\n\n8.2.2 二维数组名作用\n查看二维数组所占空间\n\n查看二维数组的首地址\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint arr[2][3] &#x3D;\n\t&#123;\n\t\t&#123;1, 2, 3&#125;,\n\t\t&#123;4, 5, 6&#125;\n\t&#125;;\n\n\tcout &lt;&lt; &quot;二维数组的大小：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组一行的大小：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组元素的大小：&quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组的行数：&quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组的列数：&quot; &lt;&lt; sizeof(arr[0]) &#x2F; sizeof(arr[0][0]) &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;*************************&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;地址\n\tcout &lt;&lt; &quot;二维数组的首地址：&quot; &lt;&lt; (int)arr &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第一行的地址：&quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第二行的地址：&quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第一个元素的地址：&quot; &lt;&lt; (int)&amp;arr[0][0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第二个元素的地址：&quot; &lt;&lt; (int)&amp;arr[0][1] &lt;&lt; endl;\n&#125;\n\n8.2.3 二维数组输入输出#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    static int a[2][3];\n\n    printf(&quot;Enter 6 Num:\\n&quot;);\n\n    for (int i &#x3D; 0; i &lt; 2; ++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 3; ++j)\n        &#123;\n            printf(&quot;%d Row %d Column:&quot;, i, j);\n            scanf_s(&quot;%d&quot;, &amp;a[i][j]);\n        &#125;\n    &#125;\n\n    printf(&quot;Log Array :\\n&quot;);\n\n    for (int k &#x3D; 0; k &lt; 2; ++k)\n    &#123;\n        for (int g &#x3D; 0; g &lt; 3; ++g)\n        &#123;\n            printf(&quot;%3d&quot;, a[k][g]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n8.2.4 二维数组找到最大元素及索引#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    static int a[3][4];\n    int max &#x3D; a[0][0];\n    int row &#x3D; 0, column &#x3D; 0;\n\n    printf(&quot;Enter 12 Num To Array\\n&quot;);\n\n    for (int i &#x3D; 0; i &lt; 3; ++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 4; ++j)\n        &#123;\n            printf(&quot;%d Row %d Column :&quot;, i, j);\n            scanf_s(&quot;%d&quot;, &amp;a[i][j]);\n        &#125;\n    &#125;\n\n    printf(&quot;Log Array\\n&quot;);\n\n    for (int k &#x3D; 0; k &lt; 3; ++k)\n    &#123;\n        for (int g &#x3D; 0; g &lt; 4; ++g)\n        &#123;\n            if (max &lt; a[k][g])\n            &#123;\n                max &#x3D; a[k][g];\n                row &#x3D; k;\n                column &#x3D; g;\n            &#125;\n            printf(&quot;%3d&quot;, a[k][g]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n\n    printf(&quot;Max num : %d;\\t Row : %d;\\t Column : %d\\t&quot;, max, row, column);\n\n    return 0;\n&#125;\n\n\n\n8.2.5 3*3二维数组求对角线值和第一种：效率低\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int a[3][3] &#x3D; &#123;&#123;1, 2, 3&#125;,\n                   &#123;4, 5, 6&#125;,\n                   &#123;7, 8, 9&#125;&#125;;\n    int sum &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt; 3; ++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 3; ++j)\n        &#123;\n            if (i &#x3D;&#x3D; j)\n            &#123;\n                sum +&#x3D; a[i][j];\n            &#125;\n        &#125;\n    &#125;\n    printf(&quot;3*3的二维数组对角线的值和：%d&quot;, sum);\n\n    return 0;\n&#125;\n\n第二种：效率高\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int a[3][3] &#x3D; &#123;&#123;1, 2, 3&#125;,\n                   &#123;4, 5, 6&#125;,\n                   &#123;7, 8, 9&#125;&#125;;\n    int sum &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt; 3; ++i)\n    &#123;\n        sum +&#x3D; a[i][i];\n    &#125;\n\n    printf(&quot;3*3的二维数组对角线的值和：%d&quot;, sum);\n\n    return 0;\n&#125;\n\n\n\n\n\n8.3 字符数组\n说明：字符数组相较于普通数组，除了它们的共同特性外，字符数组具有独自的特点\n\n定义：char 数组名 【常量表达式】； —-  char a 【10】；\n定义字符数组a有10个元素，每个元素一个字符变量，占一个字节空间，用于存放一个字符变量\n\n\n8.3.1 字符数组初始化\n逐个元素初始化：char c[3] &#x3D; {‘a’, ‘b’, ‘c’};\t\n （如果初值个数&gt;数组长度，语法错误）\n （如果初值个数&lt;数组长度，则其余元素自动定义为“串结束符”：\\0）\n （如果初值个数&#x3D;数组长度，则定义时，可省略数组长度）\n\n用字符串初始化：char a[11] &#x3D; {“I am a boy”};\n\n\n\n\n\n\n8.3.2 字符数组输入输出char a[20];\n\n用格式符”%c“，逐个字符输入输出\nscanf (“%c”, &amp;a[0]);\nprintf (“%c”, a[0]);\n\n用格式符”%s“，整个字符串输入输出 (字符串输出时，数组长度至少大于初值个数一个单元，即默认的”\\0“，否则输出结果不符合预期)\nscanf (“%s”, &amp;a);\nprintf (“%s”, a);\n\n\n\n\n8.3.3 字符串处理函数\n\n\n\n\n\n\n\n\n\n9. 函数9.1 函数的定义9.1.1 函数的分类\n是否由用户定义\n标准库函数\n用户自定义函数\n\n\n是否返回值\n返回值的函数：sqrt(x) fabs(x)\n不返回值的函数:  clrscr()\n\n\n是否有参数\n有参函数：sqrt(x) fabs(x)\n无参函数:  clrscr()\n\n\n是否在文件内部\n内部函数\n外部函数\n\n\n\n9.1.2 函数的定义\n方式一：\n函数返回值类型 函数名(参数列表)\n\t参数类型说明\n\t&#123;\n\t\t变量说明；\n\t\t语句序列；\n\t&#125;\n\n方式二：\n函数返回值类型 函数名(参数类型说明 参数列表)\n&#123;\n\t变量说明；\n\t语句序列；\n&#125;\n\n9.1.3 定义不返回值的函数#include &lt;stdio.h&gt;\n\nvoid write() &#x2F;&#x2F;无返回值，无参数的函数\n&#123;\n    for (int i &#x3D; 0; i &lt;&#x3D; 12; ++i)\n    &#123;\n        printf(&quot;%c&quot;, &#39;*&#39;);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;\n\nint main()\n&#123;\n    write();\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n\nvoid write(int num) &#x2F;&#x2F;无返回值，有参数的函数\n&#123;\n    for (int i &#x3D; 0; i &lt;&#x3D; num; ++i)\n    &#123;\n        printf(&quot;%c&quot;, &#39;*&#39;);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;\n\nint main()\n&#123;\n    write(12);\n    return 0;\n&#125;\n\n\n\n9.1.4 定义返回值的函数#include &lt;stdio.h&gt;\n\nint sum(int num)\n&#123;\n    int sum &#x3D; 0;\n    for (int i &#x3D; 0; i &lt;&#x3D; num; ++i)\n    &#123;\n        sum +&#x3D; i;\n    &#125;\n    return sum;\n&#125;\n\nint main()\n&#123;\n    printf(&quot;%d&quot;, sum(3));\n    return 0;\n&#125;\n\n\n\n9.2 函数的使用9.2.1 函数的执行过程例：求前n个自然数和的平均值\n#include &lt;stdio.h&gt;\n\nfloat averageNum(float num)\n&#123;\n    float sum &#x3D; 0.0f, average;\n    int count;\n    for (int i &#x3D; 0; i &lt;&#x3D; (int)num ; ++i)\n    &#123;\n        sum +&#x3D; (float)i;\n        count &#x3D; i;\n    &#125;\n    average &#x3D; sum &#x2F; (float)count;\n\n    return average;\n&#125;\n\nint main()\n&#123;\n    int enterNum;\n    printf(&quot;enter num:&quot;);\n    scanf_s(&quot;%d&quot;, &amp;enterNum);\n    printf(&quot;averageNum&#x3D;%7.2f&quot;, averageNum((float)enterNum));\n    return 0;\n&#125;\n\n\n\n9.3 函数的调用形式\n语句调用\n表达式调用\n\n9.4 函数的声明声明：先定义后调用，声明的函数必须放在main函数之前，否则运行错误\n注：\n\nC++中可以运行，但结果错误\n返回值为int，权限高，可以不声明\n\n#include &lt;stdio.h&gt;\n\nint maxNum(int x, int y, int z); &#x2F;&#x2F; 先声明函数\n\nint main()\n&#123;\n    printf(&quot;MaxNum:%d&quot;, maxNum(10, 20, 30));\n    return 0;\n&#125;\n\nint maxNum(int x, int y, int z) &#x2F;&#x2F; 在mian()函数后面定义函数\n&#123;\n    int max &#x3D; 0;\n    max &#x3D; x &gt; y ? x : y;\n    max &#x3D; max &gt; z ? max : z;\n    return max;\n&#125;\n\n\n\n9.5 带参宏和函数的区别区别：宏中的 sum(x, y)，x和y不存值，而是将函数中出现sum(x, y)类型的表达式用 x+y替代，并返回，再有函数将表达式x+y赋值计算\n\n宏：返回替换的表达式，带入函数中计算\n函数：带入参数计算，返回结果\n\n#include &lt;stdio.h&gt;\n\n#define sum(x, y) x+y; &#x2F;&#x2F; 带参宏\n\nint main()\n&#123;\n    int num &#x3D; 0;\n    num &#x3D; sum(10, 20); &#x2F;&#x2F; 展开： num &#x3D; sum(x+y) -&gt; num &#x3D; x + y\n    printf(&quot;Sum Num :%d&quot;, num);\n    return 0;\n&#125;\n\n\n\n9.6 函数的嵌套和递归调用9.6.1 函数的嵌套调用\n\n\n\n9.6.2 例题\n\n#include &lt;stdio.h&gt;\n\nint funcSum(int num);\n\nfloat funcCalculate(int m, int n, int p);\n\nint main()\n&#123;\n    int m, n, p;\n    printf(&quot;enter num:&quot;);\n    scanf_s(&quot;%d %d %d&quot;, &amp;m, &amp;n, &amp;p);\n    float num &#x3D; funcCalculate(m, n, p);\n    printf(&quot;Calculate Num :%7.2f&quot;, num);\n    return 0;\n&#125;\n\nint funcSum(int num)\n&#123;\n    int sum;\n    for (sum &#x3D; 0; num &gt; 0; --num)\n    &#123;\n        sum +&#x3D; num;\n    &#125;\n    return sum;\n&#125;\n\nfloat funcCalculate(int m, int n, int p)\n&#123;\n    float y &#x3D; (float)(funcSum(m) * funcSum(n));\n    y &#x3D; y &#x2F; (float)funcSum(p);\n    return y;\n&#125;\n\n\n\n9.6.3 函数的递归调用\n\n\n\n\n\n9.7 变量的作用域9.7.1 定义和区别\n\n\n\n9.7.2 全局变量例子\n\n\n\n9.7.3 全局变量和局部变量同名\n\n\n\n\n\n9.8 变量的存储类型9.8.1 定义和分类\n\n\n\n\n\n9.8.2 例子\n\n\n\n\n\n\n\n\n\n10. 指针10.1 指针的概念\n计算机中为方便地区不同的内存单元，会为每个单元分配内存地址，这个地址称为内存单元地址，简称：内存地址\nC语言中把指针定义为地址，指针是地址的另一种描述，相同的概念：指针&#x3D;&#x3D;地址\n\n10.2 指针的类型\n指针指向的对象类型可能不同\n变量，数组，函数，结构体均是内存中的存储对象，都有这不同的存储类型，不同类型的存储空间大小不同，它们的地址是属于不同类型的指针。\n不同类型的指针之间，不能直接有任何操作\n\n10.3 指针和变量10.3.1 变量的指针\n一个变量通常占用若干个连续的内存单元，把这若干个单元起始单元的地址称为变量的地址\n内存单元本身的地址是0和1组成，不方便使用，C语言用 “&amp;变量名” 表示变量的地址\n不同类型的变量，指针的类型不同\n\n10.3.2 指向变量的指针变量\n指针变量：专门存放地址的变量\n\n指向变量的指针变量：专门存放其他变量地址的指针变量，该指针变量指向对象是一个变量\n\n形式：数据类型名 *变量名；\n\n例：\nint x &#x3D; 5;\nint *p1; # p1是变量名， *是定义符，向系统说明p1是指针变量（存放地址）\np1 &#x3D; &amp;x; # &amp;x是整形变量的地址，将其赋值个p1保存，此时p1保存了x的地址\n# x是p1指向的变量，p1是x变量的指针变量\n\n\n指针运算符 “*” 又称间接访问运算符：间址运算符（单目运算符，第二优先级，右结合性）\n\n形式：*地址表达式\n\n先计算表达式的值，再根据表达式的值（地址）及类型，访问内存中相应的对象，分别是两种：从内存中读取，往内存中写入\n\n“*&amp;x”：右结合性 &#x3D;&#x3D; * (&amp;x) &#x3D;&#x3D; x &#x3D;&#x3D; *&amp;x\nint a &#x3D; 5;\nint *pa; # 此处的*是定义一个pa的指针变量\n*pa &#x3D; &amp;a; # 把 a的地址存进去，&amp;（引用）获得变量的地址，此处 *（解析）指向并得到地址内的值\nprintf(&quot;*pa&#x3D;%d&quot;, *pa); # 打印结果为 *pa&#x3D;5；\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int a &#x3D; 5, b &#x3D; 10, *pa &#x3D; NULL, *pb &#x3D; NULL;\n    pa &#x3D; &amp;a;\n    pb &#x3D; &amp;b;\n    printf(&quot;*pa &#x3D; %d, *pb &#x3D; %d&quot;, *pa, *pb);\n\n    *pb &#x3D; *pa + *pb;\n    printf(&quot;\\n*pb &#x3D; %d&quot;, *pb);\n\n    return 0;\n&#125;\n\n\n\n10.3.3 指向指针变量的指针\n定义一个指针变量，让它保存其他指针变量的地址，则该指针变量为指向指针的指针变量（多级指针）\nint x &#x3D; 5;\nint *px;\npx &#x3D; &amp;5; # 此时px存储了x的地址\n\nint *py;\npy &#x3D; &amp;px; # py存储了px的地址（二级指针)\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int a &#x3D; 5;\n    int *pa;\n    int **pb; # 定义一个 int * 类型的指针变量（二级指针）\n\n    pa &#x3D; &amp;a; # a的地址赋值该指针变量 pa\n    pb &#x3D; &amp;pa; # 指针变量pa的地址赋值 pb\n\n    printf(&quot;**pb &#x3D; %d&quot;, **pb); # **pb &#x3D;&#x3D; *(*pb): (*pb)解析pb内地址指向的变量pa，*(*pb) &#x3D;&#x3D; *pa \n\n    return 0;\n&#125;\n\n10.4 指针与数组\n一个数组占用一片连续的内存空间，数组元素的使用可以和同类型的变量相比\n\n10.4.1 一维数组与指针\n一维数组的指针\nint arrX[5], i;\n# w + i &#x3D;&#x3D; &amp;arrX[i] : 表示第i个元素的地址\n# w &#x3D;&#x3D; &amp;arrX[0] : 表示数组的首地址和第0个元素的地址\n# *(w + i) &#x3D;&#x3D; arrX[i] : 表示dii个元素 &#x2F; * （解析）w + i \n\n指向数组元素的指针变量\nint arrX[5], i, *p;\n# p &#x3D; &amp;i;\n# p &#x3D; &amp;arrX[i];\n# p &#x3D; w + i;\n# 当i&#x3D;0 有 p &#x3D; w，此时p指向arrX[0]\n\n引用数组元素方法：int a[5], *p &#x3D; a;\n\n下标法：a[i], p[i]\n\n指针法：*(a+i), *(p+i)\n\n例子：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int arr[10], *p &#x3D; NULL;\n    p &#x3D; arr;\n    int x &#x3D; 0;\n\n    while (p &lt; arr+10)\n    &#123;\n        printf(&quot;arr[%d]&#x3D;&quot;, x);\n        scanf_s(&quot;%d&quot;, p);\n        p++;\n        x++;\n    &#125;\n\n    for (p &#x3D; arr + 9; p &gt;&#x3D; arr ; --p)\n    &#123;\n        printf(&quot;%3d&quot;, *p);\n    &#125;\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int arr[10] &#x3D; &#123;10, 20, 30, 40, 50, 60, 70, 80, 90, 100&#125;;\n    int *p &#x3D; arr + 2;\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        printf(&quot;%5d&quot;, p[i]);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n10.4.2 二维数组与指针int i, j, arr[3][4];\nw + i # 表示i行的行地址；i &#x3D; 0，arr表示第0行的行地址\n\n*(arr + i) # 与arr[i]相同，表示第i行的一维数组名称，也是arr[i][0]的元素地址\n*(arr + i) + j # 表示&amp;arr[i][j]，表示第i行第j列的元素地址\n*(*(w + i)+ j) &#x3D;&#x3D;&#x3D;&#x3D; arr[i][j]\n\nint i, j, k, arr[i][j][k];\n*(*(*(arr + i) +j) +k) &#x3D;&#x3D; arr[i][j][k]\n\n\n\n\n\n\n\n\n\n10.5 指针和字符10.5.1 指针变量访问字符数组#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    char *str &#x3D; &quot;Hello World !&quot;;\n    printf(&quot;%s\\n&quot;, str);\n    printf(&quot;%s\\n&quot;, str + 6);\n\n    return 0;\n&#125;\n\n\n\n10.5.2 指向字符的指针变量输入字符串，判断是否是回文符\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n    char str[20], *str_Front, *str_Rear;\n\n    printf(&quot;Enter String :&quot;);\n    gets_s(str, 20);\n    str_Rear &#x3D; str + strlen(str) - 1;\n\n    for (str_Front &#x3D; str; str_Front &lt; str_Rear; str_Front++, str_Rear--)\n    &#123;\n        if (*str_Front !&#x3D; *str_Rear)\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;%d %d&quot;, *str_Front, *str_Rear);\n\n    if (*str_Front &gt; *str_Rear)\n    &#123;\n        printf(&quot; F&quot;);\n    &#125;\n    else\n    &#123;\n        printf(&quot; T&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n\n\n10.6 指针和函数10.6.1 指针变量作为函数的参数#include &lt;stdio.h&gt;\n\nvoid funcSwap(int *x, int *y);\n\nint main()\n&#123;\n    int x &#x3D; 2, y &#x3D; 3;\n    funcSwap(&amp;x, &amp;y); # &amp; 为引用 得到 x的内存地址\n    printf(&quot;x &#x3D; %d, y &#x3D; %d&quot;, x, y);\n\n    return 0;\n&#125;\n\nvoid funcSwap(int *x, int *y) # 此处是写如 * 为定义 地址变量（指针变量）\n&#123;\n    int s &#x3D; *x; #访问时，* 为解析地址的内存值 &#x3D;&#x3D; x\n    *x &#x3D; *y;\n    *y &#x3D; s;\n&#125;\n\n\n\n10.6.2 指针变量实现字符串复制#include &lt;stdio.h&gt;\n\nvoid funcCopyStr(char *originStr, char *flagStr);\n\nint main()\n&#123;\n    char str_Origin[100], str_Flag[100];\n\n    printf(&quot;Enter String To Copy :&quot;);\n    gets_s(str_Origin, 100);\n\n    funcCopyStr(str_Origin, str_Flag);\n    printf(&quot;%s\\n&quot;, str_Origin);\n    printf(&quot;%s\\n&quot;, str_Flag);\n\n    return 0;\n&#125;\n\nvoid funcCopyStr(char *originStr, char *flagStr)\n&#123;\n    for (; (*flagStr &#x3D; *originStr); originStr++, flagStr++);\n&#125;\n\n\n\n10.6.3 指针数组做函数参数#include &lt;stdio.h&gt;\n\nint main(int n, char *args[]) # mian函数内只能定义这样的形参 n &#x3D;&#x3D; 命令单词的个数；*args[] &#x3D;&#x3D; 保存命令参数的地址\n&#123;\n    printf(&quot;n&#x3D;%d&quot;, n);\n\n    for (int i &#x3D; 1; i &lt; n; ++i)\n    &#123;\n        printf(&quot;%s\\n&quot;, args[i]);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n10.6.4 指针函数\n函数也可以返回地址（指针函数）\n\n类型标识符 *函数名(参数表) {}\n#include &lt;stdio.h&gt;\n\nint *funcJudgeMaxNum(int *p_num1, int *p_num2);\n\nint main()\n&#123;\n    int num1, num2, *maxNum;\n\n    printf(&quot;Enter num1 and num2 :&quot;);\n    scanf_s(&quot;%d %d&quot;, &amp;num1, &amp;num2);\n\n    maxNum &#x3D; funcJudgeMaxNum(&amp;num1, &amp;num2);\n    printf(&quot;MaxNum &#x3D; %d&quot;, *maxNum);\n\n    return 0;\n&#125;\n\nint *funcJudgeMaxNum(int *p_num1, int *p_num2)\n&#123;\n    return *p_num1 &gt; *p_num2 ? p_num1 : p_num2;\n&#125;\n\n10.6.5 指针函数动态获取内存空间#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\n\nint main()\n&#123;\n    int numCount, *p_TestArr;\n\n    printf(&quot;Enter num count&#x3D;&quot;);\n    scanf_s(&quot;%d&quot;, &amp;numCount);\n\n    p_TestArr &#x3D; (int *)malloc(numCount * sizeof(int)); # 申请一个numCount*2字节的空间并转换成内存地址赋值个 p_TestArr\n\n    for (int i &#x3D; 0; i &lt; numCount; ++i)\n    &#123;\n        printf(&quot;TestArr[%d]&#x3D;&quot;, i);\n        scanf_s(&quot;%d&quot;, &amp;p_TestArr[i]);\n    &#125;\n\n    printf(&quot;This Arr&#x3D;&quot;);\n    for (int j &#x3D; 0; j &lt; numCount; ++j)\n    &#123;\n        printf(&quot;%4d&quot;, p_TestArr[j]);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n10.6.6 指向函数的指针变量\n概念：一个专门保存函数地址的指针变量\n\n定义：\nint (*f) (int1, int2); # 参数类型可以不带\nfloat (*p) ();\nfloat *(*f) ();\n\n#include &lt;stdio.h&gt;\n\nfloat func_AddNum(float num1, float num2);\nfloat func_SubNum(float num1, float num2);\nfloat func_MulNum(float num1, float num2);\nfloat func_DivNum(float num1, float num2);\n\nint main()\n&#123;\n    int num1, num2;\n    char op;\n    float (*p_Calculate)(float, float);\n\n    printf(&quot;Enter num1 num2:&quot;);\n    scanf_s(&quot;%d %c %d&quot;, &amp;num1, &amp;op, 1, &amp;num2);\n\n    switch (op)\n    &#123;\n        case &#39;+&#39;: p_Calculate &#x3D; func_AddNum;\n            break;\n        case &#39;-&#39;: p_Calculate &#x3D; func_SubNum;\n            break;\n        case &#39;*&#39;: p_Calculate &#x3D; func_MulNum;\n            break;\n        case &#39;&#x2F;&#39;: p_Calculate &#x3D; func_DivNum;\n            break;\n    &#125;\n    printf(&quot;CalculateResult Num &#x3D; %.2f&quot;, (*p_Calculate)(num1, num2));\n    getchar();\n\n    return 0;\n&#125;\n\nfloat func_AddNum(float num1, float num2)\n&#123;\n    return num1 + num2;\n&#125;\n\nfloat func_SubNum(float num1, float num2)\n&#123;\n    return num1 - num2;\n&#125;\n\nfloat func_MulNum(float num1, float num2)\n&#123;\n    return num1 * num2;\n&#125;\n\nfloat func_DivNum(float num1, float num2)\n&#123;\n    return num1 &#x2F; num2;\n&#125;\n\n11. 结构体11.1 结构体与变量11.1.1 结构体类型的定义\n是具有不同类型的有序集合\n\n结构体所占空间等于各个数据成员的所需空间之和\nstruct 结构体名\n&#123;\n    类型表示符 成员名1;\n    类型表示符 成员名2;\n    类型表示符 成员名3;\n&#125;\n\nstruct 定义结构体类型的关键字\n域名或成员名：命名规则和变量相同，同一结构体的同层成员不可同名\n\n11.1.2 结构体变量\n先定义结构体类型，再定义变量名\nstruct s_Student\n&#123;\n    int age;\n&#125;\n\nstruct s_Student stu1, stu2;\n\n\n\n定义结构体类型和定义变量名写在一起\nstruct s_Student\n&#123;\n    int age;\n&#125;stu1, stu2;\n\n\n\n若结构体类型名只用一次，则定义可省去\nstruct\n&#123;\n    int age;\n&#125;stu1, stu2;\n\n11.1.3 结构体类型嵌套\n定义：结构体成员可以是其他结构体类型，但不能在结构体中嵌套其他结构体\nstruct s_date\n&#123;\n    int year, month, day;\n&#125;\n\nstruct s_student\n&#123;\n    char name[20];\n    struct birthday;\n&#125;\n\nstruct s_student stu1, stu2;\n\n11.1.4 typedef 定义类型\n把一种数据类型名定义成与之等价的另一种类型名\ntypedef int fh_int;\nfh_int x, y; # &#x3D;&#x3D; int x, y;\n\ntypedef int * fh_pint;\nfh_pint x, y; # &#x3D;&#x3D; *x, *y;\n\n利用typedef可以将struct student 定义成一个较为简单的类型名\ntypedef struct student fh_stu;\nfh_stu stu1, stu2; # &#x3D;&#x3D; struct student stu1, stu2;\n\n11.1.5 结构体的引用\n结构体是聚合类型的数据，由多种不同的类型的数据成员组成\n\n结构体变量的输入输出，只能对其各个成员分别进行\n结构体成员的表达式：结构体变量名.成员名\n&quot;.&quot; 是成员（分量）运算符，具有最高优先级\n注：同类型的结构体变量之间，可以整体相互赋值\n\n#include &lt;stdio.h&gt;\n\nstruct s_student\n&#123;\n    char stu_name[20];\n    int stu_age;\n    float stu_percent;\n&#125;;\n\nint main()\n&#123;\n    struct s_student stu;\n\n    printf(&quot;Enter name:&quot;);\n    gets_s(stu.stu_name, 20);\n    printf(&quot;Enter age:&quot;);\n    scanf_s(&quot;%d&quot;, &amp;stu.stu_age);\n    printf(&quot;Enter percent:&quot;);\n    scanf_s(&quot;%f&quot;, &amp;stu.stu_percent);\n\n    printf(&quot;Student:\\n&quot;);\n    printf(&quot;\\t %s\\n \\t %d\\n \\t %.2f\\n&quot;, stu.stu_name, stu.stu_age, stu.stu_percent);\n\n    return 0;\n&#125;\n\n11.1.6 结构体定义时初始化#include &lt;stdio.h&gt;\n\nstruct s1_student\n&#123;\n    char stu_name[20];\n    int stu_age;\n    float stu_percent;\n&#125;;\n\nint main()\n&#123;\n    struct s1_student stu1 &#x3D; &#123;&quot;fang&quot;, 22, 99&#125;, stu2;\n    stu2 &#x3D; stu1;\n\n    printf(&quot;Student01:\\n&quot;);\n    printf(&quot;\\t %s\\n \\t %d\\n \\t %.2f\\n&quot;, stu1.stu_name, stu1.stu_age, stu1.stu_percent);\n    printf(&quot;Student02:\\n&quot;);\n    printf(&quot;\\t %s\\n \\t %d\\n \\t %.2f\\n&quot;, stu2.stu_name, stu2.stu_age, stu2.stu_percent);\n\n    return 0;\n&#125;\n\n\n\n\n\n11.2 结构体与数组11.2.1 结构体数组的定义struct s_student\n&#123;\n    char stu_name[20];\n    int stu_age;\n    float stu_percent;\n&#125;stu[2];\n\n\n\n11.2.2 结构体数组的初始化struct s_student\n&#123;\n    char stu_name[20];\n    int stu_age;\n    float stu_percent;\n&#125;stu[2] &#x3D; \n&#123;\n    &#123;&quot;fang&quot;, 22, 99&#125;,\n    &#123;&quot;fang&quot;, 22, 99&#125;,\n    &#123;&quot;fang&quot;, 22, 99&#125;\n&#125;;\n\n\n\n\n\n11.3 结构体与指针11.3.1 指向结构体变量的指针变量\n指针变量保存结构体变量地址\nstruct s_student\n&#123;\n    char stu_name[20];\n    int stu_age;\n    float stu_percent;\n&#125;stu, *p_stu;\n\np_stu &#x3D; &amp;stu;\n\nstu.stu_age &#x3D; 20; # &#x3D;&#x3D; (*p_stu).stu_age &#x3D; 20;\n\n# (*p_stu).stu_age 不可省去（）\n# (*p_stu).stu_age 书写麻烦，所以C语言提供了 “指向运算符” ：“-&gt;”, 优先级1级，左结合性；\n# 格式：指针变量-&gt;成员分量名称\n# (*p_stu).stu_age &#x3D;&#x3D; p_stu-&gt;stu_age\n\n#include &lt;stdio.h&gt;\n\nstruct s2_student\n&#123;\n    char stu_name[20];\n    int stu_age;\n    char sex;\n    float stu_percent;\n&#125;;\n\nint main()\n&#123;\n    struct s2_student stu1 &#x3D; &#123;&quot;fang&quot;, 22, &#39;T&#39;, 99&#125;, *p_stu2;\n    p_stu2 &#x3D; &amp;stu1;\n\n    printf(&quot;Student01:\\n&quot;);\n    printf(&quot;\\t %s\\n, \\t %d\\n, \\t %s\\n, \\t %.2f\\n&quot;,\n            stu1.stu_name, stu1.stu_age, (stu1.sex &#x3D;&#x3D; &#39;T&#39;) ? &quot;man&quot; : &quot;women&quot;, stu1.stu_percent);\n\n    printf(&quot;Student02:\\n&quot;);\n    printf(&quot;\\t %s\\n, \\t %d\\n, \\t %s\\n, \\t %.2f\\n&quot;,\n            p_stu2-&gt;stu_name, p_stu2-&gt;stu_age, (p_stu2-&gt;sex &#x3D;&#x3D; &#39;T&#39;) ? &quot;man&quot; : &quot;women&quot;, p_stu2-&gt;stu_percent);\n\n    return 0;\n&#125;\n\n11.3.2 指向结构体数组的指针变量#include &lt;stdio.h&gt;\n\nstruct s3_student\n&#123;\n    char stu_name[20];\n    int stu_age;\n    char sex;\n    float stu_grade;\n&#125;;\n\nint main()\n&#123;\n    struct s3_student stu[3] &#x3D; &#123;\n            &#123;&quot;fang01&quot;, 22, &#39;T&#39;, 97&#125;,\n            &#123;&quot;fang02&quot;, 23, &#39;F&#39;, 98&#125;,\n            &#123;&quot;fang03&quot;, 24, &#39;T&#39;, 99&#125;\n    &#125;;\n    struct s3_student *p_stu;\n\n    printf(&quot;%6s %5s %5s %7s\\n&quot;, &quot;Name&quot;, &quot;Age&quot;, &quot;Sex&quot;, &quot;Grade&quot;);\n    printf(&quot;----------------------------\\n&quot;);\n\n    for (p_stu &#x3D; stu; p_stu &lt; stu + 3; p_stu++)\n    &#123;\n        printf(&quot;%7s %4d %4c %8.2f\\n&quot;, p_stu-&gt;stu_name, p_stu-&gt;stu_age, p_stu-&gt;sex, p_stu-&gt;stu_grade);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n11.4 联合体(共用体)union xyz\n&#123;\n\tchar x;\n\tint y;\n\tdouble z;\n&#125; t;\n\n# t 的内存大小，以union中最大的为标准，也就是double，8个字节\n# 由于所有成员共用一个空间，在某一时刻，t变量只有其中一个分量的有效值\n\n\n\n11.5 枚举类型\n一种简单的数据类型，把所有的值列举出来，形成该值的取值范围，枚举型变量只能从中取出值，称为枚举元素或枚举常量\n\n枚举类型是一种基本数据类型，不是构造体类型，因此不能 分解成任何基本类型\nenum 枚举名 &#123;枚举值表&#125;;\n\nenum weekday &#123;sun, mou, tue, web, thu, fri, sat&#125;;\nenum weekday a, b, c; # a, b, c 是枚举类型weekday的变量\n\n# 也可以定义枚举类型时定义变量\nenum weekday &#123;sun, mou, tue, web, thu, fri, sat&#125; a, b, c;\n# 或\nenum &#123;sun, mou, tue, web, thu, fri, sat&#125; a, b, c;\n\n11.5.1 枚举类型的使用规定\n枚举值是常量，不是变量，不能被赋值\n枚举元素本身由系统定义了一个表示序号的值，序号值可以自定\n只能把枚举值赋值给枚举变量，不能把元素的序号数值赋值给枚举变量\n输出枚举值的格式字符是 “ %d ” ，对应序号，为整数\n\n12. 文件12.1 文件概念和分类12.1.1 文件概念\n\n\n\n\n\n\n\n12.1.2 文件简单分类\n\n\n\n\n\n\n\n12.2 文件基本操作12.2.1 定义文件指针\n\n\n\n\n\n\n\n12.2.2 文件的打开\n\n\n\n\n打开方式\n含义\n说明\n\n\n\nr\n只读\n为输入打开一个已存在的文本文件\n\n\nw\n只写\n为输出打开一个文本文件\n\n\na\n只追加\n为追加打开一个已存在的文本文件\n\n\nrb\n只读\n为输入打开一个已存在的二进制文件\n\n\nwb\n只写\n为输出打开一个二进制文件\n\n\nab\n只追加\n为输入打开一个二进制文件\n\n\nr+\n读写\n为既读又写打开一个已存在的文本文件\n\n\nw+\n读写\n为既读又写新建一个文本文件\n\n\na+\n读写\n为既读又写打开一个已存在的文本文件，文件指针移至为念末尾\n\n\nrb+\n读写\n为既读又写打开一个已存在的二进制文件\n\n\nwb+\n读写\n为既读又写新建一个二进制文件\n\n\nab+\n读写\n为读&#x2F;写打开一个二进制文件进行追加\n\n\n12.2.3 文件的操作\n\n\n\n\n\n\n\n12.2.4 文件的关闭\n\n\n\n\n\n12.2.5 文件操作示例\n在C盘目录下新建一个 “ fh.txt “ 的文件，用来保存键盘输入的字符，直到按回车键为止\n字符输出函数（fputc）\nfputc函数使用格式：fputc(ch, fp_fh);\n将 ch 的值输出到 fp_fh 所指向的文件，并返回该字符，输出失败返回EOF\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n    FILE *fp_fh;\n    errno_t err_fh; # 新版C语言的要求，老版本的省去\n    char str_fh;\n\n    err_fh &#x3D; fopen_s(&amp;fp_fh,&quot;C:\\\\Users\\\\FHang\\\\Desktop\\\\fh.txt&quot;, &quot;w&quot;); # 老版本省去\n\n    if (err_fh !&#x3D; 0) # 老版本改为 if ((fp_fh &#x3D; fopen(&quot;C:\\\\Users\\\\FHang\\\\Desktop\\\\fh.txt&quot;, &quot;w&quot;)) &#x3D;&#x3D; NULL) \n    &#123;\n        printf(&quot;Can not find this file\\n&quot;);\n        exit(0);\n    &#125;\n\n    printf(&quot;Please input a string. Press enter key to end\\n&quot;);\n\n    while ((str_fh &#x3D; getchar()) !&#x3D; &#39;\\n&#39;)\n    &#123;\n        fputc(str_fh, fp_fh);\n    &#125;\n\n    fclose(fp_fh);\n    printf(&quot;Create file fh.txt success.&quot;);\n\n    return 0;\n&#125;\n\n13. 链表13.1 链表的概念13.1.1 概念链表的每个节点都有两个部分：\n\n数据区和指针区。前者用来存储数据，后者用来存储指向下一个节点的指针；\n我们使用 malloc() 函数来为每个节点分配内存；\n节点的头部只含有指向第一个节点的指针;\n存储在栈区的 head 指向了存储在堆区的节点;\n堆区的节点又互相连接，形成链状的结构;\n最后一个节点的指针区被赋值为 NULL，标明了链表的结束。\n\n13.1.2 数组相关\n数组的缺点：\n正常情况下，创建的数组为固定大小的静态数组，当数组的数据内容出现增删，需要手动修改大小；\n如果一次性创建足够大的数组，会浪费内存空间；\n动态数组的创建（不会），麻烦；\n数组的内存空间是连续的，当需要添加或删除某一个元素时，其新元素之后的所有数组元素，需要逐一遍历更换内存地址，性能消耗大；\n\n\n数组的优点：\n数组的内存空间是连续的，直接通过数组小标查找数组元素，很高效；\n\n\n\n13.1.3 链表相关\n链表优点：\n链表的内存空间是非连续的，它们通过链表中的指针域，存储了下一个的链表的首地址，以此达到数据表相连；\n插入或删除指定链表时，只需要将新链表，以及前后链表的首地址和指针域进行相关改动即可，不会影响到所有的链表；\n只需要找到第一个链表节点，就能顺着指针域找到所有的链表；\n\n\n链表缺点：\n查找指定链表节点，需要从第一个节点顺着指针域一个个找下去，消耗性能大，远不及数组直接通过下标定位；\n当在整个链表的第一节点前插入新节点，原来找到的链表首节点，就不再是首节点，需要重新找；\n链表的每个节点都需要一块内存空间存储下一个节点的首地址；\n\n\n\n13.1.4 链表分类\n内存类型区分：\n静态链表\n动态链表：使用malloc()\n\n\n功能结构区分：\n单向链表\n双向链表\n循环链表\n单向循环链表\n双向循环链表\n\n\n\n13.2 静态链表13.2.1 静态链表的结构struct Node\n&#123;\n    int data; &#x2F;&#x2F;数据域\n    struct Node* next; &#x2F;&#x2F;指针域，用于存储下一个节点的首地址\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 初始化创建静态链表节点\n    struct Node Node1 &#x3D; &#123;1, NULL&#125;;\n    struct Node Node2 &#x3D; &#123;2, NULL&#125;;\n    struct Node Node3 &#x3D; &#123;3, NULL&#125;;\n\n    &#x2F;&#x2F; 将Node2的首地址存入Node1的next指针地址变量内\n    Node1.next &#x3D; &amp;Node2;\n    Node2.next &#x3D; &amp;Node3;\n    \n    return 0;\n&#125;\n\n\n\n13.2.2 遍历打印静态链表#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n&#123;\n    int data; &#x2F;&#x2F;数据域\n    struct Node* next; &#x2F;&#x2F;指针域，用于存储下一个节点的首地址\n&#125;;\n\nvoid printList()\n&#123;\n    struct Node node1 &#x3D; &#123;1, NULL&#125;;\n    struct Node node2 &#x3D; &#123;2, NULL&#125;;\n    struct Node node3 &#x3D; &#123;3, NULL&#125;;\n\n    &#x2F;&#x2F; 将Node2的首地址存入Node1的next指针地址变量内\n    node1.next &#x3D; &amp;node2;\n    node2.next &#x3D; &amp;node3;\n\n    &#x2F;&#x2F; 遍历链表\n    &#x2F;&#x2F; 先定义一个辅助指针变量\n    struct Node *pCurrent &#x3D; &amp;node1;\n\n    while (pCurrent !&#x3D; NULL)\n    &#123;\n        &#x2F;&#x2F; 将这个指针指向的内存空间中的节点元素打印\n        printf(&quot;%d\\n&quot;, pCurrent-&gt;data);\n        &#x2F;&#x2F; 打印后，将节点的指针域内存放的下一个节点首地址，赋值给pCurrent，从而找到下一个链表节点\n        pCurrent &#x3D; pCurrent-&gt;next;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    printList();\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n\n\n13.3 动态链表(模块化)&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;3&#x2F;29.\n&#x2F;&#x2F;\n\n&#x2F;*\n * 动态创建链表\n *&#x2F;\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n&#123;\n    int data; &#x2F;&#x2F;数据域\n    struct Node *next; &#x2F;&#x2F;指针域\n&#125;;\n\n&#x2F;&#x2F; 创建链表\nstruct Node *createList()\n&#123;\n    &#x2F;&#x2F; headNode成为结构体变量\n    struct Node *headNode &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    &#x2F;&#x2F; 变量使用前，需要初始化\n    &#x2F;&#x2F; headNode-&gt;data &#x3D; 1;\n    headNode-&gt;next &#x3D; NULL;\n\n    return headNode;\n&#125;\n\n&#x2F;&#x2F; 创建节点\nstruct Node *createNode(int data)\n&#123;\n    struct Node *newNode &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    newNode-&gt;data &#x3D; data;\n    newNode-&gt;next &#x3D; NULL;\n\n    return newNode;\n&#125;\n\n&#x2F;&#x2F; 插入节点(表头法插入)\nvoid insertNodeByHead(struct Node *headNode, int data)\n&#123;\n    &#x2F;&#x2F; 创建新的插入节点\n    struct Node *newNode &#x3D; createNode(data);\n    newNode-&gt;next &#x3D; headNode-&gt;next;\n    headNode-&gt;next &#x3D; newNode;\n&#125;\n\n&#x2F;&#x2F; 删除指定链表\nvoid deleteNode(struct Node *headNode, int posData)\n&#123;\n    struct Node *posNode &#x3D; headNode-&gt;next;\n    struct Node *posNodeFront &#x3D; headNode;\n\n    if (posNode &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;Can&#39;t Delete Null Linklist !\\n&quot;);\n    &#125;\n    else\n    &#123;\n        while (posNode-&gt;data !&#x3D; posData)\n        &#123;\n            posNodeFront &#x3D; posNode;\n            posNode &#x3D; posNodeFront-&gt;next;\n\n            if (posNode &#x3D;&#x3D; NULL)\n            &#123;\n                printf(&quot;Can&#39;t Find This Linklist !\\n&quot;);\n                return;\n            &#125;\n        &#125;\n\n        posNodeFront-&gt;next &#x3D; posNode-&gt;next;\n        free(posNode);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 打印\nvoid printList(struct Node *headNode)\n&#123;\n    struct Node *pMove &#x3D; headNode-&gt;next;\n    while (pMove !&#x3D; NULL)\n    &#123;\n        printf(&quot;Data&#x3D;%d\\n&quot;, pMove-&gt;data);\n        pMove &#x3D; pMove-&gt;next;\n    &#125;\n\n    printf(&quot;\\n&quot;);\n&#125;\n\nint main()\n&#123;\n    struct Node *list &#x3D; createList();\n    insertNodeByHead(list, 1);\n    insertNodeByHead(list, 2);\n    insertNodeByHead(list, 3);\n    printList(list);\n\n    deleteNode(list, 2);\n    printList(list);\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n\n\n\n\n\n\n例子1.  求百十个位的和#include &lt;stdio.h&gt;\n\n#define Debug printf\n#define Enter scanf_s\n\nint main()\n&#123;\n    int enterNum, sumNum;\n    int b, s, g;\n\n    Debug(&quot;Enter Num : &quot;);\n    Enter(&quot;%d&quot;, &amp;enterNum);\n\n    b &#x3D; enterNum &#x2F; 100;\n    s &#x3D; enterNum &#x2F; 10 % 10;\n    g &#x3D; enterNum % 10;\n    sumNum &#x3D; b + s + g;\n\n    Debug(&quot;Sum&#x3D;%d&quot;, sumNum);\n&#125;\n\n\n\n2. 求200-300之间素数和#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int n, i;\n    int sum &#x3D; 0;\n\n    for (n &#x3D; 200; n &lt; 300; ++n)\n    &#123;\n        for (i &#x3D; 2; i &lt; n &#x2F; 2; ++i)\n        &#123;\n            if (n % i &#x3D;&#x3D; 0)\n            &#123;\n                break;\n            &#125;\n        &#125;\n        if (i &gt;&#x3D; n &#x2F; 2)\n        &#123;\n            sum +&#x3D; n;\n            printf(&quot;%4d&quot;, n);\n        &#125;\n    &#125;\n    printf(&quot;\\n sum &#x3D; %d&quot;, sum);\n\n    return 0;\n&#125;\n\n\n\n3. 斐波那契#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int f1 &#x3D; 1, f2 &#x3D; 1, f3;\n\n    printf(&quot;1&#x3D;%d\\n2&#x3D;%d\\n&quot;, f1, f2);\n\n    for (int k &#x3D; 3; k &lt;&#x3D; 20; ++k)\n    &#123;\n        f3 &#x3D; f1 + f2;\n        printf(&quot;%d&#x3D;%d\\n&quot;, k, f3);\n        f1 &#x3D; f2;\n        f2 &#x3D; f3;\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n4. 递增算法\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int sum &#x3D; 1;\n\n    for (int i &#x3D; 9; i &gt;&#x3D; 1; i--)\n    &#123;\n        sum &#x3D; (sum + 1) * 2;\n        if (i &#x3D;&#x3D; 1)\n        &#123;\n            printf(&quot;1 day has %d&quot;, sum);\n            break;\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n5. 100-999之间水仙花数#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int sum, bw, sw, gw;\n\n    for (int i &#x3D; 100; i &lt;&#x3D; 999; ++i)\n    &#123;\n        bw &#x3D; i &#x2F; 100;\n        sw &#x3D; i &#x2F; 10 % 10;\n        gw &#x3D; i % 10;\n        sum &#x3D; bw * bw * bw + sw * sw * sw + gw * gw * gw;\n\n        if (sum &#x3D;&#x3D; i)\n        &#123;\n            printf(&quot;%d\\t&quot;, sum);\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n6. 求 1!+2!+3!+…+10!#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    long sum &#x3D; 0, fact &#x3D; 1;\n\n    for (int n &#x3D; 1; n &lt;&#x3D; 10 ; ++n)\n    &#123;\n        fact *&#x3D; n;\n        sum +&#x3D; fact;\n    &#125;\n    printf(&quot;sum &#x3D; %ld&quot;, sum);\n\n    return 0;\n&#125;\n\n\n\n\n\n7. 求多项式的值\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    float x &#x3D; 0;\n    float sum &#x3D; 1, term &#x3D; 1;\n\n    printf(&quot;Enter X Num : &quot;);\n    scanf_s(&quot;%f&quot;, &amp;x);\n\n    for (int n &#x3D; 1; n &lt;&#x3D; 20 ; ++n)\n    &#123;\n        term &#x3D; (-term * x) &#x2F; x;\n        sum +&#x3D; term;\n    &#125;\n\n    printf(&quot;Calculate Num is %.2f\\n&quot;, sum);\n\n    return 0;\n&#125;\n\n\n\n\n\n8. 将整形一维数组的内容颠倒顺序#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int sum &#x3D; 0;\n    int arr[10] &#x3D; &#123;11, 22, 33, 44, 55, 66, 77, 88, 99, 100&#125;;\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        printf(&quot;%4d&quot;, arr[i]);\n    &#125;\n\n    for (int i &#x3D; 0, j &#x3D; 9; i &lt; j; ++i, --j)\n    &#123;\n        sum &#x3D; arr[i];\n        arr[i] &#x3D; arr[j];\n        arr[j] &#x3D; sum;\n    &#125;\n\n    printf(&quot;\\n&quot;);\n\n    for (int k &#x3D; 0; k &lt; 10; ++k)\n    &#123;\n        printf(&quot;%4d&quot;, arr[k]);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n9. 将3行4列的数组值转置到4行3列#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int arrA[3][4] &#x3D; &#123;&#123;1, 2,  3,  4&#125;,\n                     &#123;5, 6,  7,  8&#125;,\n                     &#123;9, 10, 11, 12&#125;&#125;;\n\n    static int arrB[4][3];\n\n    printf(&quot;Before Transpose:\\n&quot;);\n    for (int i &#x3D; 0; i &lt; 3; ++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 4; ++j)\n        &#123;\n            printf(&quot;%4d&quot;, arrA[i][j]);\n            arrB[j][i] &#x3D; arrA[i][j];\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n    \n    printf(&quot;Later Transpose:\\n&quot;);\n    for (int i &#x3D; 0; i &lt; 4; ++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 3; ++j)\n        &#123;\n            printf(&quot;%4d&quot;, arrB[i][j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n10. 将字符串1内容赋值到字符串2中#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    char s2[50];\n\n    char s1[50] &#x3D; &quot;abcdefghjklmn&quot;;\n\n    for (int i &#x3D; 0; (s2[i] &#x3D; s1[i]); ++i);\n\n    puts(s2);\n\n    return 0;\n&#125;\n\n\n\n\n\n11. 打印杨辉三角前10行#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int arr[10][10];\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt;&#x3D; i; ++j)\n        &#123;\n            if (j&#x3D;&#x3D;0||i&#x3D;&#x3D;j)\n            &#123;\n                arr[i][j] &#x3D; 1;\n            &#125;\n            else\n            &#123;\n                arr[i][j] &#x3D; arr[i-1][j-1] + arr[i-1][j];\n            &#125;\n        &#125;\n    &#125;\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt;&#x3D; i; ++j)\n        &#123;\n            printf(&quot;%5d&quot;, arr[i][j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n\n\n12. 判断字符串或数字是否为回文#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\nint main()\n&#123;\n    char enterStr[45];\n    int i, j;\n\n    gets(enterStr);\n\n    for (i &#x3D; 0, j &#x3D; strlen(enterStr) - 1; i &lt; j &amp;&amp; (enterStr[i] &#x3D;&#x3D; enterStr[j]); ++i, --j);\n\n    if (i &lt; j)\n    &#123;\n        printf(&quot;No&quot;);\n    &#125;\n    else\n    &#123;\n        printf(&quot;Yes&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int x, y &#x3D; 0, z;\n\n    printf(&quot;Enter:&quot;);\n    scanf_s(&quot;%d&quot;, &amp;z);\n    x &#x3D; z;\n\n    while (x !&#x3D; 0)\n    &#123;\n        y &#x3D; (10*y) + (x%10);\n        x &#x3D; x&#x2F;10;\n&#x2F;&#x2F;        printf(&quot;x&#x3D;%d\\n&quot;, x);\n&#x2F;&#x2F;        printf(&quot;y&#x3D;%d\\n&quot;, y);\n    &#125;\n\n    if (z &#x3D;&#x3D; y)\n    &#123;\n        printf(&quot;Yes&quot;);\n    &#125;\n    else\n    &#123;\n        printf(&quot;No&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n13. 用递归算法计算n！#include &lt;stdio.h&gt;\n\ndouble funcFact(int n);\n\nint main()\n&#123;\n    int n &#x3D; 0;\n    double factNum;\n    printf(&quot;Enter Num :&quot;);\n    scanf_s(&quot;%d&quot;, &amp;n);\n    factNum &#x3D; funcFact(n);\n    printf(&quot;Fact &#x3D; %.0lf&quot;, factNum);\n\n    return 0;\n&#125;\n\ndouble funcFact(int n)\n&#123;\n    double fact;\n    if (n &#x3D;&#x3D; 1)\n    &#123;\n        fact &#x3D; 1;\n    &#125;\n    else\n    &#123;\n        fact &#x3D; n * funcFact(n - 1);\n    &#125;\n\n    return fact;\n    &#x2F;&#x2F; 三目运算来表达\n    &#x2F;&#x2F; return n &#x3D;&#x3D; 1 ? 1 : n * funcFact(n - 1);\n&#125;\n\n\n\n14. 用递归计算1+2+…+n#include &lt;stdio.h&gt;\n\nint funcSum(int n);\n\nint main()\n&#123;\n    int enterNum;\n    printf(&quot;Enter Num :&quot;);\n    scanf_s(&quot;%d&quot;, &amp;enterNum);\n    printf(&quot;Sum &#x3D; %d&quot;, funcSum(enterNum));\n\n    return 0;\n&#125;\n\nint funcSum(int n)\n&#123;\n    return n &#x3D;&#x3D; 1 ? 1 : n + funcSum(n - 1);\n&#125;\n\n\n\n15. 用循环和递归计算任意整数个位数之和\n循环\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int n;\n    int sum &#x3D; 0;\n\n    printf(&quot;Enter Num :&quot;);\n    scanf_s(&quot;%d&quot;, &amp;n);\n    while (n)\n    &#123;\n        sum +&#x3D; n % 10;\n        n &#x3D; n &#x2F; 10;\n    &#125;\n    printf(&quot;Sum &#x3D; %d&quot;, sum);\n\n    return 0;\n&#125;\n\n\n递归\n\n#include &lt;stdio.h&gt;\n\nint funcSum(int n);\n\nint main()\n&#123;\n    int n;\n    int sum;\n\n    printf(&quot;Enter Num :&quot;);\n    scanf_s(&quot;%d&quot;, &amp;n);\n    sum &#x3D; funcSum(n);\n    printf(&quot;Sum &#x3D; %d&quot;, sum);\n\n    return 0;\n&#125;\n\nint funcSum(int n)\n&#123;\n    return n &lt; 10 ? n : (n % 10) + funcSum(n &#x2F; 10);\n&#125;\n\n\n\n16. 通过函数将数组内元素加10#include &lt;stdio.h&gt;\n\nvoid funcAdd(int *p_arr, int eleCount, int addNum);\n\nint main()\n&#123;\n    int arr[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;\n    int eleCount;\n    eleCount &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n    funcAdd(arr, eleCount, 10);\n    for (int i &#x3D; 0; i &lt; eleCount; ++i)\n    &#123;\n        printf(&quot;%3d&quot;, arr[i]);\n    &#125;\n\n    return 0;\n&#125;\n\nvoid funcAdd(int *p_arr, int eleCount, int addNum)\n&#123;\n    for (int i &#x3D; 0; i &lt; eleCount; ++i)\n    &#123;\n        p_arr[i] +&#x3D; addNum;\n    &#125;\n&#125;\n\n\n\n17. 指针变量为形参，求数组元素和平均值#include &lt;stdio.h&gt;\n\nfloat funcCalculateAverage(const int *p_arr, int eleCount);\n\nint main()\n&#123;\n    int arr[6] &#x3D; &#123;10, 20, 30, 40, 50, 11&#125;;\n    int eleCount;\n    eleCount &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n    printf(&quot;arr[%d] average &#x3D; %.2f&quot;, eleCount, funcCalculateAverage(arr, eleCount));\n\n    return 0;\n&#125;\n\nfloat funcCalculateAverage(const int *p_arr, int eleCount)\n&#123;\n    int sum &#x3D; 0;\n    float average;\n    for (int i &#x3D; 0; i &lt; eleCount; ++i)\n    &#123;\n        sum +&#x3D; p_arr[i];\n    &#125;\n    average &#x3D; (float)sum &#x2F; (float)eleCount;\n\n    return average;\n&#125;\n\n\n\n18. 数组元素指针访问数组#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int *p;\n    int arr[3][4] &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;\n\n# 两种写法\n&#x2F;&#x2F;    for (p &#x3D; arr[0]; p &lt; arr[0] + 12; p++)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        if ((p - arr[0]) % 4 &#x3D;&#x3D; 0)\n&#x2F;&#x2F;        &#123;\n&#x2F;&#x2F;            printf(&quot;\\n&quot;);\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;        printf(&quot;%3d&quot;, *p);\n&#x2F;&#x2F;    &#125;\n\n    for (p &#x3D; *(arr + 0); p &lt; *(arr + 0) + 12; p++)\n    &#123;\n        if ((p - *(arr + 0)) % 4 &#x3D;&#x3D; 0)\n        &#123;\n            printf(&quot;\\n&quot;);\n        &#125;\n        printf(&quot;%3d&quot;, *p);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n19. 一维数组访问二维数组#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int (*p)[4];\n    int arr[3][4] &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;\n    p &#x3D; arr;\n\n    for (int i &#x3D; 0; i &lt; 3; ++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 4; ++j)\n        &#123;\n            printf(&quot;%3d&quot;, p[i][j]);\n&#x2F;&#x2F;            printf(&quot;%3d&quot;, *(*(p + i) + j));\n&#x2F;&#x2F;            printf(&quot;%3d&quot;, *(*(arr + i) + j));\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int (*p)[4], arr[3][4] &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;\n    for (p &#x3D; arr; p &lt; arr + 3; p++)\n    &#123;\n        for (int i &#x3D; 0; i &lt; 4; ++i)\n        &#123;\n            printf(&quot;%3d&quot;, *(*p + i));\n&#x2F;&#x2F;            printf(&quot;%3d&quot;, *(*(arr + x) + i)); -&gt; x 的取值为 0， 1， 2\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n\n    return 0;\n&#125;\n\n\n\n20. 指针数组访问另一个一维数组#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int *p_Arr[5]; # &#x3D;&#x3D; p_Arr0, p_Arr1, ... p_Arr4\n    int tag_Arr[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        p_Arr[i] &#x3D; tag_Arr + i;\n    &#125;\n\n    for (int j &#x3D; 0; j &lt; 5; ++j)\n    &#123;\n        printf(&quot;%3d&quot;, *p_Arr[j]);\n    &#125;\n    printf(&quot;\\n&quot;);\n\n    return 0;\n&#125;\n\n\n\n21. 指针数组的应用#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    char *p_StrArr[2] &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;\n\n    for (int i &#x3D; 0; i &lt; 2; ++i)\n    &#123;\n        printf(&quot;%s\\n&quot;, p_StrArr[i]);\n    &#125;\n\n    return 0;\n&#125;\n\n","slug":"5.C语言基础_01","date":"2022-10-06T07:28:25.944Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"e341529351da1e239445a65d65dc3c4f","title":"不同虚拟机的配置方式","content":"不同虚拟机的配置方式虚拟机软件的选择：VirtualBox6.0及以上；VmwareWorkstation\nVirtualBox的配置方法：1. controller的安装过程：1.我们准备好centos7和iaas2.2的iso文件 \n2.在一个磁盘空间充足的磁盘下新建两个文件夹VT-controller; VT-compute, 之后的两个节点分别安装在这两个文件夹下 \n3.打开VirtualBox–新建–名称：Controller\n文件夹：选择之前新建的VT-controller文件夹所在地址\n类型：Linux\n版本：Other Linux（64bit）\n内存：4096MB\n虚拟硬盘：现在创建虚拟硬盘\n4.文件位置：默认\n5.文件大小：40GB\n6.虚拟硬盘类型：VDI\n7.存储在物理硬盘上：动态分配\n此时controller的模板创建好了\n1.管理–主机网络管理器–创建（创建两个虚拟网卡）\n第一块网卡（手动配置）– IPV4：192.168.100.1（内网）\n 子网掩码：255.255.255.0\nDHCP服务器关了\n第二块网卡（手动配置）– IPV4：192.168.200.1（外网）\n  子网掩码：255.255.255.0\n同样关掉DHCP服务\n2.主页面中–设置–系统（主板）–启动顺序：勾上网络，选中光驱，点边上的”向上“箭头移动到最上方\n（处理器）–处理器数量：4\n网络（网卡1）–启用网络连接–界面名称：第一网卡\n  方式：仅主机–高级–混杂：全部允许\n （网卡2）–界面名称为第二款网卡，其它配置同网卡1相同–OK\n3.在主页面中，存储–第二IDE控制器主通道（点击选择centos7.ios）\n4.启动（controller节点已经配置好了）\n2. controller节点的安装过程在centos安装之前，可以在安装界面按“Tab”键\n\n\n \n\n在原有的内容后面–空格–输入：net.ifnames&#x3D;0 biosdevname&#x3D;0\n可以禁用网卡命名规则，是的两块网卡（内网和外网）分别为eth0和eth1，方便后面使用，不过后面的内容里，要自觉将ifcfg-enp0s3和ifcfg-enp0s8换成ifcfg-eth0和ifcfg-eth1，即可\n1.Install Centos7\n2.Continue（默认英文，千万别选中文，搭建过程中会乱码和报错，之后也不会安装图形化界面，因为没必要）–SYSTEM选项中的（installtion  destination）–other storage options选项中：选中I will configure partioning\n3.Done–Click here to create them automatically（若有&#x2F;home目录，选中点击下面的‘—’号，可以删除，因为不需要）\n4.Done–Accept Changes\n5.Begin Installation\n6.此时在安装过程中可以设置Root用户的密码，密码：000000，因为方便；其它的不管\n7.reboot完成controller的安装\n3. compute的安装过程：1.新建–名称：Compute\n文件夹：选择之前新建的VT-controller文件夹所在地址\n类型：Linux\n版本：Other Linux（64bit）\n内存：2048MB\n虚拟硬盘：现在创建虚拟硬盘\n4.文件位置：默认\n5.文件大小：40GB\n6.虚拟硬盘类型：VDI\n7.存储在物理硬盘上：动态分配\n此时compute的模板创建好了\n1.主页面中–设置–系统（主板）–启动顺序：勾上网络，选中光驱，点边上的”向上“箭头移动到最上方\n（处理器）–处理器数量：2\n网络（网卡1）–启用网络连接–界面名称：第一网卡\n  方式：仅主机–高级–混杂：全部允许\n （网卡2）–界面名称为第二款网卡，其它配置同网卡1相同–OK\n2.在主页面中，存储–第二IDE控制器主通道（点击选择centos7.ios）\n3.启动（compute节点已经配置好了）\n4. controller节点的安装过程就照着上面controller节点的安装过程一样的步骤来\n至此两个节点都安装完毕！！！\n接着要对compute节点再照护一下，先将compute节点关机再操作\ncompute节点的磁盘分区（parted和fdisk两种方法，推荐用parted）\n1.在主页面中–（选中）compute节点–设置–存储–（存储介质：控制器IDE）最右边有个鼠标移上去会显示“添加虚拟硬盘”并点击–创建新的虚拟盘–文件大小：20GB–虚拟硬盘文件类型VDI–创建–OK\n2.开启compute节点（要对新添加的虚拟硬盘进行配置）\n5. 在compute中：（parted）\\# fdisk -l\n\n可以看到Disk &#x2F;dev&#x2F;sdb\n\n\\# parted &#x2F;dev&#x2F;sdb \n\n\\#p\n\n\\#h\n\n4.可以看到如图的内容： \n\n\n\n\n6. 我们需要分别进行mklabel和mkpart\\#mklable gpt\n\n\\#mkpart cinder\n\n\\#xfs\n\n\\#0\n\n\\#8G\n\n\\#I\n\n\\#p\n\n6.此时可以看到已经分好了一个8G的分区cinder\n \n\n7.同理\n\n\n\\#q（退出）\n\n此时swift的盘也分好了\ncinder和swift的盘分别对应这sdb1和sdb2，后面的IaaS搭建里的openrc配置里会用上\n7. fdisk的分区方法：sdb1的创建方式：  \n\\#fdisk &#x2F;dev&#x2F;sdb \n\n\\#m\n\n\n\n可以看到帮助文档\n\n\n其中n为添加一个新的分区，w为分好后保存，退出（如果没有w，直接退出，就等于没分区）\n前几个都是默认即可，回车\n一直到 Last sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +8G\n+size{K,M,G} 其中，+size是你要划分的大小数值，{K,M,G}里的三个为可选的单位，我们这里仅为演示所以我是+8G\n#w （保存，退出）\n此时一个分区创建好了（sdb1）\nsdb2的创建方式如下：\n\n\n\\#fdisk -l\n\n可以看到两个都创建好了 \n这里关于compute节点的磁盘分区就到这了！\n接着在compute节点中：\n\\#parted &#x2F;dev&#x2F;sd*\n\n（可以看到其中有sda, sda1, sda2, sdb, sdb1, sdc, sdc1；其中sdb1,sdb2分别为后面要配置的cinder和swift两个云盘）\n\n以上就是VirtualBox的配置方法\n接下来就是VmwareWorkstation的配置方式\n首先在主页面的上菜单栏中–编辑–虚拟网络编辑器–(VmwareWorkstation自己默认有一个VMnet0)–添加网络（添加两个，分别为VM net1，VMnet2）–选中VMnet1–在VMnet信息中选中‘仅主机模式’–选中‘将主机虚拟适配器连接到此网络’，取消使用本地DHCP–子网IP：192.168.100.0–子网掩码：255.255.255.0（内网）\n选中VMnet2–在VMnet信息中选中‘NAT模式’–选中‘将主机虚拟适配器连接到此网络’，取消使用本地DHCP–子网IP：192.168.200.0–子网掩码：255.255.255.0（外网）\n网卡配置好了，接下来是两个控制节点\n8. controller的安装过程：1.我们准备好centos7和iaas2.2的iso文件 \n2.在一个磁盘空间充足的磁盘下新建两个文件夹VM-controller; VM-compute, 之后的两个节点分别安装在这两个文件夹下\n3.在主页面中–创建新的虚拟机–典型–下一步–稍后安装操作系统–下一步：客户机操作系统：Linux–下一步\n 版本：centos7 64位\n4.虚拟机名称：Controller\n 位置：你所创建的VM-controller文件夹的地址–下一步\n 最大磁盘大小：40GB\n 选中：将虚拟磁盘拆分成多个文件–下一步–自定义硬件：内存：4GB\n  处理器数量和内核都选：2；虚拟化引擎：选中‘虚拟化 InterVT-x&#x2F;EPT或AMD-V&#x2F;RVI ’\n  选中‘新CD&#x2F;DVD（IDE）’：添加一个新的‘新CD&#x2F;DVD（IDE）’\n  （两个IDE的设备状态选中启动时连接，连接选中使用ISO映像文件）\n  浏览：centos7.iso文件的地址，第二个IDE选中iaas2.2.iso文件地址\n   选中‘网络适配器’：添加一个新的‘网络适配器2’\n（两个网络适配器，第一个：仅主机模式；第二个：默认NAT模式）–关闭–完成\n5.鼠标移到创建好的controller节点上–右击–管理–克隆–下一步–下一步–创建方法：链接克隆–下一步–虚拟机名称：Compute\n位置–浏览：VM-compute文件夹位置\n–完成–关闭\n6.编辑虚拟机–内存：2\n处理器数量和内核都选：1；虚拟化引擎：选中‘虚拟化 InterVT-x&#x2F;EPT或AMD-V&#x2F;RVI ’\n（其它不用动）\n两个节点的配置完成，安装过程和VirtualBox的安装过程一样\n接下来就是VmwareWorkstation中compute节点的添加磁盘了\n选中compute节点–编辑虚拟机设置–硬盘–添加（硬盘，添加两个）–下一步–默认推荐–创建新虚拟硬盘–磁盘大小：20GB–将虚拟硬盘拆分成多个文件–下一步–完成\n（第二块硬盘的文件名不可与第一块硬盘文件名相同，随别改一个）\n现在启动compute节点，接下来的步骤和VirtualBox的磁盘配置方法相同\n至此，两个不同虚拟机软件对两个不同节点的配置和磁盘划分的方法介绍完毕！！！\n请看下一篇secureCRTP连接虚拟机！！！\n","slug":"3.不同虚拟机的配置方式_01","date":"2022-10-06T07:28:25.941Z","categories_index":"云计算","tags_index":"IaaS","author_index":"FangH"},{"id":"60a02aae4ddcc163be15d5053e1b9c2a","title":"secureCRT上传镜像","content":"secureCRT上传镜像本文为如何在secureCRT中往虚拟机中上传镜像文件\n打开secureCRT后\n1.\n\n将鼠标移到192.168.100.10的标签，右击–打开secureFX\n2.\n\n选中本地里的XianDian-Iaas-v2.2.iso和CentOS-7-x86_64-DVD-1511.iso文件，右击–上传（直接确定默认的选项即可）\n本人这里已经上传好了（上传到root目录下，如上图所示）\n注：此处还可以额外从本地上传如上图中的  cirros-0.3.4-x86_64-disk.img ,因为XianDian和CentOS的镜像较大，后期建立云主机电脑内存不够可能会创建失败，该额外提供的镜像非常小，后期创建云主机时如果电脑内存足够大，可以用CentOS的镜像，如果不够，就用这个小镜像\n至此，secureCRT上传镜像文件的方法介绍完了，搭建IAAS时会用上这个！！！\n请看下一篇IAAS搭建！！！\n","slug":"3.secureCRT上传镜像_03","date":"2022-10-06T07:28:25.939Z","categories_index":"云计算","tags_index":"IaaS","author_index":"FangH"},{"id":"356a9c77ef7da7d0d7efea2dfccf8eb9","title":"secureCRT连接虚拟机","content":"secureCRT连接虚拟机本文介绍使用secureCRTP连接虚拟机，因为secureCRTP使用方便，观感也很好，还可以定制字体和字号，支持复制粘贴功能和上传镜像功能，这些功能在后面IAAS搭建里十分好用\n虚拟机要想能通过CRT连接，就必须要将虚拟机的网络环境配置好，也是IAAS搭建的基本要求条件\ncentos7的网络配置文件在 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;下\ncontroller和compute两个节点的配置方法基本相同，首先介绍controller的配置方式\n[root@controller ~]#\ncontroller的网络配置\n\n\n1.#cd  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;\n（将工作台切换到该目录下）\n\n\n\n2.#ls  ifcfg-enp*\n（查看所有以ifcfg-enp*  开头的文件）\n\n\n此时应该可以看到两个文件，如果不是两个，说明你之前的虚拟机网卡配置错了\n以本人的为例，出现了ifcfg-enp0s3和ifcfg-enp0s8两个文件，也就是两个网卡配置文件\n此处，我们以ifcfg-enp0s3为内网，ifcfg-enp0s8为外网，进行配置，至于为什么，上一篇有提示过\n3.#vi ifcfg-enp0s3\n按照我这样配置：（按‘i’进行修改，按‘Esc’退出修改，按‘shift’加‘x’保存退出，后面经常用，不过多阐述；如果后面如果输错文件名，退出修改后按‘shift’+‘q！’，不保存退出文件）\nTYPE&#x3D;Ethernet\n\n\n\nBOOTPROTO&#x3D;static\n（此处修改）\n\n\n\n\n\n\n\nDEFROUTE&#x3D;yes\nPEERDNS&#x3D;yes\nPEERROUTES&#x3D;yes\nIPV4_FAILURE_FATAL&#x3D;no\nIPV6INIT&#x3D;yes\nIPV6_AUTOCONF&#x3D;yes\nIPV6_DEFROUTE&#x3D;yes\nIPV6_PEERDNS&#x3D;yes\nIPV6_PEERROUTES&#x3D;yes\nIPV6_FAILURE_FATAL&#x3D;no\nNAME&#x3D;enp0s3\nUUID&#x3D;e0c0cc4d-0233-4f43-b71e-8b18920330cb\nDEVICE&#x3D;enp0s3\n\n\n\nONBOOT&#x3D;yes\n（此处修改）\n\n\n\nIPADDR&#x3D;192.168.100.10\n（此处为添加）\n\n\nGATEWAY&#x3D;192.168.100.1\n（此处为添加）\n\n\nNETMASK&#x3D;255.255.255.0\n（此处为添加）\n\n\n保存，退出\n4.#vi ifcfg-enp0s8\n分别将：\n\n\n\nBOOTPROTO&#x3D;static\n（此处修改）\n\n\n\nONBOOT&#x3D;yes\n（此处修改）\n\n\nIPADDR&#x3D;192.168.200.10\n（此处为添加）\n\n\nNETMASK&#x3D;255.255.255.0\n（此处为添加）\n\n\n注意：外网不添加GATEWAY这一项\n保存，退出\n\n\n\n5.#cd\n（将工作台切换到根目录下）\n\n\n\n6.#service  network restart\n（重新启动网卡，如果出现：Restarting network (via systemctl): [   OK ]，说明配置完成）\n\n\ncompute的网络配置[root@compute ~]#\n方法同controller一样，此处只提出不同的地方\n1.#vi ifcfg-enp0s3\n\n\n\nBOOTPROTO&#x3D;static\n（此处修改）\n\n\n\nONBOOT&#x3D;yes\n（此处修改）\n\n\nIPADDR&#x3D;192.168.100.20\n（此处为添加）\n\n\nNETMASK&#x3D;255.255.255.0\n（此处为添加）\n\n\nGATEWAY&#x3D;192.168.100.1\n（此处为添加）\n\n\n保存，退出\n2.#vi ifcfg-enp0s8\n\n\n\nBOOTPROTO&#x3D;static\n（此处修改）\n\n\n\nONBOOT&#x3D;yes\n（此处修改）\n\n\nIPADDR&#x3D;192.168.200.20\n（此处为添加）\n\n\nNETMASK&#x3D;255.255.255.0\n（此处为添加）\n\n\n保存，退出\n3.#cd\n4.#service network restart\n至此controller和compute的两个节点的网络配置完毕，此时可以使用CRT进行连接使用了\nsecureCRTP的连接：\n1.首先打开CRT，进行controller的连接\n2.文件–快速连接（出现如下窗口）\n\n\n3.主机名：192.168.100.10\n  用户名：root\n  连接–输入密码：000000–保存密码–确定\n  （此时已经连上controller的虚拟机）\n4.鼠标右击192.168.100.10的标签–会话选项\n本人的配置方法如下（个人觉的比较好看）\n\n\ncompute的连接过程和controller相同\n主机名：192.168.100.20\n（其他都一样好了）\n至此用secureCRTP连接虚拟机的内容介绍完毕，接下来就是进入正题了\n请看下一篇secureCRTP上传镜像！！！\n","slug":"3.secureCRT连接虚拟机_02","date":"2022-10-06T07:28:25.936Z","categories_index":"云计算","tags_index":"IaaS","author_index":"FangH"},{"id":"6a417038b30356b420810aef9fa30ba4","title":"Iaas搭建","content":"Iaas搭建\n\n以上是IAAS平台的基本环境配置，这些服务配置将在接下来的内容了呈现\ncontroller和compute两节点都要打开\n1.主机名的配置controller：\n\n\\#hostnamectl set-hostname controller\n\n\\#bash\n\n \n\ncompute：\n\n\\#hostnamectl set-hostname compute\n\n\\#bash\n\n2.配置映射文件controller和compute都要配置\n\\#vi &#x2F;etc&#x2F;hosts\n\n进行如下配置：\n保存退出\n3.配置controller的yum源首先配置controller的yum源\n[root@controller ~]#\n\n\\#cd &#x2F;etc&#x2F;yum.repos.d&#x2F;\n \n\\#rm -rvf *\n\n\\#vi [ftp.repo](http:&#x2F;&#x2F;ftp.repo) | 创建源文件\n\n\n\n\n配置内容如下：\n\n\ncompute的yum源先不急着配\n4.挂载iso文件（上一篇上传镜像后，才能继续进行接下来的IAAS搭建）在上一篇中提到一个小镜像cirros-0.3.4-x86_64-disk.img，此时也可以进行下一步，对电脑配置自信的可以忽略，\n[root@controller ~]# \n\n\\#cd\n\n\\#cd &#x2F;opt&#x2F; \n\n\\#mkdir  &#123;centos，iaas&#125;   | （在&#x2F;opt 目录下建立两个文件夹，用来挂载接下来的两个镜像文件）  \n\n\\#mkdir  cirros  |  （此处选做）\n  \n\\#cd\n\n\\#mount -o loop CentOS-7-x86_64-DVD-1511.iso &#x2F;opt&#x2F;centos&#x2F;  |  （上传Centos的镜像到centos文件夹下）  \n  \n\\#mount -o loop XianDian-IaaS-v2.2.iso &#x2F;opt&#x2F;iaas&#x2F;  |  （此处和上面同理）  \n    \n\\#mount -o  loop cirros-0.3.4-x86_64-disk.img  &#x2F;opt&#x2F;cirros&#x2F;  \n\n挂载成功会出现read-only等字样\n#yum clean  all      （清除缓存）  \n\n#yum list      （验证yum源）  \n\n5.搭建ftp服务器，开启并设置自启[root@controller ~]#\n\n#yum install  -y vsftpd    （搭建ftp服务器）    \n\n#vi &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf    （修改ftp的配置文件）  \n\n\n\n\n\n如上图所示，在原文本中添加\nanon_root&#x3D;&#x2F;opt&#x2F;\n\n保存退出\n#systemctl  restart vsftpd      （重启ftp服务）  \n\n#systemctl enable vsftpd      （设置开机自启）  \n\n6.关闭防火墙并设置开机不自启controller和compute都要做：\n#setenforce 0\n\n#getenforce      （出现Permissive则表示防火墙的安全级别已经降低了）  \n\n这种方式时临时的，如果重启了虚拟机，需要再执行一次\n#systemctl  stop firewalld    （关闭防火墙）    \n\n#systemctl  disable firewalld    （设置防火墙开机不自启）  \n\n7.配置compute的yum源先前已经配好了controller的yum源，这里只要用scp传过来，进行一些修改即可\n[root@compute ~]#\n\n\\#cd &#x2F;etc&#x2F;yum.reops.d&#x2F;\n\n\\#rm -rvf *\n\n\\#scp 192.168.100.10:&#x2F;&#x2F;etc&#x2F;yum.repos.d&#x2F;* .\n\n出现（yes&#x2F;no）和password就依次填写yes和000000，后面还会遇到几次，也是同样的方法\n\n\\#cd &#x2F;etc&#x2F;yum.repos.d&#x2F;\n\n\\#vi [ftp.repo\n\n\n\n照着上图进行修改从controller传来的ftp.repo文件内容即可\n接着顺便清除缓存和验证compute的yum源\n\\#cd\n\n\\#yum clean all\n\n\\#yum list\n\n这些都做好后进行下一步操作\n8.编辑controller和compute的环境变量\\#yum install -y iaas-xiandian\n\n接下来是编辑文件&#x2F;etc&#x2F;xiandian&#x2F;openrc.sh,此文件是安装过程中的各项参数，根据每项参数上一行的说明及服务器实际情况进行配置。\n首先编辑controller的openrc.sh脚本文件\n[root@controller ~]# \n\n\\#vi &#x2F;etc&#x2F;xiandian&#x2F;openrc.sh\n\n出现如下图的文件内容：\n\n\n上图是我已经修改过的（注意：该脚本文件配置每一个环节都不能有错，不然后面有些脚本会执行失败！！！）\n配置内容：\nHOST_IP&#x3D;192.168.100.10\n\nHOST_NAME&#x3D;controller\n\nHOST_IP_NODE&#x3D;192.168.100.20\n\nHOST_NAME_NODE&#x3D;compute\n\nRABBIT_USER&#x3D;openstack\n\nRABBIT_PASS&#x3D;000000\n\nDB_PASS&#x3D;000000\n\nDOMAIN_NAME&#x3D;demo（自定义）\n\nADMIN_PASS&#x3D;000000\n\nDEMO_PASS&#x3D;000000\n\nKEYSTONE_DBPASS&#x3D;000000\n\nGLANCE_DBPASS&#x3D;000000\n\nGLANCE_PASS&#x3D;000000\n\nNOVA_DBPASS&#x3D;000000\n\nNOVA_PASS&#x3D;000000\n\nNEUTRON_DBPASS&#x3D;000000\n\nNEUTRON_PASS&#x3D;000000\n\nMETADATA_SECRET&#x3D;000000\n\nINTERFACE_NAME&#x3D;enp0s8（外网网卡名，第一篇文章有提到）\n\nCINDER_DBPASS&#x3D;000000\n\nCINDER_PASS&#x3D;000000\n\nTROVE_DBPASS&#x3D;000000\n\nTROVE_PASS&#x3D;000000\n\nBLOCK_DISK&#x3D;sdb1（空白分区名，第一篇文章里有提到）\n\nSWIFT_PASS&#x3D;000000\n\nOBJECT_DISK&#x3D;sdc1（空白分区名）\n\nSTORAGE_LOCAL_NET_IP&#x3D;192.168.100.20\n\nHEAT_DBPASS&#x3D;000000\n\nHEAT_PASS&#x3D;000000\n\nCEILOMETER_DBPASS&#x3D;000000\n\nCEILOMETER_PASS&#x3D;000000\n\nAODH_DBPASS&#x3D;000000\n\nAODH_PASS&#x3D;000000\n\n（注意要去掉前面的‘#’）\n\n保存，退出\n至此，controller的openrc.sh配置好了，接下来传给compute的就可以了\n[root@controller ~]#\n\n\\#scp &#x2F;etc&#x2F;xiandian&#x2F;openrc.sh 192.168.100.20:&#x2F;&#x2F;etc&#x2F;xiandian&#x2F;openrc.sh\n\n输入：yes--输入：000000\n\n此时两个节点的openrc.sh都配好了，建议都进行一下接下来的命令：\ncontroller和compute\n\\#source &#x2F;etc&#x2F;xiandian&#x2F;openrc.sh\n\n\n\n接下来就是进入脚本跑酷环节！！！\n9.通过脚本安装服务（内容包括：安装Openstack包，配置域名解析，配置防火墙和Selinux，安装ntp服务）\ncontroller和compute：\n\\#iaas-pre-host.sh\n\n安装完成后会提示重启。因为我们在本篇内容第一步修改了主机名，所以不需要重启\n10.通过脚本安装服务（内容包括：安装Mysql数据库服务，安装Mongo数据库服务，安装RabbitMQ服务，安装memcahce）\n[root@controller ~]#\n\n\\#iaas-install-mysql.sh\n\n11.通过脚本安装keystone认证服务（内容包括：安装keystone服务软件包，创建Keystone数据库，配置数据库连接，为keystone服务创建数据库表，创建令牌，创建签名密钥和证书，定义用户、租户和角色，创建admin-openrc.sh）\n[root@controller ~]#\n\n\\#iaas-install-keystone.sh\n\n12.通过脚本安装glance服务（内容包括：安装Glance镜像服务软件包，创建Glance数据库，配置文件创建数据库连接，为镜像服务创建数据库表，创建用户，配置镜像服务，创建Endpoint和API端点，启动服务，上传镜像）\n[root@controller ~]#\n\n\\#iaas-install-glance.sh\n\n\n\n13.通过脚本Nova计算服务（内容包括：安装Nova 计算服务软件包，创建Nova数据库，创建计算服务表，创建用户，配置计算服务，创建Endpoint和API端点 ，启动服务，验证Nova，安装Nova计算服务软件包，配置Nova服务，检查系统处理器是否支持虚拟机的硬件加速，启动，清除防火墙）\ncontroller和compute同时：\n[root@controller ~]#\n\n\\#iaas-install-nova-controller.sh\n\n[root@compute ~]#\n\n\\#iaas-install-nova-compute.sh\n\n14.通过脚本安装neutron服务（内容包括：创建Neutron数据库，创建用户，创建Endpoint和API端点 ，安装neutron网络服务软件包，配置Neutron服务，编辑内核，创建数据库，启动服务和创建网桥，安装软件包，配置Neutron服务，编辑内核，启动服务进而创建网桥）\ncontroller和compute同时：\n[root@controller ~]#\n\n\\#iaas-install-neutron-controller.sh\n\n[root@compute ~]#\n\n\\#iaas-install-neutron-compute.sh\n\n\n\n接下来就是网络模式的选择\n[root@controller ~]#\n\n#iaas-install-neutron-controller-      （按两次‘Tab’）   \n\n可以看见：\niaas-install-neutron-controller-flat.sh \n\niaas-install-neutron-controller-gre.sh  \n\niaas-install-neutron-controller-vlan.sh\n\n我们选择安装gre.sh\n15.选择Neutron网络模式controller和compute同时：\n[root@controller ~]#\n\niaas-install-neutron-controller-gre.sh\n\n[root@compute ~]#\n\niaas-install-neutron-compute-gre.sh\n\n16.通过脚本安装dashboard服务（内容包括：安装Dashboard服务软件包，配置，启动服务）\n[root@controller ~]#\n\n\\#iaas-install-dashboard.sh\n\n此时可以通过浏览器网址栏输入http://192.168.100.10/dashboard进入先电云计算平台\n域：demo\n用户名：admin\n密码：000000\n17.网络–网络–创建网络点击创建网络，我这里已经创建好了\n\n\n\n\n\n\n点击已创建\n18.管理员–网络–创建网络\n\n提交\n创建好后–点击网络名称中的ext\n子网–创建子网\n\n\n下一步\n\n\n已创建\n19.网络–路由–新建路由\n\n点路由名称route–接口–增加\n\n\n\n\n20.安装cinder之前做个准备工作[root@controller ~]# \n\n\\#source &#x2F;etc&#x2F;keystone&#x2F;admin-openrc.sh\n\n\\# glance image-create --name centos7 --disk-format qcow2 --container-format bare --progress &lt; &#x2F;opt&#x2F;iaas&#x2F;images&#x2F;CentOS_7.2_x86_64_XD.qcow2 \n\n（此处将CentOS的镜像上传，下一步可以一次在平台上建立一个虚拟机，做测试）\n\n上一篇文章介绍了如何用secureCRTP上传镜像，其中补充了一个小镜像也可以用上面一样的命令上传到先电平台\n\\# glance image-create --name cirros --disk-format qcow2 --container-format bare --progress &lt; &#x2F;opt&#x2F;iaas&#x2F;images&#x2F;cirros-0.3.4-x86_64-disk.img\n\n21.在云平台中–计算–云主机–创建云主机\n启动实例\n绑定浮动IP–‘+’–分配IP–关联\n\n\n\n\n\n\n22.计算–访问&amp;安全–（defult）管理规则–删除原有的规则–添加规则\n\n\n\n分别添加–所有ICMP，所有TCP，所有UDP–并且各自添加 出口 和 入口\n如上图所示\n此时可以访问之前创建好的云主机123了，启动云主机后，可以直接在CRT上连接\n好，继续脚本跑酷！！！\n23.通过脚本安装Cinder服务（内容包括：安装Cinder块存储服务软件包，创建数据库，创建用户，创建Endpoint和API端点 ，配置Cinder服务，创建数据库，启动服务，安装块存储软件，创建LVM物理和逻辑卷，修改Cinder配置文件，重启服务，验证）\ncontroller和compute同时：\n[root@controller ~]#\n\n\\#iaas-install-cinder-controller.sh\n\n[root@compute ~]# \n\n\\#iaas-install-cinder-compute.sh\n\n完成后接着还有一步：\n[root@controller ~]#\n\n\\#source &#x2F;etc&#x2F;keystone&#x2F;admin-openrc.sh\n\n24.通过脚本安装Swift服务（内容包括：创建用户，创建Endpoint和API端点 ，编辑&#x2F;etc&#x2F;swift&#x2F;proxy-server.conf，创建账号、容器、对象，编辑&#x2F;etc&#x2F;swift&#x2F;swift.conf，启动服务和赋予权限，安装软件包，配置rsync，配置账号、容器和对象，修改Swift配置文件，重启服务和赋予权限）\ncontroller和compute同时：\n[root@controller ~]#\n\n\\#iaas-install-swift-controller.sh\n\n[root@compute ~]# \n\n\\#iaas-install-swift-compute.sh\n\n25.通过脚本安装Trove服务（内容包括：安装Trove数据库服务的软件包，创建数据库，创建用户，创建Endpoint和API端点 ，配置trove.conf文件，配置trove-taskmanager.conf，配置trove-conductor.conf文件，配置trove-guestagent.conf，同步数据库，启动服务）\n需注意安装Trove服务之前需要配置好网络（flat或gre）,创建好子网，并确认系统已经安装swift和cinder两个服务，否则安装会失败。\n[root@controller ~]#\n\n\\#iaas-install-trove.sh\n\n26.查看上传的镜像[root@controller ~]#\n\n\\#cat &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iaas-install-trove.sh\n\n（查看上传的镜像）\n\n\n\n\n27.上传镜像将提供的MySQL_5.6_xiandian.qcow2 上传到系统内\n[root@controller ~]#\n\n\\#glance image-create --name &quot;mysql-5.6&quot; --disk-format qcow2 --container-format bare --progress &lt; MySQL_5.6_XD.qcow2\n\n\n\n\n\n\\# ls &#x2F;opt&#x2F;iaas&#x2F;images\n\n如上图可以查看到 MySQL_5.6_XD.qcow2 已经成功上传\n28.创建数据库存储[root@controller ~]#\n\n\\# trove-manage datastore_update mysql &#39;&#39;\n\n29.使用上传的镜像更新数据库[root@controller ~]#\n\n\\# trove-manage datastore_version_update mysql mysql-5.6 mysql $&#123;Glance_Image_ID&#125; &#39;&#39; 1\n\n将其中${Glance_Image_ID} 改为26节第一张图里面的ID后面的字符串\n\\# trove create mysql-1 $&#123;FLAVOR_ID&#125; --size 5 --databases myDB --users user:r00tme --datastore_version mysql-5.6 --datastore \n\nmysql\n\n将其中${FLAVOR_ID}改为2\n创建完成后查询trove列表\n[root@controller ~]#\n\n\\#trove list\n\n\n\n30.通过脚本安装heat服务（内容包括：安装heat编配服务软件包，创建数据库，创建用户，创建Endpoint和API端点 ，配置Heat服务，创建数据库，启动服务）\n[root@controller ~]#\n\n\\#iaas-install-heat.sh\n\n\n\n31.nginx模板nginx模板文件存放在&#x2F;etc&#x2F;xiandian&#x2F;目录下，在使用模板之前需成功安装，ceilometer监控服务以及alarm监控服务。\n[root@controller ~]#\n\n\\#ls &#x2F;etc&#x2F;xiandian&#x2F;\n\n可以查看nginx模板\n构建一台http服务器，将lb-server.yaml模板文件上传至http服务器中。\n32.通过脚本安装Ceilometer服务（内容包括：安装Ceilometer监控服务软件包，创建数据库，创建用户，创建Endpoint和API端点 ，配置Ceilometer，启动服务，监控组件，安装软件包，配置Ceilometer）\ncontroller和compute同时：\n[root@controller ~]#\n\n\\#iaas-install-ceilometer-controller.sh\n\n[root@compute ~]# \n\n\\#iaas-install-ceilometer-compute.sh\n\n33.通过脚本安装alarm服务（内容包括：创建数据库，创建keystone用户，创建Endpoint和API，安装软件包，配置aodh，同步数据库，启动服务）\n[root@controller ~]#\n\n\\#iaas-install-alarm.sh\n\n\n\n34.添加控制节点资源到云平台修改openrc.sh，把compute节点的IP和主机名改为controller节点的IP和主机名\n[root@compute ~]# \n\n\\#vi &#x2F;etc&#x2F;xiandian&#x2F;openrc.sh\n\n修改以下参数为：\nHOST_IP_NODE&#x3D;192.168.100.10\n\nHOST_NAME_NODE&#x3D;controller\n\n保存退出\n修改结果如上图所示\n[root@controller ~]#\n\n\\#iaas-install-nova-compute.sh\n\n将compute的资源添加到controller中\n最后提供一个卸载脚本命令\n35.系统卸载系统提供一键卸载脚本，节点运行iaas-uninstall-all.sh脚本，脚本卸载当前节点的所有云平台数据，如果卸载节点为controller节点则会清除所有的数据（此时云平台也被清空），如果卸载节点为compute节点则会删除compute节点的数据。\ncontroller和compute同时：\n[root@controller ~]#\n\n\\#iaas-uninstall-all.sh\n\n[root@compute ~]# \n\n\\#iaas-uninstall-all.sh\n\n至此，IAAS平台搭建完成！！！\n请看下一篇PAAS的平台搭建！！！\n","slug":"3.Iaas搭建_04","date":"2022-10-06T07:28:25.933Z","categories_index":"云计算","tags_index":"IaaS","author_index":"FangH"},{"id":"d96e73c46a21215b2a6710733d95f450","title":"HTML","content":"HTML1.HTML的基本格式&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;title&gt;…&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n​\t\n​\t\n标签：&lt;title&gt;…&lt;&#x2F;title&gt; 位于&lt;head&gt;…&lt;&#x2F;head&gt;之间，用于浏览器标题。\n\n&lt;p&gt;…&lt;&#x2F;p&gt;位于&lt;body&gt;…&lt;&#x2F;body&gt;\n\t用于段落位置\n\t\t居中：&lt;p align&#x3D;&quot;center&quot;&gt;…&lt;&#x2F;p&gt;\n\t\t左对齐：&lt;p align&#x3D;&quot;left&quot;&gt;…&lt;&#x2F;p&gt;\n\t\t右对齐：&lt;p align&#x3D;&quot;right&quot;&gt;…&lt;&#x2F;p&gt;\n\t\n\t不产生段落间距换行：&lt;br&gt;\n\t预格式标记：&lt;pre&gt;…&lt;&#x2F;pre&gt;\n\t\n\t文本标题：Dreamweaver 提供6种标准的标题样式\n\t\t&lt;h1&gt;…&lt;&#x2F;h1&gt;\n\t\t&lt;h2&gt;…&lt;&#x2F;h2&gt;\n\t\t&lt;h3&gt;…&lt;&#x2F;h3&gt;\n\t\t&lt;h4&gt;…&lt;&#x2F;h4&gt;\n\t\t&lt;h5&gt;…&lt;&#x2F;h5&gt;\n\t\t&lt;h6&gt;…&lt;&#x2F;h6&gt;\n\t\t(从上到下依次由大变小)\n\t\n\t设置文本格式\n\t\t可以设置字体：&lt;font face&#x3D;&quot;字体&quot;&gt;…&lt;&#x2F;font&gt;\n\t\t字号：&lt;font size&#x3D;&quot;字体字号&quot;&gt;…&lt;&#x2F;font&gt;\n\t\t\t1~7号字体为绝对大小；-4~+4为相对3号的缩小与放大。\n\t\t颜色：&lt;font color&#x3D;&quot;字体颜色&quot;&gt;…&lt;&#x2F;font&gt;\n\t\t\n\t设置文本样式\n\t\t常用的格式化标记：\n\t\t\t加粗：&lt;b&gt;…&lt;&#x2F;b&gt;\t\t&lt;strong&gt;…&lt;&#x2F;strong&gt;\n\t\t\t斜体:&lt;i&gt;…&lt;i&gt;\t\t&lt;em&gt;…&lt;&#x2F;em&gt;    &lt;cite&gt;…&lt;&#x2F;cite&gt;\n\t\t\t上标：&lt;sup&gt;…&lt;&#x2F;sup&gt;\t\t下标：&lt;sub&gt;…&lt;&#x2F;sub&gt;\n\t\t\t下划线：&lt;u&gt;…&lt;&#x2F;u&gt;\t\t中划线：&lt;s&gt;…&lt;&#x2F;s&gt;\n\t\t\t闪烁：&lt;blink&gt;…&#x2F;blink&lt;&gt;\t\t\n\n2.列表​\t无序列表：位于…之间。\n&lt;ul&gt;\n\t&lt;li&gt;…&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n\n\ntype值：&lt;ul type&#x3D;&quot;disc&quot;&gt;\n\t\t\t   \t&lt;li&gt;…&lt;&#x2F;li&gt;\n\t\t\t   &lt;&#x2F;ul&gt;\n\t\tdisc(默认值)：实心圆\n\t\tcircle：空心圆\n\t\tsquare:实心正方形\n\t\t\n有序列表：\n\t&lt;ol&gt;…&lt;&#x2F;ol&gt;\n\t\n\ttype:&lt;ol type&#x3D;&quot;l&quot;&gt;\n\t\t   &lt;li&gt;…&lt;&#x2F;li&gt;\n\t\t   &lt;&#x2F;ol&gt;\n\t\t\n\ttype:\n\t\tl（默认）：1，2，3，4…\n\t\ta: a, b, c, d…\n\t\tA: A, B, C, D…\n\t\ti: i, ii, iii, iv…\n\t\tI: I, II, III, IV…\n\n3.列表嵌套无序中嵌入有序\n\t&lt;body&gt;\n\t\t&lt;ul&gt;\n\t\t\t&lt;li&gt;…\n\t\t\t\t&lt;ol&gt;\n\t\t\t\t\t&lt;li&gt;…&lt;&#x2F;li&gt;\n\t\t\t\t&lt;&#x2F;ol&gt;\n\t\t\t&lt;&#x2F;li&gt;\n\t\t&lt;&#x2F;ul&gt;\n\t&lt;&#x2F;body&gt;\n\n插入符号：\n\t&amp;nbsp:空格\t&amp;copy:版权\t&amp;lt:小于号“&lt;”\t&amp;gt:大于号“&gt;”\t&amp;quot:双引号“&quot;&quot;”\n\n水平线：&lt;hr&gt;\n\t&lt;hr align&#x3D;&quot;center&quot; width&#x3D;&quot;200&quot; size&#x3D;&quot;5&quot; noshade&#x3D;&quot;noshade&quot; color&#x3D;&quot;#FF0000&quot; id&#x3D;&quot;line&quot;&gt;\n\t\n\t\talign:对齐方式\twidth:宽度（长度）\tsize:高度\tcolor:颜色\tnoshade:阴影\n\n4.文件头标签插入关键字&lt;meta&gt;位于&lt;head&gt;…&lt;&#x2F;head&gt;\n&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;…&quot;&gt;\n\n插入说明：对网页内容的详细说明\n&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;…,…&quot;&gt;\n\n刷新：指网页的刷新时间或跳转至其他页面的功能\n&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;10&quot;&gt;\n\t一定时间后跳转至其他页面\n\t&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;10;url&#x3D;…网页地址…&quot;&gt;\n\n5.使用图像插入图像：&lt;img src&#x3D;&quot;图片地址&#x2F;图片名.jpg&quot; width&#x3D;&quot;600&quot; height&#x3D;&quot;404&quot;&#x2F;&gt;\n\n地址：\n\t绝对地址：文件所在具体位置\n\t相对地址：与网页同一级目录\n\t\n\t例子：C &gt;&gt; user &gt;&gt; html &gt;&gt; photo &gt;&gt; p1.jpg\n\t\t\t\t\t\t\t   p1.jpg                     p2.jpg\n\t\t\t绝对地址：&#x2F;photos&#x2F;p1.jpg\n\t\t\t相对地址：p1.jpg\n\t\t\t\n图像属性\n\talt:&lt;img src&#x3D;&quot; &quot; alt&#x3D;&quot;…&quot;&#x2F;&gt; 图像无法显示时，显示alt内容。\n\tborder:&lt;img src&#x3D;&quot; &quot; border&#x3D;&quot;…&#x2F;&quot;&gt; 给图像加边。\n\talign:&lt;img src&#x3D;&quot; &quot; align&#x3D;&quot;…&#x2F;&quot;&gt; 给图像对齐。\n\t\talign&#x3D;&quot;right, left, top, bottom&quot;\n\n6.vspace与hspace：设置水平，垂直边距。​\t\n7.网页背景图像​\t\n插入背景图像，位于&lt;body&gt;…&lt;&#x2F;body&gt;中\n&lt;body backgroup&#x3D;&quot;图片地址&quot;&gt;&lt;&#x2F;body&gt;\n\n\n\n8.网页背景音乐&lt;embed src&#x3D;&quot;音乐地址&quot; hidden&#x3D;&quot;true&quot; autostart&#x3D;&quot;true&quot; loop&#x3D;&quot;-1&quot;&gt;\n当loop为-1或infinite时，播放次数为无限次。\n\n\n\n9.设置背景图像不随页面滚动&lt;body style&#x3D;&quot;backgroup-attachment&#x3D;fixed&quot;; backgroup&#x3D;&quot;地址&quot;&gt;&lt;&#x2F;body&gt;\nbackgroup-attachment&#x3D;fixed为背景附加属性“固定”\nbackgroup-position&#x3D;center为背景位置设置为“中心”\n\n​\t\n10.滚动标签：marqueemarquee可以移动文字，图片，表格\n&lt;marquee&gt;…&lt;&#x2F;marquee&gt;(默认向左滚动)\n\n滚动方向：direction\n&lt;marquee direction&#x3D;&quot;滚动方向&quot;&gt;…&lt;&#x2F;marquee&gt;\n\t滚动方向:up, down, left, right\n\t\n滚动方式：behavior\n&lt;marquee behavior&#x3D;&quot;方式&quot;&gt;…&lt;&#x2F;marquee&gt;\n\t方式：scroll 循环（默认）\n\t\t\tslide 滚动一次\n\t\t\talternate 交替滚动\n\t\t\t\n滚动次数：loop\n&lt;marquee loop&#x3D;&quot;次数&quot;&gt;…&lt;&#x2F;marquee&gt;\n\n滚动速度：scrollamount\n&lt;marquee scrollamount&#x3D;&quot;速度&quot;&gt;…&lt;&#x2F;marquee&gt;\n\t实际为每次滚动的移动长度，以像素为单位。\n\n滚动延迟：scrolldelay\n&lt;marquee scrolldelay&#x3D;&quot;时间间隔&quot;&gt;…&lt;&#x2F;marquee&gt;\n\t“时间间隔”以毫秒为单位\n\t\n滚动区域背景颜色:bgcolor\n&lt;marquee bgcolor&#x3D;&quot;颜色&quot;&gt;…&lt;&#x2F;marquee&gt;\n\t&quot;颜色&quot;为十六进制码\n\n滚动背景宽度：width和高度：height\n&lt;marquee width&#x3D;&quot;宽度&quot; height&#x3D;&quot;高度&quot;&gt;…&lt;&#x2F;marquee&gt;\n\n设置空白空间hspace, vspace\n&lt;marquee hspace&#x3D;&quot;水平范围&quot; vspace&#x3D;&quot;垂直范围&quot;&gt;…&lt;&#x2F;marquee&gt;\n\n\n\n11.多媒体标签embedembed可以插入各种多媒体\n&lt;embed src&#x3D;&quot;地址&quot; loop&#x3D;&quot;true&quot; autostart&#x3D;&quot;true&quot; width&#x3D;&quot;宽度&quot; height&#x3D;&quot;&quot;&gt;\n\n​\t\n12.超链接的建立​\t\t基础：每个网页都有唯一的地址，统称为资源定位符（URL）​\t\t\n链接元素&lt;a&gt;…&lt;&#x2F;a&gt;\n\t指定路径属性href\n\t\t&lt;a href&#x3D;&quot;链接地址&quot;&gt;…&lt;&#x2F;a&gt;\n\t\t&lt;a name&#x3D;&quot;链接命名&quot;&gt;…&lt;&#x2F;a&gt; \n\t\t\ttitle&#x3D;&quot;给链接添加提示文字&quot;\n\t\t\ttarget&#x3D;&quot;指定链目标窗口&quot;\n\t\t\t\n显示链接目标属性\n\t&lt;a href&#x3D;&quot;链接地址&quot; target&#x3D;&quot;目标窗口的打开方式&quot;&gt;\n\t\t方式：_blank打开一个新的窗口\n\t\t\t\t_self在本窗口打开\n\t\t\t\t_top在整个窗口中打开\n\t\t\t\t_parent在父框架集中打开文档\n\n13.设置不同的链接目标锚链接：\n&lt;a href&#x3D;&quot;#锚点名称&quot;&gt;…&lt;&#x2F;a&gt;\n&lt;a href&#x3D;&quot;命名&quot; id&#x3D;&quot;锚点名称&quot;&gt;…&lt;&#x2F;a&gt;\n\n设置图片超链接：&lt;a href&#x3D;&quot;地址&quot; target&#x3D;&quot;方式&quot;&gt;…&lt;img src&#x3D;&quot;地址&quot;&gt;…&lt;&#x2F;a&gt;\n\n设置电子邮件链接：&lt;a href&#x3D;&quot;mailto&#x3D;邮箱地址&quot;&gt;…&lt;&#x2F;a&gt;\n\n\n\n14.表格元素结构​\t由行，列，单元格组成，表格标记table，行标记tr，单元格标记td​\t\t\n结构：表格&lt;table&gt;\n\t\t\t&lt;table&gt;表格内容&lt;&#x2F;table&gt;\n\t\t行&lt;tr&gt;\n\t\t\t&lt;tr&gt;行内容&lt;&#x2F;tr&gt;\n\t\t单元格&lt;td&gt;\n\t\t\t&lt;td&gt;单元格内容&lt;&#x2F;td&gt;:内容可为文字，图像，表单，甚至另一个表格\n\t\t\t\n&lt;table&gt;元素属性:\n\t边框属性border(外边框)\n\t\t&lt;table border&#x3D;&quot;边框宽度&quot;&gt;\n\t水平对齐属性align(用于表格在页面中的位置)\n\t\t&lt;table align&#x3D;&quot;对齐方式&quot;&gt;\n\t\t\t参数：left\t左对齐\n\t\t\t      center\t居中\n\t\t\t      right\t右对齐\n\n\t高度属性height\n\t\t&lt;table height&#x3D;&quot;表格高度&quot;&gt;\n\t\t\t高度可为像素，也可为百分比\n\t\t\t\n\t宽度属性width\n\t\t&lt;table width&#x3D;&quot;表格宽度&quot;&gt;\n\t\t宽度可为像素，百分比\n\t\t\n\t边框颜色属性bordercolor(边框宽度不为零)\n\t\t&lt;table border&#x3D;&quot;边框宽度&quot; bordercolor&#x3D;&quot;边框颜色&quot;&gt;\n\t\t颜色为十六进制或英文名称\n\t\t\n\t边框亮边线属性\n\t\t&lt;table bordercolorlight&#x3D;&quot;亮边框的颜色&quot;&gt;\n\t\t&lt;table bordercolorlight&#x3D;&quot;暗边框的颜色&quot;&gt;\n\t\t\n\t背景颜色属性bgcolor\n\t\t&lt;table bgcolor&#x3D;&quot;颜色&quot;&gt;\n\t\t\n\t背景图片属性background(表格背景)\n\t\t&lt;table background&#x3D;&quot;图片地址&quot;&gt;\n\t\n\t单元格间距属性cellspacing\n\t\t&lt;table cellspacing&#x3D;&quot;单元格&quot;&gt;\n\n\t单元格补白属性cellspadding\n\t\t规定单元格边沿与其内容之间的空白\n\t\t&lt;table cellspadding&#x3D;&quot;单元补白属性&quot;&gt;\n\t\t\n\t&lt;tr&gt;元素的属性（行）\n\t\t水平对齐属性align\n\t\t\t&lt;table align&#x3D;&quot;水平对齐方式&quot;&gt;\n\t\t\t方式：left(默认), center, right\n\t\t\t\n\t\t垂直对齐属性valign\n\t\t\t&lt;tr valign&#x3D;&quot;垂直对齐方式&quot;&gt;\n\t\t\t方式：top, middle, bottom\n\t\t\t\n\t\t行的背景颜色bgcolor\n\t\t\t&lt;tr bgcolor&#x3D;&quot;行的背景颜色&quot;&gt;\n\t\t\t只对行起作用，会覆盖表格背景\n\t\t\n\t\t行边框颜色\n\t\t\t&lt;tr bordercolor&#x3D;&quot;行边框颜色&quot;&gt;\n\t\t\t\n\t&lt;td&gt;元素的属性\n\t\t宽度：&lt;td width&#x3D;&quot;单元格宽度&quot;&gt;\n\t\t高度：&lt;td height&#x3D;&quot;单元格高度&quot;&gt;\n\t\t指定单元格背景色：&lt;td bgcolor&#x3D;&quot;颜色&quot;&gt;\n\t\t指定单元格背景图：&lt;td background&#x3D;&quot;图片地址&quot;&gt;\n\t\t指定水平对齐：&lt;td align&#x3D;&quot;水平对齐&quot;&gt;    方式：left, center, right\n\t\t指定垂直对齐：&lt;td valign&#x3D;&quot;垂直对齐&quot;&gt;    方式：top, middle, bottom\n\t\t指定单元格边框颜色：&lt;td border&#x3D;&quot;颜色&quot;&gt;\n\t\t\n\t合并列表属性colspan(跨列)    rowspan(跨行)\n\t\t&lt;td colspan&#x3D;&quot;跨列数&quot;&gt;\n\t\t&lt;td rowspan&#x3D;&quot;跨行数&quot;&gt;\n\t\t\n\t表格标题：位于&lt;table&gt;…&lt;&#x2F;table&gt;\n\t\t&lt;caption&gt;标题&lt;&#x2F;caption&gt;\n\t\t\n\t表格框架简例：\n\t\t&lt;table border&#x3D;&quot;&quot; width&#x3D;&quot;&quot; cellspacing&#x3D;&quot;&quot; cellsapdding&#x3D;&quot;&quot;&gt;\n\t\t\t&lt;tr&gt;\n\t\t\t\t&lt;td&gt;…&lt;&#x2F;td&gt;\n\t\t\t&lt;&#x2F;tr&gt;\n\t\t&lt;&#x2F;table&gt;\n\t\t\n\t内联框架：\n\t\t&lt;iframe src&#x3D;&quot;地址&quot; width&#x3D;&quot;&quot; height&#x3D;&quot;&quot;&gt;&lt;&#x2F;iframe&gt;\n\n15.多媒体​\t\t\t\nFlash 是矢量的Web交互动画制作工具，Dreamweaver提供了使用Flash对象的功能。\n\nFlash动画\n\tDreamweaver &gt;&gt; 插入 &gt;&gt; 媒体 &gt;&gt; SWF命令\n\t选择要插入的&quot;.swf&quot;的动画文件，得到Flash占位符。可在 属性面板中进行属性设置。\n\t\n透明Flash动画\n\t新建一个“网页”，在“外观CSS分类”中添加“背景图像”\n\t插入“.swf”后，在属性中Wmode中选择“透明”\n\nFlashPaper\n\t原理是FlashPaper虚拟机打印可打印的文档转换为SWF或PDF。\n\t\nFlash视频\n\tFlash视频即为FLV流媒体格式的视频\n\t选择“插入” &gt;&gt; “媒体” &gt;&gt; “FLV”\n\t“视频类型”：累进式下载视频，先将FLV文件下载到访问者的硬盘，然后再播放。\n\t流视频：进行一段缓冲时间后才在网页上播放视频内容。\n\n插入shockwave影片\n\t插入 &gt;&gt; 媒体 &gt;&gt; shockwave\n\t打开“选择文件”，选择&quot;.dcr&quot;, &quot;.dir&quot;, &quot;.dxr&quot;\n\n插入Applet\n\tApplet用Java编程语言开发的，可嵌入Web页中的小型应用程序\n\t插入 &gt;&gt; 媒体 &gt;&gt; Applet命令 &gt;&gt;  &quot;.class&quot;\n\t\n插入ActiveX控件\n\tActiveX是可以在浏览器中充当插入，可重复使用：插入 &gt;&gt; 媒体 &gt;&gt; ActiveX\n\t在属性面板中“class ID”插入视频，参数内可控制播放参数。\n\t&lt;param name&#x3D;&quot;AutoRewind&quot; value&#x3D;&quot;true&quot;&gt;    播放完回到开始\n\t&quot;FileName&quot;\t设置视频文件\n\t&quot;ShowControls&quot;\t控制条\n\t&quot;ShowPositionControls&quot;\t快进&#x2F;快退\n\t&quot;ShowAudioControls&quot;\t音频调节\n\t&quot;ShowTracker&quot;\t播放条\n\t&quot;ShowDisplay&quot;\t播放列表\n\t&quot;ShowStatusBar&quot;\t状态栏\n\t&quot;ShowCaptioning&quot;\t字幕\n\t&quot;AutoStart&quot;\t自动播放\n\t&quot;Volume&quot;\t音量\n\t&quot;AllowChangeDisplaySize&quot;\t允许改变显示尺寸\n\t&quot;EnableContextMenu&quot;\t显示右键菜单\n\t&quot;Windowless Video&quot;\t双击鼠标切换全屏\n\n插入音频\n\t\n\t通过&lt;bgsound&gt;标签添加背景音乐\n\t&lt;embed&gt;添加音乐播放器\n\t\t\n\t\t设置背景音乐，用于&lt;body&gt;…&lt;&#x2F;body&gt;之间\n\t\t&quot;&lt;bgsound&quot;后按空格出现属性：\n\t\t\tbalance\t设置左右对齐\n\t\t\tdelay\t设置播放延时\n\t\t\tloop\t设置循环次数，当loop&#x3D;-1，表示无限循环\n\t\t\tvolume\t设置音乐音量\n\t\t\tsrc\t文件地址\n\t\n\t设置音乐播放器\n\t\t&lt;embed src&#x3D;&quot;地址&quot; …&gt;\n\n滚动字幕\n\t&lt;marquee&gt;…&lt;&#x2F;marquee&gt;\n\t&quot;&lt;marquee&quot;后空格可以选择属性：\n\t\tbehavior\t滚动方式 ：\n\t\t\talternate 文本左右滚动\n\t\t\tscroll 循环滚动\n\t\t\tslide 滚动后固定\n\t\tbgcolor\t背景色\n\t\tdirection\t滚动方向：\n\t\t\tup \n\t\t\tdown \n\t\t\tleft \n\t\t\tright\n\t\theight 滚动效果的高度\twidth 宽度\n\t\tloop\t循环次数\n\t\tscrollamount\t滚动延迟时间\n\t\thspace 水平范围\tvspace 垂直范围\n\n16.使用框架​\t概述：可以在同一浏览器窗口中显示多个不同的文件，常用于左侧和上侧的区域设置为目录区和导航条，内部有超链，用于方便浏览其他的网页。​\t\n创建框架\n\t&lt;frameset&gt;和&lt;frame&gt;\n\t\t&lt;frameset cols&#x3D;&quot;96,*&quot;&gt;\n\t\t\t&lt;frame src&#x3D;&quot;left.html&quot;&#x2F;&gt;\n\t\t\t&lt;frame rows&#x3D;&quot;59,572&quot;&gt;\n\t\t\t\t&lt;frame src&#x3D;&quot;top.html&quot;&gt;\n\t\t\t\t&lt;frame src&#x3D;&quot;main.html&quot;&#x2F;&gt;\n\t\t\t&lt;&#x2F;frameset&gt;\n\t\t&lt;&#x2F;frameset&gt;\n\t\t\n\t&lt;frame&gt;只存在于&lt;frameset&gt;中，用于链接URL\n\t\t以像素为单位，也可取百分比：cols:框架的列数 rows:框架的行数\n\t\t“*”：表示框架占剩余未被定义的空间\n\n浮动框架\n\t&lt;iframe src&#x3D;&quot;地址&quot; name&#x3D;&quot;…&quot; width&#x3D;&quot;…&quot; height&#x3D;&quot;… align&#x3D;&quot;…&quot; scrolling&#x3D;&quot;yes&#x2F;no&quot; frameborder&#x3D;&quot;…&quot;&gt;&lt;&#x2F;frame&gt;\n\t\n\tname:框架标识名\n\tscrolling:是否出现滚动条\n\tframeborder:边框\n\t\n\t&lt;a href&#x3D;&quot;地址&quot; target&#x3D;&quot;…&quot;&gt;…&lt;&#x2F;a&gt;\n\ttarget结合name使用\n\n\n​\t\t​\t​\t\n","slug":"2_HTML_01","date":"2022-10-06T07:28:25.931Z","categories_index":"编程","tags_index":"HTML/CSS","author_index":"FangH"},{"id":"a7d67895004888252f8010c8618442cf","title":"CSS","content":"CSS1.类型属性用于定义网页中文本的字体、大小、颜色、样式及文本链接的修饰效果\n.cs2&#123;\n\nfont-family:&quot;黑体&quot;; (字体)\n\nfont-size:14px; (字号大小)\n\nfont-style:italic; (文字样式：normal, italic(斜体), oblique(偏斜)\n\nfont-weight:bold; (字体粗细:normal, bold(粗), bolder, lighter)\n\nfont-variant:small-caps; (字体变体)\n\nfont-height:20px (行高，行间距)\n\ntext-transform:capitalize; (大小写) uppercase, lowercase, none\n\ncolor:#F00; (颜色)\n\ntext-decoration:underline(下划线)，overline(上划线)，（文字修饰）\n\n&#125;\n\nline-through(删除线)，blink(闪烁线)，none\n2.背景属性.cs3&#123;\n\nbackground-attachment:fixed;\n\nbackground-image:url(bg.gif)\n\nbackground-repeat:repeat-x;\n\nbackground-position:right bottom;\n\nbackground-color:#F00; (背景颜色)\n\n&#125;\n\nbackground-image:url(地址); 背景图像\nbackground-repeat:用来设置图像重复显示的形式\nno-repeat(不重复)，repeat，repeat-x(横向重复)，repeat-y(纵向重复)\nbackground-attachment:用来设置背景是否随着页面滚动而滚动\nscroll(滚动)，fixed(固定)\nbackground-position:用于设置背景图片在网页中的位置\nleft(左对齐)，right, center, top, bottom, 也可输入数字\n3.区域属性.cs4&#123;\n\ncenter-spacing:2px; （字符间距，优先级高于单词，可选normal）\n\ntext-align:center; (文本对齐，left, right, center, justify(绝对居中))\n\ntext-indent:10; (文本缩进，设置第一行缩进距离，可取长度或百分比)\n\nvertical-align:middle;\n\nword-spacing:2px; (单词间距，可取长度或normal)\n\nwhile-space:nowrap;\n\ndisplay:none;\n\n&#125;\n\nwhile-spacing(空格):\nnormal:使多重空格合并成一个\npre:保留元素中的空格原始形象，不允许多重空格合并成一个\nnowrap:（不换行）长文本不自动换行\n4.方框属性css可以控制框大小，外观，位置，将每个文档的元素存入其中\n.cs5&#123;\n\ncontent:  （div的内容）\n\nborder:2px （div的边框粗细）\n\nmargin:30px （div之间的间距）\n\npadding:20px(填充) （content与div边框的间距）\n\nclear:right(清除浮动效果)\n\nfloat:right(浮动) 设置快元素的浮动效果\n\nheight:400px\n\nwidth:400px\n\n&#125;\n\nfloat:选择left(左对齐)元素放置在左页面空白处；right\npadding:定义应用样式的元素内容和元素边界之间的空白大小\nmargin:定义样式元素与其他之间的空白大小\nmargin-top right bottom left\n top 左右 bottom\n上下 左右\n四边\n5.边框属性可以设置元素边框的宽度、样式、颜色\n.cs6&#123;\n\nborder-top-width:2px;\n\n&#125;\n\nborder-方向-（宽度）颜色：…；\nborder 宽度 solid 颜色\nstyle(样式)：设定边框线的样式\nnone，dotted（点线），dashed（虚线），solid（实线），double（双实线）\ngroove（沟槽），ridge（脊形），inset（凹陷），outset（凸起）\n6.列表属性控制列表内容的各项元素\nList-style-type(列表类型)\ntype:disc(默认实心圆),  circle(实心圆),  none, square(实心方块), decimal(数字), lower-roman(小写罗马数字)\n upper-roman, lower-alpha(小写英文数字), upper–alpha\nList-style-image(项目符号图像)\n以图片做为无序列表的符号：outside（在方框外显示） inside（在方框内显示） \n7.定位属性position(位置)：可以设置浏览器放置AP Div 的方式\nstatic(静态)：由浏览器决定元素的左边缘和上边缘\nabsolute(绝对)：以top、bottom、left、right,坐标为页面左上角\nfixed(固定)：将元素相对其显示的页面或窗口进行定位\nrelative(相对)：坐标原点为当前位置\nvisibility(显示)：设置的初始化显示属性\ninherit(继承)：继承分层父级元素的可见性属性\nvisible(可见)：层显示可见\nhidden(隐藏)：层隐藏\nwidth&#x2F;height：设置元素宽，高的值\nz-index(z轴)：定义层的顺序；可以用auto（自动）或相应数\noverflow(溢出)：定义层中，内容超出层的边界后发生的情况\nvisible(可见)，hidden, scroll, auto\nplacement(放置)：设置层的大小和位置\nclip(剪辑区域)：定义可见层的局部区域的位置和大小，可以把元素区域剪切成各种形状\n8.扩展属性分页：通过样式来为网页添加分页符号。允许用户在指定元素前后进行分页，分页是指打印网页内容时在某一位置停止，后续内容在另一页上打印。\npage-break-before ; page-break-after\n\n视觉效果：cursor(光标) fillter(过滤器)\n在CSS中有一个Alpha滤镜，这个滤镜可以设置目标元素的透明度。还可以通过指定坐标，从而实现各种不同范围的透明度。\n具体语法如下：\n&#123;filter:alpha(opacity&#x3D;opacity,\n\nfinishopacity&#x3D;finishopacity,\n\nstyle&#x3D;style,\n\nstartx&#x3D;startx,\n\nstarty&#x3D;starty,\n\nfinishx&#x3D;finishx,\n\nfinishy&#x3D;finishy)&#125;\n\n具体参数含义如下：\nopacity 透明度。默认的范围是从0 到 100，他们其实是百分比的形式。也就是说，0代表完全透明，100代表完全不透明。 \nfinishopacity 是一个可选参数，如果想要设置渐变的透明效果，就可以使用他们来指定结束时的透明度。范围也是0 到 100。 \nstyle  指定透明区域的形状特征：0 代表统一形状，1 代表线形，2 代表放射状，3 代表矩形 \nstartx  渐变透明效果开始处的 X坐标。 只能style &#x3D; 1才有效\nstarty  渐变透明效果开始处的 Y坐标。 只能style &#x3D; 1才有效 \nfinishx 渐变透明效果结束处的 X坐标。 只能style &#x3D; 1才有效\nfinishy 渐变透明效果结束处的 Y坐标。 只能style &#x3D; 1才有效 \n以上的参数可以选用，可以只设置一个opacity\n实例： \n&lt;html&gt; \n\n&lt;head&gt; \n\n&lt;title&gt;alpha效果展示：&lt;&#x2F;title&gt; \n\n&lt;style type&#x3D;&quot;text&#x2F;Css&quot;&gt;                &#x2F;&#x2F;*定义CSS样式*&#x2F;&#x2F;    \n\n.half&#123;filter:alpha(opacity&#x3D;50)&#125;    &#x2F;&#x2F;*透明度50，默认形状*&#x2F;&#x2F;  \n\n.s0&#123;filter:alpha(opacity&#x3D;30,style&#x3D;0)&#125; &#x2F;&#x2F;*透明度30，统一形状*&#x2F;&#x2F;  \n\n.s1&#123;filter:alpha(opacity&#x3D;80,style&#x3D;1)&#125; &#x2F;&#x2F;*透明度80，线性透明*&#x2F;&#x2F;  \n\n.s2&#123;filter:alpha(opacity&#x3D;80,style&#x3D;2)&#125; &#x2F;&#x2F;*透明度80，放射性*&#x2F;&#x2F;  \n\n.s3&#123;filter:alpha(opacity&#x3D;80,style&#x3D;3)&#125; &#x2F;&#x2F;*透明度80，长方形*&#x2F;&#x2F;  \n\n&lt;&#x2F;style&gt;  \n\n&lt;&#x2F;head&gt; \n\n&lt;body&gt; \n\n&lt;img src&#x3D;&quot;Sunset.jpg&quot;&gt;  \n\n&lt;img class&#x3D;half src&#x3D;&quot;Sunset.jpg&quot;&gt;   \n\n&lt;img class&#x3D;s0 src&#x3D;&quot;Sunset.jpg&quot;&gt;     \n\n&lt;img class&#x3D;s1 src&#x3D;&quot;Sunset.jpg&quot;&gt;      \n\n&lt;img class&#x3D;s2 src&#x3D;&quot;Sunset.jpg&quot;&gt;        \n\n&lt;img class&#x3D;s3 src&#x3D;&quot;Sunset.jpg&quot;&gt;       \n\n&lt;&#x2F;body&gt; \n\n&lt;&#x2F;html&gt;\n\n9.标准文档流组成&amp;display属性块级元素（block level）&lt;h1&gt;~&lt;h6&gt;,&lt;p&gt;,&lt;div&gt;,&lt;hr&gt;,列表\n\n列表：&lt;ul&gt;\n    &lt;li&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;dl&gt;\n\n&lt;dt&gt;&lt;&#x2F;dt&gt;\n\n&lt;dd&gt;&lt;&#x2F;dd&gt;\n\n&lt;&#x2F;dl&gt;\n\n内联元素（inline）&lt;span&gt;,&lt;a&gt;,&lt;img&#x2F;&gt;,&lt;strong&gt;\n\n内联标签可以包含于块级标签中，成为它的子元素\ndisplay属性：控制元素的显示与隐藏；\n块级元素和行级元素之间的转换；\n\n\n\nblock\n块级元素的默认值，元素会被显示为块级元素，该元素前后会带有换行符\n\n\n\ninline\n内联元素的默认值，元素会被显示为内联元素，该元素前后不会带有换行符\n\n\nnone\n设置元素不会被显示\n\n\n10.float浮动属性\n\n\nleft\n元素向左浮动\n\n\n\nright\n元素向右浮动\n\n\nnone\n默认值，元素不浮动，并会显示在其文本中的位置\n\n\nclear属性\n\n\nleft\n在左侧不允许浮动元素\n\n\n\nright\n在右侧不允许浮动元素\n\n\nboth\n在左右两侧不允许浮动元素\n\n\nnone\n默认值，允许浮动元素出现在两侧\n\n\n11.overflow属性（溢出处理）\n\n\nvisible\n默认值，内容不会被修剪，会呈现在盒子之外\n\n\n\nhidden\n内容会被修剪，并且其余内容比可见\n\n\nscroll\n内容会被修剪，但浏览器会显示滚动条，以显示其余内容\n\n\nauto\n如果内容会被修剪，但浏览器会显示滚动条，以显示其余内容\n\n\n12.position属性（元素定位）\n\n\nstatic\n默认值，没有定位\n\n\n\nrelative\n相对定位\n\n\nabsolute\n绝对定位\n\n\nfixed\n固定定位（在一些浏览器中不支持，使用较少）\n\n\nrelative:相对自身原来的位置进行偏移\n&#123;\n\nposition:relative;\n\ntop: px;\n\nbottom: px;\n\nleft: px;\n\nright: px;\n\n&#125;\n\n(px值可为负数，以浏览器为参照进行偏移，正值为偏离参照物，负值为接近参照物)\n设置相对定位的盒子会相对它原来的位置，通过指定偏移，到达新的位置。\n设置相对定位的盒子仍在标准流中，它对父级盒子和相邻的盒子都没有任何影响。\n设置了position属性值为relative的网页元素，无论是在标准流中还是在浮动流中，都不会对它的父级元素和相邻元素有任何影响，它只针对自身原来的位置进行偏移。\nabsolute：绝对定位，以某个参照物进行位置偏移\n&#123;\n\nposition:absolute;\n\ntop: px;\n\nbottom: px;\n\nleft: px;\n\nright: px;\n\n&#125;\n\n（px值可为负数，以浏览器为参照进行偏移，px为正值时，效果为距离浏览器边框距离，负值为远离浏览器边框的距离）\n使用了绝对定位的元素以它最近的一个：“已经定位”的“祖先元素”为基准进行偏移。如果没有已经定位的祖先元素，那么会以浏览器窗口为基准进行定位。\n绝对定位的元素从标准文档流中脱离，这意味着它们对其他元素的定位不会造成影响。\n13.z-index属性（调整元素定位时重叠层的上下位置）z-index属性值：整数，默认值为0；\n设置了position属性时，z-index属性可以设置各元素之间的重叠高低关系；\nz-index值大的层位于其值小的层上方；\n14.网页元素透明度&amp;CSS元素透明度\n\n\nopacity:x 属性\nx值为0~1，值越小越透明\nopacity:0.4;\n\n\n\nfilter:alpha(opacity&#x3D;x)\nx值为0~100,值越小越透明\nfilter:alpha(opacity&#x3D;40);\n\n\n","slug":"2_CSS_02","date":"2022-10-06T07:28:25.928Z","categories_index":"编程","tags_index":"HTML/CSS","author_index":"FangH"},{"id":"fdd7c70afe97f7b4969565b83472fc45","title":"C++_职工管理系统","content":"C++_职工管理系统1. 管理系统需求系统需求：\n\n职工管理系统可以用来管理公司内所有员工的信息\n公司职工分三类：普通员工，经理，老板；\n显示员工信息：显示职工编号，职工姓名，职工岗位\n职责：\n普通员工职责：完成经理的任务\n经理职责：完成老板的任务\n老板：管理所有事务\n\n\n\n管理系统需要的功能：\n\n退出管理程序：退出当前管理系统\n增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号，姓名，部门编号\n显示职工信息：显示公司内部所有职工的信息\n删除离职职工：按照编号删除指定的职工\n修改职工信息：按照编号修改职工个人信息\n查找职工信息：按照职工的编号或者职工的姓名进行查找相关人员信息\n按照编号排序：按照职工编号，进行排序，排序规则由用户指定\n清空所有文档：清空文件中记录的所有职工信息（清空前需要确认，防止误删）\n\n2. 创建管理类\n管理类的内容：\n用户的沟通菜单界面\n对职工增删改查的操作\n与文件的读写交互\n\n\n\n2.1 创建文件\nClion中创建\n头文件：workerManager.h\n源文件：workerManager.cpp\n主文件：StaffManagerSystem_Main.cpp\nCMakeList.txt\n\n\n\n2.2 创建管理类文件\nCMakeList.txt\ncmake_minimum_required(VERSION 3.19)\nproject(StaffManagementSystem)\n\nset(CMAKE_CXX_STANDARD 14)\n\nadd_executable(StaffManagementSystem StaffManagerSystem_Main.cpp workerManager.h workerManager.cpp)\n\nworkerManager.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n#define STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass WorkerManager\n&#123;\npublic:\n    WorkerManager();\n    ~WorkerManager();\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n\nworkerManager.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n#include &quot;workerManager.h&quot;\n\nWorkerManager::WorkerManager()\n&#123;\n\n&#125;\n\nWorkerManager::~WorkerManager()\n&#123;\n\n&#125;\n\nStaffManagerSystem_Main.cpp\n#include &lt;iostream&gt;\n#include &quot;workerManager.h&quot;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;\n    return 0;\n&#125;\n\n3. 菜单功能\n功能描述：与用户沟通的界面\n\n3.1 添加成员函数\n在workerManager.h中的WorkerManager类中添加成员函数：void Show_Menu();\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n#define STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n#define wm workerManager\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass WorkerManager\n&#123;\npublic:\n    WorkerManager();\n    ~WorkerManager();\n\n    &#x2F;&#x2F; 显示菜单\n    void Show_Menu();\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n\n3.2 菜单功能实现\n在管理类 workerManager.cpp 中实现具体 Show_Menu() 函数\nvoid WorkerManager::Show_Menu()\n&#123;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;员工管理系统主菜单&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;0.退出管理系统&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1.增加职工信息&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2.显示职工信息&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3.删除离职职工&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;4.修改职工信息&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;5.查找职工信息&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;6.按照编号排序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;7.清空所有文档&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; endl;\n&#125;\n\n3.3 测试菜单功能\n在StaffManagerSystem_Main.cpp中进行测试\n#include &lt;iostream&gt;\n#include &quot;workerManager.h&quot;\n\nint main()\n&#123;\n    WorkerManager workerManager;\n    wm.Show_Menu();\n    return 0;\n&#125;\n\n4. 退出功能4.1 提供菜单功能接口\n在main函数中提供分支选择，提供菜单界面每个功能的接口\n\n先创建一个StaffManagerSystem_Main.cpp中的函数showMenu()&#123;&#125;;\n#include &lt;iostream&gt;\n#include &quot;workerManager.h&quot;\n\nvoid showMenu()\n&#123;\n        &#x2F;&#x2F; 初始选择\n    int choice &#x3D; 0;\n\n    &#x2F;&#x2F; 生成 管理界面 对象\n    WorkerManager workerManager;\n    &#x2F;&#x2F; 调用 菜单界面\n    ReShowMenu:\n    wm.Show_Menu();\n    cout &lt;&lt; &quot;功能选择 &gt;&gt; &quot;;\n    cin &gt;&gt; choice;\n\n    &#x2F;&#x2F; 菜单界面的功能选择分支\n    switch (choice)\n    &#123;\n        case 0: &#x2F;&#x2F; 0.退出管理系统\n            wm.exitSystem();\n            break;\n        case 1: &#x2F;&#x2F; 1.增加职工信息\n            break;\n        case 2: &#x2F;&#x2F; 2.显示职工信息\n            break;\n        case 3: &#x2F;&#x2F; 3.删除离职职工\n            break;\n        case 4: &#x2F;&#x2F; 4.修改职工信息\n            break;\n        case 5: &#x2F;&#x2F; 5.查找职工信息\n            break;\n        case 6: &#x2F;&#x2F; 6.按照编号排序\n            break;\n        case 7: &#x2F;&#x2F; 7.清空所有文档\n            break;\n        default: &#x2F;&#x2F; 0 ~ 7 之外任意值，清空，重来菜单界面\n            system(&quot;cls&quot;);\n            goto ReShowMenu;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    showMenu();\n    return 0;\n&#125;\n\n4.2 实现退出功能\n在workerManager.h中提供退出系统的成员函数 void exitSystem();\n\n在workerManager.cpp中具体实现功能\n&#x2F;&#x2F; 0.退出管理系统\nvoid WorkerManager::exitSystem()\n&#123;\n    cout &lt;&lt; &quot;员工管理系统-退出&quot; &lt;&lt; endl;\n    exit(0);\n&#125;\n\n5. 创建职工类5.1 创建职工抽象类\n职工分类：\n\n普通员工\n经理\n老板\n\n\n将三种职工抽象到一个类Worker中，利用多态管理不同职工类\n\n职工的属性：\n\n职工编号\n职工姓名\n职工部门编号\n\n\n职工行为：\n\n岗位职责信息描述\n获取岗位名称\n\n\n创建头文件 worker.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_WORKER_H\n#define STAFFMANAGEMENTSYSTEM_WORKER_H\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 职工抽象类\nclass Worker\n&#123;\npublic:\n    int worker_ID; &#x2F;&#x2F; 职工ID\n    string worker_Name; &#x2F;&#x2F; 职工姓名\n    int worker_DepartID; &#x2F;&#x2F; 职工部门编号\n\n    &#x2F;&#x2F; 获得 职工的信息\n    virtual void getWorkerInfo() &#x3D; 0;\n\n    &#x2F;&#x2F; 获得 职工部门的岗位名称\n    virtual void getWorkerDepartName() &#x3D; 0;\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_WORKER_H\n\n5.2 创建普通员工类\n普通员工继承职工抽象类，并重写父类中的纯虚函数\n\n在头文件和源文件的文件夹中创建employee.h和employee.cpp\n\nemployee.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_EMPLOYEE_H\n#define STAFFMANAGEMENTSYSTEM_EMPLOYEE_H\n\n#include &quot;worker.h&quot;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Employee : public Worker\n&#123;\npublic:\n    &#x2F;&#x2F; 初始化 员工 构造函数\n    Employee(int w_Id, string w_Name, int w_DepartId);\n\n    &#x2F;&#x2F; 获得员工个人信息\n    void getWorkerInfo() override;\n\n    &#x2F;&#x2F; 获得员工部门岗位名称\n    void getWorkerDepartName() override;\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_EMPLOYEE_H\n\nemployee.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n#include &quot;..&#x2F;Header&#x2F;employee.h&quot;\n\nEmployee::Employee(int w_Id, string w_Name, int w_DepartId)\n&#123;\n    this-&gt;worker_ID &#x3D; w_Id;\n    this-&gt;worker_Name &#x3D; w_Name;\n    this-&gt;worker_DepartID &#x3D; w_DepartId;\n&#125;\n\nvoid Employee::getWorkerInfo()\n&#123;\n    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;worker_ID\n         &lt;&lt; &quot;\\t职工姓名：&quot; &lt;&lt; this-&gt;worker_Name\n         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()\n         &lt;&lt; &quot;\\t岗位职责：完成经理的任务&quot; &lt;&lt; endl;\n&#125;\n\nstring Employee::getWorkerDepartName()\n&#123;\n    return string(&quot;普通员工&quot;);\n&#125;\n\n5.3 创建经理类\n经理类继承职工抽象类，并重写父类中虚函数\n\n在头文件和源文件文件夹内，创建manager.h和manager.cpp\n\nmanager.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_MANAGER_H\n#define STAFFMANAGEMENTSYSTEM_MANAGER_H\n\n#include &quot;worker.h&quot;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 经理类\nclass Manager : public Worker\n&#123;\npublic:\n    &#x2F;&#x2F; 初始化 经理 构造函数\n    Manager(int w_Id, string w_Name, int w_DepartId);\n\n    &#x2F;&#x2F; 获得经理个人信息\n    void getWorkerInfo() override;\n\n    &#x2F;&#x2F; 获得经理部门岗位名称\n    string getWorkerDepartName() override;\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_MANAGER_H\n\nmanager.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#include &quot;..&#x2F;Header&#x2F;manager.h&quot;\n\n&#x2F;&#x2F; 构造函数 初始化 经理 信息\nManager::Manager(int w_Id, string w_Name, int w_DepartId)\n&#123;\n    this-&gt;worker_ID &#x3D; w_Id;\n    this-&gt;worker_Name &#x3D; w_Name;\n    this-&gt;worker_DepartID &#x3D; w_DepartId;\n&#125;\n\n&#x2F;&#x2F; 获得 职工信息\nvoid Manager::getWorkerInfo()\n&#123;\n    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;worker_ID\n         &lt;&lt; &quot;\\t职工姓名：&quot; &lt;&lt; this-&gt;worker_Name\n         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()\n         &lt;&lt; &quot;\\t岗位职责：完成老板的任务&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 获得 职工 岗位信息\nstring Manager::getWorkerDepartName()\n&#123;\n    return string(&quot;经理&quot;);\n&#125;\n\n5.4 创建老板类\n老板类继承职工抽象类，并重写父类中虚函数\n\n在头文件和源文件文件夹内，创建boss.h和boss.cpp\n\nboss.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_BOSS_H\n#define STAFFMANAGEMENTSYSTEM_BOSS_H\n\n#include &quot;worker.h&quot;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 老板类\nclass Boss : public Worker\n&#123;\npublic:\n    &#x2F;&#x2F; 初始化 老板 构造函数\n    Boss(int w_Id, string w_Name, int w_DepartId);\n\n    &#x2F;&#x2F; 获得老板个人信息\n    void getWorkerInfo() override;\n\n    &#x2F;&#x2F; 获得老板部门岗位名称\n    string getWorkerDepartName() override;\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_BOSS_H\n\nboss.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#include &quot;..&#x2F;Header&#x2F;boss.h&quot;\n\n&#x2F;&#x2F; 构造函数 初始化 老板 信息\nBoss::Boss(int w_Id, string w_Name, int w_DepartId)\n&#123;\n    this-&gt;worker_ID &#x3D; w_Id;\n    this-&gt;worker_Name &#x3D; w_Name;\n    this-&gt;worker_DepartID &#x3D; w_DepartId;\n&#125;\n\n&#x2F;&#x2F; 获得 职工信息\nvoid Boss::getWorkerInfo()\n&#123;\n    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;worker_ID\n         &lt;&lt; &quot;\\t职工姓名：&quot; &lt;&lt; this-&gt;worker_Name\n         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()\n         &lt;&lt; &quot;\\t岗位职责：管理所有事务&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 获得 职工 岗位信息\nstring Boss::getWorkerDepartName()\n&#123;\n    return string(&quot;老板&quot;);\n&#125;\n\n5.5 测试多态\n在StaffManagerSystem_Main.cpp中添加测试函数void demo()&#123;&#125;;\n\n测试代码：\n#include &lt;iostream&gt;\n#include &quot;..&#x2F;Header&#x2F;workerManager.h&quot;\n#include &quot;..&#x2F;Header&#x2F;worker.h&quot;\n#include &quot;..&#x2F;Header&#x2F;employee.h&quot;\n#include &quot;..&#x2F;Header&#x2F;manager.h&quot;\n#include &quot;..&#x2F;Header&#x2F;boss.h&quot;\n\nvoid demo()\n&#123;\n    Worker *worker &#x3D; nullptr;\n    \n    worker &#x3D; new Employee(1, &quot;Normal_A&quot;, 1);\n    worker-&gt;getWorkerInfo();\n    \n    worker &#x3D; new Manager(2, &quot;Manager_A&quot;, 2);\n    worker-&gt;getWorkerInfo();\n    \n    worker &#x3D; new Boss(3, &quot;Boss_A&quot;, 3);\n    worker-&gt;getWorkerInfo();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n6. 添加职工\n功能描述：批次添加职工，并保存到文件中\n\n6.1 功能分析\n分析：\n用户在批量创建时，可能创建不同种类的职工\n如果想将所有不同种类的职工都放在一个数组中，可以将所有员工的指针维护到一个数租里\n如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker **维护\n\n\n堆区开辟以Worker类型的数组：Worker ** = new Worker*[];\n\n6.2 功能实现\n在WorkerManager.h添加成员属性\n&#x2F;&#x2F; 记录文件中的人数\nint worker_EmpNum;\n\n    &#x2F;&#x2F; 员工数组指针\n    Worker ** worker_EmpArray;\n\n\n\n在WorkerManager.cpp中构造函数初始化属性\nWorkerManager::WorkerManager()\n&#123;\n    &#x2F;&#x2F; 初始化人数\n    this-&gt;worker_EmpNum &#x3D; 0;\n\n    &#x2F;&#x2F; 初始化数组指针\n    this-&gt;worker_EmpArray &#x3D; nullptr;\n&#125;\n\n\n\n在WorkerManager.h添加成员函数\n&#x2F;&#x2F; 1.增加职工信息\n void addEmployee();\n\n\n\n在WorkerManager.cpp中实现void addEmployee()&#123;&#125;\n&#x2F;&#x2F; 1.增加职工信息\nvoid WorkerManager::addEmployee()\n&#123;\n    cout &lt;&lt; &quot;输入增加职工数量：&gt;&gt;&quot;;\n    int addNum &#x3D; 0;\n    cin &gt;&gt; addNum;\n\n    if (addNum &gt; 0)\n    &#123;\n        &#x2F;&#x2F; 计算需要的空间大小 &#x3D; 已用的空间 + 新需要的空间\n        int newSize &#x3D; this-&gt;worker_EmpNum + addNum;\n\n        &#x2F;&#x2F; 在 堆区中开辟 计算好大小的内存空间\n        Worker **newSpace &#x3D; new Worker *[newSize];\n\n        &#x2F;&#x2F; 将已有空间的内容存在新的内村空间中\n        if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n        &#123;\n            for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n            &#123;\n                newSpace[i] &#x3D; this-&gt;worker_EmpArray[i];\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 再将 需要添加的新内容加入\n        for (int j &#x3D; 0; j &lt; addNum; j++)\n        &#123;\n            int worker_ID; &#x2F;&#x2F; 职工ID\n            string worker_Name; &#x2F;&#x2F; 职工姓名\n            int worker_DepartID; &#x2F;&#x2F; 职工部门编号\n\n            cout &lt;&lt; &quot;输入第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;位员工信息:&quot; &lt;&lt; endl;\n            cout &lt;&lt; &quot;职工编号&gt;&gt;&quot;;\n            cin &gt;&gt; worker_ID;\n\n            cout &lt;&lt; &quot;职工姓名&gt;&gt;&quot;;\n            cin &gt;&gt; worker_Name;\n\n            cout &lt;&lt; &quot;职工岗位_ 1.员工_2.经理_3.老板&gt;&gt;&quot;;\n            cin &gt;&gt; worker_DepartID;\n\n            Worker *worker &#x3D; nullptr;\n\n            switch (worker_DepartID)\n            &#123;\n                case 1:\n                    worker &#x3D; new Employee(worker_ID, worker_Name, 1);\n                    break;\n                case 2:\n                    worker &#x3D; new Manager(worker_ID, worker_Name, 2);\n                    break;\n                case 3:\n                    worker &#x3D; new Boss(worker_ID, worker_Name, 3);\n                    break;\n                default:\n                    break;\n            &#125;\n\n            newSpace[this-&gt;worker_EmpNum + j] &#x3D; worker;\n        &#125;\n        &#x2F;&#x2F; 释放原本的空间\n        delete[] this-&gt;worker_EmpArray;\n\n        &#x2F;&#x2F; 更改新空间的指向\n        this-&gt;worker_EmpArray &#x3D; newSpace;\n\n        &#x2F;&#x2F; 更新 新的个数\n        this-&gt;worker_EmpNum &#x3D; newSize;\n\n        &#x2F;&#x2F; 提示信息\n        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;需输入正确的数字&quot; &lt;&lt; endl;\n    &#125;\n\n    system(&quot;cls&quot;);\n&#125;\n\n6.3 测试添加\n部分修改：\n\nworkerManager.h\n#include &lt;iostream&gt;\n#include &quot;worker.h&quot;\n#include &quot;employee.h&quot;\n#include &quot;manager.h&quot;\n#include &quot;boss.h&quot;\n\nStaffManagerSystem_Main.cpp\n#include &lt;iostream&gt;\n#include &quot;..&#x2F;Header&#x2F;workerManager.h&quot;\n\nvoid showMenu()\n&#123;\n    &#x2F;&#x2F; 初始选择\n    int choice &#x3D; 0;\n\n    &#x2F;&#x2F; 生成 管理界面 对象\n    WorkerManager workerManager;\n\n    &#x2F;&#x2F; 调用 菜单界面\n    while (true)\n    &#123;\n        wm.Show_Menu();\n        cout &lt;&lt; &quot;功能选择 &gt;&gt; &quot;;\n        cin &gt;&gt; choice;\n\n        &#x2F;&#x2F; 菜单界面的功能选择分支\n        switch (choice)\n        &#123;\n            case 0: &#x2F;&#x2F; 0.退出管理系统\n                wm.exitSystem();\n                break;\n            case 1: &#x2F;&#x2F; 1.增加职工信息\n                wm.addEmployee();\n                break;\n            case 2: &#x2F;&#x2F; 2.显示职工信息\n                break;\n            case 3: &#x2F;&#x2F; 3.删除离职职工\n                break;\n            case 4: &#x2F;&#x2F; 4.修改职工信息\n                break;\n            case 5: &#x2F;&#x2F; 5.查找职工信息\n                break;\n            case 6: &#x2F;&#x2F; 6.按照编号排序\n                break;\n            case 7: &#x2F;&#x2F; 7.清空所有文档\n                break;\n            default: &#x2F;&#x2F; 0 ~ 7 之外任意值，清空，重来菜单界面\n                system(&quot;cls&quot;);\n                break;\n        &#125;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    showMenu();\n    return 0;\n&#125;\n\nworkerManager.cpp\nWorkerManager::~WorkerManager()\n&#123;\n    if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n    &#123;\n        delete[] this-&gt;worker_EmpArray;\n        this-&gt;worker_EmpArray &#x3D; nullptr;\n    &#125;\n&#125;\n\n\n\n6.4 补充：职工ID唯一性\n确保职工文件内，每个职工的worker_ID是唯一的\n\n在workerManager.h中添加成员函数bool isEmployeeIDExist(int workerID);\n&#x2F;&#x2F; 排查添加的新职工的编号在文件中是否存在\nbool isEmployeeIDExist(int workerID);\n\n在workerManager.cpp中实现成员函数bool isEmployeeIDExist(int workerID)&#123;&#125;\n&#x2F;&#x2F; 排查添加的新职工的编号在文件中是否存在\nbool WorkerManager::isEmployeeIDExist(int workerID)\n&#123;\n    bool isIDExist &#x3D; true;\n    for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n    &#123;\n        if (this-&gt;worker_EmpArray[i]-&gt;worker_ID &#x3D;&#x3D; workerID)\n        &#123;\n            isIDExist &#x3D; true;\n            break;\n        &#125;\n        else\n        &#123;\n            isIDExist &#x3D; false;\n        &#125;\n    &#125;\n    return isIDExist;\n&#125;\n\n修改workerManager.cpp中的成员函数void addEmployee()&#123;&#125;\n&#x2F;&#x2F; 1.增加职工信息\nvoid WorkerManager::addEmployee()\n&#123;\n    cout &lt;&lt; &quot;&lt;-- 已录入职工数量：&quot; &lt;&lt; worker_EmpNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入增加职工数量：&gt;&gt; &quot;;\n    int addNum &#x3D; 0;\n    cin &gt;&gt; addNum;\n\n    if (addNum &gt; 0)\n    &#123;\n        &#x2F;&#x2F; 计算需要的空间大小 &#x3D; 已用的空间 + 新需要的空间\n        int newSize &#x3D; this-&gt;worker_EmpNum + addNum;\n\n        &#x2F;&#x2F; 在 堆区中开辟 计算好大小的内存空间\n        Worker **newSpace &#x3D; new Worker *[newSize];\n\n        &#x2F;&#x2F; 将已有空间的内容存在新的内村空间中\n        if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n        &#123;\n            for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n            &#123;\n                newSpace[i] &#x3D; this-&gt;worker_EmpArray[i];\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 再将 需要添加的新内容加入\n        for (int j &#x3D; 0; j &lt; addNum; j++)\n        &#123;\n            int worker_ID; &#x2F;&#x2F; 职工ID\n            string worker_Name; &#x2F;&#x2F; 职工姓名\n            int worker_DepartID; &#x2F;&#x2F; 职工部门编号\n            bool isExistID &#x3D; true; &#x2F;&#x2F; 新增的变量，用于判断文件中是否已存在某个ID\n\n            &#x2F;&#x2F; 在输入职工ID的地方，进行了修改\n            &#x2F;&#x2F; 每次输入ID，都要判断一次，输入的ID在职工文件中是否已经存在\n            &#x2F;&#x2F; 存在就继续循环该语句，不存在再继续执行\n            while (true)\n            &#123;\n                cout &lt;&lt; &quot;输入第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;位员工信息:&quot; &lt;&lt; endl;\n                cout &lt;&lt; &quot;职工编号&gt;&gt; &quot;;\n                cin &gt;&gt; worker_ID;\n                isExistID &#x3D; isEmployeeIDExist(worker_ID);\n\n                if (isExistID)\n                &#123;\n                    cout &lt;&lt; &quot;编号已经存在&quot; &lt;&lt; endl;\n                    system(&quot;pause&quot;);\n                    system(&quot;cls&quot;);\n                &#125;\n                else\n                &#123;\n                    break;\n                &#125;\n            &#125;\n\n            cout &lt;&lt; &quot;职工姓名&gt;&gt; &quot;;\n            cin &gt;&gt; worker_Name;\n\n            cout &lt;&lt; &quot;职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;\n            cin &gt;&gt; worker_DepartID;\n            cout &lt;&lt; endl;\n\n            Worker *worker &#x3D; nullptr;\n\n            switch (worker_DepartID)\n            &#123;\n                case 1:\n                    worker &#x3D; new Employee(worker_ID, worker_Name, 1);\n                    break;\n                case 2:\n                    worker &#x3D; new Manager(worker_ID, worker_Name, 2);\n                    break;\n                case 3:\n                    worker &#x3D; new Boss(worker_ID, worker_Name, 3);\n                    break;\n                default:\n                    break;\n            &#125;\n\n            newSpace[this-&gt;worker_EmpNum + j] &#x3D; worker;\n        &#125;\n        &#x2F;&#x2F; 释放原本的空间\n        delete[] this-&gt;worker_EmpArray;\n\n        &#x2F;&#x2F; 更改新空间的指向\n        this-&gt;worker_EmpArray &#x3D; newSpace;\n\n        &#x2F;&#x2F; 更新 新的个数\n        this-&gt;worker_EmpNum &#x3D; newSize;\n\n        &#x2F;&#x2F; 更新 文件不在为假\n        this-&gt;isFileEmpty &#x3D; false;\n\n        &#x2F;&#x2F; 提示信息\n        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;\n\n        &#x2F;&#x2F; 保存录入的职工信息到文本文件中\n        this-&gt;saveNewToFile();\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;需输入正确的数字&quot; &lt;&lt; endl;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n7. 文件交互7.1 写文件\n功能描述：对文件进行读写\n在上一个添加功能中，只完成了将数据添加到内存中，程序结束数据将被回收\n需求给项目的文件管理类添加一个文件交互功能，将数据保存到文本中，进行写操作\n\n\n\n7.1.1 设定文件路径\n首先是设定文件路径\n\n路径的选择最好是项目内，采用相对路径，在项目目录下创建文件夹 File\n\n在workerManager.h中添加宏常量，并包含头文件fstream.h\n#define WORKER_FILENAME &quot;..&#x2F;File&#x2F;workerFile.txt&quot;\n#include &lt;fstream&gt;\n\n7.1.2 成员函数声明\n在workerManager.h中添加成员函数void saveNewToFile();\n&#x2F;&#x2F; 保持录入职工的信息到文件\nvoid saveNewToFile();\n\n7.1.3 保存文件实现workerManager.cpp\n&#x2F;&#x2F; 保持录入职工的信息到文件\nvoid WorkerManager::saveNewToFile()\n&#123;\n    ofstream ofs;\n    ofs.open(WORKER_FILENAME, ios::out);\n\n    for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n    &#123;\n        ofs &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_ID &lt;&lt; &quot; &quot;\n            &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_Name &lt;&lt; &quot; &quot;\n            &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_DepartID &lt;&lt; endl;\n    &#125;\n\n    ofs.close();\n&#125;\n\n\n\n\n\n7.1.4 保存文件测速\n在workerManager.cpp实现的添加职工功能打印成功后面，添加保存文件的函数void saveNewToFile();\n &#x2F;&#x2F; 提示信息\ncout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;\n\n&#x2F; 保存录入的职工信息到文本文件中\n this-&gt;saveNewToFile();\n\n7.2 读文件\n功能描述：将文件中的内容读取到程序中\n\n上一个功能完成了在程序中将堆中的数据保存到文本文件中，但还需要一个程序启动时，读取文本文件数据到堆中的功能\n\n同时需要完成清空文本文件的功能\n\n构造函数初始化数据的情况分三种：\n\n第一次使用，文件未创建\n文件存在，数据被清空\n文件存在，数据也存在\n\n\n\n7.2.1 文件未创建\n在workerManager.h中添加成员变量，bool isFileEmpty; 来标记文件是否为空\n&#x2F;&#x2F; 判断文件是否为空\nbool isFileEmpty;\n\n\n\n\n修改workerManager.cpp中的构造函数\nWorkerManager::WorkerManager()\n&#123;\n    &#x2F;&#x2F; 初始化 读文件对象\n    ifstream ifs;\n    ifs.open(WORKER_FILENAME, ios::in);\n\n    &#x2F;&#x2F; 文件不存在的情况\n    if (!ifs.is_open())\n    &#123;\n        cout &lt;&lt; &quot;文件不存在&quot; &lt;&lt; endl;\n        this-&gt;worker_EmpNum &#x3D; 0;\n        this-&gt;worker_EmpArray &#x3D; nullptr;\n        &#x2F;&#x2F; 初始化 文件 是空\n        this-&gt;isFileEmpty &#x3D; true;\n        ifs.close();\n        return;\n    &#125;\n    \n    &#x2F;&#x2F; 初始化人数\n    this-&gt;worker_EmpNum &#x3D; 0;\n\n    &#x2F;&#x2F; 初始化数组指针\n    this-&gt;worker_EmpArray &#x3D; nullptr;\n\n    &#x2F;&#x2F; 判断文件是否为空\n    this-&gt;isFileEmpty &#x3D; false;\n&#125;\n\n确保项目中，没有workerFile.txt文件存在，运行时，可以看到打印结果，同时完成初始化\n\n\n7.2.2 文件存在且数据为空\nworkerManager.cpp中，在构造函数中加入代码\nWorkerManager::WorkerManager()\n&#123;\n    &#x2F;&#x2F; 初始化 读文件对象\n    ifstream ifs;\n    ifs.open(WORKER_FILENAME, ios::in);\n\n    &#x2F;&#x2F; 文件不存在的情况\n    if (!ifs.is_open())\n    &#123;\n        cout &lt;&lt; &quot;&lt;-- 提示：职工文件不存在 --&gt;&quot; &lt;&lt; endl;\n        this-&gt;worker_EmpNum &#x3D; 0;\n        this-&gt;worker_EmpArray &#x3D; nullptr;\n        &#x2F;&#x2F; 初始化 文件 是空\n        this-&gt;isFileEmpty &#x3D; true;\n        ifs.close();\n        return;\n    &#125;\n\n    &#x2F;&#x2F; 文件存在 数据为空\n    string str;\n    ifs &gt;&gt; str;\n    if (ifs.eof())\n    &#123;\n        cout &lt;&lt; &quot;&lt;-- 提示：职工文件为空 --&gt;&quot; &lt;&lt; endl;\n        this-&gt;worker_EmpNum &#x3D; 0;\n        this-&gt;worker_EmpArray &#x3D; nullptr;\n        this-&gt;isFileEmpty &#x3D; true;\n        ifs.close();\n        return;\n    &#125;\n&#125;\n\n同时，在文件存在时，文件判空变量isFileEmpty需要修改为false；\n\n在workerManager.cpp中的void WorkerManager::addEmployee()中，进行更改\n&#x2F;&#x2F; 更改新空间的指向\nthis-&gt;worker_EmpArray &#x3D; newSpace;\n\n&#x2F;&#x2F; 更新 新的个数\nthis-&gt;worker_EmpNum &#x3D; newSize;\n\n&#x2F;&#x2F; 更新 文件不在为空\nthis-&gt;isFileEmpty &#x3D; false;\n\n&#x2F;&#x2F; 提示信息\ncout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;\n\n此时先创建项目文件，可以手动在File文件夹内直接新建workerFile.txt；\n\n也可以先运行项目，添加职工信息后，手动删除文件内的内容，再进行测速上面的代码\n\n\n7.2.3 文件存在且有数据7.2.3.1 获取记录的职工人数\n在workerManager.h中添加成员函数int getEmpNum();\n&#x2F;&#x2F; 获得记录职工人数\nint getEmpNum();\n\n在workerMananger.cpp中实现功能\n&#x2F;&#x2F; 获得记录职工人数\nint WorkerManager::getEmpNum()\n&#123;\n    ifstream ifs;\n    ifs.open(WORKER_FILENAME, ios::in);\n\n    &#x2F;&#x2F; 存入 读到的数据\n    int worker_ID;\n    string worker_Name;\n    int worker_DepartID;\n    &#x2F;&#x2F; 初始化 记录人数\n    int empNum &#x3D; 0;\n\n    &#x2F;&#x2F; 当 读文件操作对象 返回为真\n    while (ifs &gt;&gt; worker_ID &amp;&amp; ifs &gt;&gt; worker_Name &amp;&amp; ifs &gt;&gt; worker_DepartID)\n    &#123;\n        &#x2F;&#x2F; 记录人数 +1\n        empNum++;\n    &#125;\n    ifs.close();\n    \n    return empNum;\n&#125;\n\n在workerManager.cpp的构造函数中继续添加测试代码\n&#x2F;&#x2F; 文件存在 有数据\n&#x2F;&#x2F; 获得文件已记录人数\nint empNum &#x3D; this-&gt;getEmpNum();\n&#x2F;&#x2F; 更新 记录人数\nthis-&gt;worker_EmpNum &#x3D; empNum;\ncout &lt;&lt; &quot;&lt;-- 职工数量: &quot; &lt;&lt; empNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;\n\n此时可以运行项目，添加数个职工信息后，再重新启动项目，即可看到测试数据\n\n\n7.2.3.2 初始化职工信息数组\n根据职工的数据以及职工数据，初始化workerManager.h中的Worker ** worker_EmpArray;指针\n\n在workerManager.h中添加成员函数void initEmployee();\n &#x2F;&#x2F; 初始化职工\nvoid initEmployee();\n\n在workerManager.cpp中实现void initEmployee()&#123;&#125;\n&#x2F;&#x2F; 初始化职工\nvoid WorkerManager::initEmployee()\n&#123;\n    ifstream ifs;\n    ifs.open(WORKER_FILENAME, ios::in);\n\n    &#x2F;&#x2F; 存入 读到的数据\n    int worker_ID;\n    string worker_Name;\n    int worker_DepartID;\n    &#x2F;&#x2F; 初始化 记录人数\n    int index &#x3D; 0;\n\n    &#x2F;&#x2F; 当 读文件操作对象 返回为真\n    while (ifs &gt;&gt; worker_ID &amp;&amp; ifs &gt;&gt; worker_Name &amp;&amp; ifs &gt;&gt; worker_DepartID)\n    &#123;\n        Worker *worker &#x3D; nullptr;\n\n        &#x2F;&#x2F; 根据 DepartID，创建不同职工对象\n        if (worker_DepartID &#x3D;&#x3D; 1)\n        &#123;\n            worker &#x3D; new Employee(worker_ID, worker_Name, worker_DepartID);\n        &#125;\n        else if (worker_DepartID &#x3D;&#x3D; 2)\n        &#123;\n            worker &#x3D; new Manager(worker_ID, worker_Name, worker_DepartID);\n        &#125;\n        else\n        &#123;\n            worker &#x3D; new Boss(worker_ID, worker_Name, worker_DepartID);\n        &#125;\n        &#x2F;&#x2F; 生成职工对象后，存入职工数组中\n        this-&gt;worker_EmpArray[index] &#x3D; worker;\n        index++;\n    &#125;\n    ifs.close();\n&#125;\n\n在workerManager.cpp的构造函数中继续添加代码\n&#x2F;&#x2F; 根据职工数量创建数组\nthis-&gt;worker_EmpArray &#x3D; new Worker *[this-&gt;worker_EmpNum];\nthis-&gt;initEmployee();\n&#x2F;&#x2F; 测试代码\nfor (int i &#x3D; 0; i &lt;worker_EmpNum; i++)\n&#123;\n\tcout &lt;&lt; &quot;&lt;-- 职工编号：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_ID\n\t\t&lt;&lt; &quot;职工姓名：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_Name\n\t\t&lt;&lt; &quot;职工部门：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_DepartID\n\t\t&lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;\n&#125;\n\n8. 显示职工\n功能描述：显示已录入职工文件内所有的职工信息\n\n8.1 显示职工函数声明\n在workerManager.h中添加成员函数void showEmployeeInfo();\n&#x2F;&#x2F; 2.显示职工信息\nvoid showEmployeeInfo();\n\n8.2 显示职工函数实现\n在workerManager.cpp中实现函数void showEmployeeInfo()&#123;&#125;\n&#x2F;&#x2F; 2.显示职工信息\nvoid WorkerManager::showEmployeeInfo()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        for (int i &#x3D; 0; i &lt; worker_EmpNum; i++)\n        &#123;\n            &#x2F;&#x2F; 利用多态调用接口\n            this-&gt;worker_EmpArray[i]-&gt;getWorkerInfo();\n        &#125;\n    &#125;\n    system(&quot;cls&quot;);\n&#125;\n\n在StaffManagerSystem_Main.cpp中的void showMenu()&#123;&#125;中补充调用showEmployeeInfo()的代码\ncase 2: &#x2F;&#x2F; 2.显示职工信息\n    wm.showEmployeeInfo();\n    break;\n\n9. 删除职工\n功能描述：按照职工的编号进行删除职工操作\n\n9.1 职工是否存在函数声明\n删除，修改，查找职工功能都需要先检查文件中是否存在职工\n\n在workerManager.h中添加成员函数int IsEmployeeExist(int workerID);\n&#x2F;&#x2F; 职工是否存在\nint isEmployeeExist(int workerID);\n\n9.2 职工是否存在函数实现\n在workerManager.cpp中实现成员函数int isEmployeeExist()&#123;&#125;\n&#x2F;&#x2F; 职工是否存在\nint WorkerManager::isEmployeeExist(int workerID)\n&#123;\n    &#x2F;&#x2F; 默认index为职工的编号，-1是不存在\n    int index &#x3D; -1;\n    for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n    &#123;\n        if (this-&gt;worker_EmpArray[i]-&gt;worker_ID &#x3D;&#x3D; workerID)\n        &#123;\n            index &#x3D; i;\n            break;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 返回 -1 表示不存在这个职工，其他表示找到了对应职工的ID编号\n    return index;\n&#125;\n\n9.3 删除职工函数声明\n在workerManager.h中添加成员函数void deletEmployee();\n&#x2F;&#x2F; 3.删除离职职工\nvoid deletEmployee();\n\n9.4 删除职工函数实现\n在workerManager.cpp中实现成员函数void deletEmployee()&#123;&#125;\n&#x2F;&#x2F; 3.删除离职职工\nvoid WorkerManager::deletEmployee()\n&#123;\n    &#x2F;&#x2F; 先判断是否存在职工文件\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        int workerID &#x3D; 0;\n        cout &lt;&lt; &quot;输入需要删除的职工编号&gt;&gt; &quot;;\n        cin &gt;&gt; workerID;\n\n        &#x2F;&#x2F; 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号\n        int workerIndex &#x3D; isEmployeeExist(workerID);\n        if (workerIndex !&#x3D; -1)\n        &#123;\n            &#x2F;&#x2F; 删掉指定数据后，数组数据需要数据前移\n            for (int i &#x3D; workerIndex; i &lt; this-&gt;worker_EmpNum -1; i++)\n            &#123;\n                this-&gt;worker_EmpArray[i] &#x3D; this-&gt;worker_EmpArray[i + 1];\n            &#125;\n            &#x2F;&#x2F; 没移动一个数据，数组后面需要移动的数据就少一个\n            this-&gt;worker_EmpNum--;\n            &#x2F;&#x2F; 修改数据后，将更新的数据保存到文件中\n            this-&gt;saveNewToFile();\n            cout &lt;&lt; &quot;编号:&quot; &lt;&lt; workerIndex + 1 &lt;&lt; &quot; 职工已删除&quot; &lt;&lt; endl;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;删除失败，职工编号错误&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n    system(&quot;cls&quot;);\n&#125;\n\n\n\n在StaffManagerSystem_Main.cpp中添加删除职工的接口\ncase 3: &#x2F;&#x2F; 3.删除离职职工\n    wm.deletEmployee();\n    break;\n\n10. 修改职工\n功能描述：输入职工编号，删除文件中对应的职工信息\n\n10.1 修改职工函数声明\n在workerManager.h中添加成员函数void modifyEmployeeInfo();\n&#x2F;&#x2F; 4.修改职工信息\nvoid modifyEmployeeInfo();\n\n10.2 修改职工函数实现\n在workerManager.cpp中实现成员函数void modifyEmployeeInfo()&#123;&#125;\n&#x2F;&#x2F; 4.修改职工信息\nvoid WorkerManager::modifyEmployeeInfo()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        int workerID &#x3D; 0;\n        cout &lt;&lt; &quot;输入需要修改的职工编号&gt;&gt; &quot;;\n        cin &gt;&gt; workerID;\n\n        &#x2F;&#x2F; 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号\n        int workerIndex &#x3D; isEmployeeExit(workerID);\n        if (workerIndex !&#x3D; -1)\n        &#123;\n            &#x2F;&#x2F; 找到存在且有效的职工编号后，删除数组中对应的信息\n            delete this-&gt;worker_EmpArray[workerIndex];\n\n            int newWorker_ID; &#x2F;&#x2F; 职工ID\n            string newWorker_Name; &#x2F;&#x2F; 职工姓名\n            int newWorker_DepartID; &#x2F;&#x2F; 职工部门编号\n\n            cout &lt;&lt; &quot;查的编号:&quot; &lt;&lt; workerID &lt;&lt; &quot; 的职工&quot; &lt;&lt; endl;\n            cout &lt;&lt; &quot;新的职工编号&gt;&gt; &quot;;\n            cin &gt;&gt; newWorker_ID;\n\n            cout &lt;&lt; &quot;新的职工姓名&gt;&gt; &quot;;\n            cin &gt;&gt; newWorker_Name;\n\n            cout &lt;&lt; &quot;新的职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;\n            cin &gt;&gt; newWorker_DepartID;\n            cout &lt;&lt; endl;\n\n            Worker *worker &#x3D; nullptr;\n\n            switch (newWorker_DepartID)\n            &#123;\n                case 1:\n                    worker &#x3D; new Employee(newWorker_ID, newWorker_Name, 1);\n                    break;\n                case 2:\n                    worker &#x3D; new Manager(newWorker_ID, newWorker_Name, 2);\n                    break;\n                case 3:\n                    worker &#x3D; new Boss(newWorker_ID, newWorker_Name, 3);\n                    break;\n                default:\n                    break;\n            &#125;\n\n            &#x2F;&#x2F; 更新数据到数组中对应的编号\n            this-&gt;worker_EmpArray[workerIndex] &#x3D; worker;\n\n            cout &lt;&lt; &quot;新编号:&quot; &lt;&lt; newWorker_ID &lt;&lt; &quot; 职工的信息，修改完成&quot;\n                 &lt;&lt; &quot; 新部门编号:&quot; &lt;&lt; this-&gt;worker_EmpArray[workerIndex]-&gt;worker_DepartID &lt;&lt; endl;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;修改失败，职工编号错误或不存在&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n    system(&quot;cls&quot;);\n&#125;\n\n在StaffManagerSystem_Main.cpp中添加修改职工的接口\ncase 4: &#x2F;&#x2F; 4.修改职工信息\n    wm.modifyEmployeeInfo();\n    break;\n\n11. 查找职工\n功能描述：提供两种查找方式\n按职工编号查找\n按职工姓名查找\n\n\n\n11.1 查找职工函数声明\n在workerManager.h中添加成员函数void findEmployee();\n&#x2F;&#x2F; 5.查找职工信息\nvoid findEmployee();\n\n11.2 查找职工函数实现\n在workerManager.cpp中实现成员函数void findEmployee()&#123;&#125;;\n&#x2F;&#x2F; 5.查找职工信息\nvoid WorkerManager::findEmployee()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        int findSwitch &#x3D; 0;\n        cout &lt;&lt; &quot;查找选择_1.编号_2.姓名&gt;&gt; &quot;;\n        cin &gt;&gt; findSwitch;\n\n        if (findSwitch &#x3D;&#x3D; 1)\n        &#123;\n            int findWorkerID;\n            cout &lt;&lt; &quot;查找的职工编号&gt;&gt; &quot;;\n            cin &gt;&gt; findWorkerID;\n\n            &#x2F;&#x2F; 判断输入的编号有效性\n            int workerIndex &#x3D; isEmployeeExist(findWorkerID);\n            if (workerIndex !&#x3D; -1)\n            &#123;\n                cout &lt;&lt; &quot;查找成功&quot; &lt;&lt; endl;\n                cout &lt;&lt; &quot;职工信息: &quot;;\n                this-&gt;worker_EmpArray[workerIndex]-&gt;getWorkerInfo();\n            &#125;\n            else\n            &#123;\n                cout &lt;&lt; &quot;查找失败，职工编号错误或不存在&quot; &lt;&lt; endl;\n            &#125;\n        &#125;\n        else if (findSwitch &#x3D;&#x3D; 2)\n        &#123;\n            string findWorkerName;\n            cout &lt;&lt; &quot;查找的职工姓名&gt;&gt; &quot;;\n            cin &gt;&gt; findWorkerName;\n\n            bool isFindByName &#x3D; false;\n            for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n            &#123;\n                if (this-&gt;worker_EmpArray[i]-&gt;worker_Name &#x3D;&#x3D; findWorkerName)\n                &#123;\n                    isFindByName &#x3D; true;\n                    cout &lt;&lt; &quot;查到职工: &quot; &lt;&lt; findWorkerName &lt;&lt; &quot; 职工编号: &quot; &lt;&lt; worker_EmpArray[i]-&gt;worker_ID &lt;&lt; endl;\n                    cout &lt;&lt; &quot;职工信息: &quot;;\n                    worker_EmpArray[i]-&gt;getWorkerInfo();\n                &#125;\n            &#125;\n            if (!isFindByName)\n            &#123;\n                cout &lt;&lt; &quot;查找失败，职工编号、姓名错误或不存在&quot; &lt;&lt; endl;\n            &#125;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n    system(&quot;cls&quot;);\n&#125;\n\n在StaffManagerSystem_Main.cpp中添加查找职工的接口\ncase 5: &#x2F;&#x2F; 5.查找职工信息\n    wm.findEmployee();\n    break;\n\n12. 排序职工\n功能描述：按照职工编号排序，可以依据用户选择进行升序排列和降序排列\n\n12.1 排序函数声明\n在workerManager.h 中添加成员函数void sortEmployeeByID();\n&#x2F;&#x2F; 6.按照编号排序\nvoid sortEmployeeByID();\n\n12.2 排序函数实现\n在workerManager.cpp中实现成员函数void sortEmployeeByID()&#123;&#125;\n&#x2F;&#x2F; 6.按照编号排序\nvoid WorkerManager::sortEmployeeByID()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n        system(&quot;pause&quot;);\n        system(&quot;cls&quot;);\n    &#125;\n    else\n    &#123;\n        int switchSort &#x3D; 0;\n        cout &lt;&lt; &quot;依据编号，选择排序方式_1.升序排列_2.降序排列&gt;&gt; &quot;;\n        cin &gt;&gt; switchSort;\n\n        for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; ++i)\n        &#123;\n            int maxOrmin &#x3D; i;\n            for (int j &#x3D; i + 1; j &lt; this-&gt;worker_EmpNum; ++j)\n            &#123;\n                &#x2F;&#x2F; 升序排列\n                if (switchSort &#x3D;&#x3D; 1)\n                &#123;\n                    &#x2F;&#x2F; 升序排列，如是指定下标的值 大于 遍历出的最小值，说明指定的不是最小的，把遍历的下标赋值给变量\n                    if (worker_EmpArray[maxOrmin]-&gt;worker_ID &gt; worker_EmpArray[j]-&gt;worker_ID)\n                    &#123;\n                        maxOrmin &#x3D; j;\n                    &#125;\n                &#125;\n                    &#x2F;&#x2F; 降序排列\n                else if (switchSort &#x3D;&#x3D; 2)\n                &#123;\n                    &#x2F;&#x2F; 降序排列，如是指定下标的值 小于 遍历出的最大值，说明指定的不是最大的，把遍历的下标赋值给变量\n                    if (worker_EmpArray[maxOrmin]-&gt;worker_ID &lt; worker_EmpArray[j]-&gt;worker_ID)\n                    &#123;\n                        maxOrmin &#x3D; j;\n                    &#125;\n                &#125;\n                else\n                &#123;\n                    cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 交换数据\n            if (maxOrmin !&#x3D; i)\n            &#123;\n                Worker *temp &#x3D; worker_EmpArray[i];\n                worker_EmpArray[i] &#x3D; worker_EmpArray[maxOrmin];\n                worker_EmpArray[maxOrmin] &#x3D; temp;\n            &#125;\n        &#125;\n        cout &lt;&lt; &quot;排序成功&quot; &lt;&lt; endl;\n        this-&gt;saveNewToFile();\n        this-&gt;showEmployeeInfo();\n    &#125;\n&#125;\n\n在StaffManagerSystem_Main.cpp这补充接口调用\ncase 6: &#x2F;&#x2F; 6.按照编号排序\n    wm.sortEmployeeByID();\n    break;\n\n13. 清空文件\n功能描述：将文件记录数据清空\n\n13.1 清空文件函数声明\n在workerManager.h中添加成员函数void toEmptyFile();\n&#x2F;&#x2F; 7.清空所有文档\nvoid toEmptyFile();\n\n13.2 清空文件函数实现\n在workerManager.h中实现成员函数void toEmptyFile()&#123;&#125;\n&#x2F;&#x2F; 7.清空所有文档\nvoid WorkerManager::toEmptyFile()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n        system(&quot;pause&quot;);\n        system(&quot;cls&quot;);\n    &#125;\n    else\n    &#123;\n        int switchNum &#x3D; 0;\n        cout &lt;&lt; &quot;确认清空文件_1.确认_2.取消&gt;&gt; &quot;;\n        cin &gt;&gt; switchNum;\n\n        if (switchNum &#x3D;&#x3D; 1)\n        &#123;\n            &#x2F;&#x2F; 打开模式 ios::trunc 如果存在文件 删除后 重新生成\n            ofstream ofs(WORKER_FILENAME, ios::trunc);\n            ofs.close();\n\n            &#x2F;&#x2F; 判断内存中堆区的是否存在 存在需要释放\n            if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n            &#123;\n                for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n                &#123;\n                    if (this-&gt;worker_EmpArray[i] !&#x3D; nullptr)\n                    &#123;\n                        delete this-&gt;worker_EmpArray[i];\n                    &#125;\n                &#125;\n                this-&gt;worker_EmpNum &#x3D; 0;\n                delete[] worker_EmpArray;\n                this-&gt;worker_EmpArray &#x3D; nullptr;\n                this-&gt;isFileEmpty &#x3D; true;\n            &#125;\n            cout &lt;&lt; &quot;职工文件清空完成&quot; &lt;&lt; endl;\n        &#125;\n        else if (switchNum &#x3D;&#x3D; 2)\n        &#123;\n            cout &lt;&lt; &quot;已取消清空职工文件&quot; &lt;&lt; endl;\n\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n13.3 析构函数修改完善\n析构函数内，先判断数组属性是否存在，存在改为NULL，之后删除对象\nWorkerManager::~WorkerManager()\n&#123;\n    if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n    &#123;\n        for (int i&#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n        &#123;\n            if (this-&gt;worker_EmpArray[i] !&#x3D; nullptr)\n            &#123;\n                delete this-&gt;worker_EmpArray[i];\n            &#125;\n        &#125;\n        delete[] this-&gt;worker_EmpArray;\n        this-&gt;worker_EmpArray &#x3D; nullptr;\n    &#125;\n&#125;\n\n13.4 清空文件函数测试\n在StaffManagerSystem_Main.cpp这补充接口调用\ncase 7: &#x2F;&#x2F; 7.清空所有文档\n    wm.toEmptyFile();\n    break;\n\n14. 后期bug修复14.1 职工编号存在判断失误\nbug描述：\n\n清空文件后，重新添加职工，输入任意编号，都会判断职工编号已经存在\n\n\nbug修复：\n\n在workerManager.h这添加成员变量\n&#x2F;&#x2F; 判断文件是否存在某个编号\nbool isIDExist;\n\n在workerManager.cpp中修改bool WorkerManager::isEmployeeIDExist(int workerID)&#123;&#125;\n&#x2F;&#x2F; 排查添加的新职工的编号在文件中是否存在\nbool WorkerManager::isEmployeeIDExist(int workerID)\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        this-&gt;isIDExist &#x3D; false;\n    &#125;\n    else\n    &#123;\n        for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n        &#123;\n            if (this-&gt;worker_EmpArray[i]-&gt;worker_ID &#x3D;&#x3D; workerID)\n            &#123;\n                this-&gt;isIDExist &#x3D; true;\n                break;\n            &#125;\n            else\n            &#123;\n                this-&gt;isIDExist &#x3D; false;\n            &#125;\n        &#125;\n    &#125;\n    return this-&gt;isIDExist;\n&#125;\n\n在workerManager.cpp中修改void WorkerManager::addEmployee()&#123;&#125;\n&#x2F;&#x2F; 1.增加职工信息\nvoid WorkerManager::addEmployee()\n&#123;\n    cout &lt;&lt; &quot;&lt;-- 已录入职工数量：&quot; &lt;&lt; worker_EmpNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入增加职工数量：&gt;&gt; &quot;;\n    int addNum &#x3D; 0;\n    cin &gt;&gt; addNum;\n\n    if (addNum &gt; 0)\n    &#123;\n        &#x2F;&#x2F; 计算需要的空间大小 &#x3D; 已用的空间 + 新需要的空间\n        int newSize &#x3D; this-&gt;worker_EmpNum + addNum;\n\n        &#x2F;&#x2F; 在 堆区中开辟 计算好大小的内存空间\n        Worker **newSpace &#x3D; new Worker *[newSize];\n\n        &#x2F;&#x2F; 将已有空间的内容存在新的内村空间中\n        if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n        &#123;\n            for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n            &#123;\n                newSpace[i] &#x3D; this-&gt;worker_EmpArray[i];\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 再将 需要添加的新内容加入\n        for (int j &#x3D; 0; j &lt; addNum; j++)\n        &#123;\n            int worker_ID; &#x2F;&#x2F; 职工ID\n            string worker_Name; &#x2F;&#x2F; 职工姓名\n            int worker_DepartID; &#x2F;&#x2F; 职工部门编号\n            bool isExistID &#x3D; true; &#x2F;&#x2F; 新增的变量，用于判断文件中是否已存在某个ID\n\n            &#x2F;&#x2F; 在输入职工ID的地方，进行了修改\n            &#x2F;&#x2F; 每次输入ID，都要判断一次，输入的ID在职工文件中是否已经存在\n            &#x2F;&#x2F; 存在就继续循环该语句，不存在再继续执行之后的语句\n            while (true)\n            &#123;\n                cout &lt;&lt; &quot;输入第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;位员工信息:&quot; &lt;&lt; endl;\n                cout &lt;&lt; &quot;职工编号&gt;&gt; &quot;;\n                cin &gt;&gt; worker_ID;\n                this-&gt;isIDExist &#x3D; isEmployeeIDExist(worker_ID);\n\n                if (this-&gt;isIDExist)\n                &#123;\n                    cout &lt;&lt; &quot;编号已经存在&quot; &lt;&lt; endl;\n                    system(&quot;pause&quot;);\n                    system(&quot;cls&quot;);\n                &#125;\n                else\n                &#123;\n                    break;\n                &#125;\n            &#125;\n\n            cout &lt;&lt; &quot;职工姓名&gt;&gt; &quot;;\n            cin &gt;&gt; worker_Name;\n\n            cout &lt;&lt; &quot;职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;\n            cin &gt;&gt; worker_DepartID;\n            cout &lt;&lt; endl;\n\n            Worker *worker &#x3D; nullptr;\n\n            switch (worker_DepartID)\n            &#123;\n                case 1:\n                    worker &#x3D; new Employee(worker_ID, worker_Name, 1);\n                    break;\n                case 2:\n                    worker &#x3D; new Manager(worker_ID, worker_Name, 2);\n                    break;\n                case 3:\n                    worker &#x3D; new Boss(worker_ID, worker_Name, 3);\n                    break;\n                default:\n                    break;\n            &#125;\n\n            newSpace[this-&gt;worker_EmpNum + j] &#x3D; worker;\n        &#125;\n        &#x2F;&#x2F; 释放原本的空间\n        delete[] this-&gt;worker_EmpArray;\n\n        &#x2F;&#x2F; 更改新空间的指向\n        this-&gt;worker_EmpArray &#x3D; newSpace;\n\n        &#x2F;&#x2F; 更新 新的个数\n        this-&gt;worker_EmpNum &#x3D; newSize;\n\n        &#x2F;&#x2F; 更新 文件不在为假\n        this-&gt;isFileEmpty &#x3D; false;\n\n        &#x2F;&#x2F; 提示信息\n        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;\n\n        &#x2F;&#x2F; 保存录入的职工信息到文本文件中\n        this-&gt;saveNewToFile();\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;需输入正确的数字&quot; &lt;&lt; endl;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n在workerManager.cpp中的void WorkerManager::toEmptyFile()&#123;&#125;修改\ncout &lt;&lt; &quot;职工文件清空完成&quot; &lt;&lt; endl;\nthis-&gt;isIDExist &#x3D; false;\n\n\n\n15. 源码整理-Clion项目结构：\n\nStaffManagerSystem\nFile\nHeader\nboss.h\nemployee.h\nmanager.h\nworker.h\nworkerManager.h\n\n\nMain\nStaffManagerSystem_Main.cpp\n\n\nSource\nboss.cpp\nemployee.cpp\nmanager.cpp\nworkerManager.cpp\n\n\nCMakeList.txt\n\n\n\n对应源码：\n\nStaffManagerSystem\nFile\n\nHeader\n\nboss.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_BOSS_H\n#define STAFFMANAGEMENTSYSTEM_BOSS_H\n\n#include &quot;worker.h&quot;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 老板类\nclass Boss : public Worker\n&#123;\npublic:\n    &#x2F;&#x2F; 初始化 老板 构造函数\n    Boss(int w_Id, string w_Name, int w_DepartId);\n\n    &#x2F;&#x2F; 获得老板个人信息\n    void getWorkerInfo() override;\n\n    &#x2F;&#x2F; 获得老板部门岗位名称\n    string getWorkerDepartName() override;\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_BOSS_H\n\n\n\nemployee.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_EMPLOYEE_H\n#define STAFFMANAGEMENTSYSTEM_EMPLOYEE_H\n\n#include &quot;worker.h&quot;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 普通员工 类\nclass Employee : public Worker\n&#123;\npublic:\n    &#x2F;&#x2F; 初始化 员工 构造函数\n    Employee(int w_Id, string w_Name, int w_DepartId);\n\n    &#x2F;&#x2F; 获得员工个人信息\n    void getWorkerInfo() override;\n\n    &#x2F;&#x2F; 获得员工部门岗位名称\n    string getWorkerDepartName() override;\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_EMPLOYEE_H\n\n\n\nmanager.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_MANAGER_H\n#define STAFFMANAGEMENTSYSTEM_MANAGER_H\n\n#include &quot;worker.h&quot;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 经理类\nclass Manager : public Worker\n&#123;\npublic:\n    &#x2F;&#x2F; 初始化 经理 构造函数\n    Manager(int w_Id, string w_Name, int w_DepartId);\n\n    &#x2F;&#x2F; 获得经理个人信息\n    void getWorkerInfo() override;\n\n    &#x2F;&#x2F; 获得经理部门岗位名称\n    string getWorkerDepartName() override;\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_MANAGER_H\n\n\n\nworker.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_WORKER_H\n#define STAFFMANAGEMENTSYSTEM_WORKER_H\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 职工抽象类\nclass Worker\n&#123;\npublic:\n    int worker_ID; &#x2F;&#x2F; 职工ID\n    string worker_Name; &#x2F;&#x2F; 职工姓名\n    int worker_DepartID; &#x2F;&#x2F; 职工部门编号\n\n    &#x2F;&#x2F; 获得 职工的信息\n    virtual void getWorkerInfo() &#x3D; 0;\n\n    &#x2F;&#x2F; 获得 职工部门的岗位名称\n    virtual string getWorkerDepartName() &#x3D; 0;\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_WORKER_H\n\n\n\nworkerManager.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#ifndef STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n#define STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n\n#define wm workerManager\n#define WORKER_FILENAME &quot;..&#x2F;File&#x2F;workerFile.txt&quot;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &quot;worker.h&quot;\n#include &quot;employee.h&quot;\n#include &quot;manager.h&quot;\n#include &quot;boss.h&quot;\n\nusing namespace std;\n\nclass WorkerManager\n&#123;\npublic:\n    &#x2F;&#x2F; 记录文件中的人数\n    int worker_EmpNum;\n\n    &#x2F;&#x2F; 判断文件是否为空\n    bool isFileEmpty;\n\n    &#x2F;&#x2F; 判断文件是否存在某个编号\n    bool isIDExist;\n\n    &#x2F;&#x2F; 员工数组指针\n    Worker ** worker_EmpArray;\n\n    WorkerManager();\n    ~WorkerManager();\n\n    &#x2F;&#x2F; 显示员工管理系统主菜单\n    void Show_Menu();\n\n    &#x2F;&#x2F; 保持录入职工的信息到文件\n    void saveNewToFile();\n\n    &#x2F;&#x2F; 获得记录职工人数\n    int getEmpNum();\n\n    &#x2F;&#x2F; 初始化职工\n    void initEmployee();\n\n    &#x2F;&#x2F; 职工是否存在\n    int isEmployeeExist(int workerID);\n\n    &#x2F;&#x2F; 排查添加的新职工的编号在文件中是否存在\n    bool isEmployeeIDExist(int workerID);\n\n    &#x2F;&#x2F; 0.退出管理系统\n    void exitSystem();\n\n    &#x2F;&#x2F; 1.增加职工信息\n    void addEmployee();\n\n    &#x2F;&#x2F; 2.显示职工信息\n    void showEmployeeInfo();\n\n    &#x2F;&#x2F; 3.删除离职职工\n    void deletEmployee();\n\n    &#x2F;&#x2F; 4.修改职工信息\n    void modifyEmployeeInfo();\n\n    &#x2F;&#x2F; 5.查找职工信息\n    void findEmployee();\n\n    &#x2F;&#x2F; 6.按照编号排序\n    void sortEmployeeByID();\n\n    &#x2F;&#x2F; 7.清空所有文档\n    void toEmptyFile();\n\n&#125;;\n\n#endif &#x2F;&#x2F;STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H\n\n\nMain\n\nStaffManagerSystem_Main.cpp\n#include &lt;iostream&gt;\n#include &quot;..&#x2F;Header&#x2F;workerManager.h&quot;\n\n&#x2F;&#x2F; 早期测试代码\nvoid demo()\n&#123;\n    Worker *worker;\n\n    worker &#x3D; new Employee(1, &quot;Normal_A&quot;, 1);\n    worker-&gt;getWorkerInfo();\n    delete worker;\n\n    worker &#x3D; new Manager(2, &quot;Manager_A&quot;, 2);\n    worker-&gt;getWorkerInfo();\n    delete worker;\n\n    worker &#x3D; new Boss(3, &quot;Boss_A&quot;, 3);\n    worker-&gt;getWorkerInfo();\n    delete worker;\n&#125;\n\n&#x2F;&#x2F; 显示职工管理系统的主界面\nvoid showMenu()\n&#123;\n    &#x2F;&#x2F; 初始选择\n    int choice &#x3D; 0;\n\n    &#x2F;&#x2F; 生成 管理界面 对象\n    WorkerManager workerManager;\n\n    &#x2F;&#x2F; 调用 菜单界面\n    while (true)\n    &#123;\n        wm.Show_Menu();\n        cout &lt;&lt; &quot;功能选择 &gt;&gt; &quot;;\n        cin &gt;&gt; choice;\n\n        &#x2F;&#x2F; 菜单界面的功能选择分支\n        switch (choice)\n        &#123;\n            case 0: &#x2F;&#x2F; 0.退出管理系统\n                wm.exitSystem();\n                break;\n            case 1: &#x2F;&#x2F; 1.增加职工信息\n                wm.addEmployee();\n                break;\n            case 2: &#x2F;&#x2F; 2.显示职工信息\n                wm.showEmployeeInfo();\n                break;\n            case 3: &#x2F;&#x2F; 3.删除离职职工\n                wm.deletEmployee();\n                break;\n            case 4: &#x2F;&#x2F; 4.修改职工信息\n                wm.modifyEmployeeInfo();\n                break;\n            case 5: &#x2F;&#x2F; 5.查找职工信息\n                wm.findEmployee();\n                break;\n            case 6: &#x2F;&#x2F; 6.按照编号排序\n                wm.sortEmployeeByID();\n                break;\n            case 7: &#x2F;&#x2F; 7.清空所有文档\n                wm.toEmptyFile();\n                break;\n            default: &#x2F;&#x2F; 0 ~ 7 之外任意值，清空，重来菜单界面\n                system(&quot;pause&quot;);\n                system(&quot;cls&quot;);\n                break;\n        &#125;\n    &#125;\n&#125;\n\nint main()\n&#123;\n&#x2F;&#x2F;    demo();\n    showMenu();\n    return 0;\n&#125;\n\n\nSource\n\nboss.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#include &quot;..&#x2F;Header&#x2F;boss.h&quot;\n\n&#x2F;&#x2F; 构造函数 初始化 老板 信息\nBoss::Boss(int w_Id, string w_Name, int w_DepartId)\n&#123;\n    this-&gt;worker_ID &#x3D; w_Id;\n    this-&gt;worker_Name &#x3D; w_Name;\n    this-&gt;worker_DepartID &#x3D; w_DepartId;\n&#125;\n\n&#x2F;&#x2F; 获得 职工信息\nvoid Boss::getWorkerInfo()\n&#123;\n    cout &lt;&lt; &quot;编号：&quot; &lt;&lt; this-&gt;worker_ID\n         &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; this-&gt;worker_Name\n         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()\n         &lt;&lt; &quot;\\t职责：管理所有的事务&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 获得 职工 岗位信息\nstring Boss::getWorkerDepartName()\n&#123;\n    return string(&quot;老板&quot;);\n&#125;\n\n\n\n\nemployee.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n#include &quot;..&#x2F;Header&#x2F;employee.h&quot;\n\n&#x2F;&#x2F; 构造函数 初始化 普通员工 信息\nEmployee::Employee(int w_Id, string w_Name, int w_DepartId)\n&#123;\n    this-&gt;worker_ID &#x3D; w_Id;\n    this-&gt;worker_Name &#x3D; w_Name;\n    this-&gt;worker_DepartID &#x3D; w_DepartId;\n&#125;\n\n&#x2F;&#x2F; 获得 职工信息\nvoid Employee::getWorkerInfo()\n&#123;\n    cout &lt;&lt; &quot;编号：&quot; &lt;&lt; this-&gt;worker_ID\n         &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; this-&gt;worker_Name\n         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()\n         &lt;&lt; &quot;\\t职责：完成经理的任务&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 获得 职工 岗位信息\nstring Employee::getWorkerDepartName()\n&#123;\n    return string(&quot;员工&quot;);\n&#125;\n\n\n\nmanager.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n\n#include &quot;..&#x2F;Header&#x2F;manager.h&quot;\n\n&#x2F;&#x2F; 构造函数 初始化 经理 信息\nManager::Manager(int w_Id, string w_Name, int w_DepartId)\n&#123;\n    this-&gt;worker_ID &#x3D; w_Id;\n    this-&gt;worker_Name &#x3D; w_Name;\n    this-&gt;worker_DepartID &#x3D; w_DepartId;\n&#125;\n\n&#x2F;&#x2F; 获得 职工信息\nvoid Manager::getWorkerInfo()\n&#123;\n    cout &lt;&lt; &quot;编号：&quot; &lt;&lt; this-&gt;worker_ID\n         &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; this-&gt;worker_Name\n         &lt;&lt; &quot;\\t岗位：&quot; &lt;&lt; this-&gt;getWorkerDepartName()\n         &lt;&lt; &quot;\\t职责：执行老板的任务&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 获得 职工 岗位信息\nstring Manager::getWorkerDepartName()\n&#123;\n    return string(&quot;经理&quot;);\n&#125;\n\n\n\nworkerManager.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;26.\n&#x2F;&#x2F;\n#include &quot;..&#x2F;Header&#x2F;workerManager.h&quot;\n\nWorkerManager::WorkerManager()\n&#123;\n    &#x2F;&#x2F; 1. 初始化 读文件对象\n    ifstream ifs;\n    ifs.open(WORKER_FILENAME, ios::in);\n\n    &#x2F;&#x2F; 2. 文件不存在的情况\n    if (!ifs.is_open())\n    &#123;\n        cout &lt;&lt; &quot;&lt;-- 提示：职工文件不存在 --&gt;&quot; &lt;&lt; endl;\n        this-&gt;worker_EmpNum &#x3D; 0;\n        this-&gt;worker_EmpArray &#x3D; nullptr;\n        &#x2F;&#x2F; 初始化 文件 是空\n        this-&gt;isFileEmpty &#x3D; true;\n        ifs.close();\n        return;\n    &#125;\n\n    &#x2F;&#x2F; 3. 文件存在 数据为空\n    string str;\n    ifs &gt;&gt; str;\n    if (ifs.eof())\n    &#123;\n        cout &lt;&lt; &quot;&lt;-- 提示：职工文件为空 --&gt;&quot; &lt;&lt; endl;\n        this-&gt;worker_EmpNum &#x3D; 0;\n        this-&gt;worker_EmpArray &#x3D; nullptr;\n        this-&gt;isFileEmpty &#x3D; true;\n        ifs.close();\n        return;\n    &#125;\n\n    &#x2F;&#x2F; 4. 文件存在 有数据\n    &#x2F;&#x2F; 获得文件已记录人数\n    int empNum &#x3D; this-&gt;getEmpNum();\n    &#x2F;&#x2F; 更新 记录人数\n    this-&gt;worker_EmpNum &#x3D; empNum;\n    cout &lt;&lt; &quot;&lt;-- 职工数量: &quot; &lt;&lt; empNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; 根据职工数量创建数组\n    this-&gt;worker_EmpArray &#x3D; new Worker *[this-&gt;worker_EmpNum];\n    this-&gt;initEmployee();\n    &#x2F;&#x2F; 测试代码\n&#x2F;&#x2F;    for (int i &#x3D; 0; i &lt;worker_EmpNum; i++)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; &quot;&lt;-- 职工编号：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_ID\n&#x2F;&#x2F;             &lt;&lt; &quot;   职工姓名：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_Name\n&#x2F;&#x2F;             &lt;&lt; &quot;   职工部门：&quot; &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_DepartID\n&#x2F;&#x2F;             &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;\n&#x2F;&#x2F;    &#125;\n&#125;\n\nWorkerManager::~WorkerManager()\n&#123;\n    if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n    &#123;\n        for (int i&#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n        &#123;\n            if (this-&gt;worker_EmpArray[i] !&#x3D; nullptr)\n            &#123;\n                delete this-&gt;worker_EmpArray[i];\n            &#125;\n        &#125;\n        delete[] this-&gt;worker_EmpArray;\n        this-&gt;worker_EmpArray &#x3D; nullptr;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 显示员工管理系统主菜单\nvoid WorkerManager::Show_Menu()\n&#123;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;员工管理系统主菜单&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;0.退出管理系统&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1.增加职工信息&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2.显示职工信息&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3.删除离职职工&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;4.修改职工信息&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;5.查找职工信息&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;6.按照编号排序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;7.清空所有文档&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 保持录入职工的信息到文件\nvoid WorkerManager::saveNewToFile()\n&#123;\n    &#x2F;&#x2F; 初始化 写文件对象\n    ofstream ofs;\n    ofs.open(WORKER_FILENAME, ios::out);\n\n    for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n    &#123;\n        ofs &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_ID &lt;&lt; &quot; &quot;\n            &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_Name &lt;&lt; &quot; &quot;\n            &lt;&lt; this-&gt;worker_EmpArray[i]-&gt;worker_DepartID &lt;&lt; endl;\n    &#125;\n\n    ofs.close();\n&#125;\n\n&#x2F;&#x2F; 获得记录职工人数\nint WorkerManager::getEmpNum()\n&#123;\n    ifstream ifs;\n    ifs.open(WORKER_FILENAME, ios::in);\n\n    &#x2F;&#x2F; 存入 读到的数据\n    int worker_ID;\n    string worker_Name;\n    int worker_DepartID;\n    &#x2F;&#x2F; 初始化 记录人数\n    int empNum &#x3D; 0;\n\n    &#x2F;&#x2F; 当 读文件操作对象 返回为真\n    while (ifs &gt;&gt; worker_ID &amp;&amp; ifs &gt;&gt; worker_Name &amp;&amp; ifs &gt;&gt; worker_DepartID)\n    &#123;\n        &#x2F;&#x2F; 记录人数 +1\n        empNum++;\n    &#125;\n    ifs.close();\n\n    return empNum;\n&#125;\n\n&#x2F;&#x2F; 初始化职工\nvoid WorkerManager::initEmployee()\n&#123;\n    ifstream ifs;\n    ifs.open(WORKER_FILENAME, ios::in);\n\n    &#x2F;&#x2F; 存入 读到的数据\n    int worker_ID;\n    string worker_Name;\n    int worker_DepartID;\n    &#x2F;&#x2F; 初始化 记录人数\n    int index &#x3D; 0;\n\n    &#x2F;&#x2F; 当 读文件操作对象 返回为真\n    while (ifs &gt;&gt; worker_ID &amp;&amp; ifs &gt;&gt; worker_Name &amp;&amp; ifs &gt;&gt; worker_DepartID)\n    &#123;\n        Worker *worker &#x3D; nullptr;\n\n        &#x2F;&#x2F; 根据 DepartID，创建不同职工对象\n        if (worker_DepartID &#x3D;&#x3D; 1)\n        &#123;\n            worker &#x3D; new Employee(worker_ID, worker_Name, worker_DepartID);\n        &#125;\n        else if (worker_DepartID &#x3D;&#x3D; 2)\n        &#123;\n            worker &#x3D; new Manager(worker_ID, worker_Name, worker_DepartID);\n        &#125;\n        else\n        &#123;\n            worker &#x3D; new Boss(worker_ID, worker_Name, worker_DepartID);\n        &#125;\n        &#x2F;&#x2F; 生成职工对象后，存入职工数组中\n        this-&gt;worker_EmpArray[index] &#x3D; worker;\n        index++;\n    &#125;\n    ifs.close();\n&#125;\n\n&#x2F;&#x2F; 职工是否存在\nint WorkerManager::isEmployeeExist(int workerID)\n&#123;\n    &#x2F;&#x2F; 默认index为职工的编号，-1是不存在\n    int index &#x3D; -1;\n    for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n    &#123;\n        if (this-&gt;worker_EmpArray[i]-&gt;worker_ID &#x3D;&#x3D; workerID)\n        &#123;\n            index &#x3D; i;\n            break;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 返回 -1 表示不存在这个职工，其他表示找到了对应职工的ID编号\n    return index;\n&#125;\n\n&#x2F;&#x2F; 排查添加的新职工的编号在文件中是否存在\nbool WorkerManager::isEmployeeIDExist(int workerID)\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        this-&gt;isIDExist &#x3D; false;\n    &#125;\n    else\n    &#123;\n        for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n        &#123;\n            if (this-&gt;worker_EmpArray[i]-&gt;worker_ID &#x3D;&#x3D; workerID)\n            &#123;\n                this-&gt;isIDExist &#x3D; true;\n                break;\n            &#125;\n            else\n            &#123;\n                this-&gt;isIDExist &#x3D; false;\n            &#125;\n        &#125;\n    &#125;\n    return this-&gt;isIDExist;\n&#125;\n\n&#x2F;&#x2F; 0.退出管理系统\nvoid WorkerManager::exitSystem()\n&#123;\n    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;员工管理系统-退出&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n    exit(0);\n&#125;\n\n&#x2F;&#x2F; 1.增加职工信息\nvoid WorkerManager::addEmployee()\n&#123;\n    cout &lt;&lt; &quot;&lt;-- 已录入职工数量：&quot; &lt;&lt; worker_EmpNum &lt;&lt; &quot; --&gt;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入增加职工数量：&gt;&gt; &quot;;\n    int addNum &#x3D; 0;\n    cin &gt;&gt; addNum;\n\n    if (addNum &gt; 0)\n    &#123;\n        &#x2F;&#x2F; 计算需要的空间大小 &#x3D; 已用的空间 + 新需要的空间\n        int newSize &#x3D; this-&gt;worker_EmpNum + addNum;\n\n        &#x2F;&#x2F; 在 堆区中开辟 计算好大小的内存空间\n        Worker **newSpace &#x3D; new Worker *[newSize];\n\n        &#x2F;&#x2F; 将已有空间的内容存在新的内村空间中\n        if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n        &#123;\n            for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n            &#123;\n                newSpace[i] &#x3D; this-&gt;worker_EmpArray[i];\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 再将 需要添加的新内容加入\n        for (int j &#x3D; 0; j &lt; addNum; j++)\n        &#123;\n            int worker_ID; &#x2F;&#x2F; 职工ID\n            string worker_Name; &#x2F;&#x2F; 职工姓名\n            int worker_DepartID; &#x2F;&#x2F; 职工部门编号\n            bool isExistID &#x3D; true; &#x2F;&#x2F; 新增的变量，用于判断文件中是否已存在某个ID\n\n            &#x2F;&#x2F; 在输入职工ID的地方，进行了修改\n            &#x2F;&#x2F; 每次输入ID，都要判断一次，输入的ID在职工文件中是否已经存在\n            &#x2F;&#x2F; 存在就继续循环该语句，不存在再继续执行之后的语句\n            while (true)\n            &#123;\n                cout &lt;&lt; &quot;输入第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;位员工信息:&quot; &lt;&lt; endl;\n                cout &lt;&lt; &quot;职工编号&gt;&gt; &quot;;\n                cin &gt;&gt; worker_ID;\n                this-&gt;isIDExist &#x3D; isEmployeeIDExist(worker_ID);\n\n                if (this-&gt;isIDExist)\n                &#123;\n                    cout &lt;&lt; &quot;编号已经存在&quot; &lt;&lt; endl;\n                    system(&quot;pause&quot;);\n                    system(&quot;cls&quot;);\n                &#125;\n                else\n                &#123;\n                    break;\n                &#125;\n            &#125;\n\n            cout &lt;&lt; &quot;职工姓名&gt;&gt; &quot;;\n            cin &gt;&gt; worker_Name;\n\n            cout &lt;&lt; &quot;职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;\n            cin &gt;&gt; worker_DepartID;\n            cout &lt;&lt; endl;\n\n            Worker *worker &#x3D; nullptr;\n\n            switch (worker_DepartID)\n            &#123;\n                case 1:\n                    worker &#x3D; new Employee(worker_ID, worker_Name, 1);\n                    break;\n                case 2:\n                    worker &#x3D; new Manager(worker_ID, worker_Name, 2);\n                    break;\n                case 3:\n                    worker &#x3D; new Boss(worker_ID, worker_Name, 3);\n                    break;\n                default:\n                    break;\n            &#125;\n\n            newSpace[this-&gt;worker_EmpNum + j] &#x3D; worker;\n        &#125;\n        &#x2F;&#x2F; 释放原本的空间\n        delete[] this-&gt;worker_EmpArray;\n\n        &#x2F;&#x2F; 更改新空间的指向\n        this-&gt;worker_EmpArray &#x3D; newSpace;\n\n        &#x2F;&#x2F; 更新 新的个数\n        this-&gt;worker_EmpNum &#x3D; newSize;\n\n        &#x2F;&#x2F; 更新 文件不在为假\n        this-&gt;isFileEmpty &#x3D; false;\n\n        &#x2F;&#x2F; 提示信息\n        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工&quot; &lt;&lt; endl;\n\n        &#x2F;&#x2F; 保存录入的职工信息到文本文件中\n        this-&gt;saveNewToFile();\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;需输入正确的数字&quot; &lt;&lt; endl;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F; 2.显示职工信息\nvoid WorkerManager::showEmployeeInfo()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n        system(&quot;pause&quot;);\n        system(&quot;cls&quot;);\n    &#125;\n    else\n    &#123;\n        for (int i &#x3D; 0; i &lt; worker_EmpNum; i++)\n        &#123;\n            &#x2F;&#x2F; 利用多态调用接口\n            this-&gt;worker_EmpArray[i]-&gt;getWorkerInfo();\n        &#125;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F; 3.删除离职职工\nvoid WorkerManager::deletEmployee()\n&#123;\n    &#x2F;&#x2F; 先判断是否存在职工文件\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n        system(&quot;pause&quot;);\n        system(&quot;cls&quot;);\n    &#125;\n    else\n    &#123;\n        int workerID &#x3D; 0;\n        cout &lt;&lt; &quot;输入需要删除的职工编号&gt;&gt; &quot;;\n        cin &gt;&gt; workerID;\n\n        &#x2F;&#x2F; 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号\n        int workerIndex &#x3D; isEmployeeExist(workerID);\n        if (workerIndex !&#x3D; -1)\n        &#123;\n            &#x2F;&#x2F; 删掉指定数据后，数组数据需要数据前移\n            for (int i &#x3D; workerIndex; i &lt; this-&gt;worker_EmpNum - 1; i++)\n            &#123;\n                this-&gt;worker_EmpArray[i] &#x3D; this-&gt;worker_EmpArray[i + 1];\n            &#125;\n            &#x2F;&#x2F; 没移动一个数据，数组后面需要移动的数据就少一个\n            this-&gt;worker_EmpNum--;\n            &#x2F;&#x2F; 修改数据后，将更新的数据保存到文件中\n            this-&gt;saveNewToFile();\n            cout &lt;&lt; &quot;编号:&quot; &lt;&lt; workerIndex + 1 &lt;&lt; &quot; 职工已删除&quot; &lt;&lt; endl;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;删除失败，职工编号错误或不存在&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F; 4.修改职工信息\nvoid WorkerManager::modifyEmployeeInfo()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n        system(&quot;pause&quot;);\n        system(&quot;cls&quot;);\n    &#125;\n    else\n    &#123;\n        int workerID &#x3D; 0;\n        cout &lt;&lt; &quot;输入需要修改的职工编号&gt;&gt; &quot;;\n        cin &gt;&gt; workerID;\n\n        &#x2F;&#x2F; 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号\n        int workerIndex &#x3D; isEmployeeExist(workerID);\n        if (workerIndex !&#x3D; -1)\n        &#123;\n            &#x2F;&#x2F; 找到存在且有效的职工编号后，删除数组中对应的信息\n            delete this-&gt;worker_EmpArray[workerIndex];\n\n            int newWorker_ID; &#x2F;&#x2F; 职工ID\n            string newWorker_Name; &#x2F;&#x2F; 职工姓名\n            int newWorker_DepartID; &#x2F;&#x2F; 职工部门编号\n\n            cout &lt;&lt; &quot;查的编号:&quot; &lt;&lt; workerID &lt;&lt; &quot; 的职工&quot; &lt;&lt; endl;\n            cout &lt;&lt; &quot;新的职工编号&gt;&gt; &quot;;\n            cin &gt;&gt; newWorker_ID;\n\n            cout &lt;&lt; &quot;新的职工姓名&gt;&gt; &quot;;\n            cin &gt;&gt; newWorker_Name;\n\n            cout &lt;&lt; &quot;新的职工岗位_ 1.员工_2.经理_3.老板&gt;&gt; &quot;;\n            cin &gt;&gt; newWorker_DepartID;\n            cout &lt;&lt; endl;\n\n            Worker *worker &#x3D; nullptr;\n\n            switch (newWorker_DepartID)\n            &#123;\n                case 1:\n                    worker &#x3D; new Employee(newWorker_ID, newWorker_Name, 1);\n                    break;\n                case 2:\n                    worker &#x3D; new Manager(newWorker_ID, newWorker_Name, 2);\n                    break;\n                case 3:\n                    worker &#x3D; new Boss(newWorker_ID, newWorker_Name, 3);\n                    break;\n                default:\n                    break;\n            &#125;\n\n            &#x2F;&#x2F; 更新数据到数组中对应的编号\n            this-&gt;worker_EmpArray[workerIndex] &#x3D; worker;\n\n            cout &lt;&lt; &quot;新编号:&quot; &lt;&lt; newWorker_ID &lt;&lt; &quot; 职工的信息，修改完成&quot;\n                 &lt;&lt; &quot; 新部门编号:&quot; &lt;&lt; this-&gt;worker_EmpArray[workerIndex]-&gt;worker_DepartID &lt;&lt; endl;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;修改失败，职工编号错误或不存在&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F; 5.查找职工信息\nvoid WorkerManager::findEmployee()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n        system(&quot;pause&quot;);\n        system(&quot;cls&quot;);\n    &#125;\n    else\n    &#123;\n        int findSwitch &#x3D; 0;\n        cout &lt;&lt; &quot;查找选择_1.编号_2.姓名&gt;&gt; &quot;;\n        cin &gt;&gt; findSwitch;\n\n        if (findSwitch &#x3D;&#x3D; 1)\n        &#123;\n            int findWorkerID;\n            cout &lt;&lt; &quot;查找的职工编号&gt;&gt; &quot;;\n            cin &gt;&gt; findWorkerID;\n\n            &#x2F;&#x2F; 判断输入的编号有效性\n            int workerIndex &#x3D; isEmployeeExist(findWorkerID);\n            if (workerIndex !&#x3D; -1)\n            &#123;\n                cout &lt;&lt; &quot;查找成功&quot; &lt;&lt; endl;\n                cout &lt;&lt; &quot;职工信息: &quot;;\n                this-&gt;worker_EmpArray[workerIndex]-&gt;getWorkerInfo();\n            &#125;\n            else\n            &#123;\n                cout &lt;&lt; &quot;查找失败，职工编号错误或不存在&quot; &lt;&lt; endl;\n            &#125;\n        &#125;\n        else if (findSwitch &#x3D;&#x3D; 2)\n        &#123;\n            string findWorkerName;\n            cout &lt;&lt; &quot;查找的职工姓名&gt;&gt; &quot;;\n            cin &gt;&gt; findWorkerName;\n\n            bool isFindByName &#x3D; false;\n            for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n            &#123;\n                if (this-&gt;worker_EmpArray[i]-&gt;worker_Name &#x3D;&#x3D; findWorkerName)\n                &#123;\n                    isFindByName &#x3D; true;\n                    cout &lt;&lt; &quot;查到职工: &quot; &lt;&lt; findWorkerName &lt;&lt; &quot; 职工编号: &quot; &lt;&lt; worker_EmpArray[i]-&gt;worker_ID &lt;&lt; endl;\n                    cout &lt;&lt; &quot;职工信息: &quot;;\n                    worker_EmpArray[i]-&gt;getWorkerInfo();\n                &#125;\n            &#125;\n            if (!isFindByName)\n            &#123;\n                cout &lt;&lt; &quot;查找失败，职工编号、姓名错误或不存在&quot; &lt;&lt; endl;\n            &#125;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F; 6.按照编号排序\nvoid WorkerManager::sortEmployeeByID()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n        system(&quot;pause&quot;);\n        system(&quot;cls&quot;);\n    &#125;\n    else\n    &#123;\n        int switchSort &#x3D; 0;\n        cout &lt;&lt; &quot;依据编号，选择排序方式_1.升序排列_2.降序排列&gt;&gt; &quot;;\n        cin &gt;&gt; switchSort;\n\n        for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; ++i)\n        &#123;\n            int maxOrmin &#x3D; i;\n            for (int j &#x3D; i + 1; j &lt; this-&gt;worker_EmpNum; ++j)\n            &#123;\n                &#x2F;&#x2F; 升序排列\n                if (switchSort &#x3D;&#x3D; 1)\n                &#123;\n                    &#x2F;&#x2F; 升序排列，如是指定下标的值 大于 遍历出的最小值，说明指定的不是最小的，把遍历的下标赋值给变量\n                    if (worker_EmpArray[maxOrmin]-&gt;worker_ID &gt; worker_EmpArray[j]-&gt;worker_ID)\n                    &#123;\n                        maxOrmin &#x3D; j;\n                    &#125;\n                &#125;\n                    &#x2F;&#x2F; 降序排列\n                else if (switchSort &#x3D;&#x3D; 2)\n                &#123;\n                    &#x2F;&#x2F; 降序排列，如是指定下标的值 小于 遍历出的最大值，说明指定的不是最大的，把遍历的下标赋值给变量\n                    if (worker_EmpArray[maxOrmin]-&gt;worker_ID &lt; worker_EmpArray[j]-&gt;worker_ID)\n                    &#123;\n                        maxOrmin &#x3D; j;\n                    &#125;\n                &#125;\n                else\n                &#123;\n                    cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 交换数据\n            if (maxOrmin !&#x3D; i)\n            &#123;\n                Worker *temp &#x3D; worker_EmpArray[i];\n                worker_EmpArray[i] &#x3D; worker_EmpArray[maxOrmin];\n                worker_EmpArray[maxOrmin] &#x3D; temp;\n            &#125;\n        &#125;\n        cout &lt;&lt; &quot;排序成功&quot; &lt;&lt; endl;\n        this-&gt;saveNewToFile();\n        this-&gt;showEmployeeInfo();\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 7.清空所有文档\nvoid WorkerManager::toEmptyFile()\n&#123;\n    if (this-&gt;isFileEmpty)\n    &#123;\n        cout &lt;&lt; &quot;职工文件不存在或记录为空&quot; &lt;&lt; endl;\n        system(&quot;pause&quot;);\n        system(&quot;cls&quot;);\n    &#125;\n    else\n    &#123;\n        int switchNum &#x3D; 0;\n        cout &lt;&lt; &quot;确认清空文件_1.确认_2.取消&gt;&gt; &quot;;\n        cin &gt;&gt; switchNum;\n\n        if (switchNum &#x3D;&#x3D; 1)\n        &#123;\n            &#x2F;&#x2F; 打开模式 ios::trunc 如果存在文件 删除后 重新生成\n            ofstream ofs(WORKER_FILENAME, ios::trunc);\n            ofs.close();\n\n            &#x2F;&#x2F; 判断内存中堆区的是否存在 存在需要释放\n            if (this-&gt;worker_EmpArray !&#x3D; nullptr)\n            &#123;\n                for (int i &#x3D; 0; i &lt; this-&gt;worker_EmpNum; i++)\n                &#123;\n                    if (this-&gt;worker_EmpArray[i] !&#x3D; nullptr)\n                    &#123;\n                        delete this-&gt;worker_EmpArray[i];\n                    &#125;\n                &#125;\n                this-&gt;worker_EmpNum &#x3D; 0;\n                delete[] worker_EmpArray;\n                this-&gt;worker_EmpArray &#x3D; nullptr;\n                this-&gt;isFileEmpty &#x3D; true;\n            &#125;\n            cout &lt;&lt; &quot;职工文件清空完成&quot; &lt;&lt; endl;\n            this-&gt;isIDExist &#x3D; false;\n        &#125;\n        else if (switchNum &#x3D;&#x3D; 2)\n        &#123;\n            cout &lt;&lt; &quot;已取消清空职工文件&quot; &lt;&lt; endl;\n\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;输入正确的选择&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n    system(&quot;pause&quot;);\n    system(&quot;cls&quot;);\n&#125;\n\n\nCMakeList.txt\ncmake_minimum_required(VERSION 3.19)\nproject(StaffManagementSystem)\n\nset(CMAKE_CXX_STANDARD 14)\n\nadd_executable(StaffManagementSystem\n        Main&#x2F;StaffManagerSystem_Main.cpp\n        Header&#x2F;workerManager.h Header&#x2F;worker.h Header&#x2F;employee.h Header&#x2F;manager.h Header&#x2F;boss.h\n        Source&#x2F;workerManager.cpp Source&#x2F;employee.cpp Source&#x2F;manager.cpp Source&#x2F;boss.cpp\n        )\n\n\n\n","slug":"1_C++_职工管理系统_04","date":"2022-10-06T07:28:25.925Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"ece0e381639ba808e0c15b18566061ec","title":"C++_通讯录管理系统","content":"C++_通讯录管理系统1. 系统需求\n添加联系人：向通讯录中添加联系人，联系人信息（姓名，性别，年龄，联系电话，家庭住址），最多记录1000人\n显示联系人：显示通讯录中所有联系人信息\n删除联系人：按照姓名进行删除指定联系人\n查找联系人：按照姓名查找指定联系人信息\n修改联系人：按照姓名重新修改联系人信息\n清空联系人：清空通讯录中所有联系人信息\n退出通讯录：退出当前正在使用的通讯录\n\n2. 创建项目1. 创建项目\nVS中创建新项目 AddressBook\n选择空项目\n\n2. 创建文件\n在新的项目中找到源文件\n在源文件中创建空的 AddressBook.cpp文件\n\n3. 菜单功能\n描述：用户选择功能界面\n\n步骤：\n\n分装函数显示该界面 void showAddressBookMenu()\n在main中调用封装好的函数\n创建头文件 AddressBook.h\n创建源文件 Features.cpp\n\n\n代码：\nAddressBook.h\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid showAddressBookMenu();\n\nFeatures.cpp\n#include &quot;AddressBook.h&quot;\n\nvoid showAddressBookMenu()\n&#123;\n\tcout &lt;&lt; &quot;-------- Address Book --------&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t1. 添加联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t2. 显示联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t3. 删除联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t4. 查找联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t5. 修改联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t6. 清空联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t0. 退出通讯录&quot; &lt;&lt; endl;\n&#125;\n\nAddressBook.cpp\n#include &lt;iostream&gt;\n#include &quot;AddressBook.h&quot;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tshowAddressBookMenu();\n&#125;\n\n4. 退出功能\n描述：退出通讯录\n\n思路：通过switch语句判断用户的输入，执行退出功能\n\n代码：\nmain.cpp\n#include &lt;iostream&gt;\n#include &quot;AddressBook.h&quot;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint userSelect;\n\n\twhile (true)\n\t&#123;\n\t\tshowAddressBookMenu();\n\t\t\n\t\tcout &lt;&lt; &quot;Select : &quot;;\n\t\tcin &gt;&gt; userSelect;\n\n\t\tswitch (userSelect)\n\t\t&#123;\n\t\tcase 1: &#x2F;&#x2F;1. 添加联系人\n\t\t\tbreak;\n\t\tcase 2: &#x2F;&#x2F;2. 显示联系人\n\t\t\tbreak;\n\t\tcase 3: &#x2F;&#x2F;3. 删除联系人\n\t\t\tbreak;\n\t\tcase 4: &#x2F;&#x2F;4. 查找联系人\n\t\t\tbreak;\n\t\tcase 5: &#x2F;&#x2F;5. 修改联系人\n\t\t\tbreak;\n\t\tcase 6: &#x2F;&#x2F;6. 清空联系人\n\t\t\tbreak;\n\t\tcase 0: &#x2F;&#x2F;0. 退出通讯录\n\t\t\texitAddressBook();\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n.h\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid showAddressBookMenu();\nvoid exitAddressBook();\n\n源.cpp\n#include &quot;AddressBook.h&quot;\n\nvoid showAddressBookMenu()\n&#123;\n\tcout &lt;&lt; &quot;-------- Address Book --------&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t1. 添加联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t2. 显示联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t3. 删除联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t4. 查找联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t5. 修改联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t6. 清空联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t0. 退出通讯录&quot; &lt;&lt; endl;\n&#125;\n\nvoid exitAddressBook()\n&#123;\n\tcout &lt;&lt; &quot;已退出通讯录&quot; &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n&#125;\n\n5. 添加联系人\n描述：实现添加联系人功能，上限1000人，联系人信息（姓名，性别，年龄，联系电话，住址）\n步骤：\n设计联系人结构体\n设计通讯录结构体\nmain中创建通讯录\n分装添加联系人函数\n\n\n\n1. 设计联系人结构体\n联系人信息（姓名，性别，年龄，联系电话，住址）\nmain\nstruct s_ContactPerson\n&#123;\n\tstring m_Name;\n\tint m_Sex;\n\tint m_Age;\n\tstring m_Address;\n&#125;;\n\n2. 设计通讯录结构体main\n#define MAX 1000 &#x2F;&#x2F;限定通讯录的最大人数\n\nstruct s_AddressBook\n&#123;\n\ts_ContactPerson personArr[MAX];\n\tint m_Size; &#x2F;&#x2F;通讯录的联系人数\n&#125;;\n\n\n\n3. main中创建通讯录s_AddressBook s_ABS; &#x2F;&#x2F;创建通讯录\ns_ABS.m_Size &#x3D; 0;\n\n\n\n4. 添加联系人void addPerson(s_AddressBook* s_ABS)\n&#123;\n\tif (s_ABS-&gt;m_Size &#x3D;&#x3D; MAX)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Address Book is Full !&quot;;\n\t\treturn;\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F;Enter address book contactperson info : name\n\t\tstring enterName;\n\t\tcout &lt;&lt; &quot;Enter name: &quot;;\n\t\tcin &gt;&gt; enterName;\n\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Name &#x3D; enterName;\n\n\t\t&#x2F;&#x2F;Enter address book contactperson info : sex\n\t\tint enterSex &#x3D; 0;\n\t\twhile (true)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Enter sex(1-Man;2-Women;default 0): &quot;;\n\t\t\tcin &gt;&gt; enterSex;\n\t\t\tif (enterSex &#x3D;&#x3D; 1 || enterSex &#x3D;&#x3D; 2)\n\t\t\t&#123;\n\t\t\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Sex &#x3D; enterSex;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Enter 1 or 2&quot; &lt;&lt; endl;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;Enter address book contactperson info : age\n\t\tint enterAge &#x3D; 0;\n\t\tcout &lt;&lt; &quot;Enter age: &quot;;\n\t\tcin &gt;&gt; enterAge;\n\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Age &#x3D; enterAge;\n\n\t\t&#x2F;&#x2F;Enter address book contactperson info : phone\n\t\tstring enterPhone;\n\t\tcout &lt;&lt; &quot;Enter phone: &quot;;\n\t\tcin &gt;&gt; enterPhone;\n\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_phone &#x3D; enterPhone;\n\n\t\t&#x2F;&#x2F;Enter address book contactperson info : address\n\t\tstring enterAddress;\n\t\tcout &lt;&lt; &quot;Enter address: &quot;;\n\t\tcin &gt;&gt; enterAddress;\n\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Address &#x3D; enterAddress;\n\n\t\t&#x2F;&#x2F;tip info\n\t\tcout &lt;&lt; s_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Name &lt;&lt; &quot; Add Succeeded !&quot; &lt;&lt; endl;\n\n\t\t&#x2F;&#x2F;update address book m_size \n\t\ts_ABS-&gt;m_Size++;\n\n\t\t&#x2F;&#x2F;clear console show info\n\t\tsystem(&quot;pause&quot;); &#x2F;&#x2F;请按任意键\n\t\tsystem(&quot;cls&quot;); &#x2F;&#x2F;clear console show info\n\t&#125;\n&#125;\n\nmain中\ncase 1: &#x2F;&#x2F;1. 添加联系人\n\t\t\taddPerson(&amp;s_ABS); &#x2F;&#x2F;通过地址传递结构体实参，可以在函数中修改本地的结构体内实参值\n\t\t\tbreak;\n\n\n\n5. 显示联系人\n描述：显示通讯录中已有的联系人信息\n\n步骤：\n\n封装显示联系人函数\n测速显示联系人函数\n\n代码添加：\nvoid showPerson(s_AddressBook* s_ABS)\n&#123;\n\tif (s_ABS-&gt;m_Size &#x3D;&#x3D; 0)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- Address Book No Contact ! --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; s_ABS-&gt;m_Size; i++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot; &quot; &lt;&lt; s_ABS-&gt;m_Size &lt;&lt; &quot;. &quot;\n\t\t\t\t&lt;&lt; &quot;Name: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Name \n\t\t\t\t&lt;&lt; &quot; &#x2F; Sex: &quot; &lt;&lt; (s_ABS-&gt;personArr[i].m_Sex &#x3D;&#x3D; 1 ? &quot;男&quot;:&quot;女&quot;)\n\t\t\t\t&lt;&lt; &quot; &#x2F; Age: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Age \n\t\t\t\t&lt;&lt; &quot; &#x2F; Phone: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_phone \n\t\t\t\t&lt;&lt; &quot; &#x2F; Address: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Address &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\nmain中\ncase 2: &#x2F;&#x2F;2. 显示联系人\n\t\t\tshowPerson(&amp;s_ABS);\n\t\t\tbreak;\n\n6. 删除联系人\n描述：按照姓名删除指定联系人\n\n步骤：\n\n封装检测联系人是否存在函数\n封装删除联系人函数\n测速删除联系人函数\n\n&#x2F;&#x2F;查找联系人(服务与删除联系人功能)\nint findPerson(s_AddressBook* s_ABS, string enterName)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; s_ABS-&gt;m_Size; i++)\n\t&#123;\n\t\tif (s_ABS-&gt;personArr[i].m_Name &#x3D;&#x3D; enterName)\n\t\t&#123;\n\t\t\treturn i; &#x2F;&#x2F;若找到\n\t\t&#125;\n\t&#125;\n\treturn -1; &#x2F;&#x2F;若没找到\n&#125;\n\n&#x2F;&#x2F;删除联系人\nvoid deletPerson(s_AddressBook* s_ABS, int personIndex, string enterName)\n&#123;\n\tif (personIndex &#x3D;&#x3D; -1)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- &quot; &lt;&lt; enterName &lt;&lt; &quot; Delet Succeeded ! --------&quot; &lt;&lt; endl;\n\t\tfor (int i &#x3D; personIndex; i &lt; s_ABS-&gt;m_Size; i++)\n\t\t&#123;\n\t\t\ts_ABS-&gt;personArr[i] &#x3D; s_ABS-&gt;personArr[i + 1];\n\t\t&#125;\n\t\ts_ABS-&gt;m_Size--;\n\t&#125;\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F;提示输入信息\nstring tipEnterInfo(string enterName)\n&#123;\n\tcout &lt;&lt; &quot;Enter Name for Delet: &quot;;\n\tcin &gt;&gt; enterName;\n\treturn enterName;\n&#125;\n\n&#x2F;&#x2F;提示返回信息\nvoid tipReturnInfo(int returnNum)\n&#123;\n\tif (returnNum &#x3D;&#x3D; -1)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- Have Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n&#125;\n\nmain中\ncase 3: &#x2F;&#x2F;3. 删除联系人\n\t\t&#123;\n\t\t\tstring enterName;\n\t\t\tint personIndex;\n\t\t\t\n\t\t\tenterName &#x3D; tipEnterInfo(enterName);\n\t\t\tfindPerson(&amp;s_ABS, enterName);\n\t\t\t\n\t\t\tpersonIndex &#x3D; findPerson(&amp;s_ABS, enterName);\n\t\t\t&#x2F;&#x2F;tipReturnInfo(findPerson(&amp;s_ABS, enterName));\n\t\t\tdeletPerson(&amp;s_ABS, personIndex, enterName); \n\t\t&#125;\n\n7. 查找联系人\n描述：按照指定的姓名查找联系人是否存在\n\n步骤：\n\n封装查找联系人函数\n测速查找联系人函数\n\n&#x2F;&#x2F;查找联系人\nvoid findPerson(s_AddressBook* s_ABS)\n&#123;\n\tcout &lt;&lt; &quot;Enter name: &quot;;\n\tstring findName;\n\tcin &gt;&gt; findName;\n\n\tint nameIndex &#x3D; findPersonByDelet(s_ABS, findName);\n\t\n\tif (nameIndex &#x3D;&#x3D; -1)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot; &quot; &lt;&lt; nameIndex &lt;&lt; &quot;. &quot;\n\t\t\t&lt;&lt; &quot;Name: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Name\n\t\t\t&lt;&lt; &quot; &#x2F; Sex: &quot; &lt;&lt; (s_ABS-&gt;personArr[nameIndex].m_Sex &#x3D;&#x3D; 1 ? &quot;男&quot; : &quot;女&quot;)\n\t\t\t&lt;&lt; &quot; &#x2F; Age: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Age\n\t\t\t&lt;&lt; &quot; &#x2F; Phone: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_phone\n\t\t\t&lt;&lt; &quot; &#x2F; Address: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Address &lt;&lt; endl;\n\t&#125;\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\nmain中\ncase 4: &#x2F;&#x2F;4. 查找联系人\n\t\t\tfindPerson(&amp;s_ABS);\n\t\t\tbreak;\n\n8. 修改联系人\n描述：修改指定姓名的联系人的信息\n\n步骤：\n\n封装修改联系人函数\n测速修改联系人函数\n\n &#x2F;&#x2F;修改联系人菜单\n void showModifyContactMenu()\n &#123;\n \tcout &lt;&lt; endl;\n \tcout &lt;&lt; &quot;-------- Modify Contact --------&quot; &lt;&lt; endl;\n \tcout &lt;&lt; &quot;\\t1. Modify Name&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;\\t2. Modify Sex&quot; &lt;&lt; endl;\n \tcout &lt;&lt; &quot;\\t3. Modify Age&quot; &lt;&lt; endl;\n \tcout &lt;&lt; &quot;\\t4. Modify Phone&quot; &lt;&lt; endl;\n \tcout &lt;&lt; &quot;\\t5. Modify Address&quot; &lt;&lt; endl;\n \tcout &lt;&lt; &quot;\\t0. Exit Modify&quot; &lt;&lt; endl;\n &#125;\n \n &#x2F;&#x2F;修改联系人\n int modifyPerson(s_AddressBook* s_ABS)\n &#123;\n \tcout &lt;&lt; &quot;Enter name: &quot;;\n \tstring modifyName;\n \tcin &gt;&gt; modifyName;\n \n \tint nameIndex &#x3D; findPersonByDeletOrModify(s_ABS, modifyName);\n \n \tif (nameIndex &#x3D;&#x3D; -1)\n \t&#123;\n \t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\n \t&#125;\n \telse\n \t&#123;\n \t\tint userSelect;\n \t\t\n \t\twhile (true)\n \t\t&#123;\n \t\t\tshowModifyContactMenu();\n \n \t\t\tcout &lt;&lt; &quot;Select : &quot;;\n \t\t\tcin &gt;&gt; userSelect;\n \t\t\t\n \t\t\tswitch (userSelect)\n \t\t\t&#123;\n \t\t\tcase 1 : &#x2F;&#x2F;Modify Name\n \t\t\t&#123;\n \t\t\t\tcout &lt;&lt; &quot;Enter name: &quot; &lt;&lt; endl;\n \t\t\t\tstring newName;\n \t\t\t\tcin &gt;&gt; newName;\n \t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Name &#x3D; newName;\n \t\t\t\tcout &lt;&lt; &quot;-------- Modify Name Succeeded ! --------&quot; &lt;&lt; endl;\n \t\t\t\t\n \t\t\t\tsystem(&quot;pause&quot;);\n \t\t\t\tsystem(&quot;cls&quot;);\n \t\t\t&#125;\n \t\t\t\tbreak;\n \t\t\tcase 2: &#x2F;&#x2F;Modify Sex\n \t\t\t&#123;\n \t\t\t\tcout &lt;&lt; &quot;Enter sex(1-Man &#x2F; 2-Women &#x2F; default 1): &quot;;\n \t\t\t\tint newSex;\n \t\t\t\twhile (true)\n \t\t\t\t&#123;\n \t\t\t\t\tcin &gt;&gt; newSex;\n \t\t\t\t\tif (newSex &#x3D;&#x3D; 1 || newSex &#x3D;&#x3D; 2)\n \t\t\t\t\t&#123;\n \t\t\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Sex &#x3D; newSex;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t&#125;\n \t\t\t\t\telse\n \t\t\t\t\t&#123;\n \t\t\t\t\t\tcout &lt;&lt; &quot;Enter 1 or 2&quot; &lt;&lt; endl;\n \t\t\t\t\t&#125;\n \t\t\t\t&#125;\n \t\t\t\tcout &lt;&lt; &quot;-------- Modify Sex Succeeded ! --------&quot; &lt;&lt; endl;\n \n \t\t\t\tsystem(&quot;pause&quot;);\n \t\t\t\tsystem(&quot;cls&quot;);\n \t\t\t&#125;\n \t\t\t\tbreak;\n \t\t\tcase 3: &#x2F;&#x2F;Modify Age\n \t\t\t&#123;\n \t\t\t\tcout &lt;&lt; &quot;Enter Age: &quot;;\n \t\t\t\tint newAge;\n \t\t\t\tcin &gt;&gt; newAge;\n \t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Age &#x3D; newAge;\n \t\t\t\tcout &lt;&lt; &quot;-------- Modify Age Succeeded ! --------&quot; &lt;&lt; endl;\n \n \t\t\t\tsystem(&quot;pause&quot;);\n \t\t\t\tsystem(&quot;cls&quot;);\n \t\t\t&#125;\n \t\t\t\tbreak;\n \t\t\tcase 4: &#x2F;&#x2F;Modify Phone\n \t\t\t&#123;\n \t\t\t\tcout &lt;&lt; &quot;Enter Phone: &quot;;\n \t\t\t\tstring newPhone;\n \t\t\t\tcin &gt;&gt; newPhone;\n \t\t\t\ts_ABS-&gt;personArr[nameIndex].m_phone &#x3D; newPhone;\n \t\t\t\tcout &lt;&lt; &quot;-------- Modify Phone Succeeded ! --------&quot; &lt;&lt; endl;\n \n \t\t\t\tsystem(&quot;pause&quot;);\n \t\t\t\tsystem(&quot;cls&quot;);\n \t\t\t&#125;\n \t\t\t\tbreak;\n \t\t\tcase 5: &#x2F;&#x2F;Modify Address\n \t\t\t&#123;\n \t\t\t\tcout &lt;&lt; &quot;Enter Address: &quot;;\n \t\t\t\tstring newAddress;\n \t\t\t\tcin &gt;&gt; newAddress;\n \t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Address &#x3D; newAddress;\n \t\t\t\tcout &lt;&lt; &quot;-------- Modify Address Succeeded ! --------&quot; &lt;&lt; endl;\n \n \t\t\t\tsystem(&quot;pause&quot;);\n \t\t\t\tsystem(&quot;cls&quot;);\n \t\t\t&#125;\n \t\t\t\tbreak;\n \t\t\tcase 0:\n \t\t\t&#123;\n \t\t\t\tcout &lt;&lt; &quot;已退出修改联系人&quot; &lt;&lt; endl;\n \t\t\t\tsystem(&quot;pause&quot;);\n \t\t\t\tsystem(&quot;cls&quot;);\n \t\t\t&#125;\n \t\t\treturn 0;\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tbreak;\n \t\t\t&#125;\n \t\t&#125;\n \t&#125;\n \n \tsystem(&quot;pause&quot;);\n \tsystem(&quot;cls&quot;);\n &#125;\n\nmain\ncase 5: &#x2F;&#x2F;5. 修改联系人\n\t\t\tmodifyPerson(&amp;s_ABS);\n\t\t\tbreak;\n\n9. 清空联系人\n描述：清空通讯录中所有联系人的信息\n\n步骤：\n\n封装清空联系人函数\n测速清空联系人函数\n\n&#x2F;&#x2F;清空联系人\nvoid cleanPerson(s_AddressBook* s_ABS)\n&#123;\n\tstring enterYN;\n\tstring selectYN;\n\twhile (true)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Clean All Contact ( y &#x2F; n ): &quot;;\n\t\tcin &gt;&gt; enterYN;\n\t\tif (enterYN &#x3D;&#x3D; &quot;y&quot; || enterYN &#x3D;&#x3D; &quot;n&quot;)\n\t\t&#123;\n\t\t\tselectYN &#x3D; enterYN;\n\t\t\tbreak;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Enter y or n&quot; &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\n\tif (selectYN &#x3D;&#x3D; &quot;y&quot;)\n\t&#123;\n\t\ts_ABS-&gt;m_Size &#x3D; 0;\n\t\tcout &lt;&lt; &quot;-------- Address Book Clean Succeeded ! --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- Address Book Clean Exit ! --------&quot; &lt;&lt; endl;\n\t&#125;\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\nmain\ncase 6: &#x2F;&#x2F;6. 清空联系人\n\t\t\tcleanPerson(&amp;s_ABS);\n\t\t\tbreak;\n\n6. 源码#include &lt;iostream&gt;\n#define MAX 1000 &#x2F;&#x2F;限定通讯录的最大人数\n\nusing namespace std;\n\nstruct s_ContactPerson\n&#123;\n\tstring m_Name;\n\tint m_Sex &#x3D; 1;\n\tint m_Age &#x3D; 0;\n\tstring m_phone;\n\tstring m_Address;\n&#125;;\n\nstruct s_AddressBook\n&#123;\n\ts_ContactPerson personArr[MAX];\n\tint m_Size &#x3D; 0; &#x2F;&#x2F;通讯录的联系人数\n&#125;;\n\n&#x2F;&#x2F;显示通讯录菜单\nvoid showAddressBookMenu()\n&#123;\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; &quot;-------- Address Book --------&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t1. 添加联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t2. 显示联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t3. 删除联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t4. 查找联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t5. 修改联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t6. 清空联系人&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t0. 退出通讯录&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;添加联系人\nvoid addPerson(s_AddressBook* s_ABS)\n&#123;\n\tif (s_ABS-&gt;m_Size &#x3D;&#x3D; MAX)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Address Book is Full !&quot;;\n\t\treturn;\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F;Enter address book contactperson info : name\n\t\tstring enterName;\n\t\tcout &lt;&lt; &quot;Enter name: &quot;;\n\t\tcin &gt;&gt; enterName;\n\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Name &#x3D; enterName;\n\n\t\t&#x2F;&#x2F;Enter address book contactperson info : sex\n\t\tint enterSex &#x3D; 0;\n\t\twhile (true)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Enter sex(1-Man &#x2F; 2-Women &#x2F; default 1): &quot;;\n\t\t\tcin &gt;&gt; enterSex;\n\t\t\tif (enterSex &#x3D;&#x3D; 1 || enterSex &#x3D;&#x3D; 2)\n\t\t\t&#123;\n\t\t\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Sex &#x3D; enterSex;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Enter 1 or 2&quot; &lt;&lt; endl;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;Enter address book contactperson info : age\n\t\tint enterAge &#x3D; 0;\n\t\tcout &lt;&lt; &quot;Enter age: &quot;;\n\t\tcin &gt;&gt; enterAge;\n\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Age &#x3D; enterAge;\n\n\t\t&#x2F;&#x2F;Enter address book contactperson info : phone\n\t\tstring enterPhone;\n\t\tcout &lt;&lt; &quot;Enter phone: &quot;;\n\t\tcin &gt;&gt; enterPhone;\n\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_phone &#x3D; enterPhone;\n\n\t\t&#x2F;&#x2F;Enter address book contactperson info : address\n\t\tstring enterAddress;\n\t\tcout &lt;&lt; &quot;Enter address: &quot;;\n\t\tcin &gt;&gt; enterAddress;\n\t\ts_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Address &#x3D; enterAddress;\n\n\t\t&#x2F;&#x2F;tip info\n\t\tcout &lt;&lt; &quot;-------- &quot; &lt;&lt; s_ABS-&gt;personArr[s_ABS-&gt;m_Size].m_Name &lt;&lt; &quot; Add Succeeded ! --------&quot; &lt;&lt; endl;\n\n\t\t&#x2F;&#x2F;update address book m_size \n\t\ts_ABS-&gt;m_Size++;\n\n\t\t&#x2F;&#x2F;clear console show info\n\t\tsystem(&quot;pause&quot;); &#x2F;&#x2F;请按任意键\n\t\tsystem(&quot;cls&quot;); &#x2F;&#x2F;clear console show info\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;显示联系人\nvoid showPerson(s_AddressBook* s_ABS)\n&#123;\n\tif (s_ABS-&gt;m_Size &#x3D;&#x3D; 0)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- Address Book No Contact ! --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; s_ABS-&gt;m_Size; i++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot;. &quot;\n\t\t\t\t&lt;&lt; &quot;Name: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Name \n\t\t\t\t&lt;&lt; &quot; &#x2F; Sex: &quot; &lt;&lt; (s_ABS-&gt;personArr[i].m_Sex &#x3D;&#x3D; 1 ? &quot;男&quot;:&quot;女&quot;)\n\t\t\t\t&lt;&lt; &quot; &#x2F; Age: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Age \n\t\t\t\t&lt;&lt; &quot; &#x2F; Phone: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_phone \n\t\t\t\t&lt;&lt; &quot; &#x2F; Address: &quot; &lt;&lt; s_ABS-&gt;personArr[i].m_Address &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F;查找联系人(服务与删除联系人功能)\nint findPersonByDeletOrModify (s_AddressBook* s_ABS, string enterName)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; s_ABS-&gt;m_Size; i++)\n\t&#123;\n\t\tif (s_ABS-&gt;personArr[i].m_Name &#x3D;&#x3D; enterName)\n\t\t&#123;\n\t\t\treturn i; &#x2F;&#x2F;若找到\n\t\t&#125;\n\t&#125;\n\treturn -1; &#x2F;&#x2F;若没找到\n&#125;\n\n&#x2F;&#x2F;删除联系人\nvoid deletPerson(s_AddressBook* s_ABS, int personIndex, string enterName)\n&#123;\n\tif (personIndex &#x3D;&#x3D; -1)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- &quot; &lt;&lt; enterName &lt;&lt; &quot; Delet Succeeded ! --------&quot; &lt;&lt; endl;\n\t\tfor (int i &#x3D; personIndex; i &lt; s_ABS-&gt;m_Size; i++)\n\t\t&#123;\n\t\t\ts_ABS-&gt;personArr[i] &#x3D; s_ABS-&gt;personArr[i + 1];\n\t\t&#125;\n\t\ts_ABS-&gt;m_Size--;\n\t&#125;\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F;提示输入信息\nstring tipEnterInfo(string enterName)\n&#123;\n\tcout &lt;&lt; &quot;Enter Name for Delet: &quot;;\n\tcin &gt;&gt; enterName;\n\treturn enterName;\n&#125;\n\n&#x2F;&#x2F;提示返回信息\nvoid tipReturnInfo(int returnNum)\n&#123;\n\tif (returnNum &#x3D;&#x3D; -1)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- Have Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;查找联系人\nvoid findPerson(s_AddressBook* s_ABS)\n&#123;\n\tcout &lt;&lt; &quot;Enter name: &quot;;\n\tstring findName;\n\tcin &gt;&gt; findName;\n\n\tint nameIndex &#x3D; findPersonByDeletOrModify(s_ABS, findName);\n\t\n\tif (nameIndex &#x3D;&#x3D; -1)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot; &quot; &lt;&lt; nameIndex &lt;&lt; &quot;. &quot;\n\t\t\t&lt;&lt; &quot;Name: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Name\n\t\t\t&lt;&lt; &quot; &#x2F; Sex: &quot; &lt;&lt; (s_ABS-&gt;personArr[nameIndex].m_Sex &#x3D;&#x3D; 1 ? &quot;男&quot; : &quot;女&quot;)\n\t\t\t&lt;&lt; &quot; &#x2F; Age: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Age\n\t\t\t&lt;&lt; &quot; &#x2F; Phone: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_phone\n\t\t\t&lt;&lt; &quot; &#x2F; Address: &quot; &lt;&lt; s_ABS-&gt;personArr[nameIndex].m_Address &lt;&lt; endl;\n\t&#125;\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F;修改联系人菜单\nvoid showModifyContactMenu()\n&#123;\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; &quot;-------- Modify Contact --------&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t1. Modify Name&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t2. Modify Sex&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t3. Modify Age&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t4. Modify Phone&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t5. Modify Address&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;\\t0. Exit Modify&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;修改联系人\nint modifyPerson(s_AddressBook* s_ABS)\n&#123;\n\tcout &lt;&lt; &quot;Enter name: &quot;;\n\tstring modifyName;\n\tcin &gt;&gt; modifyName;\n\n\tint nameIndex &#x3D; findPersonByDeletOrModify(s_ABS, modifyName);\n\n\tif (nameIndex &#x3D;&#x3D; -1)\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- No Contact --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tint userSelect;\n\t\t\n\t\twhile (true)\n\t\t&#123;\n\t\t\tshowModifyContactMenu();\n\n\t\t\tcout &lt;&lt; &quot;Select : &quot;;\n\t\t\tcin &gt;&gt; userSelect;\n\t\t\t\n\t\t\tswitch (userSelect)\n\t\t\t&#123;\n\t\t\tcase 1 : &#x2F;&#x2F;Modify Name\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Enter name: &quot; &lt;&lt; endl;\n\t\t\t\tstring newName;\n\t\t\t\tcin &gt;&gt; newName;\n\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Name &#x3D; newName;\n\t\t\t\tcout &lt;&lt; &quot;-------- Modify Name Succeeded ! --------&quot; &lt;&lt; endl;\n\t\t\t\t\n\t\t\t\tsystem(&quot;pause&quot;);\n\t\t\t\tsystem(&quot;cls&quot;);\n\t\t\t&#125;\n\t\t\t\tbreak;\n\t\t\tcase 2: &#x2F;&#x2F;Modify Sex\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Enter sex(1-Man &#x2F; 2-Women &#x2F; default 1): &quot;;\n\t\t\t\tint newSex;\n\t\t\t\twhile (true)\n\t\t\t\t&#123;\n\t\t\t\t\tcin &gt;&gt; newSex;\n\t\t\t\t\tif (newSex &#x3D;&#x3D; 1 || newSex &#x3D;&#x3D; 2)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Sex &#x3D; newSex;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t\telse\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tcout &lt;&lt; &quot;Enter 1 or 2&quot; &lt;&lt; endl;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tcout &lt;&lt; &quot;-------- Modify Sex Succeeded ! --------&quot; &lt;&lt; endl;\n\n\t\t\t\tsystem(&quot;pause&quot;);\n\t\t\t\tsystem(&quot;cls&quot;);\n\t\t\t&#125;\n\t\t\t\tbreak;\n\t\t\tcase 3: &#x2F;&#x2F;Modify Age\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Enter Age: &quot;;\n\t\t\t\tint newAge;\n\t\t\t\tcin &gt;&gt; newAge;\n\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Age &#x3D; newAge;\n\t\t\t\tcout &lt;&lt; &quot;-------- Modify Age Succeeded ! --------&quot; &lt;&lt; endl;\n\n\t\t\t\tsystem(&quot;pause&quot;);\n\t\t\t\tsystem(&quot;cls&quot;);\n\t\t\t&#125;\n\t\t\t\tbreak;\n\t\t\tcase 4: &#x2F;&#x2F;Modify Phone\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Enter Phone: &quot;;\n\t\t\t\tstring newPhone;\n\t\t\t\tcin &gt;&gt; newPhone;\n\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_phone &#x3D; newPhone;\n\t\t\t\tcout &lt;&lt; &quot;-------- Modify Phone Succeeded ! --------&quot; &lt;&lt; endl;\n\n\t\t\t\tsystem(&quot;pause&quot;);\n\t\t\t\tsystem(&quot;cls&quot;);\n\t\t\t&#125;\n\t\t\t\tbreak;\n\t\t\tcase 5: &#x2F;&#x2F;Modify Address\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Enter Address: &quot;;\n\t\t\t\tstring newAddress;\n\t\t\t\tcin &gt;&gt; newAddress;\n\t\t\t\ts_ABS-&gt;personArr[nameIndex].m_Address &#x3D; newAddress;\n\t\t\t\tcout &lt;&lt; &quot;-------- Modify Address Succeeded ! --------&quot; &lt;&lt; endl;\n\n\t\t\t\tsystem(&quot;pause&quot;);\n\t\t\t\tsystem(&quot;cls&quot;);\n\t\t\t&#125;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;已退出修改联系人&quot; &lt;&lt; endl;\n\t\t\t\tsystem(&quot;pause&quot;);\n\t\t\t\tsystem(&quot;cls&quot;);\n\t\t\t&#125;\n\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F;清空联系人\nvoid cleanPerson(s_AddressBook* s_ABS)\n&#123;\n\tstring enterYN;\n\tstring selectYN;\n\twhile (true)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Clean All Contact ( y &#x2F; n ): &quot;;\n\t\tcin &gt;&gt; enterYN;\n\t\tif (enterYN &#x3D;&#x3D; &quot;y&quot; || enterYN &#x3D;&#x3D; &quot;n&quot;)\n\t\t&#123;\n\t\t\tselectYN &#x3D; enterYN;\n\t\t\tbreak;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Enter y or n&quot; &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\n\tif (selectYN &#x3D;&#x3D; &quot;y&quot;)\n\t&#123;\n\t\ts_ABS-&gt;m_Size &#x3D; 0;\n\t\tcout &lt;&lt; &quot;-------- Address Book Clean Succeeded ! --------&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;-------- Address Book Clean Exit ! --------&quot; &lt;&lt; endl;\n\t&#125;\n\tsystem(&quot;pause&quot;);\n\tsystem(&quot;cls&quot;);\n&#125;\n\n&#x2F;&#x2F;退出通讯录\nvoid exitAddressBook()\n&#123;\n\tcout &lt;&lt; &quot;已退出通讯录&quot; &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n&#125;\n\n\nint main()\n&#123;\n\tint userSelect;\n\ts_AddressBook s_ABS; &#x2F;&#x2F;创建通讯录\n\ts_ABS.m_Size &#x3D; 0;\n\n\twhile (true)\n\t&#123;\n\t\tshowAddressBookMenu();\n\t\t\n\t\tcout &lt;&lt; &quot;Select : &quot;;\n\t\tcin &gt;&gt; userSelect;\n\n\t\tswitch (userSelect)\n\t\t&#123;\n\t\tcase 1: &#x2F;&#x2F;1. 添加联系人\n\t\t\taddPerson(&amp;s_ABS); &#x2F;&#x2F;通过地址传递结构体实参，可以在函数中修改本地的结构体内实参值\n\t\t\tbreak;\n\t\tcase 2: &#x2F;&#x2F;2. 显示联系人\n\t\t\tshowPerson(&amp;s_ABS);\n\t\t\tbreak;\n\t\tcase 3: &#x2F;&#x2F;3. 删除联系人\n\t\t&#123;\n\t\t\tstring enterName;\n\t\t\tint personIndex;\n\t\t\t\n\t\t\tenterName &#x3D; tipEnterInfo(enterName);\n\t\t\tfindPersonByDeletOrModify(&amp;s_ABS, enterName);\n\t\t\t\n\t\t\tpersonIndex &#x3D; findPersonByDeletOrModify(&amp;s_ABS, enterName);\n\t\t\t&#x2F;&#x2F;tipReturnInfo(findPersonByDeletOrModify(&amp;s_ABS, enterName));\n\t\t\tdeletPerson(&amp;s_ABS, personIndex, enterName); \n\t\t&#125;\n\t\t\tbreak;\n\t\tcase 4: &#x2F;&#x2F;4. 查找联系人\n\t\t\tfindPerson(&amp;s_ABS);\n\t\t\tbreak;\n\t\tcase 5: &#x2F;&#x2F;5. 修改联系人\n\t\t\tmodifyPerson(&amp;s_ABS);\n\t\t\tbreak;\n\t\tcase 6: &#x2F;&#x2F;6. 清空联系人\n\t\t\tcleanPerson(&amp;s_ABS);\n\t\t\tbreak;\n\t\tcase 0: &#x2F;&#x2F;0. 退出通讯录\n\t\t\texitAddressBook();\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n","slug":"1_C++_通讯录管理系统_02","date":"2022-10-06T07:28:25.923Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"85a2acfa491d3e6f2208fd787a774695","title":"C++_模板和STL","content":"C++_模板和STL\n记录C++泛型编程和STL的使用和原理\n\n1. 模板-Template1.1 模板概念\n作用：建立通用的模具，提高编程的复用性\n特点：\n模板在实际项目中不可直接使用，它只是一个框架，需根据实际情况进行使用\n模板的通用不是万能的\n\n\n\n1.2 函数模板\nC++提供了另一种编程思想，泛型编程，主要利用的技术就是模板template\nC++提供了两种模板机制：函数模板和类模板\n\n1.2.1 函数模板语法\n函数模板的作用：\n\n建立一个通用函数，其函数返回值类型和形参类型可以不确定，是一个虚拟的类型\n\n当需要使用时，再根据实际情况进行声明或由编译器自行判断数据类型\n\n\n\n语法：\ntemplate &lt;typename T&gt;\n函数的声明或定义\n\n\n\n解释：\n\ntemplate：声明创建模板\ntypename：表面后面的符号，代表着是一种数据类型，但不确定是哪种，也可以用class来代替\nT：通用数据类型，是一个符号，可以换成别的代替，通常大写，并习惯写成T\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 13:35\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 函数模板\n&#x2F;&#x2F; 声明一个模板，通用数据符号 T， 防止编译器报错\ntemplate &lt;typename T&gt;\nvoid swap_T(T &amp;num1, T &amp;num2)\n&#123;\n    T tempNum &#x3D; num1;\n    num1 &#x3D; num2;\n    num2 &#x3D; tempNum;\n&#125;\n\nvoid demo1()\n&#123;\n    int num1 &#x3D; 10;\n    int num2 &#x3D; 20;\n    &#x2F;&#x2F; 自动类型推导\n    swap_T(num1, num2);\n    cout &lt;&lt; &quot;自动类型: &quot; ;\n    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;\n\n    &#x2F;&#x2F; 指定类型\n    swap_T&lt;int&gt;(num1, num2);\n    cout &lt;&lt; &quot;指定类型: &quot; ;\n    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;\n\n\n\n总结：\n\n函数模板的创建利用关键字template\n使用函数模板有两种方式：自动类型推导和显示指定类型\n模板的目的是提高复用性，将类型参数化\n\n\n\n1.2.2 函数模板注意事项注意事项：\n\n自动类型推导：通用数据类型 T 必须推导出一致的类型，才能使用\n模板函数在使用时，无论哪种方式，必须确定了使用的数据类型，才能使用\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 13:55\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nvoid swap_T(T &amp;num1, T &amp;num2)\n&#123;\n    T tempNum &#x3D; num1;\n    num1 &#x3D; num2;\n    num2 &#x3D; tempNum;\n&#125;\n\nvoid demo1()\n&#123;\n    int num1 &#x3D; 10;\n    int num2 &#x3D; 20;\n    char c1 &#x3D; &#39;A&#39;;\n    &#x2F;&#x2F; 自动类型推导\n    &#x2F;&#x2F; num1 和 num2 都是 int 类型，可以自动推导出是一致类型\n    swap_T(num1, num2);\n\n    &#x2F;&#x2F; c1是char类型，是错误的使用方式\n    &#x2F;&#x2F; swap_T(c1, num2);\n    cout &lt;&lt; &quot;自动类型: &quot; ;\n    cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot; -&quot; &lt;&lt; &quot; num2: &quot; &lt;&lt; num2 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;\n\n\n\n\n\n1.2.3 函数模板案例\n案例描述：\n\n利用函数模板封装一个排序函数，可以对不同类型数据进行排序\n排序规则：从大到小，排序算法为选择排序\n分别利用char数组和int数组进行测试\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 14:01\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\ntemplate &lt;class T&gt;\nvoid swap_T(T &amp;a, T &amp;b)\n&#123;\n    T temp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; temp;\n&#125;\n\ntemplate &lt;class T&gt;\nvoid sort_T(T arr[], int length)\n&#123;\n    for (int i &#x3D; 0; i &lt; length; ++i)\n    &#123;\n        &#x2F;&#x2F; 假设最大值的下标，后面进行比较\n        int max &#x3D; i;\n        for (int j &#x3D; i + 1; j &lt; length; ++j)\n        &#123;\n            &#x2F;&#x2F; 将假设的下标对应的值和后面的值，比较\n            if (arr[max] &lt; arr[j])\n            &#123;\n                max &#x3D; j;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 上面的循环结束后，检查一开始假设的下标，是否是循环检查出的最大值下标\n        if (max !&#x3D; i)\n        &#123;\n            swap_T(arr[max], arr[i]);\n        &#125;\n    &#125;\n&#125;\n\ntemplate &lt;class T&gt;\nvoid print_T(T arr, int length)\n&#123;\n    cout &lt;&lt; &quot;从大到小排序后：&quot;;\n    for (int i &#x3D; 0; i &lt; length; ++i)\n    &#123;\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid sortCharDemo()\n&#123;\n    char c_Array[26];\n    int c_Length;\n\n    cout &lt;&lt; &quot;输入字符(a - z) &gt;&gt; &quot;;\n    cin &gt;&gt; c_Array;\n    &#x2F;&#x2F; 实际的字符后面有一个 &#96;\\0&#96;收尾,这获取长度方法不好\n    &#x2F;&#x2F;c_Length &#x3D; (sizeof(c_Array) &#x2F; sizeof(char));\n\n    &#x2F;&#x2F; strlen() 获取长度，读到&#96;\\0&#96;，就不读，适合这个项目的需求\n    &#x2F;&#x2F; 需要包含 &lt;cstring&gt;\n    c_Length &#x3D; strlen(c_Array);\n\n    sort_T(c_Array, c_Length);\n    print_T(c_Array, c_Length);\n&#125;\n\nvoid sortIntDemo()\n&#123;\n    int i_Array[10];\n    int i &#x3D; 0;\n    int i_Length;\n\n    cout &lt;&lt; &quot;输入数字(0 - 9) &gt;&gt; &quot;;\n    while (cin.peek() !&#x3D; &#39;\\n&#39;)\n    &#123;\n        cin &gt;&gt; i_Array[i++];\n        i_Length &#x3D; i;\n    &#125;\n\n    sort_T(i_Array, i_Length);\n    print_T(i_Array, i_Length);\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; sortCharDemo();\n    sortIntDemo();\n    return 0;\n&#125;\n\n1.2.4 普通和模板函区别\n区别：\n\n普通函数调用时，可以发生自动类型转换 (隐式类型转换)\n函数模板调用时，利用自动类型转换，不会发生(隐式类型转换)\n如果利用显示指定类型的方式，可以发生(隐式类型转换)\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 15:54\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint add(int a,  int b)\n&#123;\n    return a + b;\n&#125;\n\ntemplate &lt;class T&gt;\nT add_T(T a, T b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    &#x2F;&#x2F; c -&gt; ASCII &#x3D; 97\n    char c &#x3D; &#39;a&#39;;\n\n    &#x2F;&#x2F; 普通函数 可以隐式类型转换\n    cout &lt;&lt; add(a, c) &lt;&lt; endl;\n\n    &#x2F;&#x2F; 模板函数 自动类型转换 无法隐式类型转换\n    &#x2F;&#x2F; cout &lt;&lt; add_T(a, c) &lt;&lt; endl;\n    &#x2F;&#x2F; 指定类型转换 可以隐式类型转换\n    cout &lt;&lt; add_T&lt;int&gt;(a, c) &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n总结：建议使用显示指定类型的方式调用函数模板，可以自己确定通用类型T\n\n\n1.2.5 普通和模板函数调用\n调用规则：\n\n如果函数模板和普通函数都能实现，优先调用普通函数\n可以通过空模板参数列表来，强制调用函数模板\n函数模板可以发生重载\n如果函数模板可以产生更好的匹配，优先调用函数模板\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 16:18\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid print(int a, int b)\n&#123;\n    cout &lt;&lt; &quot;普通函数调用&quot; &lt;&lt; endl;\n&#125;\n\ntemplate &lt;class T&gt;\nT print(T a, T b)\n&#123;\n    cout &lt;&lt; &quot;模板函数调用&quot; &lt;&lt; endl;\n&#125;\n\ntemplate &lt;class T&gt;\nT print(T a, T b, T c)\n&#123;\n    cout &lt;&lt; &quot;模板函数重载调用&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 1. 如果函数模板和普通函数都能实现，优先调用普通函数\n    print(1, 2);\n\n    &#x2F;&#x2F; 2. 可以通过空模板参数列表来，强制调用函数模板\n    print&lt;&gt;(1, 2);\n\n    &#x2F;&#x2F; 3. 函数模板可以发生重载\n    print(1, 2, 3);\n\n    &#x2F;&#x2F; 4. 如果函数模板可以产生更好的匹配，优先调用函数模板\n    &#x2F;&#x2F; 因为 a， b为char，隐式类型转换调用普通函数，不如直接自动类型转换调用模板函数调用来的方便\n    print(&#39;a&#39;, &#39;b&#39;);\n\n    return 0;\n&#125;\n\n总结：如果需要使用模板函数，就不用提供声明普通函数，以免产生二义性\n\n\n1.2.6 模板的局限性\n局限性：模板的通用性，并非万能\n\n代码示例_1：如果传入的 a 和 b是数组，该模板函数无法实现\ntemplate &lt;class T&gt;\nvoid func(T a, T b)\n&#123;\n    a &#x3D; b;\n&#125;\n\n代码示例_2：传入的是自定义类型数据，同样无法实现\ntemplate &lt;class T&gt;\nvoid func(T a, T b)\n&#123;\n    if (a &gt; b)\n    &#123;......&#125;\n&#125;\n\n\n\n解决方法：C++为了解决这个问题，提供模板的重载，可以为特定的类型提供具体化的模板\n\n代码示例_3：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 16:44\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 自定义的结构体数据类型\nstruct Person\n&#123;\n    Person(int age, string name)\n    &#123;\n        this-&gt;age &#x3D; age;\n        this-&gt;name &#x3D; name;\n    &#125;\n    int age;\n    string name;\n&#125;;\n\ntemplate &lt;class T&gt;\nbool compare_T(T &amp;a, T &amp;b)\n&#123;\n    return a &#x3D;&#x3D; b;\n&#125;\n\n&#x2F;&#x2F; 具体化模板函数的实现，当传入参数类型为 Person，优先调用这个模板函数\ntemplate&lt;&gt; bool compare_T(Person &amp;p1, Person &amp;p2)\n&#123;\n    return p1.age &#x3D;&#x3D; p2.age &amp;&amp; p1.name &#x3D;&#x3D; p2.name;\n&#125;\n\nvoid demo1()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n    bool rel &#x3D; compare_T(a, b);\n    string printInfo &#x3D; rel ? &quot;a &#x3D; b&quot; : &quot;a !&#x3D; b&quot;;\n    cout &lt;&lt; printInfo &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    Person p1(10, &quot;fh&quot;);\n    Person p2(10, &quot;fh&quot;);\n    bool rel &#x3D; compare_T(p1, p2);\n    string printInfo &#x3D; rel ? &quot;p1 &#x3D; p2&quot; : &quot;p1 !&#x3D; p2&quot;;\n    cout &lt;&lt; printInfo &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n总结：\n\n利用具体化模板函数，可以解决自定义类型的通用化\n学习模板并非是为了写模板，而是能够在STL中使用系统提供的模板\n\n\n\n1.3 类模板1.3.1 类模板语法\n类模板作用：建立一个通用类，类的成员数据类型可以不具体声明，用虚拟类型代替\n\n类模板语法：\ntemplate &lt;class name_T, class age_T&gt;\nclass 类名\n&#123;\npublic:\n    name_T name;\n    age_T age;\n&#125;;\n\n代码示例：类和结构体都可以\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;9 17:17\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 类和结构体都可以这么用\ntemplate &lt;class name_T, class age_T&gt;\nstruct Person\n&#123;\n    name_T name;\n    age_T age;\n\n    Person(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Person&lt;string, int&gt;(&quot;fh&quot;, 24);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n1.3.2 类和模板区别\n区别：\n\n类模板没有自动类型推导的使用方式\n类模板在模板参数列表中，可以有默认参数\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;11 7:40\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nstruct Person01\n&#123;\n    name_T name;\n    age_T age;\n\n    Person01(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n    ~Person01()\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 用结构体来代替类了\n&#x2F;&#x2F; 类模板中，可以在参数列表中，指明默认参数类型，生成对象时，不需要再显示指定类型\ntemplate &lt;class name_T &#x3D; string, class age_T &#x3D; int&gt;\nstruct Person02\n&#123;\n    name_T name;\n    age_T age;\n\n    Person02(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n    ~Person02()\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo_P1()\n&#123;\n    &#x2F;&#x2F; 类模板没有自动类型推导，所以这个写法是错误的\n    &#x2F;&#x2F; Person01&lt;&gt; person01(&quot;FH&quot;, 24);\n\n    &#x2F;&#x2F; 需要显示指定类型\n    Person01&lt;string, int&gt; person01(&quot;FH&quot;, 24);\n&#125;\n\nvoid demo_P2()\n&#123;\n    Person02&lt;&gt; person02(&quot;XX&quot;, 24);\n&#125;\n\nint main()\n&#123;\n    demo_P1();\n    demo_P2();\n    return 0;\n&#125;\n\n1.3.3 类模板中成员函数创建时机\n类模板中和普通类中的成员函数创建时机存在区别\n\n普通类中的成员函数一开始就可以创建\n类模板中的成员函数在调用时才会创建\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 13:51\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person1\n&#123;\npublic:\n    void showPerson1()\n    &#123;\n        cout &lt;&lt; &quot;Show Person 1&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Person2\n&#123;\npublic:\n    void showPerson2()\n    &#123;\n        cout &lt;&lt; &quot;Show Person 2&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\ntemplate &lt;class class_T&gt;\nclass Person_T\n&#123;\npublic:\n    class_T person;\n\n    &#x2F;&#x2F; 传入的类型不确定，所以默认情况下，编译器不会保错\n    &#x2F;&#x2F; 此时，类模板中的函数不会被创建，当正确调用类模板时，才会创建\n    void showFunc1()\n    &#123;\n        person.showPerson1();\n    &#125;\n    void showFunc2()\n    &#123;\n        person.showPerson2();\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Person_T&lt;Person1&gt; p1;\n    p1.showFunc1();\n    &#x2F;&#x2F; 传入的是Person1，所以编译时，编译器创建类模板内的成员函数时，找不到可以调用的showPerson2()\n    &#x2F;&#x2F; p1.showFunc2();\n    \n    &#x2F;&#x2F; 传入Person2，才能调用showPerson2()，但同样也找不到showPerson1()\n    Person_T&lt;Person2&gt; p2;\n    p2.showFunc2();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n1.3.4 类模板对象做函数参数\n说明：类模板实例化出对象，向函数传参的方式\n\n三种传入方式：\n\n指定传入类型：直接显示对象的数据类型\n参数模板化：将对象中的参数变为模板进行传递\n整个类模板化：将对象类型模板化进行传递\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 14:08\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\npublic:\n    name_T name;\n    age_T age;\n\n    Person(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n\n    void showPerson()\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 1. 指定传入类型：直接显示对象的数据类型\nvoid print1(Person&lt;string, int&gt; &amp;person)\n&#123;\n    person.showPerson();\n&#125;\n\nvoid demo1()\n&#123;\n    Person&lt;string, int&gt; person(&quot;FH&quot;, 24);\n    print1(person);\n&#125;\n\n&#x2F;&#x2F; 2. 参数模板化：将对象中的参数变为模板进行传递\ntemplate &lt;class string_T, class int_T&gt;\nvoid print2(Person&lt;string_T, int_T&gt; &amp;person)\n&#123;\n    person.showPerson();\n&#125;\n\nvoid demo2()\n&#123;\n    Person&lt;string, int&gt; person(&quot;FF&quot;, 22);\n    print2(person);\n&#125;\n\n&#x2F;&#x2F; 3. 整个类模板化：将对象类型模板化进行传递\ntemplate &lt;class person_T&gt;\nvoid print3(person_T &amp;person)\n&#123;\n    person.showPerson();\n&#125;\n\nvoid demo3()\n&#123;\n    Person&lt;string, int&gt; person(&quot;HH&quot;, 20);\n    print3(person);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    demo3();\n    return 0;\n&#125;\n\n1.3.5 类模板与继承\n当类模板遇到需要继承时，需注意：\n\n当子类继承的父类是模板时，子类在声明时，需要指出父类中 T 的类型\n如果不指定，编译器无法给子类分配内存\n如果要灵活指定父类中的 T 类型，子类也需变成类模板\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 14:34\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class class_T&gt;\nclass Base\n&#123;\npublic:\n    class_T base_Info;\n&#125;;\n\nclass Derived_1 : Base&lt;int&gt; &#123;&#125;;\n\ntemplate &lt;class deClass_T, class baseClass_T&gt;\nclass Derived_2 : Base&lt;baseClass_T&gt;\n&#123;\npublic:\n    deClass_T derived_Info;\n\n    Derived_2()\n    &#123;\n        cout &lt;&lt; &quot;deClass_T: &quot; &lt;&lt; typeid(deClass_T).name() &lt;&lt; endl;\n        cout &lt;&lt; &quot;baseClass_T: &quot; &lt;&lt; typeid(baseClass_T).name() &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Derived_2&lt;int, char&gt; derived2;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n1.3.6 类模板成员函数类外实现\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 15:04\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\npublic:\n    name_T name;\n    age_T age;\n\n    &#x2F;&#x2F; 类模板 内 声明\n    Person(name_T name, age_T age);\n    void showPerson();\n&#125;;\n\n&#x2F;&#x2F; 类模板 外 实现\ntemplate &lt;class name_T, class age_T&gt;\nPerson&lt;name_T, age_T&gt;::Person(name_T name, age_T age)\n&#123;\n    this-&gt;name &#x3D; name;\n    this-&gt;age &#x3D; age;\n&#125;\n\ntemplate &lt;class name_T, class age_T&gt;\nvoid Person&lt;name_T, age_T&gt;::showPerson()\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);\n    person.showPerson();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n1.3.7 类模板分文件编写\n说明：掌握类模板成员函数分文件编写产生的问题及解决方式\n\n问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到\n\n解决：\n\n直接包含 .cpp文件\n将声明和实现写在同一个文件中，并改名为.hpp，是约定的标准名称，并非强制要求\n\n\n代码示例：\n\n第一种：直接包含 .cpp文件\nperson.h\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;12.\n&#x2F;&#x2F;\n\n#ifndef TEMPLATE_STL_PERSON_H\n#define TEMPLATE_STL_PERSON_H\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\npublic:\n    name_T name;\n    age_T age;\n\n    Person(name_T name, age_T age);\n    void showPerson();\n&#125;;\n\n#endif &#x2F;&#x2F;TEMPLATE_STL_PERSON_H\n\nperson.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;12.\n&#x2F;&#x2F;\n\n#include &quot;person.h&quot;\n\ntemplate &lt;class name_T, class age_T&gt;\nPerson&lt;name_T, age_T&gt;::Person(name_T name, age_T age)\n&#123;\n    this-&gt;name &#x3D; name;\n    this-&gt;age &#x3D; age;\n&#125;\n\ntemplate &lt;class name_T, class age_T&gt;\nvoid Person&lt;name_T, age_T&gt;::showPerson()\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n&#125;\n\nperson_Main.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 15:30\n&#x2F;&#x2F;\n\n&#x2F;&#x2F; 包含头文件 不管用 因为类模板的成员函数 只在调用时创建 所以编译时无法链接到外部文件\n&#x2F;&#x2F; #include &quot;person.h&quot;\n\n&#x2F;&#x2F; 第一种：直接包含 .cpp 文件\n&#x2F;&#x2F; 直接包含 源文件 源文件中包含头文件 同时实现了 类模板的成员函数\n#include &quot;person.cpp&quot;\n\nvoid demo()\n&#123;\n    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);\n    person.showPerson();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n第二种：将声明和实现写在同一个文件中，并改名为.hpp\nperson.hpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;12.\n&#x2F;&#x2F;\n\n#ifndef TEMPLATE_STL_PERSON_H\n#define TEMPLATE_STL_PERSON_H\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\npublic:\n    name_T name;\n    age_T age;\n\n    Person(name_T name, age_T age);\n    void showPerson();\n&#125;;\n\ntemplate &lt;class name_T, class age_T&gt;\nPerson&lt;name_T, age_T&gt;::Person(name_T name, age_T age)\n&#123;\n    this-&gt;name &#x3D; name;\n    this-&gt;age &#x3D; age;\n&#125;\n\ntemplate &lt;class name_T, class age_T&gt;\nvoid Person&lt;name_T, age_T&gt;::showPerson()\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n&#125;\n\n#endif &#x2F;&#x2F;TEMPLATE_STL_PERSON_H\n\nperson_Main.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 15:47\n&#x2F;&#x2F;\n#include &quot;person.hpp&quot;\n\nvoid demo()\n&#123;\n    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);\n    person.showPerson();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n\n\n1.3.8 类模板与友元\n说明：类模板配合友元函数的类内和类外实现\n\n实现：\n\n全局函数类内实现：直接在类内声明友元\n全局函数类外实现：需要让编译器提前知道全局函数的存在\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;12 15:57\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 全局函数 类外实现\ntemplate &lt;class name_T, class age_T&gt;\nclass Person;\n\ntemplate &lt;class name_T, class age_T&gt;\nvoid showPerson_2(Person&lt;name_T, age_T&gt; &amp;person)\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt;person.age &lt;&lt; endl;\n&#125;\n\ntemplate &lt;class name_T, class age_T&gt;\nclass Person\n&#123;\n    &#x2F;&#x2F; 全局函数 类内实现\n    friend void showPerson_1(Person&lt;name_T, age_T&gt; &amp;person)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name &lt;&lt; &quot; -- &quot; &lt;&lt; &quot;Age: &quot; &lt;&lt;person.age &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; 全局函数 类外实现\n    friend void showPerson_2&lt;&gt;(Person&lt;name_T, age_T&gt; &amp;person);\n\nprivate:\n    name_T name;\n    age_T age;\n\npublic:\n    Person(name_T name, age_T age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;全局函数，类内实现: &quot;;\n    Person&lt;string, int&gt; person(&quot;FH&quot;, 24);\n    showPerson_1(person);\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;全局函数，类外实现: &quot;;\n    Person&lt;string, int&gt; person(&quot;fh&quot;, 24);\n    showPerson_2(person);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n1.3.9 类模板案例\n案例要求：实现一个通用的数组类\n\n案例功能：\n\n可以对内置类型和自定义类型进行存储\n将数组的数据存储到堆区\n构造函数可以传入数组的容量\n提供拷贝函数及operator=防止浅拷贝问题\n提供尾差法和尾删法对数组中的数据进行增删\n通过下标访问数组中的元素\n获取数组中的元素个数和数组容量\n\n\n代码示例：(初期)\nfArray.hpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;13.\n&#x2F;&#x2F;\n\n#ifndef TEMPLATE_STL_FARRAY_HPP\n#define TEMPLATE_STL_FARRAY_HPP\n\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class array_T&gt;\nclass FArray\n&#123;\nprivate:\n    array_T *arrayAddress; &#x2F;&#x2F; 指针指向堆区开辟的数组首地址\n    int arrayCapacity; &#x2F;&#x2F; 数组容量\n    int arraySize; &#x2F;&#x2F; 数组大小\n\npublic:\n    &#x2F;&#x2F; 初始化 数组的容量 大小 和 在堆区创建\n    FArray(int capacity)\n    &#123;\n        this-&gt;arrayCapacity &#x3D; capacity;\n        this-&gt;arraySize &#x3D; 0;\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n\n        cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;\n    &#125;\n    &#x2F;&#x2F; 释放堆区的数组\n    ~FArray()\n    &#123;\n        if (this-&gt;arrayAddress !&#x3D; nullptr)\n        &#123;\n            delete[] this-&gt;arrayAddress;\n            this-&gt;arrayAddress &#x3D; nullptr;\n\n            cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 拷贝构造函数，解决浅拷贝问题\n    FArray(const FArray &amp;fArray)\n    &#123;\n        this-&gt;arrayCapacity &#x3D; fArray.arrayCapacity;\n        this-&gt;arraySize &#x3D; fArray.arraySize;\n\n        &#x2F;&#x2F; 这是编译器默认的浅拷贝，在析构函数执行后，因为地址始终不为null，所以会重复释放\n        &#x2F;&#x2F; this-&gt;arrayAddress &#x3D; fArray.arrayAddress;\n        &#x2F;&#x2F; 重新开辟空间，解决浅拷贝问题\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n        &#x2F;&#x2F; 将 fArray的数据拷贝进新的空间中\n        for (int i &#x3D; 0; i &lt; this-&gt;arraySize; ++i)\n        &#123;\n            this-&gt;arrayAddress[i] &#x3D; fArray.arrayAddress[i];\n        &#125;\n\n        cout &lt;&lt; &quot;拷贝函数调用&quot; &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; operator&#x3D; 解决浅拷贝问题\n    FArray &amp;operator&#x3D;(const FArray &amp;fArray)\n    &#123;\n        &#x2F;&#x2F; 先判断堆区是否存在，存在就先释放\n        if (this-&gt;arrayAddress !&#x3D; nullptr)\n        &#123;\n            delete[] this-&gt;arrayAddress;\n            this-&gt;arrayAddress &#x3D; nullptr;\n            this-&gt;arrayCapacity &#x3D; 0;\n            this-&gt;arraySize &#x3D; 0;\n        &#125;\n\n        &#x2F;&#x2F; 深拷贝\n        this-&gt;arrayCapacity &#x3D; fArray.arrayCapacity;\n        this-&gt;arraySize &#x3D; fArray.arraySize;\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n\n        for (int i &#x3D; 0; i &lt; this-&gt;arraySize; ++i)\n        &#123;\n            this-&gt;arrayAddress[i] &#x3D; fArray.arrayAddress[i];\n        &#125;\n\n        cout &lt;&lt; &quot;operator&#x3D;函数调用&quot; &lt;&lt; endl;\n        return *this;\n    &#125;\n&#125;;\n\n#endif &#x2F;&#x2F;TEMPLATE_STL_FARRAY_HPP\n\nfArray_Main.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;13 14:36\n&#x2F;&#x2F;\n#include &quot;fArray.hpp&quot;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 测试 初期，创建一个容量5的int类型数组\n    &#x2F;&#x2F; 测试 构造函数和析构函数\n    FArray&lt;int&gt; fArray1(5);\n\n    &#x2F;&#x2F; 测试 拷贝构造函数\n    FArray&lt;int&gt; fArray2(fArray1);\n\n    &#x2F;&#x2F; 测试 operator&#x3D; 函数\n    FArray&lt;int&gt; fArray3(10);\n    fArray3 &#x3D; fArray1;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n\n\n代码示例：（后期）\nfArray.hpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;7&#x2F;13.\n&#x2F;&#x2F;\n\n#ifndef TEMPLATE_STL_FARRAY_HPP\n#define TEMPLATE_STL_FARRAY_HPP\n\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class array_T&gt;\nclass FArray\n&#123;\nprivate:\n    array_T *arrayAddress; &#x2F;&#x2F; 指针指向堆区开辟的数组首地址\n    int arrayCapacity; &#x2F;&#x2F; 数组容量\n    int arraySize; &#x2F;&#x2F; 数组大小\n\npublic:\n    &#x2F;&#x2F; 初始化 数组的容量 大小 和 在堆区创建\n    FArray(int capacity)\n    &#123;\n        this-&gt;arrayCapacity &#x3D; capacity;\n        this-&gt;arraySize &#x3D; 0;\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n\n        &#x2F;&#x2F; cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;\n    &#125;\n    &#x2F;&#x2F; 释放堆区的数组\n    ~FArray()\n    &#123;\n        if (this-&gt;arrayAddress !&#x3D; nullptr)\n        &#123;\n            delete[] this-&gt;arrayAddress;\n            this-&gt;arrayAddress &#x3D; nullptr;\n\n            &#x2F;&#x2F; cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 拷贝构造函数，解决浅拷贝问题\n    FArray(const FArray &amp;fArray)\n    &#123;\n        this-&gt;arrayCapacity &#x3D; fArray.arrayCapacity;\n        this-&gt;arraySize &#x3D; fArray.arraySize;\n\n        &#x2F;&#x2F; 这是编译器默认的浅拷贝，在析构函数执行后，因为地址始终不为null，所以会重复释放\n        &#x2F;&#x2F; this-&gt;arrayAddress &#x3D; fArray.arrayAddress;\n        &#x2F;&#x2F; 重新开辟空间，解决浅拷贝问题\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n        &#x2F;&#x2F; 将 fArray的数据拷贝进新的空间中\n        for (int i &#x3D; 0; i &lt; this-&gt;arraySize; ++i)\n        &#123;\n            this-&gt;arrayAddress[i] &#x3D; fArray.arrayAddress[i];\n        &#125;\n\n        &#x2F;&#x2F; cout &lt;&lt; &quot;拷贝函数调用&quot; &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; operator&#x3D; 解决浅拷贝问题\n    FArray &amp;operator&#x3D;(const FArray &amp;fArray)\n    &#123;\n        &#x2F;&#x2F; 先判断堆区是否存在，存在就先释放\n        if (this-&gt;arrayAddress !&#x3D; nullptr)\n        &#123;\n            delete[] this-&gt;arrayAddress;\n            this-&gt;arrayAddress &#x3D; nullptr;\n            this-&gt;arrayCapacity &#x3D; 0;\n            this-&gt;arraySize &#x3D; 0;\n        &#125;\n\n        &#x2F;&#x2F; 深拷贝\n        this-&gt;arrayCapacity &#x3D; fArray.arrayCapacity;\n        this-&gt;arraySize &#x3D; fArray.arraySize;\n        this-&gt;arrayAddress &#x3D; new array_T[this-&gt;arrayCapacity];\n\n        for (int i &#x3D; 0; i &lt; this-&gt;arraySize; ++i)\n        &#123;\n            this-&gt;arrayAddress[i] &#x3D; fArray.arrayAddress[i];\n        &#125;\n\n        &#x2F;&#x2F; cout &lt;&lt; &quot;operator&#x3D;函数调用&quot; &lt;&lt; endl;\n        return *this;\n    &#125;\n\n    &#x2F;&#x2F; 返回数组大小\n    int getArraySize()\n    &#123;\n        return this-&gt;arraySize;\n    &#125;\n\n    &#x2F;&#x2F; 返回数组容量\n    int getArrayCapacity()\n    &#123;\n        return this-&gt;arrayCapacity;\n    &#125;\n\n    &#x2F;&#x2F; 尾插法\n    void tail_Insertion(const array_T &amp;arrayValue)\n    &#123;\n        &#x2F;&#x2F; 先判断数组容量是否够\n        if (this-&gt;arrayCapacity &#x3D;&#x3D; this-&gt;arraySize)\n        &#123;\n            return;\n        &#125;\n\n        this-&gt;arrayAddress[this-&gt;arraySize] &#x3D; arrayValue; &#x2F;&#x2F; 将数据插入到数组的尾部\n        this-&gt;arraySize++; &#x2F;&#x2F; 更新数组的大小\n    &#125;\n\n    &#x2F;&#x2F; 尾删法\n    void tail_Deletion()\n    &#123;\n        &#x2F;&#x2F; 让用户无法访问最后一个元素，逻辑删除\n        if (this-&gt;arraySize &#x3D;&#x3D; 0)\n        &#123;\n            return;\n        &#125;\n\n        this-&gt;arraySize--;\n    &#125;\n\n    &#x2F;&#x2F; 通过小标访问数组元素 自定义的数据类型，内置的[]不能用，需要重载[]\n    array_T &amp;operator[](int fArray_Index)\n    &#123;\n        return this-&gt;arrayAddress[fArray_Index];\n    &#125;\n&#125;;\n\n#endif &#x2F;&#x2F;TEMPLATE_STL_FARRAY_HPP\n\nfArray.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;13 14:36\n&#x2F;&#x2F;\n#include &quot;fArray.hpp&quot;\n\nint arrayIntCount &#x3D; 0;\nint arrayPersonCount &#x3D; 0;\n\n&#x2F;&#x2F; 打印int类型数组\nvoid printIntArray(FArray&lt;int&gt; &amp;fArray)\n&#123;\n    arrayIntCount++;\n    cout &lt;&lt; &quot;数组&quot; &lt;&lt; arrayIntCount &lt;&lt; &quot;：[ &quot;;\n    for (int i &#x3D; 0; i &lt; fArray.getArraySize(); ++i)\n    &#123;\n        cout &lt;&lt; fArray[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 前期测试：创建到堆区，拷贝构造函数，operator&#x3D; 函数\nvoid test1()\n&#123;\n    &#x2F;&#x2F; 测试 初期，创建一个容量5的int类型数组\n    &#x2F;&#x2F; 测试 构造函数和析构函数\n    FArray&lt;int&gt; fArray1(5);\n\n    &#x2F;&#x2F; 测试 拷贝构造函数\n    FArray&lt;int&gt; fArray2(fArray1);\n\n    &#x2F;&#x2F; 测试 operator&#x3D; 函数\n    FArray&lt;int&gt; fArray3(10);\n    fArray3 &#x3D; fArray1;\n&#125;\n\n&#x2F;&#x2F; 后期测试：尾插法，容量，大小\nvoid test2()\n&#123;\n    &#x2F;&#x2F; 创建数组 和 容量\n    FArray&lt;int&gt; fArray1(10);\n\n    &#x2F;&#x2F; 用尾插法插入数据\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        fArray1.tail_Insertion(i);\n    &#125;\n    &#x2F;&#x2F; 打印数组\n    printIntArray(fArray1);\n\n    &#x2F;&#x2F; 查看数组 容量 大小\n    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray1.getArrayCapacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray1.getArraySize() &lt;&lt; endl;\n\n    &#x2F;&#x2F; 尾删法 测试\n    FArray&lt;int&gt; fArray2(fArray1);\n    printIntArray(fArray2);\n\n    fArray2.tail_Deletion();\n    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray2.getArrayCapacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray2.getArraySize() &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 后期测试 自定义数据类型\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person()&#123;&#125;;\n    Person(string name, int age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 打印Person类型数组\nvoid printPersonArray(FArray&lt;Person&gt; &amp;fArray)\n&#123;\n    arrayPersonCount++;\n    cout &lt;&lt; &quot;数组&quot; &lt;&lt; arrayPersonCount &lt;&lt; &quot;：[ &quot;;\n    for (int i &#x3D; 0; i &lt; fArray.getArraySize(); ++i)\n    &#123;\n        cout &lt;&lt; fArray[i].name &lt;&lt; &quot; &quot; &lt;&lt; fArray[i].age &lt;&lt; &quot; - &quot;;\n    &#125;\n    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;\n&#125;\n\nvoid test3()\n&#123;\n    FArray&lt;Person&gt; fArray(3);\n    Person person1(&quot;FH&quot;, 24);\n    Person person2(&quot;HH&quot;, 22);\n\n    fArray.tail_Insertion(person1);\n    fArray.tail_Insertion(person2);\n\n    printPersonArray(fArray);\n\n    cout &lt;&lt; &quot;数组容量：&quot; &lt;&lt; fArray.getArrayCapacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;数组大小：&quot; &lt;&lt; fArray.getArraySize() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; test1();\n    &#x2F;&#x2F; test2();\n    test3();\n    return 0;\n&#125;\n\n2. STL基础2.1 STL的诞生\nC++的面向对象和泛型编程思想，目的是复用性\n大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作\n为了建立数据结构和算法的标准，诞生了STL\n\n2.2 STL基本概念\nSTL(Standard Template Library，标准模板库)\nSTL广义上分为：容器(container)，算法(algorithm)，迭代器(iterator)\n容器和算法之间通过迭代器进行连接\nSTL激活所有的代码都采用了模板类或模板函数\n\n2.3 STL六大组件\nSTL大体分为六个组件：\n容器\n算法\n迭代器\n仿函数\n适配器(配接器)\n空间配置器\n\n\n组件介绍：\n容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据\n算法：各种常用的算法，如sort、find、copy、for_each等\n迭代器：扮演了容器和算法之间的胶合剂\n仿函数：行为类似函数，可作为算法的某种策略\n适配器：一种修饰容器或仿函数或迭代器接口\n空间配置器：负责空间的配置和管理\n\n\n\n2.4 STL容器\\算法\\迭代器\n容器：存放数据，将运用最广泛的一些数据结构实现出来\n\n常用数据结构：数组，链表，树，栈，队列，集合，映射表 等\n容器分为：序列式容器和关联式容器\n序列式容器：强调值的排序，序列容器中的每个元素均有固定的位置\n关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系\n\n\n\n\n算法：解决问题，有限的步骤，解决逻辑或数学上的问题\n\n算法分为：质变算法和非质变算法\n质变算法：值运算过程中会更改区间内的元素的内容，例如：拷贝，替换，删除等\n非质变算法：值运算过程中不会更改区间内的元素内容，例如：查找，计数，遍历，寻找极值等\n\n\n\n\n迭代器：容器和算法之间胶合剂\n\n提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表示方式\n\n每个容器都有自己的专属迭代器\n\n迭代器使用类似指针\n\n迭代器的种类：\n\n\n\n种类\n功能\n支持算法\n\n\n\n输入迭代器\n对数据只读访问\n只读，支持 ++，&#x3D;&#x3D;，!&#x3D;\n\n\n输出迭代器\n对数据只写访问\n只写，支持 ++\n\n\n前向迭代器\n读写操作，并能向前推进迭代器\n读写，支持 ++，&#x3D;&#x3D;，!&#x3D;\n\n\n双向迭代器\n读写操作，并能向前和向后操作\n读写，支持 ++，–\n\n\n随机访问迭代器\n读写操作，可以跳跃访问任意数据\n读写，支持 ++，–，[n]，-n，&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D;\n\n\n\n常用的容器这迭代器种类为双向迭代器和随机访问迭代器\n\n\n\n\n2.5 容器\\算法\\迭代器基础2.5.1 vector存放内置数据类型\n容器：vector\n\n算法：for_each\n\n迭代器：vector&lt;int&gt;::iterator\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;19 14:23\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvoid fPrint(int value)\n&#123;\n    cout &lt;&lt; value &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 创建一个vector容器\n    vector&lt;int&gt; v;\n\n    &#x2F;&#x2F; 插入数据\n    v.push_back(10);\n    v.push_back(11);\n    v.push_back(12);\n    v.push_back(13);\n\n    &#x2F;&#x2F; 通过创建迭代器访问容器中的数据\n    vector&lt;int&gt;::iterator iBegin &#x3D; v.begin(); &#x2F;&#x2F; 起始地迭代器 指向容器中的第一个元素\n    vector&lt;int&gt;::iterator iEnd &#x3D; v.end(); &#x2F;&#x2F; 指向容器最后一个元素 之后的地址\n\n    &#x2F;&#x2F; 第一种遍历方式\n&#x2F;&#x2F;    while (iBegin !&#x3D; iEnd)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; *iBegin &lt;&lt; endl;\n&#x2F;&#x2F;        iBegin++;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F; 第二种遍历方式\n&#x2F;&#x2F;    for (vector&lt;int&gt;::iterator i &#x3D; v.begin(); i !&#x3D; v.end(); ++i)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; *i &lt;&lt; endl;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F; 第三种遍历方式\n    for_each(v.begin(), v.end(), fPrint);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n2.5.2 vector存放自定义数据类型\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;19 14:49\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(string name, int age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;&lt; --demo1-- &gt;&quot; &lt;&lt; endl;\n    vector&lt;Person&gt; v_P;\n\n    Person p1(&quot;fh&quot;, 24);\n    Person p2(&quot;ff&quot;, 22);\n    Person p3(&quot;hh&quot;, 20);\n\n    v_P.push_back(p1);\n    v_P.push_back(p2);\n    v_P.push_back(p3);\n\n    for (vector&lt;Person&gt;::iterator it_P &#x3D; v_P.begin(); it_P !&#x3D; v_P.end(); ++it_P)\n    &#123;\n        cout &lt;&lt; it_P-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; it_P-&gt;age &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;&lt; --demo2-- &gt;&quot; &lt;&lt; endl;\n    vector&lt;Person *&gt; v_P;\n\n    Person p1(&quot;fh&quot;, 24);\n    Person p2(&quot;ff&quot;, 22);\n    Person p3(&quot;hh&quot;, 20);\n\n    v_P.push_back(&amp;p1);\n    v_P.push_back(&amp;p2);\n    v_P.push_back(&amp;p3);\n\n    for (vector&lt;Person *&gt;::iterator it_P &#x3D; v_P.begin(); it_P !&#x3D; v_P.end(); ++it_P)\n    &#123;\n        cout &lt;&lt; (*it_P)-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; (*it_P)-&gt;age &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n2.5.3 vector容器嵌套容器\n容器中嵌套容器，将数据进行遍历打印\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;19 15:07\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 创建大容器\n    vector&lt;vector&lt;int&gt;&gt; v_Big;\n    &#x2F;&#x2F; 创建小容器\n    vector&lt;int&gt; v_S1;\n    vector&lt;int&gt; v_S2;\n    vector&lt;int&gt; v_S3;\n    vector&lt;int&gt; v_S4;\n    &#x2F;&#x2F; 向小容器中添加数据\n    for (int i &#x3D; 0; i &lt; 4; ++i)\n    &#123;\n        v_S1.push_back(i + 1);\n        v_S2.push_back(i + 2);\n        v_S3.push_back(i + 3);\n        v_S4.push_back(i + 4);\n    &#125;\n    &#x2F;&#x2F; 将小容器插入大容器\n    v_Big.push_back(v_S1);\n    v_Big.push_back(v_S2);\n    v_Big.push_back(v_S3);\n    v_Big.push_back(v_S4);\n    &#x2F;&#x2F; 遍历大容器\n    for (vector&lt;vector&lt;int&gt;&gt;::iterator it_Big &#x3D; v_Big.begin(); it_Big !&#x3D; v_Big.end(); ++it_Big)\n    &#123;\n        &#x2F;&#x2F; (*it_Big)是小容器 vector&lt;int&gt;\n        &#x2F;&#x2F; 遍历小容器\n        for (vector&lt;int&gt;::iterator it_Small &#x3D; (*it_Big).begin(); it_Small !&#x3D; (*it_Big).end(); ++it_Small)\n        &#123;\n            cout &lt;&lt; *it_Small &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3. STL常用容器3.1 string容器3.1.1 string基本概念\n本质：string是C++的风格字符串，而string本质是一个类\nstring和char * 区别：\nchar * 是指针\nstring 是指针，内部封装了 char * ，管理这个字符串，是一个 char * 的容器\n\n\n特点：\nstring内部封装了很多的成员方法\n查找 find，拷贝 copy，删除 delete，替换 replace，插入 insert\nstring管理 char * 所分配的内存，不用担心复制越界和取值越界，由类内部进行负责\n\n\n\n3.1.2 string构造函数\n构造函数原型：\n\n\n\nstring();\n创建一个空的字符串\n\n\n\nstring(const char *s);\n使字符串初始化\n\n\nstring(const string &amp;s);\n用一个string对象初始化另一个string对象\n\n\nstring(int n, char c);\n使用n个字符c，初始化\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;7&#x2F;20 9:43\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 创建一个空的字符串\n    string string1;\n\n    &#x2F;&#x2F; 使字符串初始化\n    const char *str &#x3D; &quot;HelloWorld&quot;;\n    string string2(str);\n    cout &lt;&lt; &quot;string2 &#x3D; &quot; &lt;&lt; string2 &lt;&lt; endl;\n\n    &#x2F;&#x2F; 用一个string对象初始化另一个string对象\n    string string3(string2);\n    cout &lt;&lt; &quot;string3 &#x3D; &quot; &lt;&lt; string3 &lt;&lt; endl;\n\n    &#x2F;&#x2F; 使用n个字符c，初始化\n    string string4(10, &#39;a&#39;);\n    cout &lt;&lt; &quot;string4 &#x3D; &quot; &lt;&lt; string4 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.1.3 string赋值操作\n功能描述：给string字符串赋值\n\n\n\n赋值的函数原型\n\n\n\n\nstring &amp;operator=(const char *s);\nchar *类型字符串，赋值给当前的字符串\n\n\nstring &amp;operator=(const string &amp;s);\n字符串s，赋值给当前的字符串\n\n\nstring &amp;operator=(char c);\n字符，赋值给当前字符串\n\n\nstring &amp;assign(const char *s);\n字符串s，赋值给当前的字符串\n\n\nstring &amp;assign(const char *s, int n);\n字符串s的前n个字符，赋值给当前的字符串\n\n\nstring &amp;assign(const string &amp;s);\n字符串s，赋值给当前的字符串\n\n\nstring &amp;assign(int n, char c);\n用n个字符c，赋值给当前字符串\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 14:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    string string1;\n    string1 &#x3D; &quot;hello world&quot;;\n    cout &lt;&lt; &quot;string1 &#x3D; &quot; &lt;&lt; string1 &lt;&lt; endl;\n\n    string string2;\n    string2 &#x3D; string1;\n    cout &lt;&lt; &quot;string2 &#x3D; &quot; &lt;&lt; string2 &lt;&lt; endl;\n\n    string string3;\n    string3 &#x3D; &quot;A&quot;;\n    cout &lt;&lt; &quot;string3 &#x3D; &quot; &lt;&lt; string3 &lt;&lt; endl;\n\n    string string4;\n    string4.assign(&quot;hello world&quot;);\n    cout &lt;&lt; &quot;string4 &#x3D; &quot; &lt;&lt; string4 &lt;&lt; endl;\n\n    string string5;\n    string5.assign(&quot;hello world&quot;, 3);\n    cout &lt;&lt; &quot;string5 &#x3D; &quot; &lt;&lt; string5 &lt;&lt; endl;\n\n    string string6;\n    string6.assign(6, &#39;a&#39;);\n    cout &lt;&lt; &quot;string6 &#x3D; &quot; &lt;&lt; string6 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.1.4 string字符拼接\n功能描述：实现字符串末尾拼接字符串\n\n\n\n函数原型\n\n\n\n\nstring &amp;operator+=(const char *str);\n重载+&#x3D;操作符\n\n\nstring &amp;operator+=(const char c);\n重载+&#x3D;操作符\n\n\nstring &amp;operator+=(const string &amp;str);\n重载+&#x3D;操作符\n\n\nstring &amp;append(const char *s);\n字符串s，连接到当前字符串的末尾\n\n\nstring &amp;append(const char *s, int n);\n字符串s的前n个字符，连接到当前字符串的末尾\n\n\nstring &amp;append(const string &amp;s);\n等同于，string &amp;operator+=(const string &amp;str);\n\n\nstring &amp;append(const string &amp;s, int pos, int n);\n字符串s中从pos开始取n个字符，连接到当前字符串的末尾\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 15:12\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    string string1 &#x3D; &quot;Hello &quot;;\n    string1 +&#x3D; &quot;World&quot;;\n    cout &lt;&lt; &quot;String1 &#x3D; &quot; &lt;&lt; string1 &lt;&lt; endl;\n\n    string string2 &#x3D; &quot;Hi &quot;;\n    string2 +&#x3D; string1;\n    cout &lt;&lt; &quot;String2 &#x3D; &quot; &lt;&lt; string2 &lt;&lt; endl;\n\n    string string3 &#x3D; &quot;Age &quot;;\n    string3 +&#x3D; &#39;8&#39;;\n    cout &lt;&lt; &quot;String3 &#x3D; &quot; &lt;&lt; string3 &lt;&lt; endl;\n\n    string string4 &#x3D; &quot;Hello &quot;;\n    string4.append(&quot;World&quot;);\n    cout &lt;&lt; &quot;String4 &#x3D; &quot; &lt;&lt; string4 &lt;&lt; endl;\n\n    string string5 &#x3D; &quot;Hi &quot;;\n    string5.append(string4);\n    cout &lt;&lt; &quot;String5 &#x3D; &quot; &lt;&lt; string5 &lt;&lt; endl;\n\n    string string6;\n    string6.append(&quot;Hello World&quot;, 4);\n    cout &lt;&lt; &quot;String6 &#x3D; &quot; &lt;&lt; string6 &lt;&lt; endl;\n\n    string string7 &#x3D; string5;\n    string7.append(&quot;Hello World&quot;, 5, 6);\n    cout &lt;&lt; &quot;String7 &#x3D; &quot; &lt;&lt; string7 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.1.5 string查找替换\n功能描述：\n\n查找：查找指定字符串是否存在\n\n替换：在指定的位置替换字符串\n\n\n\n函数原型\n\n\n\n\nint find(const string &amp;str, int pos = 0) const;\n查找str第一次出现的位置，默认pos从头开始\n\n\nint find(const char *s, int pos = 0) const;\n查找s第一次出现的位置，默认pos从头开始\n\n\nint find(const char *s, int pos, int n) const;\n从pos查找s的前n个字符第一次位置\n\n\nint find(const char *c, int pos = 0) const;\n查找字符c第一次出现位置\n\n\nint rfind(const string &amp;str, int pos = npos) const;\n查找str最后一次位置，从pos开始找\n\n\nint rfind(const char *s, int pos = npos) const;\n查找s最后一次位置，从pos开始找\n\n\nint rfind(const char *s, int pos, int n) const;\n从pos查找s的前n个字符最后一次位置\n\n\nint rfind(const char *c, int pos = 0) const;\n查找字符c最后一次出现位置\n\n\nstring &amp;replace(int pos, int n, const string &amp;str) const;\n替换从pos开始n个字符为字符串str\n\n\nstring &amp;replace(int pos, int n, const char *s) const;\n替换从pos开始n个字符为字符串s\n\n\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 15:46\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid findString()\n&#123;\n    string string1 &#x3D; &quot;AABBCCBBAA&quot;;\n    int pos1 &#x3D; string1.find(&quot;BB&quot;);\n    cout &lt;&lt; &quot;BB pos1 &#x3D; &quot; &lt;&lt; pos1 &lt;&lt; endl;\n\n    int pos2 &#x3D; string1.rfind(&quot;BB&quot;);\n    cout &lt;&lt; &quot;BB pos2 &#x3D; &quot; &lt;&lt; pos2 &lt;&lt; endl;\n&#125;\n\nvoid replaceString()\n&#123;\n    string string1 &#x3D; &quot;ABCDE&quot;;\n    string1.replace(2, 3, &quot;123&quot;);\n    cout &lt;&lt; &quot;String1 &#x3D; &quot; &lt;&lt; string1 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    findString();\n    replaceString();\n    return 0;\n&#125;\n\n\n\n总结：\n\nfind是从左往右查，rfind是从右往左查\nfind查到字符后，返回字符的位置，找不到返回-1\nreplace在替换时，需指定起始位置，替换字符数，替换字符\n\n\n\n3.1.6 string字符比较\n功能描述：字符串之间比较\n\n比较方式：按照字符编码ACSII进行比较\n\n= 返回 0\n&gt; 返回 1\n&lt; 返回 -1\n\n\n\n\n函数原型\n\n\n\n\nint compare(const string &amp;str) const;\n与字符串str比较\n\n\nint compare(const char *s) const;\n与字符串s比较\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 16:12\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    string string1 &#x3D; &quot;Hello&quot;;\n    string string2 &#x3D; &quot;World&quot;;\n\n    if (string1.compare(string2) &#x3D;&#x3D; 0)\n    &#123;\n        cout &lt;&lt; &quot;string1 string2&quot; &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;string1 string2&quot; &lt;&lt; &quot; !&#x3D; &quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.1.7 string字符存取\nstring中单个字符串存取方式有两种：\n\n\n\n方式\n\n\n\n\nchar &amp;operator[](int n);\n通过[]方式取字符\n\n\nchar &amp;at(int n);\n通过at取字符\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 16:23\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstring string1 &#x3D; &quot;ABCDEFG&quot;;\n\nvoid demo1()\n&#123;\n    for (int i &#x3D; 0; i &lt; string1.size(); ++i)\n    &#123;\n        cout &lt;&lt; string1[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    for (int i &#x3D; 0; i &lt; string1.size(); ++i)\n    &#123;\n        cout &lt;&lt; string1.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n3.1.8 string插入删除\n功能描述：对string字符串进行插入和删除字符操作\n\n\n\n函数原型\n\n\n\n\nstring &amp;insert(int pos, const char *s);\n插入字符串\n\n\nstring &amp;insert(int pos, const string &amp;str);\n插入字符串\n\n\nstring &amp;insert(int pos, int n, char c);\n在指定位置插入n个字符c\n\n\nstring &amp;erase(int pos, int n = npos);\n删除从pos开始的n个字符\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;9&#x2F;21 16:35\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid demoInsert()\n&#123;\n    string str1 &#x3D; &quot;Hello &quot;;\n    string str2 &#x3D; &quot;world &quot;;\n\n    str1.insert(6, &quot;world &quot;);\n    cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    str1.insert(12, str2);\n    cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    str1.insert(18, 6, &#39;!&#39;);\n    cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;\n&#125;\n\nvoid demoDelete()\n&#123;\n    string str3 &#x3D; &quot;Hello World&quot;;\n    str3.erase(5, 6);\n    cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demoInsert();\n    demoDelete();\n    return 0;\n&#125;\n\n总结：插入insert()和删除erase()都是从下标0开始的\n\n\n3.1.9 string获取字串\n功能描述：从字符串中获得想要的一段子字符串\n\n\n\n函数原型\n\n\n\n\nstring substr(int pos = 0, int n = npos) const;\n返回由pos开始的n个字符组成的字符串\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;5 14:59\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid subStringDemo()\n&#123;\n    string str1 &#x3D; &quot;Hello World&quot;;\n\n    str1 &#x3D; str1.substr(0, 5);\n    cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;\n&#125;\n\nvoid getEmailTypeInfo()\n&#123;\n    string str2 &#x3D; &quot;752972182@qq.com&quot;;\n\n    int pos &#x3D; str2.find(&quot;@&quot;);\n    string str3 &#x3D; str2.substr(pos + 1, 2);\n    str2 &#x3D; str2.substr(0, pos);\n\n    cout &lt;&lt; &quot;str2 email user &#x3D; &quot; &lt;&lt; str2 &lt;&lt; endl;\n    cout &lt;&lt; &quot;str3 email type &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    subStringDemo();\n    getEmailTypeInfo();\n    return 0;\n&#125;\n\n3.2 vector容器3.2.1 vector基本概念\n功能：vector数据结构和数组非常相似，也称为单端数组\n\n与数组的区别：数组是静态空间，vector可以动态扩展\n\n动态扩展：并非是在原有的空间后面，连续开辟新空间；而是在另一个更大的内存空间中重新开辟，并拷贝原来的容器数据，同时释放原容器\n\nvector容器的迭代器是支持随机访问的迭代器\n\n\n\nvector迭代器方法介绍 vector&lt;T&gt; v;\n\n\n\n\nv.rend();\n容器第一个元素之前的地址\n\n\nv.end();\n容器最后一个元素之后的地址\n\n\nv.begin();\n容器第一个元素自身的地址\n\n\nv.rbegin();\n容器最后一个元素之前的地址\n\n\nv.insert();\n容器中插入一个元素\n\n\n\n\n3.2.2 vector构造函数\n功能描述：创建vector容器\n\n\n\n函数原型 vector&lt;T&gt; v;\n\n\n\n\nvector&lt;T&gt; v;\n采用模板类实现，默认构造函数\n\n\nvector(v.begin(), v.end());\n将 [ v.begin(), v.end() ) 之间的元素拷贝给自身 [闭 开)区间\n\n\nvector(n, elem);\n构造函数将 n个 元素拷贝给自身\n\n\nvector(const vector &amp;vec);\n拷贝构造函数\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;5 15:37\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    &#x2F;&#x2F; 默认构造（无参）\n    vector&lt;int&gt; v1;\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    &#x2F;&#x2F; 通过 [ ) 构造\n    vector&lt;int&gt; v2(v1.begin(), v1.end());\n    printVector(v2);\n\n    &#x2F;&#x2F; n个 elem构造\n    vector&lt;int&gt; v3(10, 1);\n    printVector(v3);\n\n    &#x2F;&#x2F; 拷贝构造\n    vector&lt;int&gt; v4(v1);\n    printVector(v4);\n&#125;\n\nint main()\n&#123;\n    demo1();\n\n    return 0;\n&#125;\n\n3.2.3 vector赋值操作\n功能描述：给容器赋值\n\n\n\n函数原型 vector&lt;T&gt; v;\n\n\n\n\nvetor &amp;operator=(const vector &amp;vec);\n重载= 操作符\n\n\nv.assign(v.begin, v.end);\n将 [begin, end)区间中的数据拷贝到自身\n\n\nv.assign(n, elem);\n将 n个 elem拷贝赋值给自身\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;5 16:08\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    vector&lt;int&gt; v2 &#x3D; v1;\n    printVector(v2);\n\n    vector&lt;int&gt; v3(v1.begin(), v1.end());\n    printVector(v3);\n\n    vector&lt;int&gt; v4(10, 1);\n    printVector(v4);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.2.4 vector容量大小\n功能描述：对vector容器的容量和大小进行操作\n\n\n\n函数原型\n\n\n\n\nempty();\n判断容器是否为空\n\n\ncapacity();\n获取容器的容量\n\n\nsize();\n获取容器中的元素个数\n\n\nresize(int num);\n重新指定容器长度，若变长，默认填充；若变短，删除末尾超出容器长度的元素\n\n\nresize(int num, elem);\n重新指定容器长度，若变长，elem填充；若变短，删除末尾超出容器长度的元素\n\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;5 16:18\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    if (v1.empty())\n    &#123;\n        cout &lt;&lt; &quot;v1 is empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;v1 not empty&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;v1 size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl;\n        cout &lt;&lt; &quot;v1 capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;\n    &#125;\n\n    v1.resize(10);\n    printVector(v1);\n\n    v1.resize(15, 1);\n    printVector(v1);\n\n    v1.resize(2);\n    printVector(v1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.2.5 vector插入删除\n功能描述：对vector容器进行插入、删除操作\n\n\n\n函数原型\n\n\n\n\npush_back(elem);\n尾部插入元素 elem\n\n\npop_back();\n删除最后一个元素\n\n\ninsert(const_iterator pos, elem);\n迭代器指向位置pos，插入元素elem\n\n\ninsert(const_iterator pos, int count, elem);\n迭代器指向位置pos，插入count个元素elem\n\n\nerase(const_iterator pos);\n删除迭代器指向位置pos的元素\n\n\nerase(const_iterator start, const_iterator end);\n删除迭代器选择的start到end之间的元素\n\n\nclear();\n清空容器\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;10 15:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator iterator &#x3D; v.begin(); iterator !&#x3D; v.end(); ++iterator)\n    &#123;\n        cout &lt;&lt; *iterator &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    &#x2F;&#x2F; 尾插入\n    vector&lt;int&gt; v1;\n    v1.push_back(1);\n    v1.push_back(2);\n    v1.push_back(3);\n    v1.push_back(4);\n    v1.push_back(5);\n    printVector(v1);\n\n    &#x2F;&#x2F; 尾删除\n    v1.pop_back();\n    printVector(v1);\n\n    &#x2F;&#x2F; 迭代器指定位置插入\n    v1.insert(v1.begin(), 0);\n    printVector(v1);\n\n    &#x2F;&#x2F; 迭代器指定位置插入 指定数量 元素\n    v1.insert(v1.end(), 3, 5);\n    printVector(v1);\n\n    &#x2F;&#x2F; 删除迭代器指向位置的元素\n    v1.erase(v1.end() - 1);\n    printVector(v1);\n\n    &#x2F;&#x2F; 删除迭代器选择的start到end之间的元素\n    v1.erase(v1.begin() + 1, v1.end() - 2);\n    printVector(v1);\n\n    &#x2F;&#x2F; clear\n    v1.clear();\n    printVector(v1);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;\n\n3.2.6 vector数据存取\n功能描述：vector中的数据存取操作\n\n\n\n函数原型\n\n\n\n\nat(int index);\n返回索引index所指的数据\n\n\noperator[];\n返回索引index所指的数据\n\n\nfront();\n返回容器中第一个数据元素\n\n\nback();\n返回容器中最后一个数据元素\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;10 16:20\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    for (int i &#x3D; 0; i &lt; v.size(); ++i)\n    &#123;\n        cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (int i &#x3D; 0; i &lt; v.size(); ++i)\n    &#123;\n        cout &lt;&lt; v.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;Vector Front Elem: &quot; &lt;&lt; v.front() &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;Vector Back Elem: &quot; &lt;&lt; v.back() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.2.7 vector互换容器\n功能描述：实现两个容器内元素的互换\n\n\n\n函数原型\n\n\n\n\nswap(otherVector);\n将otherVector与本身的元素互换\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;10 16:30\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid debugVector(vector&lt;int&gt; &amp;v)\n&#123;\n    for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid debugVectorInfo(vector&lt;int&gt; &amp;v)\n&#123;\n    cout &lt;&lt; &quot;Vector Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;Vector Size: &quot; &lt;&lt; v.size() &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n\n    for (int i &#x3D; 5; i &gt; 0; --i)\n    &#123;\n        v2.push_back(i);\n    &#125;\n\n    v1.swap(v2);\n\n    debugVector(v1);\n    debugVector(v2);\n&#125;\n\nvoid demo2()\n&#123;\n    vector&lt;int&gt; v3;\n    for (int i &#x3D; 0; i &lt; 1000000; ++i)\n    &#123;\n        v3.push_back(i);\n    &#125;\n    debugVectorInfo(v3);\n\n    &#x2F;&#x2F; 巧用 swap() 收缩容器的容量大小0\n    v3.resize(10);\n    vector&lt;int&gt;(v3).swap(v3);\n    debugVectorInfo(v3);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n总结：swap还可以收缩容器的容量大小\n\n\n3.2.8 vector预留空间\n功能描述：减少vector在动态扩展容器时的扩展次数\n\n\n\n函数原型\n\n\n\n\nreserve(int length);\n容器预留length个元素长度，预留位置不初始化，元素不可访问\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;10 16:54\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid demo1()\n&#123;\n    int count &#x3D; 0;\n    int *p &#x3D; nullptr;\n\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt; 10000000; ++i)\n    &#123;\n        v.push_back(i);\n        if (p !&#x3D; &amp;v[0])\n        &#123;\n            p &#x3D; &amp;v[0];\n            ++count;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;Number Of Extensions: &quot; &lt;&lt; count &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    int count &#x3D; 0;\n    int *p &#x3D; nullptr;\n\n    vector&lt;int&gt; v;\n    v.reserve(10000001);\n\n    for (int i &#x3D; 0; i &lt; 10000000; ++i)\n    &#123;\n        v.push_back(i);\n        if (p !&#x3D; &amp;v[0])\n        &#123;\n            p &#x3D; &amp;v[0];\n            ++count;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;Reserve Number Of Extensions: &quot; &lt;&lt; count &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n总结：如果一开始容器需要插入足够大的数据时，可以通过reserve的方式提前预留，已减少容器扩展的次数\n\n\n3.3 deque容器3.3.1 deque基本概念\n功能：双端数组，可以对容器头端进行插入、删除操作\n\ndeque与vector的区别：\n\nvector头部插入、删除效率低，数据量越大，效率越低\nvector访问元素比deque快，源于内部实现的区别\n\n\ndeque功能介绍：\n\n\n\n函数原型\n\n\n\n\npush_front();\n头部插入\n\n\npop_front();\n头部删除\n\n\n\ndeque内部工作原理：\n\ndeque内部有一个中控器，维护每段缓冲区的内容，缓冲区存放真实数据\n中控器维护的是缓冲区的地址，使得deque在使用时，像是连续的内存空间\ndeque容器的迭代器支持随机访问\n\n\n\n3.3.2 deque构造函数\n功能描述：deque容器构造\n\n\n\n函数原型\n\n\n\n\ndeque&lt;T&gt; dequeT;\n默认构造形式\n\n\ndeque(begin, end);\n构造函数将 [begin, end)区间中的元素拷贝给自身\n\n\ndeque(n, elem);\n构造函数将n个elem拷贝给自身\n\n\ndeque(const deque &amp;deque);\n拷贝构造函数\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;14 12:27\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; const 修饰 该容器为只可 读\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    &#x2F;&#x2F; 无参构造\n    deque&lt;int&gt; d1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        d1.push_back(i);\n    &#125;\n    printDeque(d1);\n\n    &#x2F;&#x2F; 区间构造\n    deque&lt;int&gt; d2(d1.begin(), d1.end());\n    printDeque(d2);\n\n    &#x2F;&#x2F; n个元素构造\n    deque&lt;int&gt; d3(10, 1);\n    printDeque(d3);\n\n    &#x2F;&#x2F; 拷贝构造\n    deque&lt;int&gt; d4(d3);\n    printDeque(d4);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;\n\n总结：deque与vector相似，灵活使用即可\n\n\n3.3.3 deque赋值操作\n功能描述：给deque容器赋值\n\n\n\n函数原型\n\n\n\n\ndeque &amp;operator=(const deque &amp;deque);\n重载等号操作\n\n\nassign(begin, end);\n将 [begin, end)区间中的数据拷贝赋值给本身\n\n\nassign(n, elem);\n将n个elem拷贝赋值给本身\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;14 13:13\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nvoid printDeque(deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    deque&lt;int&gt; deque1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    &#x2F;&#x2F; operator&#x3D;\n    deque&lt;int&gt; deque2 &#x3D; deque1;\n    printDeque(deque2);\n\n    &#x2F;&#x2F; assign(begin, end)\n    deque&lt;int&gt; deque3;\n    deque3.assign(deque1.begin(), deque1.end());\n    printDeque(deque3);\n\n    &#x2F;&#x2F; assign(n, elem)\n    deque&lt;int&gt; deque4;\n    deque4.assign(10, 1);\n    printDeque(deque4);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.3.4 deque大小操作\n功能描述：对deque容器的大小进行操作\n\n\n\n函数原型\n\n\n\n\ndeque.empty();\n判断容器是否为空\n\n\ndeque.size();\n获取容器中元素个数\n\n\ndeque.resize(num);\n重新指定容器长度为num，容器过长以默认值填充，容器过短，删除末尾多余元素\n\n\ndeque.resize(num, elem)\n重新指定容器长度为num，容器过长以elem填充，容器过短，删除末尾多余元素\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;17 15:17\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt;&quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 初始化 deque1\n    deque&lt;int&gt; deque1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    &#x2F;&#x2F; 判断deque1是否为空，不为空，打印出容器大小\n    if (deque1.empty())\n    &#123;\n        cout &lt;&lt; &quot;deque1 is empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;deque1 size: &quot; &lt;&lt; deque1.size() &lt;&lt; endl;\n        &#x2F;&#x2F; deque 没有容量的概念(capacity)\n    &#125;\n\n    &#x2F;&#x2F; deque1 大小重置\n    deque1.resize(12);\n    printDeque(deque1);\n\n    deque1.resize(15, 1);\n    printDeque(deque1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n总结：\n\ndeque没有容量的概念\nempty判断是否为空\nsize获取容器的大小\nresize重置容器大小\n\n\n\n3.3.5 deque插入删除\n功能描述：向deque容器插入和删除数据\n\n函数原型：\n\n\n\n两端插入caoz\n\n\n\n\npush_back(elem);\n容器尾部添加一个数据\n\n\npush_front(elem);\n容器头部插入一个数据\n\n\npop_back();\n删除容器最后一个数据\n\n\npop_front();\n删除容器开头一个数据\n\n\n\n\n\n指定位置操作\n\n\n\n\ninsert(pos, elem);\n在pos位置插入一个elem元素的拷贝，返回新数据的位置\n\n\ninsert(pos, n, elem);\n在pos位置插入n个elem元素的拷贝，无返回值\n\n\ninsert(pos, begin, end);\n在pos位置插入[begin, end)区间的数据，无返回值\n\n\nclear();\n清空容器所有数据\n\n\nerase(begin, end);\n删除[begin, end)区间的数据，返回下一个数据的位置\n\n\nerase(pos);\n删除pos位置的数据，返回下一个数据的位置\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;17 15:38\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    deque&lt;int&gt; deque1;\n\n    &#x2F;&#x2F; push_back()\n    deque1.push_back(1);\n    deque1.push_back(2);\n\n    &#x2F;&#x2F; push_front()\n    deque1.push_front(0);\n    deque1.push_front(0);\n    printDeque(deque1);\n\n    &#x2F;&#x2F; pop_back()\n    deque1.pop_back();\n\n    &#x2F;&#x2F; pop_front()\n    deque1.pop_front();\n    printDeque(deque1);\n\n    &#x2F;&#x2F; insert(pos, elem)\n    deque1.insert(deque1.begin(), 0);\n\n    &#x2F;&#x2F; insert(pos, n, elem)\n    deque1.insert(deque1.end(), 2, 2);\n    printDeque(deque1);\n\n    &#x2F;&#x2F; clear()\n    deque1.clear();\n    printDeque(deque1);\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    &#x2F;&#x2F; erase(begin, end)\n    deque1.erase(deque1.begin(), deque1.end() - 7);\n    printDeque(deque1);\n\n    &#x2F;&#x2F; erase(pos)\n    deque1.erase(deque1.begin() + 1);\n    printDeque(deque1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.3.6 deque数据存取\n功能描述：的deque中的数据的存取操作\n\n\n\n函数原型\n\n\n\n\nat(int index);\n返回索引index所指的数据\n\n\noperator[index];\n返回索引index所指的数据\n\n\nfront();\n返回容器中第一个数据\n\n\nback();\n返回容器这最后一个数据\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;17 15:57\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    deque&lt;int&gt; deque1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    &#x2F;&#x2F; at(int index)\n    cout &lt;&lt; deque1.at(1) &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator[]\n    cout &lt;&lt; deque1[1] &lt;&lt; endl;\n\n    &#x2F;&#x2F; front()\n    cout &lt;&lt; deque1.front() &lt;&lt; endl;\n\n    &#x2F;&#x2F; back()\n    cout &lt;&lt; deque1.back() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.3.7 deque容器排序\n功能描述：利用算法实现deque容器进行排序\n\n\n\n函数原型\n\n\n\n\nsort(iterator begin, iterator end);\n对begin, end区间的数据进行排序\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;17 16:05\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid printDeque(const deque&lt;int&gt; &amp;otherDeque)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it &#x3D; otherDeque.begin(); it !&#x3D; otherDeque.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    deque&lt;int&gt; deque1;\n    for (int i &#x3D; 20; i &gt; 0; i -&#x3D; 2)\n    &#123;\n        deque1.push_back(i);\n    &#125;\n    printDeque(deque1);\n\n    std::sort(deque1.begin(), deque1.end());\n    printDeque(deque1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n总结：使用sort排序，需引入头文件algorithm\n\n\n3.4 案例-评委打分3.4.1 案例描述\n5名选上ABCDE，10名评委分别对每一名选手打分，去除最高分和最低分，取平均分\n\n3.4.2 实现步骤\n创建5名选手，存入vector容器中\n遍历vector容器，获取每一名选手，使用for循环，把10名评委的打分存入deque容器中\nsort算法对deque容器中分数排序，去除最高和最低分\ndeque容器遍历一遍，累加总分\n获取平均分\n\n3.4.3 示例代码&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;20 14:26\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nclass Player\n&#123;\npublic:\n    string playerName;\n    int playerScore;\n\n    Player(string name, int score)\n    &#123;\n        this-&gt;playerName &#x3D; name;\n        this-&gt;playerScore &#x3D; score;\n    &#125;\n&#125;;\n\n&#x2F;*Test Code*&#x2F;\n&#x2F;*void printVector(vector&lt;Player&gt; &amp;v_Player)\n&#123;\n    for (vector&lt;Player&gt;::iterator it &#x3D; v_Player.begin(); it !&#x3D; v_Player.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; (*it).playerName &lt;&lt; &quot; Score: &quot; &lt;&lt; (*it).playerScore &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printPlayerScores(vector&lt;Player&gt; &amp;v_Player, deque&lt;int&gt; &amp;d_Scores)\n&#123;\n    for (vector&lt;Player&gt;::iterator v_it &#x3D; v_Player.begin(); v_it !&#x3D; v_Player.end(); ++v_it)\n    &#123;\n        cout &lt;&lt; v_it-&gt;playerName &lt;&lt; endl;\n        for (deque&lt;int&gt;::iterator d_it &#x3D; d_Scores.begin(); d_it !&#x3D; d_Scores.end(); ++d_it)\n        &#123;\n            cout &lt;&lt; *d_it &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;*&#x2F;\n\n&#x2F;*Program Code*&#x2F;\nvector&lt;Player&gt; createPlayers()\n&#123;\n    int score &#x3D; 0;\n    string nameSeed &#x3D; &quot;ABCDE&quot;;\n    vector&lt;Player&gt; v_Player;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        string name &#x3D; &quot;player&quot;;\n        name +&#x3D; nameSeed[i];\n        Player player(name, score);\n        v_Player.push_back(player);\n    &#125;\n\n    &#x2F;&#x2F; printVector(v_Player);\n\n    return v_Player;\n&#125;\n\nint playerScoreSortAndDeal(deque&lt;int&gt; &amp;d_Scores)\n&#123;\n    float averageScore;\n    int allScore &#x3D; 0;\n\n    std::sort(d_Scores.begin(), d_Scores.end());\n    d_Scores.pop_front();\n    d_Scores.pop_back();\n\n    for (deque&lt;int&gt;::iterator it &#x3D; d_Scores.begin(); it !&#x3D; d_Scores.end(); ++it)\n    &#123;\n        allScore +&#x3D; (*it);\n    &#125;\n    averageScore &#x3D; allScore &#x2F; d_Scores.size();\n    return averageScore;\n&#125;\n\nvoid setPlayerScore(vector&lt;Player&gt; &amp;v_Player)\n&#123;\n    for (vector&lt;Player&gt;::iterator it &#x3D; v_Player.begin(); it !&#x3D; v_Player.end(); ++it)\n    &#123;\n        deque&lt;int&gt; d_Scores;\n\n        for (int i &#x3D; 0; i &lt; 10; ++i)\n        &#123;\n            int score &#x3D; (rand() % 71) + 30;\n            d_Scores.push_back(score);\n        &#125;\n\n        it-&gt;playerScore &#x3D; playerScoreSortAndDeal(d_Scores);\n\n        &#x2F;&#x2F; printPlayerScores(v_Player, d_Scores);\n    &#125;\n&#125;\n\nvoid showPlayerAverageScore(vector&lt;Player&gt; &amp;v_Player)\n&#123;\n    for (vector&lt;Player&gt;::iterator it &#x3D; v_Player.begin(); it !&#x3D; v_Player.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; + it-&gt;playerName &lt;&lt; &quot; AverageScore: &quot; &lt;&lt; it-&gt;playerScore &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int) time(NULL));\n\n    vector&lt;Player&gt; v_Player &#x3D; createPlayers();\n    setPlayerScore(v_Player);\n    showPlayerAverageScore(v_Player);\n\n    return 0;\n&#125;\n\n\n\n\n\n3.5 stack容器3.5.1 stack基本概念\n概念：stack是一种先进后出(First In Last out : FILO)的数据结构，它只有一个出口\n栈底存放首个元素，后续其它元素都在栈顶依次加入\n栈中的元素，只有栈顶的元素可以被外界使用，也因此不支持遍历的行为\npush()入栈，pop()出栈，empty()判断栈是否为空，size()获取栈大小\n\n3.5.2 stack常用接口\n功能描述：栈容器常用的对外口\n\n构造函数：\n\nstack&lt;T&gt; stk; 采用模板类实现，stack对象的默认构造形式\nstack(const stack &amp;stk); 拷贝构造函数\n\n\n赋值操作：\n\nstack &amp;operator=(const stack &amp;stk); 重载等号操作\n\n\n数据存取：\n\npush(elem); 向栈顶添加元素\npop(); 移除栈顶的元素\ntop(); 返回栈顶的元素\n\n\n大小操作：\n\nempty(); 判断栈是否为空\nsize() 获取栈大小\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;20 16:13\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    stack&lt;int&gt; stk;\n\n    stk.push(10);\n    stk.push(20);\n    stk.push(30);\n\n    while (!stk.empty())\n    &#123;\n        cout &lt;&lt; &quot;Stack Size: &quot; &lt;&lt; stk.size() &lt;&lt; endl;\n        cout &lt;&lt; &quot;Stack Top Element: &quot; &lt;&lt; stk.top() &lt;&lt; endl;\n        stk.pop();\n    &#125;\n    cout &lt;&lt; &quot;Stack Size: &quot; &lt;&lt; stk.size() &lt;&lt; endl;\n    cout &lt;&lt; &quot;Stack Top Element: &quot; &lt;&lt; stk.top() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.6 queue容器3.6.1 queue基本概念\n概念：queue是先进先出(First In Frist Out : FIFO)的数据结构，它有两个出口\n队列容器只能队尾加入元素，对头删除元素\n队列容器只有头和尾可被外界使用，因此不支持遍历行为\n队列中进数据：入队push\n队列中出数据：出队pop\n\n3.6.2 queue常用接口\n功能描述：栈容器常用的对外接口\n\n构造函数：\n\nqueue&lt;T&gt; que; 采用模板类实现，queue对象的默认构造形式\nqueue(const queue &amp;que); 拷贝构造函数\n\n\n赋值操作：\n\nqueue&amp;operator=(const queue &amp;que); 重载等号操作\n\n\n数据存取：\n\npush(elem); 向队尾添加元素\npop(); 移除队头元素\nback(); 返回最后一个元素\nfront(); 返回第一个元素\n\n\n大小操作：\n\nempty(); 判断栈是否为空\nsize() 获取栈大小\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;20 16:37\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(string name, int age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    queue&lt;Person&gt; q;\n\n    Person p1(&quot;QQ&quot;, 10);\n    Person p2(&quot;WW&quot;, 20);\n    Person p3(&quot;EE&quot;, 30);\n    Person p4(&quot;RR&quot;, 40);\n\n    q.push(p1);\n    q.push(p2);\n    q.push(p3);\n    q.push(p4);\n\n    cout &lt;&lt; &quot;Queue Size: &quot; &lt;&lt; q.size() &lt;&lt; endl;\n\n    while (!q.empty())\n    &#123;\n        cout &lt;&lt; &quot;Front Name: &quot; + q.front().name + &quot; Front Age: &quot; &lt;&lt; q.front().age &lt;&lt; endl;\n        cout &lt;&lt; &quot;Back Name: &quot; + q.back().name + &quot; Back Age: &quot; &lt;&lt; q.back().age &lt;&lt; endl;\n\n        q.pop();\n    &#125;\n\n    cout &lt;&lt; &quot;Queue Size: &quot; &lt;&lt; q.size() &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.7 list容器3.7.1 list基本概念\n功能：将数据进行链式存储\n\n链表：是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链实现的\n\n链表的组成：链表由一系列结点组成\n\n结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\n\nSTL中的链表是一个双向循环链表\n\n优点：可以对任意位置进行快速插入或删除元素\n\n缺点：\n\n链表容器遍历元素比数组慢\n占用空间比数组大\n\n\nSTL链表的结构：双向循环链表\n\n结点：\n\ndata区：存储数据\npionter区：(默认指向null，则是不循环双向链表)\nprev：指向上一个结点的首地址(第一个结点默认指向最后一个结点的首地址)\nnext：指向下一个结点的首地址(最后一个结点默认指向第一个结点的首地址)\n\n\n\n\n方法：\n\npush_front()：添加一个新结点做为首结点\npop_front()：删除首结点\npush_back()：添加一个新结点做为尾结点\npop_back()：删除尾结点\n\n\n迭代器：\n\nbegin()：获得首结点的地址\ninsert()：获得指定的结点的地址\nend()：获得尾结点的地址\n\n\n补充：由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器\n\nlist的优点：\n\n采用动态存储分配，不会造成内存浪费和溢出\n链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素\n\n\nlist的缺点：\n\n链表的灵活带来的是空间(指针域)和时间(遍历)的额外消费较大\n\n\nlist的重要性质：插入和删除操作都不会造成原有list容器迭代器的失效(vector中会失效)\n\n总结：STL中的lsit和vector是两个常用的容器，各有优缺点\n\n\n3.7.2 list构造函数\n功能描述：创建list容器\n\n\n\n函数原型\n\n\n\n\nlist&lt;T&gt; list;\nlist采用模板类实现，对象的默认构造函数形式\n\n\nlist(begin, end);\n构造函数将[begin, end)区间中的元素拷贝给自身\n\n\nlist(n, elem);\n构造函数将n个elem拷贝给自身\n\n\nlist(const list &amp;list);\n拷贝构造函数\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;27 14:37\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;otherList)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; otherList.begin(); it !&#x3D; otherList.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; list1;\n    list1.push_back(1);\n    list1.push_back(2);\n    list1.push_back(3);\n    list1.push_back(4);\n\n    printList(list1);\n\n    &#x2F;&#x2F; 区间构造\n    list&lt;int&gt; list2(list1.begin(), list1.end());\n    printList(list2);\n\n    &#x2F;&#x2F; 拷贝构造\n    list&lt;int&gt; list3(list2);\n    printList(list3);\n\n    &#x2F;&#x2F; n 个 elem\n    list&lt;int&gt; list4(4, 0);\n    printList(list4);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.7.3 list赋值交换\n功能描述：给list容器进行赋值，以及容器list交换\n\n\n\n函数原型\n\n\n\n\nassign(begin, end);\n将[begin, end)区间中的数据拷贝赋值给自身\n\n\nassign(n, elem);\nn个elem拷贝赋值给自身\n\n\nlist &amp;operator=(const list &amp;list);\n重载=操作符\n\n\nswap(list);\n将list与自身的元素互换\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;27 14:49\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;Demo1 &gt;&gt;&quot; &lt;&lt; endl;\n    list&lt;int&gt; l1(4, 1);\n    printList(l1);\n\n    &#x2F;&#x2F; operator&#x3D;\n    list&lt;int&gt; l2 &#x3D; l1;\n    printList(l2);\n\n    &#x2F;&#x2F; assign(begin, end)\n    list&lt;int&gt; l3;\n    l3.assign(l1.begin(), l1.end());\n    printList(l3);\n\n    &#x2F;&#x2F; assign(n, elem)\n    list&lt;int&gt; l4;\n    l4.assign(4, 0);\n    printList(l4);\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;Demo2 &gt;&gt;&quot; &lt;&lt; endl;\n    list&lt;int&gt; list1(4, 0);\n    list&lt;int&gt; list2(4, 9);\n\n    cout &lt;&lt; &quot;Swap List Before &gt;&gt;&quot; &lt;&lt; endl;\n    printList(list1);\n    printList(list2);\n\n    cout &lt;&lt; &quot;Swap List Last &gt;&gt;&quot; &lt;&lt; endl;\n    list1.swap(list2);\n    printList(list1);\n    printList(list2);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n3.7.4 list大小操作\n功能描述：对list容器的大小进行操作\n\n\n\n函数原型\n\n\n\n\nsize();\n返回容器中元素个数\n\n\nempty();\n判断容器是否为空\n\n\nresize();\n重新指定容器长度为num，容器过长以默认值填充，容器过短，删除末尾多余元素\n\n\nresize(num, elem);\n重新指定容器长度为num，容器过长以elem填充，容器过短，删除末尾多余元素\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;27 15:06\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; list1(5, 1);\n\n    if (list1.empty())\n    &#123;\n        cout &lt;&lt; &quot;List1 Is Empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;List1 Size: &quot; &lt;&lt; list1.size() &lt;&lt; endl;\n    &#125;\n\n    list1.resize(10, 2);\n    printList(list1);\n\n    list1.resize(5);\n    printList(list1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.7.5 list插入删除\n功能描述：对list容器进行数据的插入和删除\n\n\n\n函数原型\n\n\n\n\npush_back(elem);\n在容器尾部加入一个元素\n\n\npop_back();\n删除容器中最后一个元素\n\n\npush_front(elem);\n在容器开头加入一个元素\n\n\npop_front();\n删除容器开头的一个元素\n\n\ninsert(pos, elem);\n在pos的位置插入elem元素的拷贝，返回新数据的位置\n\n\ninsert(pos, n, elem);\n在pos位置插入n个elem元素，无返回值\n\n\ninsert(pos, begin, end);\n在pos位置插入[begin, end)区间的数据，无返回值\n\n\nclear();\n移除容器中所有的元素\n\n\nerase(begin, end);\n删除[begin, end)区间的数据，返回下一个数据的位置\n\n\nerase(pos);\n删除pos位置的数据，返回下一个数据的位置\n\n\nremove(elem);\n删除容器中所有与elem元素匹配的元素\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;29 14:54\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; l1;\n\n    &#x2F;&#x2F; push_back()\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        l1.push_back(i);\n    &#125;\n    printList(l1);\n\n    &#x2F;&#x2F; push_front()\n    for (int i &#x3D; 1; i &lt;5; ++i)\n    &#123;\n        l1.push_front(1);\n    &#125;\n    printList(l1);\n\n    &#x2F;&#x2F; pop_back()\n    l1.pop_back();\n    printList(l1);\n\n    &#x2F;&#x2F; pop_front()\n    l1.pop_front();\n    printList(l1);\n\n    &#x2F;&#x2F; insert(pos, elem)\n    l1.insert(l1.begin(), 0);\n    printList(l1);\n\n    &#x2F;&#x2F; insert(pos, n, elem)\n    l1.insert(l1.end(), 3, 5);\n    printList(l1);\n\n    &#x2F;&#x2F; insert(pos, begin, end);\n    list&lt;int&gt; l2(3, 9);\n    l1.insert(l1.end(), l2.begin(), l2.end());\n    printList(l1);\n\n    &#x2F;&#x2F; erase(pos)\n    l1.erase(++l1.begin());\n    printList(l1);\n\n    &#x2F;&#x2F; remove(elem)\n    l1.remove(5);\n    printList(l1);\n\n    &#x2F;&#x2F; clear()\n    l1.clear();\n    l1.push_front(9);\n    printList(l1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.7.6 list数据存取\n功能描述：对list容器数据进行存取\n\n\n\n函数原型\n\n\n\n\nfront();\n返回第一个元素\n\n\nback();\n返回最后一个元素\n\n\n\n补充：list&lt;int&gt; l1;\n\nl1[0];\nl1.at(0);\n原因：list容器本质是链表，空间不连续，无法使用数组下标的方式获得数值，迭代器也不支持随机访问\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;29 15:33\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; l1;\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        l1.push_back(i);\n    &#125;\n    printList(l1);\n\n    cout &lt;&lt; &quot;l1 first&gt;&gt; &quot; &lt;&lt; l1.front() &lt;&lt; endl;\n    cout &lt;&lt; &quot;l1 back&gt;&gt; &quot; &lt;&lt; l1.back() &lt;&lt; endl;\n\n    &#x2F;&#x2F; 双向访问\n    list&lt;int&gt;::iterator it1 &#x3D; ++l1.begin();\n    list&lt;int&gt;::iterator it2 &#x3D; --l1.end();\n    l1.erase(it1, it2);\n    printList(l1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.7.7 list容器排序\n功能描述：将容器中的元素反转，以及元素排序\n\n\n\n函数原型\n\n\n\n\nreverse();\n反转链表\n\n\nsort();\n链表排序\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;29 15:54\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(const list&lt;int&gt; &amp;other)\n&#123;\n    for (list&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nbool upSort(int &amp;list1, int &amp;list2)\n&#123;\n    return list1 &gt; list2;\n&#125;\n\nvoid demo()\n&#123;\n    list&lt;int&gt; list1;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        list1.push_back(i);\n    &#125;\n    printList(list1);\n\n    &#x2F;&#x2F; reverse()\n    list1.reverse();\n    printList(list1);\n\n    &#x2F;&#x2F; sort() -- 默认从小到大\n    list1.sort();\n    printList(list1);\n\n    &#x2F;&#x2F; sort() -- 改为从大到小\n    list1.sort(upSort);\n    printList(list1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.8 案例-自定义数据排序\n案例描述：将Person自定义数据类型进行排序，Person中属性有：姓名，年龄，身高\n\n排序规则：按照年龄进行升序(年龄小的放在前面)，如果年龄相同，按照身高进行降序(身高低的放在前面)\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;29 16:15\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n    int height;\n\n    Person(const string &amp;name, int age, int height)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n        this-&gt;height &#x3D; height;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; Debug\nvoid printPersonList(const list&lt;Person&gt; &amp;other)\n&#123;\n    for (list&lt;Person&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot; Height:&quot; &lt;&lt; it-&gt;height &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nbool sortRule(Person &amp;person1, Person &amp;person2)\n&#123;\n    if (person1.age &#x3D;&#x3D; person2.age)\n    &#123;\n        return person1.height &lt; person2.height;\n    &#125;\n    else\n    &#123;\n        return person1.age &lt; person2.age;\n    &#125;\n&#125;\n\nlist&lt;Person&gt; createPersonList()\n&#123;\n    list&lt;Person&gt; l1;\n\n    Person person1(&quot;QQ&quot;, 10, 160);\n    Person person2(&quot;WW&quot;, 20, 150);\n    Person person3(&quot;EE&quot;, 20, 170);\n    Person person4(&quot;RR&quot;, 70, 175);\n    Person person5(&quot;TT&quot;, 30, 180);\n\n    l1.push_back(person1);\n    l1.push_back(person2);\n    l1.push_back(person3);\n    l1.push_back(person4);\n    l1.push_back(person5);\n\n    printPersonList(l1);\n\n    return l1;\n&#125;\n\nvoid upSort(list&lt;Person&gt; &amp;other)\n&#123;\n    cout &lt;&lt; &quot;UpSort&gt;&gt; By Age And Height&quot; &lt;&lt; endl;\n    other.sort(sortRule);\n    printPersonList(other);\n&#125;\n\nint main()\n&#123;\n    list&lt;Person&gt; l1 &#x3D; createPersonList();\n    upSort(l1);\n\n    return 0;\n&#125;\n\n3.9 set&#x2F;multiset容器3.9.1 set基本概念\n简介：所有元素被插入时，容器都会进行一次自动排序\n本质：set/multiset属于关联容器，底层结构是二叉树实现\nset和multiset的区别：\nset不允许容器中有重复的元素\nmultiset允许容器中有重复的元素\n\n\n\n3.9.2 set构造赋值\n功能描述：创建set容器并赋值\n\n\n\n构造\n\n\n\n\nset&lt;T&gt; st;\n默认构造函数\n\n\nset(const set &amp;st);\n拷贝构造函数\n\n\n\n\n\n赋值\n\n\n\n\nset &amp;operator=(const set &amp;st);\n重载等号操作符\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 14:49\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printSet(const set&lt;int&gt; &amp;st)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; st.begin(); it !&#x3D; st.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; st1;\n    &#x2F;&#x2F; set 只能用 insert插入数据，且不插入重复数据\n    &#x2F;&#x2F; set 会自动排序插入的数据\n    st1.insert(1);\n    st1.insert(1);\n    st1.insert(1);\n    st1.insert(4);\n    st1.insert(3);\n    st1.insert(2);\n    printSet(st1);\n\n    &#x2F;&#x2F; 默认构造\n    set&lt;int&gt; st2(st1);\n    printSet(st2);\n\n    &#x2F;&#x2F; 赋值拷贝构造\n    set&lt;int&gt; st3 &#x3D; st1;\n    printSet(st3);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n\n\n总结：set 只能用 insert插入数据，且不插入重复数据\n\n\n3.9.3 set大小交换\n功能描述：统计set容器大小，以及交换set容器\n\n\n\n函数原型\n\n\n\n\nsize();\n返回容器中元素个数\n\n\nempty();\n判断容器是否为空\n\n\nswap(st);\n交换两个容器的元素\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 15:00\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printSet(const set&lt;int&gt; &amp;st)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; st.begin(); it !&#x3D; st.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; st1;\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        st1.insert(i);\n    &#125;\n\n    if (st1.empty())\n    &#123;\n        cout &lt;&lt; &quot;Set1 Is Empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;\n        printSet(st1);\n        cout &lt;&lt; &quot;Set1 Size&gt;&gt;&quot; &lt;&lt; st1.size() &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid demo2()\n&#123;\n    set&lt;int&gt; st1;\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        st1.insert(i);\n    &#125;\n\n    set&lt;int&gt; st2;\n    for (int i &#x3D; 9; i &gt;&#x3D; 5 ; --i)\n    &#123;\n        st2.insert(i);\n    &#125;\n\n    cout &lt;&lt; &quot;Swap Before&gt;&gt;&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;\n    printSet(st1);\n    cout &lt;&lt; &quot;Set2&gt;&gt;&quot;;\n    printSet(st2);\n\n    cout &lt;&lt; &quot;Swap Last&gt;&gt;&quot; &lt;&lt; endl;\n    st1.swap(st2);\n    cout &lt;&lt; &quot;Set1&gt;&gt;&quot;;\n    printSet(st1);\n    cout &lt;&lt; &quot;Set2&gt;&gt;&quot;;\n    printSet(st2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    demo2();\n    return 0;\n&#125;\n\n3.9.4 set插入删除\n功能描述：set容器进行插入和删除数据\n\n\n\n函数原型\n\n\n\n\ninsert(elem);\n在容器中插入元素\n\n\nclear();\n清除所有元素\n\n\nerase(pos);\n删除迭代器pos所指的元素，返回下一个元素的迭代器\n\n\nerase(begin, end);\n删除[begin, end)区间内的元素，返回下一个元素的迭代器\n\n\nerase(elem);\n删除容器中的所有elem元素\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 15:14\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printSet(const set&lt;int&gt; &amp;st)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; st.begin(); it !&#x3D; st.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; st1;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        st1.insert(i);\n    &#125;\n    printSet(st1);\n\n    &#x2F;&#x2F; erase(pos)\n    st1.erase(st1.begin());\n    printSet(st1);\n\n    &#x2F;&#x2F; erase(elem)\n    st1.erase(9);\n    printSet(st1);\n\n    &#x2F;&#x2F; erase(begin, end);\n    st1.erase(++st1.begin(), --st1.end());\n    printSet(st1);\n\n    &#x2F;&#x2F; clear()\n    st1.clear();\n    st1.insert(0);\n    printSet(st1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.9.5 set查找统计\n功能描述：对容器内的元素进行查找和统计\n\n\n\n函数原型\n\n\n\n\nfind(key);\n查找key是否存在，存在则返回该元素的迭代器，不存在则返回set.end();\n\n\ncount(key);\n统计key的个数\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 15:25\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printSet(const set&lt;int&gt; &amp;st)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; st.begin(); it !&#x3D; st.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; st1;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        st1.insert(i);\n    &#125;\n    printSet(st1);\n\n    &#x2F;&#x2F; find(key)\n    set&lt;int&gt;::const_iterator it &#x3D; st1.find(3);\n    if (it !&#x3D; st1.end())\n    &#123;\n        cout &lt;&lt; &quot;Set1 Find&gt;&gt;&quot; &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Set1 Not Find&quot; &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; count(key)\n    set&lt;int&gt; st2;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        st2.insert(0);\n    &#125;\n    printSet(st2);\n    cout &lt;&lt; &quot;Set2 Count 0&gt;&gt;&quot; &lt;&lt; st2.count(0) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.9.6 set&#x2F;multiset区别\n区别：\n\nset不可以插入重复的元素，multiset可以\nset插入数据同时返回插入结果，表示插入成功\nmultiset不会检查插入数据，所以可以重复插入\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 15:58\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nvoid printMultiSet(const multiset&lt;int&gt; &amp;multiset1)\n&#123;\n    for (multiset&lt;int&gt;::const_iterator it &#x3D; multiset1.begin(); it !&#x3D; multiset1.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; set1;\n    pair&lt;set&lt;int&gt;::iterator, bool&gt; pairResult;\n    pairResult &#x3D; set1.insert(1);\n    cout &lt;&lt; &quot;First&gt;&gt; &quot; &lt;&lt; endl;\n    if (pairResult.second)\n    &#123;\n        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Succeed&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Error&quot; &lt;&lt; endl;\n    &#125;\n\n    pairResult &#x3D; set1.insert(1);\n    cout &lt;&lt; &quot;Second&gt;&gt; &quot; &lt;&lt; endl;\n    if (pairResult.second)\n    &#123;\n        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Succeed&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Set1 Insert &quot; &lt;&lt; &quot;&lt;&quot; &lt;&lt; *pairResult.first &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot; Error&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid demo2()\n&#123;\n    multiset&lt;int&gt; multiset1;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        multiset1.insert(9);\n    &#125;\n    printMultiSet(multiset1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    demo2();\n    return 0;\n&#125;\n\n3.9.7 pair对组创建\n功能描述：成对出现的数据组，利用对组可以返回两个数据\n\n创建方式：\n\npair&lt;type1, type2&gt; p(value1, value2);\npair&lt;type1, type2&gt; p = make_pair(value1, value2);\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 16:18\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printPair(const pair&lt;string, int&gt; &amp;other)\n&#123;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; other.first &lt;&lt; &quot; Age: &quot; &lt;&lt; other.second &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    pair&lt;string, int&gt; pair1(&quot;FF&quot;, 22);\n    printPair(pair1);\n\n    pair&lt;string, int&gt; pair2 &#x3D; make_pair(&quot;QQ&quot;, 20);\n    printPair(pair2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.9.8 set容器排序\n默认排序：set容器默认排序是从小到大\n\n排序目标：掌握自定义排序规则\n\n使用方法：利用仿函数，改变排序规则\n\n代码示例一：set存放内置数据类型，从大到小排序\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 16:30\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nclass DownSort\n&#123;\npublic:\n    bool operator()(int value1, int value2)\n    &#123;\n        return value1 &gt; value2;\n    &#125;\n&#125;;\n\nvoid printSet(const set&lt;int&gt; &amp;other)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printSet(const set&lt;int, DownSort&gt; &amp;other)\n&#123;\n    for (set&lt;int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    set&lt;int&gt; set1;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        set1.insert(i);\n    &#125;\n    printSet(set1);\n\n    set&lt;int, DownSort&gt; set2;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        set2.insert(i);\n    &#125;\n    printSet(set2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n\n\n代码示例二：自定义数据类型，从大到小排序\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;30 16:42\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(string name, int age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nclass DownSort\n&#123;\npublic:\n    bool operator()(const Person &amp;p1, const Person &amp;p2)\n    &#123;\n        return p1.age &gt; p2.age;\n    &#125;\n&#125;;\n\nvoid printSet(const set&lt;Person, DownSort&gt; &amp;other)\n&#123;\n    for (set&lt;Person, DownSort&gt;::iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; Age: &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    Person p1(&quot;QQ&quot;, 10);\n    Person p2(&quot;WW&quot;, 40);\n    Person p3(&quot;EE&quot;, 20);\n    Person p4(&quot;RR&quot;, 30);\n\n    set&lt;Person, DownSort&gt; set1;\n    set1.insert(p1);\n    set1.insert(p2);\n    set1.insert(p3);\n    set1.insert(p4);\n\n    printSet(set1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.10 map&#x2F;multimap容器3.10.1 map基本概念\n简介：\nmap中所有的元素都是pair\npair中第一个元素为key(键值)，起到索引作用，第二元素为value(实值)\n所有元素都会根据元素的键值自动排序\n\n\n本质：\nmap/multimap属于关联式容器，底层结构是用二叉树实现\n\n\n优点：\n可以根据key值快速找到value值\n\n\nmap/multimap的区别：\nmap不允许有重复的元素\nmultimap允许重复的元素\n\n\n\n3.10.2 map构造赋值\n功能描述：对map容器进行构造和赋值操作\n\n\n\n构造\n\n\n\n\nmap&lt;T1, T2&gt; mp;\nmap默认构造函数\n\n\nmap(const map &amp;mp);\n拷贝构造函数\n\n\n\n\n\n赋值\n\n\n\n\nmap &amp;operator=(const map &amp;mp);\n重载等号操作符\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;10&#x2F;31 16:34\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid printMap(const map&lt;int, string&gt; &amp;other)\n&#123;\n    for (map&lt;int, string&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;ID: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Name: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, string&gt; map1;\n\n    map1.insert(pair&lt;int, string&gt;(1, &quot;QQ&quot;));\n    map1.insert(pair&lt;int, string&gt;(4, &quot;WW&quot;));\n    map1.insert(pair&lt;int, string&gt;(2, &quot;EE&quot;));\n    map1.insert(pair&lt;int, string&gt;(5, &quot;RR&quot;));\n    map1.insert(pair&lt;int, string&gt;(3, &quot;TT&quot;));\n\n    printMap(map1);\n\n    &#x2F;&#x2F; 拷贝构造\n    map&lt;int, string&gt; map2(map1);\n    printMap(map2);\n\n    &#x2F;&#x2F; 赋值\n    map&lt;int, string&gt; map3 &#x3D; map1;\n    printMap(map3);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.10.3 map大小交换\n功能描述：统计map容器大小以及交换map容器\n\n\n\n函数原型\n\n\n\n\nsize();\n返回容器中的元素的数目\n\n\nempty();\n判断容器是否为空\n\n\nswap(st);\n交换两个集合容器\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 15:12\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid printMap(const map&lt;int, int&gt; &amp;other)\n&#123;\n    for (map&lt;int, int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, int&gt; map1;\n    map1.insert(pair&lt;int, int&gt;(1, 10));\n    map1.insert(pair&lt;int, int&gt;(2, 20));\n    map1.insert(pair&lt;int, int&gt;(3, 30));\n\n    if (map1.empty())\n    &#123;\n        cout &lt;&lt; &quot;Map1 Is Empty&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Map1 Size &quot; &lt;&lt; map1.size() &lt;&lt; endl;\n    &#125;\n\n    map&lt;int, int&gt; map2;\n    map2.insert(pair&lt;int, int&gt;(4, 40));\n    map2.insert(pair&lt;int, int&gt;(5, 50));\n    map2.insert(pair&lt;int, int&gt;(6, 60));\n\n    map1.swap(map2);\n\n    printMap(map1);\n    printMap(map2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.10.4 map插入删除\n功能描述：map容器进行插入和删除操作\n\n\n\n函数原型\n\n\n\n\ninsert(pair&lt;type1, type2&gt;(key, value));\n在容器中插入元素\n\n\nclear();\n清空容器\n\n\nerase(pos);\n删除pos迭代器所指位置的元素，返回下一个元素的迭代器\n\n\nerase(begin, end);\n删除[begin, end]之间的元素，返回下一个元素的迭代器\n\n\nerase(key);\n删除key指定索引位置的元素\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 15:31\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid printMap(const map&lt;int, int&gt; &amp;other)\n&#123;\n    for (map&lt;int, int&gt;::const_iterator it &#x3D; other.begin(); it !&#x3D; other.end(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, int&gt; map1;\n    map1.insert(pair&lt;int, int&gt;(1, 10));\n    map1.insert(make_pair(2, 20));\n    map1.insert(map&lt;int, int&gt;::value_type(3, 30));\n\n    &#x2F;&#x2F; 不建议使用该方法插入，但可以通过这个方法利用 key 访问 value\n    map1[4] &#x3D; 40;\n\n    map1.insert(pair&lt;int, int&gt;(5, 50));\n    map1.insert(pair&lt;int, int&gt;(6, 60));\n    map1.insert(pair&lt;int, int&gt;(7, 70));\n\n    &#x2F;&#x2F; map[5]在容器中不存在，所以默认直接在容器中添加了一个，默认value为0\n    cout &lt;&lt; map1[8] &lt;&lt; endl;\n\n    printMap(map1);\n\n    map1.erase(map1.begin());\n    printMap(map1);\n\n    map1.erase(8);\n    printMap(map1);\n\n    map1.erase(++map1.begin(), --map1.end());\n    printMap(map1);\n\n    map1.clear();\n    printMap(map1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.10.5 map查找统计\n功能描述：对map容器进行查找数据以及数据统计\n\n\n\n函数原型\n\n\n\n\nfind(key);\n查找key是否存在，若存在返回key键的元素迭代器；不存在，返回set.end();\n\n\ncount(key);\n统计key的元素的个数\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 16:34\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid printMap(const map&lt;int, int&gt; &amp;other)\n&#123;\n    for (map&lt;int, int&gt;::const_iterator it &#x3D; other.cbegin(); it !&#x3D; other.cend(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, int&gt; map1;\n    map1.insert(pair&lt;int, int&gt;(1, 10));\n    map1.insert(pair&lt;int, int&gt;(2, 20));\n    map1.insert(pair&lt;int, int&gt;(3, 30));\n\n    map&lt;int, int&gt;::const_iterator itPos &#x3D; map1.find(3);\n\n    &#x2F;&#x2F; map.end() 返回的是迭代器所指位置的 “下一个”迭代器的位置\n    if (itPos !&#x3D; map1.cend())\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; itPos-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; itPos-&gt;second &lt;&lt; endl;\n        cout &lt;&lt; &quot;End Key: &quot; &lt;&lt; map1.cend()-&gt;first &lt;&lt; &quot; End Value: &quot; &lt;&lt; map1.cend()-&gt;second &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Can Find Key&quot; &lt;&lt; endl;\n    &#125;\n\n    map1.insert(pair&lt;int, int&gt;(3, 90));\n    int count &#x3D; map1.count(3);\n    cout &lt;&lt; &quot;End Key: &quot; &lt;&lt; map1.cend()-&gt;first &lt;&lt; &quot; End Value: &quot; &lt;&lt; map1.cend()-&gt;second &lt;&lt; endl;\n    cout &lt;&lt; count &lt;&lt; endl;\n\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.10.6 map容器排序\n目标：\n\nmap容器默认排序规则，按照key值进行，从小到大的排序\n掌握自定义排序规则\n\n\n主要技术点：利用仿函数，改变排序规则\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 18:08\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nclass DownSort\n&#123;\npublic:\n    bool operator()(int value1, int value2)\n    &#123;\n        return value1 &gt; value2;\n    &#125;\n&#125;;\n\nvoid printMap(const map&lt;int, int, DownSort&gt; &amp;other)\n&#123;\n    for (map&lt;int, int&gt;::const_iterator it &#x3D; other.cbegin(); it !&#x3D; other.cend(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    map&lt;int, int, DownSort&gt; map1;\n    map1.insert(pair&lt;int, int&gt;(1, 10));\n    map1.insert(pair&lt;int, int&gt;(2, 20));\n    map1.insert(pair&lt;int, int&gt;(3, 30));\n    map1.insert(pair&lt;int, int&gt;(4, 40));\n    map1.insert(pair&lt;int, int&gt;(5, 50));\n\n    printMap(map1);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.11 案例-员工分组3.11.1 案例描述\n10名员工（ABCDEFGHIJ），需要分配部门\n员工信息：姓名，工资\n部门：策划，美术，研发\n随机给10名员工分配工资和部门\n通过multimap进行信息插入：key部门编号，value员工\n分部门显示员工信息\n\n3.11.2 实现步骤\n创建10个员工对象，存入vector容器中\n遍历vector，取出每个员工，进行随机分组\n分组后，将key部门编号，value员工，存放到multimap\n分部门显示员工信息\n\n3.11.3 案例代码&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;13 19:05\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\n#define PLAN 0\n#define ART 1\n#define RD 2\n\nclass Staff\n&#123;\npublic:\n    string staff_Name;\n    int staff_Salary;\n&#125;;\n\nvoid printVector(const vector&lt;Staff&gt; &amp;other)\n&#123;\n    for (vector&lt;Staff&gt;::const_iterator it &#x3D; other.cbegin(); it !&#x3D; other.cend(); ++it)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; it-&gt;staff_Name &lt;&lt; &quot; Salary: &quot; &lt;&lt; it-&gt;staff_Salary &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid creatStaff(vector&lt;Staff&gt; &amp;v_Staff)\n&#123;\n    string staffNameSeed &#x3D; &quot;ABCDEFGHIJ&quot;;\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        Staff staff;\n        staff.staff_Name &#x3D; &quot;Staff_&quot;;\n        staff.staff_Name +&#x3D; staffNameSeed[i];\n        staff.staff_Salary &#x3D; rand() % 10000 + 10000;\n\n        v_Staff.push_back(staff);\n    &#125;\n&#125;\n\nvoid setStaffGroup(vector&lt;Staff&gt; &amp;v_Staff, multimap&lt;int, Staff&gt; &amp;map_Depart)\n&#123;\n    for (vector&lt;Staff&gt;::iterator it &#x3D; v_Staff.begin(); it !&#x3D; v_Staff.end(); ++it)\n    &#123;\n        int depart_ID &#x3D; rand() % 3;\n        map_Depart.insert(pair&lt;int, Staff&gt;(depart_ID, *it));\n    &#125;\n&#125;\n\nvoid checkStaffByGroup(multimap&lt;int, Staff&gt;::const_iterator &amp;itPos, const multimap&lt;int, Staff&gt; &amp;map_Depart, const int count)\n&#123;\n    for (int index &#x3D; 0; itPos !&#x3D; map_Depart.cend() &amp;&amp; index &lt; count; ++itPos, ++index)\n    &#123;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; itPos-&gt;second.staff_Name &lt;&lt; &quot; Salary: &quot; &lt;&lt; itPos-&gt;second.staff_Salary &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid showStaffInfoByGroup(multimap&lt;int, Staff&gt; &amp;map_Depart)\n&#123;\n    int countStaff_PLAN &#x3D; map_Depart.count(PLAN);\n    int countStaff_ART &#x3D; map_Depart.count(ART);\n    int countStaff_RD &#x3D; map_Depart.count(RD);\n\n    multimap&lt;int, Staff&gt;::const_iterator itPos_Plan &#x3D; map_Depart.find(PLAN);\n    multimap&lt;int, Staff&gt;::const_iterator itPos_Art &#x3D; map_Depart.find(ART);\n    multimap&lt;int, Staff&gt;::const_iterator itPos_RD &#x3D; map_Depart.find(RD);\n\n    cout &lt;&lt; &quot;Plan Department&gt;&gt;&quot; &lt;&lt; endl;\n    checkStaffByGroup(itPos_Plan, map_Depart, countStaff_PLAN);\n\n    cout &lt;&lt; &quot;Art Department&gt;&gt;&quot; &lt;&lt; endl;\n    checkStaffByGroup(itPos_Art, map_Depart, countStaff_ART);\n\n    cout &lt;&lt; &quot;R&amp;D Department&gt;&gt;&quot; &lt;&lt; endl;\n    checkStaffByGroup(itPos_RD, map_Depart, countStaff_RD);\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int)time(NULL));\n\n    vector&lt;Staff&gt; v_Staff;\n    creatStaff(v_Staff);\n    printVector(v_Staff);\n\n    multimap&lt;int, Staff&gt; map_Depart;\n    setStaffGroup(v_Staff, map_Depart);\n\n    showStaffInfoByGroup(map_Depart);\n\n    return 0;\n&#125;\n\n\n\n","slug":"1_C++_模板和STL_05","date":"2022-10-06T07:28:25.920Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"e614b361765c5cfea11849494ca08809","title":"C++_面向对象反汇编补充","content":"C++_面向对象反汇编补充1. 类1.1 类的定义\nC++中可以使用 struct，class来定义类\n\n1.2 struct和class区别\nstruct默认成员权限是public\nclass默认成员权限是private\n\n1.2.1 定义和访问\n代码示例：\nstruct Person\n&#123;\n    int m_Age;\n    \n    void run()\n    &#123;\n        cout &lt;&lt; &quot;m_Age: &quot; &lt;&lt; m_Age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Person\n&#123;\npublic:    \n    int m_Age;\n    \n    void run()\n    &#123;\n        cout &lt;&lt; &quot;m_Age: &quot; &lt;&lt; m_Age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nPerson person;\n&#x2F;&#x2F; 通过对象访问\nperson.m_Age &#x3D; 20;\nperson.run();\n\n&#x2F;&#x2F; 通过指针访问\nPerson *ptr_Person &#x3D; &amp;person;\nptr_Person -&gt;m_Age &#x3D; 20;\nptr_Person -&gt;run();\n\n对象person 和 指针ptr_Person的内存都是在函数的栈空间中，自动分配和回收\n\n对象person只有一个int类型的成员变量，所以是4字节\n\n指针ptr_Person在 32位占用4字节，64位占用8字节\n\n\n1.2.2 反汇编查看区别\n代码示例1：\nclass Car\n&#123;\npublic:\n    int m_price;\n    \n    void run()\n    &#123;\n        cout &lt;&lt; &quot;Car::run() &quot; &lt;&lt; m_price &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Car car1;\n    car1.m_price &#x3D; 10;\n    car1.run();\n    \n    Car car2;\n    car2.m_price &#x3D; 20;\n    car2.run();\n    \n    return 0;\n&#125;\n\n&#x2F;&#x2F; 查看核心部分汇编代码\n\nmov dword ptr[car1], 0Ah &#x2F;&#x2F; 由此可得，对象占用4字节，成员变量占用4字节，所以第一个成员变量的内存地址就是对象的地址\n&#x2F;&#x2F; Car car1;\n&#x2F;&#x2F; car1.m_price &#x3D; 10;\n\nlea ecx, [car1]\ncall 0086141A &#x2F;&#x2F; 此处 call run()\n&#x2F;&#x2F; car1.run();\n    \nmov dword ptr[car2], 14h\n&#x2F;&#x2F; Car car2;\n\nlea ecx, [car2]\ncall 0086141A &#x2F;&#x2F; 此处 call run()\n&#x2F;&#x2F; car2.m_price &#x3D; 20;\n&#x2F;&#x2F; car2.run();\n\n&#x2F;&#x2F; 由上可以等到，两个对象 car1 和 car2 的成员变量是不同的\n&#x2F;&#x2F; 但它们调用的函数的地址是同一个\n\n对象内的函数不占用对象的内存大小：\n\n类中的函数在编译阶段，会将函数的地址存放到单独的一段内存中\n当两个函数完全相同时，会去重，仅保留一个函数地址\n一个类生成的多个对象中，只有成员变量是每个对象各自拥有的，而成员方法则是统一去重存储在方法列表中\n\n\n补充：\n\n无论函数和变量存在于什么地方，如果没有在其它地方使用或调用\n该函数和变量，在编译阶段会被优化，也就是根本不存在\n\n\n\n1.3 对象的内存布局\n代码示例：\nstruct Person\n&#123;\n  int m_age;\n  int m_id;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    person.m_age &#x3D; 10;\n    person.m_id &#x3D; 100;\n    \n    cout &lt;&lt; &quot;&amp;person &#x3D; &quot; &lt;&lt; &amp;person &lt;&lt; endl;\n    cout &lt;&lt; &quot;&amp;person.m_age &#x3D; &quot; &lt;&lt; &amp;person.m_age &lt;&lt; endl;\n    cout &lt;&lt; &quot;&amp;person.m_id &#x3D; &quot; &lt;&lt; &amp;person.m_id &lt;&lt; endl;\n    return 0;\n&#125;\n\n运行结果：\n&amp;person &#x3D; 0x7bfe18\n&amp;person.m_age &#x3D; 0x7bfe18   \n&amp;person.m_id &#x3D; 0x7bfe1c  \n\n2. this\n隐式参数\n\n存储着函数调用者的地址\n\n代码示例1：\nstruct Person\n&#123;\n  int m_age;\n  \n  void run()\n  &#123;\n    &#x2F;&#x2F; 编译器会隐式传参\n    &#x2F;&#x2F; this &#x3D; &amp;person1\n      this-&gt;m_age &#x3D; 3;\n  &#125;\n&#125;;\n\nint main()\n&#123;\n    Person person1;\n    person1.m_age &#x3D; 10;\n    person1.run();\n    \n    return 0;\n&#125;\n\n反汇编分析：\n&#x2F;&#x2F; ebp-8 是 this 的地址\n&#x2F;&#x2F; eax 是 person1 的地址\n\n&#x2F;&#x2F; Person person1;\n&#x2F;&#x2F; person1.m_age &#x3D; 10;\nmov dword ptr [ebp-0Ch], 0Ah\n\n&#x2F;&#x2F; person.run();\nlea ecx, [ebp-0Ch]\ncall 00181366\n\tmov dword ptr [ebp-8], ecx\n\t\n\t&#x2F;&#x2F; this-&gt;m_age &#x3D; 3;\n\tmov eax. dword ptr [ebp-8]\n\tmov dword ptr [eax], 3\n\n\n\n\n\n代码示例2：\nstruct Person\n&#123;\n  int m_age;\n  int m_id;\n  \n  void run()&#123;&#125;\n&#125;;\n\nint main()\n&#123;\n    Person person1;\n    person1.m_age &#x3D; 10;\n    person1.m_id &#x3D; 20;\n    person1.run();\n\t\n    Person *person2 &#x3D; &amp;person1;\n    person2-&gt;m_age &#x3D; 10;\n    person2-&gt;m_id &#x3D; 10;\n    person2-&gt;run();\n    return 0;\n&#125;\n\n反汇编分析：\n&#x2F;&#x2F; Person person1;\n&#x2F;&#x2F; person1.m_age &#x3D; 10;\nmov dword ptr [ebp-14h], 0Ah\n\n&#x2F;&#x2F; person1.m_id &#x3D; 20;\nmov dword ptr [ebp-10h], 14h\n\n&#x2F;&#x2F; person1.run();\nlea ecx, [ebp-14h]\ncall 00FA141F\n\t\n&#x2F;&#x2F; Person *person2 &#x3D; &amp;person1;\nlea eax, [ebp-14h] &#x2F;&#x2F; [ebp-14h]是person1的地址\nmov dword ptr [ebp-20h], eax &#x2F;&#x2F; [ebp-20h]是指针变量person2的地址\n\n&#x2F;&#x2F; person2-&gt;m_age &#x3D; 10;\nmov eax, dword ptr [ebp-20h] &#x2F;&#x2F; eax存储的是person1的地址值\nmov dword ptr [eax], 0Ah \n\n&#x2F;&#x2F; person2-&gt;m_id &#x3D; 10;\nmov eax, dword ptr [ebp-20h]\nmov dword ptr [eax+4], 0Ah \n\n&#x2F;&#x2F; person2-&gt;run();\nmov ecx, dword ptr [ebp-20h] &#x2F;&#x2F; 将person1地址隐式传给this\ncall 003B141F\n\n\n\n代码示例3：\nstruct Person\n&#123;\n  int m_age;\n  int m_id;\n  int m_height;  \n  \n  void run()\n  &#123;\n      cout &lt;&lt; m_age &lt;&lt; &quot;+&quot; &lt;&lt; m_id &lt;&lt; &quot;+&quot; &lt;&lt; m_height &lt;&lt; endl;\n  &#125;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    person.m_age &#x3D; 10;\n    person.m_id &#x3D; 20;\n    person.m_height &#x3D; 30;\n\t\n    Person *p &#x3D; (Person *) &amp;person.m_age;\n    p-&gt;m_age &#x3D; 0;\n    p-&gt;m_id &#x3D; 0;\n    \n    &#x2F;&#x2F; 注意：这里用的 person，不是 p\n    person.run();\n    return 0;\n&#125;\n\n# 打印结果：\n# 10+0+0\n\n反汇编分析：\n&#x2F;&#x2F; Person *p &#x3D; (Person *) &amp;person.m_id;\n&#x2F;&#x2F; eax &#x3D;&#x3D; &amp;person.m_id &#x3D;&#x3D; person+4\n\n&#x2F;&#x2F; p-&gt;m_age &#x3D; 0;\nmov eax, dword ptr [p]\nmov dword ptr [eax + 0], 0h\n\n&#x2F;&#x2F; p-&gt;m_id &#x3D; 0;\nmov eax, dword ptr [p]\nmov dword ptr [eax + 4], 0h\n\n&#x2F;&#x2F; 在栈空间中&gt;&gt; &amp;person &#x3D;&#x3D; &amp;person.m_age\n&#x2F;&#x2F; 改程序中 eax 的存储的地址是 &amp;person.m_id &#x3D;&#x3D; &amp;person+4\n&#x2F;&#x2F; 所以&gt;&gt; \n&#x2F;&#x2F; p-&gt;m_age &#x3D; 0; 修改的是 m_id\n&#x2F;&#x2F; p-&gt;m_id &#x3D; 0; 修改的是 m_height\n\n思考：\nPerson *p &#x3D; (Person *) &amp;person.m_age;\np-&gt;m_age &#x3D; 0;\np-&gt;m_id &#x3D; 0;\n\n&#x2F;&#x2F; person 对象的地址传递给 run 的this\nperson.run();\n&#x2F;&#x2F; 改为\n&#x2F;&#x2F; 将指针 p 里存储的地址值传给 run 的this &#x3D;&#x3D; &amp;person.m_id 传递给 this\np-&gt;run();\n\n# 打印结果\n# 40+50+-858993460\n# -858993460 &#x3D;&#x3D; Oxcccccccc\n\n补充：\n\n上面的程序打印结果：Oxcccccccc\n\n由来：函数调用是，开辟栈空间，调用结束，用cccccccc来填充内存空间\n\n原因：\n\ncc的汇编是int3：断点\nint是硬件中断\n\n\n作用：防止指针或jump之类的指令，指向错误的内存地址，可能造成系统安全问题，所以用硬件中断指令填充被释放的栈空间\n&#x2F;&#x2F; p-&gt;run();\n&#x2F;&#x2F; 汇编中有一条指令\nmov eax, 0cccccccch\nrep stos dword ptr es:[edi]\n\n3. 内存空间的布局\n每个应用都有自己独立的内存空间：\n代码区(代码段)：用于存放代码\n全局区(数据段)：用于存放全局变量等\n栈空间：\n每调用一个函数就会给它分配一个连续的栈空间，等函数调用完毕后会自动回收这段栈空间\n自动分配和回收\n\n\n堆空间：需要主动去申请和释放\n\n\n\n3.1 代码区\n只读\n存放CPU指令(机器码)\n\n3.2 全局区\n程序结束，全局区的数据才会清空\n\n3.3 堆空间\n在程序运行过程中，为了能自由控制内存的生命周期，大小，会经常使用堆空间的内存\n\n3.3.1 堆空间申请和释放\n堆空间的申请和释放：(C/C++语言 =&gt; malloc() / free())\nvoid demo()\n&#123;\n    &#x2F;&#x2F; malloc(4) 申请4字节堆空间，返回 void *，强转成 int *\n    int *p &#x3D; (int *)malloc(4);\n    &#x2F;&#x2F; int * 占用4个字节，所以 10 赋值给4个字节空间\n    *p &#x3D; 10;\n    &#x2F;&#x2F; 释放 p 申请的所有空间\n    free(p);\n    \n    char *p &#x3D; (char *)malloc(4);\n    &#x2F;&#x2F; char * 占用1个字节空间，所以 10 赋值给 p地址的第一个字节，另外3个字节是空的\n    *p &#x3D; 10;\n    *(p + 1) &#x3D; 11;\n    *(p + 2) &#x3D; 12;\n    *(p + 3) &#x3D; 13;\n    &#x2F;&#x2F; 等价于\n    p[0] &#x3D; 10;\n    p[1] &#x3D; 11;\n    p[2] &#x3D; 12;\n    p[3] &#x3D; 13;\n    \n    free(p);\n&#125;\n\n分析上面代码的内存分布：\nint *p &#x3D; (int *)malloc(4);\n*p &#x3D; 10;\n\n&#x2F;&#x2F; X86 -- 32bit ，int 指针占用 4 字节，64bit 占用 8字节\n&#x2F;&#x2F; 栈空间\n# 地址：0x111\n# 占用：4字节\n# p &#x3D; 0x999\n\n&#x2F;&#x2F; 堆空间\n# 地址：0x999\n# 占用：4字节\n# 值：10\n\n\n\n\n\n堆空间的申请和释放：(C++语言-新 =&gt; new / delete)\nvoid demo()\n&#123;\n    int *p &#x3D; new int; &#x2F;&#x2F; 等价于  int *p &#x3D; (int *)malloc(4);\n    *p &#x3D; 10;\n    \n    &#x2F;&#x2F; 释放\n    delete p;\n&#125;\n\n(new[] / delete [])\nvoid demo()\n&#123;\n    char *p &#x3D; new char[4]; &#x2F;&#x2F; 等价于  char *p &#x3D; (char *)malloc(4);\n    *p &#x3D; 10;\n    \n    &#x2F;&#x2F; 释放\n    delete p; &#x2F;&#x2F; 错误：此时 只会 释放地址p的第一个字节空间，后面3个字节没有释放\n    delete[] p; &#x2F;&#x2F; 正确：释放 p 申请的所有空间\n&#125;\n\n\n\n注意：\n\n申请堆空间成功后，会返回那一段空间的地址\n申请和释放必须是一一对应的，不然会造成内存泄露\n\n\n\n3.3.2 堆空间初始化\n简单示例：(memset == memory set)\nint *p1 &#x3D; (int *)malloc(sizeof(int)); &#x2F;&#x2F; *p1 未初始化\n\nint *p2 &#x3D; (int *)malloc(sizeof(int));\nmemset(p2, 0, sizeof(int)); &#x2F;&#x2F; *p2 的每个字节初始化为0\n\n\n\n其它初始化方式：\nint *p &#x3D; new int; &#x2F;&#x2F; 未初始化\nint *p &#x3D; new int(); &#x2F;&#x2F; 每个字节初始化为0\n&#x2F;&#x2F; mov __memset(0), eax\n\nint *p &#x3D; new int(5); &#x2F;&#x2F; 每个字节初始化为5\n\nint *p &#x3D; new int[3]; &#x2F;&#x2F; 数组三个元素未初始化\nint *p &#x3D; new int[3](); &#x2F;&#x2F; 数组三个元素初始化为0\nint *p &#x3D; new int[3]&#123;&#125;; &#x2F;&#x2F; 数组三个元素初始化为0\nint *p &#x3D; new int[3]&#123;5&#125;; &#x2F;&#x2F; 数组首元素初始化为5，其它元素初始化为0\n\n3.3.2.1 memset\nmemset 函数将较大的数据结构(对象，数组等等)内存清零的比较快的方式\n\n代码示例1：\nPerson person;\nperson.id &#x3D; 1;\nperson.age &#x3D; 2;\nperson.height &#x3D; 3;\n\nmemset(&amp;person, 0, sizeof(person));\n\n\n\n代码示例2：\nPerson persons[] &#x3D; &#123;&#123;1, 2, 3&#125;, &#123;1, 2, 3&#125;, &#123;1, 2, 3&#125;&#125;;\nmemset(persons, 0, sizeof(persons));\n\n3.4 对象的内存\n对象可以存在于3个地方\n\n全局区(数据段)：全局变量\n栈空间：函数里面的局部变量\n堆空间：动态申请内存(malloc, new等)\n\n\n代码示例：\n&#x2F;&#x2F; 全局区\nPerson person;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 栈空间\n    Person person;\n    \n    &#x2F;&#x2F; 堆空间\n    Person *person &#x3D; new Person;\n    return 0;\n&#125;\n\n4. 构造函数\n类的默认构造函数，无论其对象在什么地方创建，都会调用构造函数\n\n但存在特殊情况，在堆中创建对象，构造函数不会调用\n\n通过malloc()，不会调用构造函数\n\n代码示例：\nPerson *person &#x3D; (Person *)malloc(sizeof(Person));\nfree(person);\n&#x2F;&#x2F; malloc 不会调用构造函数\n\nPerson *person &#x3D; new Person;\ndelete person;\n&#x2F;&#x2F; 这个 new 会调用构造函数\n\n4.1 构造函数的错误概念\n错误概念：当类内没有自己定义构造函数，编译器会默认添加一个空实现的，无参的，默认构造函数\n\n正确理解：在特定情况下，编译器才会为类生成空的无参构造函数\n\n具体情况：后面的虚函数会总结\n\n代码示例：(定义了构造函数)\nclass Person\n&#123;\n    int m_age;\n    \n    Person()&#123;&#125;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    return 0;\n&#125;\n\n反汇编分析：\n# Person person;\nlea ecx, [person]\ncall Person::Person (0A914BFh)\n&#x2F;&#x2F; 定义了构造函数时，对象创建会调用构造函数\n\n\n\n代码示例：(没定义构造函数)\nclass Person\n&#123;\n    int m_age;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    person.m_age &#x3D; 10;\n    return 0;\n&#125;\n\n反汇编分析：\n# Person person;\n# person.m_age &#x3D; 10;\nmov dword ptr[person], 0Ah\n&#x2F;&#x2F; 类没有定义构造函数时，编译时也不会创建所谓的：空实现的，无参的，默认构造函数\n\n\n\n代码示例：(没定义构造函数，但类中静态初始化了成员变量)\nclass Person\n&#123;\n    int m_age &#x3D; 0;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n    person.m_age &#x3D; 10;\n    return 0;\n&#125;\n\n反汇编分析：\n# Person person;\nlea ecx, [person]\ncall Person::Person (0314C4h)\n# person.m_age &#x3D; 10;\nmov dword ptr[person], 0Ah\n\n&#x2F;&#x2F; 没定义构造函数，但类中静态初始化了成员变量，此时编译器会创建：空实现的，无参的，默认构造函数\n\n4.2 构造函数的调用\n通过多种创建对象的方式，判读是否调用了类的构造函数\n\n代码示例：\nclass Person\n&#123;\npublic:\n    int m_age;\n\n    Person()\n    &#123;\n        m_age &#x3D; 0;\n        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int age)\n    &#123;\n        m_age &#x3D; age;\n        cout &lt;&lt; &quot;Person(int)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nPerson g_person0; &#x2F;&#x2F; Person()\nPerson g_person1(); &#x2F;&#x2F; 这是 g_person1() 函数的声明或定义，不会调用构造函数\nPerson g_person2(10); &#x2F;&#x2F; Person(int)\n\nint main()\n&#123;\n    Person person0; &#x2F;&#x2F; Person()\n    Person person1(); &#x2F;&#x2F; 这是 g_person1() 函数的声明或定义，不会调用构造函数\n    Person person2(20); &#x2F;&#x2F; Person(int)\n\n    Person *p0 &#x3D; new Person; &#x2F;&#x2F; Person()\n    Person *p1 &#x3D; new Person(); &#x2F;&#x2F; Person() ，这是在堆空间中创建对象\n    Person *p2 &#x3D; new Person(30); &#x2F;&#x2F; Person(int)\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo1\nPerson()\nPerson(int)\nPerson()\nPerson(int)\nPerson()\nPerson()\nPerson(int)\n\n4.3 构造函数的成员变量初始化\n默认情况下，没有自定义构造函数时，只有全局区和堆区的对象创建，会初始化为0，其余栈空间不会初始化成员变量\n\n如果自定义了构造函数，除了全局区，其它内存空间的成员变量默认都不会被初始化，需要手动初始化\n\n代码示例1：(无自定义构造函数)\nclass Person\n&#123;\npublic:    \n    int m_age;\n&#125;;\n\n&#x2F;&#x2F; 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0\nPerson g_person;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 栈空间的对象直接被编译器优化了，不会初始化成员变量\n    &#x2F;&#x2F; Person person;\n\n    &#x2F;&#x2F; 没有初始化\n    Person *p0 &#x3D; new Person;\n\n    &#x2F;&#x2F; 初始化\n    Person *p1 &#x3D; new Person();\n\n    cout &lt;&lt; g_person.m_age &lt;&lt; endl;\n    cout &lt;&lt; p0-&gt;m_age &lt;&lt; endl;\n    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo2\n0\n14184048\n0\n\n得出结论：\n\n全局区内，内存值默认全是 0\n堆空间内，通过 () 申请的内存，默认初始化为 0\n栈空间内，默认初始化为 cccccccc\n\n\n代码示例2：(有自定义构造函数) -&gt; 空实现\nclass Person\n&#123;\npublic:    \n    int m_age;\n    \n    Person()&#123;&#125;\n&#125;;\n\n&#x2F;&#x2F; 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0\nPerson g_person;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 没有初始化\n    Person *p0 &#x3D; new Person;\n\n    &#x2F;&#x2F; 没有初始化，初始化工作交给自定义构造函数，然而自定义构造函数是空实现，所以没有初始化\n    Person *p1 &#x3D; new Person();\n\n    cout &lt;&lt; g_person.m_age &lt;&lt; endl;\n    cout &lt;&lt; p0-&gt;m_age &lt;&lt; endl;\n    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo2\n0\n14184048\n14184048\n\n4.4 构造函数的集体初始化\n通过memset()方法实现\n\n代码示例：\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    int m_age;\n\n    Person()\n    &#123;\n        &#x2F;&#x2F; memset() 方法，方便用于类成员变量集体初始化或清零\n        memset(this, 0, sizeof(Person));\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Person *p1 &#x3D; new Person();\n\n    cout &lt;&lt; p1-&gt;m_age &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo3\n0\n\n5. 析构函数\n又名析构器，在对象销毁时自动调用，一般用于完成对象的清理工作\n没有返回值，不能重载\n通过malloc()分配的对象，free()时，不会调用析构函数\n类中的构造函数和析构函数，需要public:修饰后，才能被外界调用\n全局区的对象，不会调用析构函数\n\n5.1 malloc与析构函数\n代码示例1：\nclass Person\n&#123;\npublic:    \n    int m_age;\n\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;\n    &#125;\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; malloc 的 对象不会调用 构造函数 和 析构函数\n    Person *p0 &#x3D; (Person *)malloc(sizeof(Person));\n    free(p0);\n\n    Person *p1 &#x3D; new Person();\n    delete p1;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo4\nPerson()\n~Person()\n\n5.2 对象内申请的堆区对象\n对象析构时，只会回收对象，如果对象的成员变量指向堆空间，需要手动释放，否则会造成内存泄漏\n\n内存泄漏：该释放的内存，没有去释放\n\n代码示例：\nclass Car\n&#123;\npublic:\n    int m_price;\n\n    Car()\n    &#123;\n        cout &lt;&lt; &quot;Car()&quot; &lt;&lt; endl;\n    &#125;   \n    ~Car()\n    &#123;\n        cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;\n    &#125; \n&#125;;\n\nclass Person\n&#123;\npublic:    \n    int m_age;\n    Car *m_car;\n\n    Person()\n    &#123;\n        &#x2F;&#x2F; 此处的 m_car是在堆空间中声明，需要delete才能回收\n        &#x2F;&#x2F; 如果是栈空间声明，person在调用析构函数时，会先回收m_car\n        m_car &#x3D; new Car;\n        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;\n    &#125;\n    ~Person()\n    &#123;\n        delete m_car;\n        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Person person;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\demo&gt; .\\demo5\nCar()\nPerson()\n~Car()\n~Person()\n\n6. 声明和实现\n类的定义和声明分离，分别在 .h和.cpp中实现\n\n6.1 具体演示Person.h\nclass Person\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    Person();\n    ~Person();\n\n    void set_Age(int age);\n    int get_Age();\n&#125;;\n\n\n\nPerson.cpp\nPerson::Person()\n&#123;\n    cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;\n&#125;\nPerson::~Person()\n&#123;\n    cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;\n&#125;\n\nvoid Person::set_Age(int age)\n&#123;\n    m_age &#x3D; age;\n&#125;\nint Person::get_Age()\n&#123;\n    return m_age;\n&#125;\n\n\n\nmain.cpp\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    Person person;\n    person.set_Age(10);\n    int age &#x3D; person.get_Age();\n\n    cout &lt;&lt; age &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n\n\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo2&gt; .\\demo1.exe\nPerson()\n10\n~Person()\n\n7. 命名空间\n作用：\n解决重复命名的问题\n命名空间不影响内存布局和结构\n\n\n\n7.1 命名空间的基本用法\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace fh1\n&#123;\n    class Person\n    &#123;\n    private:\n        int m_age;\n\n    public:\n        Person();\n        ~Person();\n    &#125;;\n&#125;\n\nnamespace fh2\n&#123;\n    class Person\n    &#123;\n    private:\n        int m_age;\n\n    public:\n        Person();\n        ~Person();\n    &#125;;\n&#125;\n\nint main()\n&#123;\n    fh1::Person person1;\n    fh2::Person person2;\n    return 0;\n&#125;\n\n7.2 命名空间的嵌套\n命名空间可以一直嵌套\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace fh1\n&#123;\n    namespace fh2\n    &#123;\n        class Person\n        &#123;\n        private:\n            int m_age;\n\n        public:\n            Person();\n            ~Person();\n        &#125;;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    fh1::fh2::Person person;\n    return 0;\n&#125;\n\n7.3 存在最大默认命名空间\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace fh\n&#123;\n    void func()\n    &#123;\n        cout &lt;&lt; &quot;fh::func()&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid func()\n&#123;\n    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    fh::func();\n    &#x2F;&#x2F; 通过默认的全局命名空间，访问 fh\n    ::fh::func();\n\n    func();\n    \n   \t&#x2F;&#x2F; 通过默认的全局命名空间，访问 func()\n    ::func();\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo2&gt; .\\demo4.exe\nfh::func()\nfh::func()\nfunc()\nfunc()\n\n8. 继承\n继承可以让子类拥有父类的所有成员\n\n8.1 继承的内存布局\n子对象中的成员变量分布：最上层的父类的成员变量在子对象的首地址，依次向下排列\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int height;    \n&#125;;\n\nclass Student : public Person\n&#123;\npublic:\n    int age;    \n&#125;;\n\nclass My : public Student\n&#123;\npublic:\n    int id;    \n&#125;;\n\nint main()\n&#123;\n    Person person;\n    Student student;\n    My my;\n    my.height &#x3D; 9;\n    my.age &#x3D; 10;\n    my.id &#x3D; 11;\n\n    cout &lt;&lt; &quot;Person: &quot; &lt;&lt; sizeof(person) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Student: &quot; &lt;&lt; sizeof(student) &lt;&lt; endl;\n    cout &lt;&lt; &quot;My: &quot; &lt;&lt; sizeof(my) &lt;&lt; endl;\n    \n    cout &lt;&lt; &amp;my.height &lt;&lt; endl;\n    cout &lt;&lt; &amp;my.age &lt;&lt; endl;\n    cout &lt;&lt; &amp;my.id &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo1.exe\nPerson: 4\nStudent: 8\nMy: 12\n0x7bfe08\n0x7bfe0c\n0x7bfe10\n\n总结：父类的成员变量在前面，子类的在后面\n\n补充：父类的成员变量，子类中没有使用，子类的对象大小依然不变，编译器不会去优化，所以要合理设计类\n\n\n8.2 成员访问权限\n成员访问权限、继承方式有3种：\n\npublic：公共的，任何地方都可以访问（struct默认）\nprivate：私有的，只有当前类内部可以访问（class默认）\nprotected：子类内部和当前类可以访问\n\n\n子类在继承父类时，使用了权限修饰：子类内部访问父类成员的权限，是一下两项中权限最小的\n\n成员本身的访问权限\n上一级父类的继承方式\n\n\n开发中最多的继承方式是public继承，保留父类原来的成员访问权限\n\n访问权限，不影响对象的内存布局\n\n\n9. 初始化列表\n特点：\n\n一种便捷的初始化成员变量的方式\n只用于构造函数\n初始化顺序，只跟成员变量的声明顺序有关\n\n\n补充：\n\n如果构造函数的声明和实现分离，初始化列表只能写在实现中\n\n\n语法：\nclass Person\n&#123;\nprivate:    \n    int m_age;\n    int m_height;\n\npublic:\n    &#x2F;&#x2F; 普通写法\n    Person(int age, int height)\n    &#123;\n        m_age &#x3D; age;\n        m_height &#x3D; height;\n    &#125;\n\n    &#x2F;&#x2F; 初始化列表\n    Person(int age, int height) : m_age(age), m_height(height)\n    &#123;\n    &#125;\n&#125;;\n\n两种写法完全等价：(反汇编查看)\n&#x2F;&#x2F; 普通构造函数\n&#x2F;&#x2F; m_age &#x3D; age;\nmov eax, dword ptr[this]\nmov ecx, dword ptr[age]\nmov dword ptr[eax], ecx\n\n&#x2F;&#x2F; m_height &#x3D; height;\nmov eax, dword ptr[this]\nmov ecx, dword ptr[height]\nmov dword ptr [eax+4], ecx\n\n&#x2F;&#x2F; 初始化列表\n&#x2F;&#x2F; m_age(age)\nmov eax, dword ptr[this]\nmov ecx, dword ptr[age]\nmov dword ptr[eax], ecx\n\n&#x2F;&#x2F; m_height(height)\nmov eax, dword ptr[this]\nmov ecx, dword ptr[height]\nmov dword ptr [eax+4], ecx\n\n10. 构造函数互调10.1 互调语法\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:    \n    int m_age;\n    int m_height;\n\npublic:\n    &#x2F;&#x2F; 错误的写法\n    &#x2F;&#x2F; Person() &#123;Person(10, 20);&#125;\n    \n    &#x2F;&#x2F; 正确的写法\n    Person() : Person(0, 0)&#123;&#125;\n\n    Person(int age, int height)\n    &#123;\n        m_age &#x3D; age;\n        m_height &#x3D; height;\n\n        cout &lt;&lt; m_age &lt;&lt; &quot; &quot; &lt;&lt; m_height &lt;&lt; endl;\n    &#125;\n&#125;;\n\n\nint main()\n&#123;\n    Person person1;\n    Person person2(10, 20);\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo3.exe\n0 0\n10 20\n\n10.2 语法分析\n通过反汇编分析两种写法的正确性\n&#x2F;&#x2F; 错误的写法\n&#x2F;&#x2F; 原因：在函数体中写的 Person(0, 0); 是创建临时Person的对象，0 赋值给了临时的Person对象\n&#x2F;&#x2F; Person() &#123;Person(0, 0);&#125;\nlea ecx, [person1]\ncall Person::Person(0E61118h)\n\nmov dword ptr [this], ecx\npush 14h\npush 0Ah\n\nlea ecx, [person] &#x2F;&#x2F; person是临时对象\ncall Person::Person(0E61311h)\n\nmov dword ptr[this], ecx\n\n&#x2F;&#x2F; 正确的写法\n&#x2F;&#x2F; Person() : Person(0, 0)&#123;&#125;\nlea ecx, [person2]\ncall Person::Person(01221118h)\n\nmov dword ptr [this], ecx\npush 14h\npush 0Ah\n\nmov dword ptr[this], ecx\ncall Person::Person(01221311h)\n\nmov dword ptr[this], ecx\n\n10.3 父类的构造函数\n子类的构造函数默认会调用父类的无参构造函数\n\n子类的构造函数主动调用了父类的有参构造函数，则父类的无参构造函数不会被调用\n\n如果父类缺少无参构造函数，子类构造函数就必须显式调用父类的有参构造函数\n\n代码示例1：(默认会调用父类的无参构造函数)\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic:    \n    Student()\n    &#123;\n        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Student student;\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo4.exe\nPerson::Person()\nStudent::Student()\n\n\n\n代码示例2：(主动调用了父类的有参构造函数)\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int age)\n    &#123;\n        cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic:    \n    Student() : Person(10)\n    &#123;\n        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Student student;\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo4.exe\nPerson::Person(int)\nStudent::Student()\n\n10.4 构造和析构的顺序\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;\n    &#125;\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic:    \n    Student()\n    &#123;\n        cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;\n    &#125;\n    ~Student()\n    &#123;\n        cout &lt;&lt; &quot;Student::~Student()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Student student;\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo3&gt; .\\demo5.exe\nPerson::Person()\nStudent::Student()\nStudent::~Student()\nPerson::~Person()\n\n11. 多态\n默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态\n\n多态是面向对象非常重要的特性\n\n同一个操作，用于不同的对象，可以有不同的解释，产生不同的结果\n在运行时，可以识别出真正的对象类型，调用对应子类中的函数\n\n\n多态的要素：\n\n子类重写父类的成员函数(override)\n父类指针指向子类\n利用父类指针调用重写的成员函数\n\n\n\n11.1 父类和子类指针\n父类指针指向子类对象是安全的，子类的继承方式是public\n\n子类指针指向父类对象是不安全的\n\n代码示例1：父类指针指向子类对象\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Person\n&#123;\n    int m_age;\n&#125;;\n\nstruct Student : Person\n&#123;\n    int m_score;\n&#125;;\n\nint main()\n&#123;\n    Person *person &#x3D; new Student;\n    person-&gt;m_age &#x3D; 10;\n    cout &lt;&lt; &quot;person-&gt;m_age: &quot; &lt;&lt; person-&gt;m_age &lt;&lt; &quot;\\n&quot;;\n\n    return 0;\n&#125;\n\n打印结果\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exe\nperson-&gt;m_age: 10\n\n总结：\n\n父类指针指向子类对象，这样用父类指针使用成员变量时，会很安全，不会影响到子类独有的成员变量\n父类的成员变量存在得到内存空间，肯定在子类对象的内存范围内，不会超出子类对象的内存范围，所以安全\n\n\n代码示例2：子类指针指向父类对象\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Person\n&#123;\n    int m_age;\n&#125;;\n\nstruct Student : Person\n&#123;\n    int m_score;\n&#125;;\n\nint main()\n&#123;    \n    Student *student &#x3D; (Student *)new Person;\n    student-&gt;m_age &#x3D; 10;\n    student-&gt;m_score &#x3D; 100;\n    \n    cout &lt;&lt; &quot;m_age: &quot; &lt;&lt; student-&gt;m_age &lt;&lt; &quot;\\n&quot; \n         &lt;&lt; &quot;m_score: &quot; &lt;&lt; student-&gt;m_score &lt;&lt; &quot;\\n&quot;;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exe\nm_age: 10\nm_score: 100\n\n总结：\n\n子类指针指向父类的对象，子类指针指向的成员变量，可能会超出父类对象内存范围内的成员变量，不安全\n因为可能会覆盖掉，别的子类对象内存范围内的成员变量的值\n\n\n代码示例3：通过反汇编查看强制类型转换\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n\tCat *animal &#x3D; (Cat *)new Dog;\n    animal-&gt;speak();\n    animal-&gt;run();\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo1.exe\nCat::speak()\nCat::run()\n\n查看反汇编结果：\n&#x2F;&#x2F; Cat *animal &#x3D; (Cat *)new Dog;\nmov dword ptr[ebp-0DCh], 0\nmov ecx, dword ptr[ebp-0DCh]\nmov dword ptr[animal], ecx\n\n&#x2F;&#x2F; animal-&gt;speak();\nmov ecx, dword ptr[animal]\ncall Cat::speak(0F714F6h)\n\n&#x2F;&#x2F; animal-&gt;run();\nmov ecx, dword ptr[animal]\ncall Cat::run(0F714F1h)\n\n总结：\n\n由上面的示例3可知：指针的类型决定了，指针所能访问的内存范围\n此时还未实现多态\n\n\n\n11.2 虚函数实现多态\n通过虚函数(virtual function)实现多态\n\n虚函数：被virtual修饰的成员函数\n\n在父类中声明为虚函数，子类中重写的成员函数会自动转成虚函数\n\n代码示例：\n\n\n  #include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    virtual void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;\n    virtual void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nvoid playAnimal(Animal *animal)\n&#123;\n    animal-&gt;speak();\n    animal-&gt;run();\n&#125;\n\nint main()\n&#123;\n    playAnimal(new Dog);\n    playAnimal(new Cat);\n    return 0;\n&#125;\n\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .\\demo2.exe\nDog::speak()\nDog::run()\nCat::speak()\nCat::run()\n\n11.3 虚表\n虚函数的实现原理是虚表，这个虚表里存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表\n\n11.3.1 虚表的大小\n前提：\n\n类中的普通函数，在对象中不占用空间，因为函数存在代码区中，而对象在栈区中，只有成员变量占用空间\n父类的虚函数，在子类重写后，这些函数会存入一个虚函数表中，虚函数表占用子类对象的内存空间\nx86环境，指针是4字节\nx64环境，指针是8字节\n\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    int m_age;\n    virtual void speak()&#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;\n    virtual void run()&#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    int m_height;\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Cat\n&#123; \npublic:\n    int m_health;\n    void speak()&#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Cat::sizeof()&#x3D; &quot; &lt;&lt; sizeof(Cat) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Dog::sizeof()&#x3D; &quot; &lt;&lt; sizeof(Dog) &lt;&lt; endl;\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .&#x2F;demo3.exe\nCat::sizeof()&#x3D; 4\nDog::sizeof()&#x3D; 16\n\n结果分析：\n\nDog对象，继承了父类Animal，对象类有两个int类型成员变量：8字节\n父类还有虚函数的存在，所以需要在Dog对象内创建虚函数表：x86是4字节，x64是8字节\nDog对象重写的父类的方法，存在代码区中，不和对象一起在栈区中，所以不占用对象内存\n\n\n\n11.3.2 反汇编分析虚表\nx86环境中，内存的布局\n\n代码示例：\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog();\n    animal-&gt;m_age &#x3D; 20;\n    return 0;\n&#125;\n\n\n\n\n\n内存地址\n内存数据\n内存地址\n内存数据\n\n\n\ndog\n0x00E69B60\n0x00B89B64&#x3D;&#x3D;虚表内存地址\n0x00B89B64\n0x00B814E7&#x3D;&#x3D;Dog::speak()的调用地址\n\n\n\n0x00E69B61\n\n0x00B89B65\n\n\n\n\n0x00E69B62\n\n0x00B89B66\n\n\n\n\n0x00E69B63\n\n0x00B89B67\n\n\n\n&amp;m_age\n0x00E69B64\n20\n0x00B89B68\n0x00B814CE&#x3D;&#x3D;Dog::run()的调用地址\n\n\n\n0x00E69B65\n\n0x00B89B69\n\n\n\n\n0x00E69B66\n\n0x00B89B6A\n\n\n\n\n0x00E69B67\n\n0x00B89B6B\n\n\n\n&amp;m_height\n0x00E69B68\n0\n\n\n\n\n\n0x00E69B69\n\n\n\n\n\n\n0x00E69B6A\n\n\n\n\n\n\n0x00E69B6B\n\n\n\n\n\n\n总结：\n\n可以看到，父类中有虚函数，子类对象从首地址开始，存放虚函数表\n虚函数表内存放着内存地址，而这个内存地址指向的是代码区的地址，也正是子类对象内重写父类方法的地址\n所以实现多态后，父类指针指向子类对象时，可以通过虚函数表，使得指针调用子类的方法，以达到多态的目的\n\n\n反汇编查看：\n\n代码示例：\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog();\n    animal-&gt;m_age &#x3D; 20;\n    animal-&gt;speak();\n    return 0;\n&#125;\n\n&#x2F;&#x2F; animal-&gt;m_age &#x3D; 20;\nmov eax, dword ptr[animal] &#x2F;&#x2F; animal &#x3D;&#x3D; ebp-8 是指针变量，eax 是Dog对象的地址，里面存放着虚表的地址值\nmov dword ptr[eax+4], 14h\n\n&#x2F;&#x2F; animal-&gt;speak();\nmov eax, dword ptr[animal]\nmov edx, dword ptr[eax] &#x2F;&#x2F; 从Dog对象的地址开始往后4个字节内的数据存入到 寄存器edx 中，edx 得到 虚表的地址\n\nmov esi, esp\nmov ecx, dword ptr[animal]\nmov eax, dword ptr[edx] &#x2F;&#x2F; 从 edx 中取4个字节，eax 得到虚表中存放 Dog对象方法的地址，(但不是方法的真正地址，需要jump到真正地址)\n\ncall eax &#x2F;&#x2F; 调用 Dog对象的方法\n\n11.3.3 虚表的设计思想\n前提：项目中实现了多态，其父类指针多次指向不同的子类对象，且父类的方法用virtual修饰\n原理：\n编译器在编译时，并不知道，项目中父类指针多次指向不同的子类对象\n即便父类指针指向的对象是自己本身的对象，也一样生成用于存放虚表地址的内存空间\n编译文件是静态的，而程序在内存中执行是动态过程\n\n\n目的：\n多态中，每个子对象都要有一个虚函数表\n实现程序在内存中执行的动态性\n\n\n虚表的相关优化：\n当父类指针多次指向多个子类对象，且都是同一个类的对象\n此时，这些对象依然有各自独立存放虚表地址的内存空间\n这些子类对象的前4字节空间中存放的虚表地址值(对象的方法所在代码区的地址)是相等的\n\n\n总结：相同类的对象，不管在什么区中，共用一份虚表\n\n11.3.4 多态实现的需求\n实现需求：大致两种\n\n完全重写父类的成员函数\n在父类的成员函数基础上，利用多态附加子类对象的成员函数\n\n\n代码示例1：第一种(完全重写)\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    &#x2F;&#x2F; 子类会完全重写的虚函数是 可以 为空实现\n    virtual void speak()&#123;cout &lt;&lt; &quot;Animal&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog;\n    animal-&gt;speak();\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .&#x2F;demo4.exe\nDog::speak()\n\n\n\n代码示例2：第二种(父类的方法实现基础上附加子类的实现)\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    &#x2F;&#x2F; 父类的方法实现基础上附加子类的实现，此处的父类虚函数实现 可以 不为空实现\n    virtual void speak()&#123;cout &lt;&lt; &quot;Animal&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        Animal::speak();\n        cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog;\n    animal-&gt;speak();\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .&#x2F;demo4.exe\nAnimal\nDog::speak()\n\n11.4 虚析构函数\n父类指针指向子类对象，含有虚函数的父类，应该将析构函数声明为虚函数(虚析构函数)\n\ndelete父类指针，才会调用子类的析构函数，保证析构的完整型\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    Animal()&#123;cout &lt;&lt; &quot;Animal::Animal()&quot; &lt;&lt; endl;&#125;\n    virtual ~Animal()&#123;cout &lt;&lt; &quot;Animal::~Animal()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    Dog()&#123;cout &lt;&lt; &quot;Dog::Dog()&quot; &lt;&lt; endl;&#125;\n    ~Dog()&#123;cout &lt;&lt; &quot;Dog::~Dog()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog;\n    delete animal;\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo4&gt; .&#x2F;demo5.exe\nAnimal::Animal()\nDog::Dog()\nDog::~Dog()\nAnimal::~Animal()\n\n补充：\n\n先构造父类，再构造子类\n先析构子类，再析构父类\n父类构造可以不用virtual修饰\n\n\n\n11.5 纯虚函数\n定义：没有函数体其初始化为0的虚函数，用来定义接口规范\n\n抽象类（Abstract Class）\n\n含有纯虚函数的类，不可以实例化（不可以创建对象）\n抽象类也可以是包含非纯虚函数，成员变量\n如果父类是抽象类，子类没有完全实现纯虚函数，那么这个子类依然是抽象类\n\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    int m_age;\n    virtual void speak() &#x3D; 0;\n    virtual void run() &#x3D; 0;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()&#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Animal *animal &#x3D; new Dog();\n    cout &lt;&lt; animal-&gt;m_age &lt;&lt; endl;\n    animal-&gt;run();\n    animal-&gt;speak();\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo1.exe\n0\nDog::run()\nDog::speak()\n\n11.6 多继承11.6.1 多继承概念\nC++允许一个类，继承多个类（不建议使用）\n\n如果子类继承的多个父类都有虚函数，那么子类对象会产生对应的多张虚函数表\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Student\n&#123;\npublic:\n    int m_score;\n&#125;;\n\nclass Worker\n&#123;\npublic:\n    int m_salary;\n&#125;;\n\nclass Undergraduate : public Student, public Worker\n&#123;\npublic:\n    int m_grade;\n&#125;;\n\n\nint main()\n&#123;\n    Undergraduate under;\n    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(under) &lt;&lt; endl;\n    under.m_score &#x3D; 100;\n    under.m_salary &#x3D; 2000;\n    under.m_grade &#x3D; 4;\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo2.exe\nsizeof: 12\n\n\n\n内存布局：\n\n\n\n\n\n内存地址\n内存数据\n\n\n\n&amp;under\n&amp;m_score\n0x00E69B60\n100\n\n\n\n\n0x00E69B61\n\n\n\n\n\n0x00E69B62\n\n\n\n\n\n0x00E69B63\n\n\n\n\n&amp;m_salary\n0x00E69B64\n2000\n\n\n\n\n0x00E69B65\n\n\n\n\n\n0x00E69B66\n\n\n\n\n\n0x00E69B67\n\n\n\n\n&amp;m_grade\n0x00E69B68\n4\n\n\n\n\n0x00E69B69\n\n\n\n\n\n0x00E69B6A\n\n\n\n\n\n0x00E69B6B\n\n\n\n\n\n11.6.2 同名成员函数&#x2F;变量\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal_A\n&#123;\npublic:\n    int m_age;\n    void run()&#123;cout &lt;&lt; &quot;Animal_A::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Animal_B\n&#123;\npublic:\n    int m_age;\n    void run()&#123;cout &lt;&lt; &quot;Animal_B::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nclass Dog : public Animal_A, public Animal_B\n&#123;\npublic:\n    int m_age;\n    void run()&#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Dog dog;\n\n    dog.m_age &#x3D; 10;\n    dog.Animal_A::m_age &#x3D; 11;\n    dog.Animal_B::m_age &#x3D; 12;\n    dog.Dog::m_age &#x3D; 13;\n    \n    dog.run();\n    dog.Animal_A::run();\n    dog.Animal_B::run();\n    dog.Dog::run();\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo3.exe\nDog::run()\nAnimal_A::run()\nAnimal_B::run()\nDog::run()\n\n11.6.3 菱形继承11.6.3.1 菱形继承结构\n基本结构：\n\n定义一个类：A\n定义类B1，继承A；定义类B2，继承A\n定义类C，继承B1，B2\n\n\n菱形继承的问题：\n\n最底层的对象，从基类继承的成员变量冗余，重复\n最底层的对象，无法访问基类的成员变量，存在二义性\n\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n&#123;\n    int a;\n&#125;;\n\nclass B1 : A &#x2F;&#x2F; 继承A的成员变量，2*int &#x3D; 8字节\n&#123;\n    int b1;\n&#125;;\n\nclass B2 : A &#x2F;&#x2F; 同理，2*int &#x3D; 8字节\n&#123;\n    int b2;\n&#125;;\n\nclass C : B1, B2 &#x2F;&#x2F; 继承B1，B2，加上自身成员变量，2+2+1 int &#x3D; 20字节\n&#123;\n    int c;\n&#125;;\n\nint main()\n&#123;\n    C c;\n    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo4.exe\nsizeof: 20\n\n11.6.3.2 虚继承\n解决菱形继承带来的底层对象的成员变量冗余，重复和二义性\n\n基本结构：\n\n定义一个类：A\n定义类B1，继承 virtual A；定义类B2，继承 virtual A\n定义类C，继承B1，B2\n\n\n此时，A为 虚基类\n\n作用：B1，B2会共同继承同一份 A 的成员，而不是各自继承一份，解决了底层对象的成员冗余\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A\n&#123;\n    int a;\n&#125;;\n\nstruct B1 : virtual A &#x2F;&#x2F; 虚表8字节，成员变量4字节，12\n&#123;\n    int b1;\n&#125;;\n\nstruct B2 : virtual A &#x2F;&#x2F; 虚表8字节，成员变量4字节，12\n&#123;\n    int b2;\n&#125;;\n\nstruct C : B1, B2 &#x2F;&#x2F; 2*12 &#x3D; 24，虚表8字节，成员变量4字节，虚基类成员变量4字节 &#x3D; 24 + 8 + 4 + 4 &#x3D; 40\n&#123;\n    int c;\n&#125;;\n\nint main()\n&#123;\n    C c;\n    cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo5&gt; .&#x2F;demo4.exe\nsizeof: 40\n\n虚继承的类结构：\n\n首地址存放虚指针和偏移量\n存放自己的成员变量\n存放虚基类的成员变量\n\n\n\n12. 静态成员12.1 静态成员基本定义\n定义：static修饰的成员变量&#x2F;函数\n\n可以通过对象.静态成员，对象指针-&gt;静态成员，类名::静态成员变量，进行访问\n\n\n静态成员变量：\n\n存储在数据段（全局区，类似全局变量），整个程序运行过程中只有一份内存\n对比全局变量，它可以设定访问权限（public, protected, private），达到局部共享的目的\n必须初始化，必须在类外面初始化，初始化不能带static，如果类的声明和实现分离（在实现中初始化）\n\n\n静态成员函数：\n\n内部不能使用this指针（this指针只能用于非静态成员函数内部）\n不能是虚函数（虚函数只能是非静态成员函数）\n内部不能访问非静态成员变量\\函数，只能访问静态成员变量\\函数\n构造函数和析构函数不可以是静态的\n当声明和实现分离，实现不能带static\n\n\n总结：\n\n涉及到，通过对象来管理，调用成员的变量和函数，都不可以用static修饰\nstatic修饰的成员变量&#x2F;函数只能通过类，利用作用域使用，或者在静态的函数内使用静态成员变量\n\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    \n    static int m_price;\n\n    static void byCar();\n&#125;;\n\nint Car::m_price &#x3D; 1000;\n\nvoid Car::byCar()\n&#123;\n    cout &lt;&lt; &quot;Car is running&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Car price: &quot; &lt;&lt; Car::m_price &lt;&lt; endl;\n    Car::byCar();\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo1.exe\nCar price: 1000\nCar is running\n\n12.2 反汇编分析静态成员\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    int m_age;\n    static int m_price;\n&#125;;\n\nint Car::m_price &#x3D; 0;\n\nint g_age;\n\nint main()\n&#123;\n    Car car1;\n    Car car2;\n    \n    g_age &#x3D; 0;\n    car1.m_age &#x3D; 1;\n    car1.m_price &#x3D; 2;\n    car2.m_price &#x3D; 3;\n        \n    return 0;\n&#125;\n\n反汇编分析，静态成员变量\n&#x2F;&#x2F; g_age &#x3D; 0;\nmov dword ptr ds:[00A9A318h], 0\t&#x3D;&gt; ds 数据段\n\n&#x2F;&#x2F; car1.m_age &#x3D; 1;\nmov dword ptr[car], 1\t&#x3D;&gt; mov dword ptr[ebp-8], 1\n\n&#x2F;&#x2F; car1.m_price &#x3D; 2;\nmov dword ptr[Car::m_price 00A9A314h)], 2\t&#x3D;&gt; mov dword ptr ds:[00A9A314h], 2\n\n&#x2F;&#x2F; car2.m_price &#x3D; 3;\nmov dword ptr[Car::m_price (00A9A314h)], 3\t&#x3D;&gt; mov dword ptr ds:[00A9A314h], 3\n\n总结：\n\n全局变量和类中的静态变量，都存放在数据区内，且程序运行时，仅有一份\n静态变量和全局变量的区别：\n静态变量可以在类中定义，同时通过public, protected, private修饰其访问权限\n\n\n\n\n\n12.3 静态成员应用12.3.1 统计对象个数\n应用：无论在那个区域增加或删除对象，都能有一个唯一值去统计当前的对象个数\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    static int ms_count;\n\npublic:\n    Car()&#123;++ms_count;&#125;\n    ~Car()&#123;--ms_count;&#125;\n\n    static int getCount()&#123;return ms_count;&#125;\n&#125;;\nint Car::ms_count &#x3D; 0;\n\nCar g_car; &#x2F;&#x2F; 1\n\nint main()\n&#123;\n    Car car; &#x2F;&#x2F; 2\n    Car *p_car &#x3D; new Car; &#x2F;&#x2F; 3\n\n    cout &lt;&lt; Car::getCount() &lt;&lt; endl;\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo2.exe\n3\n\n12.3.2 单例模式\n单例模式的构建：\n\n构造&#x2F;析构函数，私有化\n定义一个私有化的 static成员变量指向唯一得到单例对象\n提供一个公共的访问单例对象的接口\n\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Rocket\n&#123;\nprivate:\n    &#x2F;&#x2F; 构造&#x2F;析构函数，私有化\n    Rocket()&#123;&#125;\n    ~Rocket()&#123;&#125;\n\n    &#x2F;&#x2F; 定义一个私有化的 static成员变量指向唯一得到单例对象\n    static Rocket* ms_rocket;\n\npublic:\n    &#x2F;&#x2F; 提供一个公共的访问单例对象的接口\n    static Rocket* sharedRocket()\n    &#123;\n        &#x2F;&#x2F; 需要考虑多线程安全\n        if (ms_rocket &#x3D;&#x3D; NULL)\n        &#123;\n            ms_rocket &#x3D; new Rocket();\n        &#125;\n        return ms_rocket;\n    &#125;\n\n    &#x2F;&#x2F; 提供一个公共的访问单例对象的接口\n    static void deleteRocket()\n    &#123;\n        &#x2F;&#x2F; 需要考虑多线程安全\n        if (ms_rocket !&#x3D; NULL)\n        &#123;\n            ms_rocket &#x3D; NULL;\n            delete ms_rocket;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 测试用函数\n    void startRocket()&#123;cout &lt;&lt; &quot;Start Rocket&quot; &lt;&lt; endl;&#125;    \n&#125;;\nRocket* Rocket::ms_rocket &#x3D; NULL;\n\nint main()\n&#123;\n    Rocket *p_rocket_1 &#x3D; Rocket::sharedRocket();\n    Rocket *p_rocket_2 &#x3D; Rocket::sharedRocket();\n    Rocket *p_rocket_3 &#x3D; Rocket::sharedRocket();\n\n    cout &lt;&lt; p_rocket_1 &lt;&lt; &quot;\\n&quot; &lt;&lt; p_rocket_2 &lt;&lt; &quot;\\n&quot; &lt;&lt; p_rocket_3 &lt;&lt; endl;\n    p_rocket_1-&gt;startRocket();\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo6&gt; .\\demo3.exe\n0x8e6b80\n0x8e6b80\n0x8e6b80\nStart Rocket\n\n总结：由打印结果可看出，指向堆区的对象指针的地址始终不变，对象的单例模型已经实现\n\n补充：delete\n\nnew是堆空间，开辟一块区域，用来存放数据\ndelete是删除堆空间开辟的区域，使得这片区域可以被别的new使用，但里面的数据没有变化，\n需要在delete之前或之后，使其初始化为null\n\n\n\n13. const成员\n被const修饰的成员变量、非静态成员函数\n\nconst成员变量：\n\n必须在类内部初始化，可以在声明时，直接赋值\n非static的const成员变量还可以在初始化列表中初始化\n\n\nconst成员函数：\n\nconst关键字写在参数列表后面，函数的声明和实现都要写const\n内部不能修改非static成员变量\n内部只能调用const修饰的成员函数，static成员函数\n非const成员函数可以调用const成员函数\n\n\nconst成员函数和非const成员函数构成重载\n非const对象（指针）优先调用非const成员函数\n\n\nconst对象（指针）只能调用const成员函数，static成员函数\n\n\n\n14. 引用类型成员\n引用类型成员变量必须初始化（不考虑static）\n在声明的时候直接初始化\n通过初始化列表初始化\n\n\n\n15. 拷贝构造函数\n拷贝构造函数是构造函数的一种\n当利用已经存在的对象创建一个新对象时（类似于拷贝），就会调用对象的拷贝构造函数进行初始化\n拷贝构造函数的格式是固定的，接收一个const修饰的引用类型参数\n\n15.1 默认拷贝构造函数\n代码示例：(默认拷贝构造函数)\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    int m_price;\n    int m_length;\n\npublic:\n    Car(int price &#x3D; 0, int lenght &#x3D; 0) : m_price(price), m_length(lenght)&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;    \n\n    void display()&#123;cout &lt;&lt; &quot;price:&quot; &lt;&lt; m_price &lt;&lt; &quot; length: &quot; &lt;&lt; m_length &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Car car1(1, 1);\n    car1.display();\n\n    Car car2(car1);\n    car2.display();\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo1.exe\nCar::Car()\nprice:1 length: 1\nprice:1 length: 1\n\n反汇编查看原理：（默认构造函数）\n&#x2F;&#x2F; x86环境\n&#x2F;&#x2F; Car car2(car1);\nmov eax, dword ptr[ebp-10h] &#x3D;&gt; 10h &#x3D; 16\nmov dword ptr[ebp-20h], eax &#x3D;&gt; 20h &#x3D; 32\n&#x2F;&#x2F; &#x3D;&gt; car2.m_prcie &#x3D; car1.m_price;\n\nmov ecx, dword ptr[ebp-0Ch] &#x3D;&gt; 0Ch &#x3D; 12\nmov dword ptr[ebo-1Ch], ecx &#x3D;&gt; 1Ch &#x3D; 28\n&#x2F;&#x2F; &#x3D;&gt; car2.m_length &#x3D; car1.m_length;\n\n&#x2F;&#x2F; car2.display();\nlea ecx, [ebp-20h]\ncall 0024141A\n\n\n&#x2F;&#x2F; x64环境\n&#x2F;&#x2F; Car car2(car1);\nmov rax, qword ptr[rbp+8] &#x3D;&gt; 8h &#x3D; 8\nmov qword ptr[rbp+28h], rax &#x3D;&gt; 28h &#x3D; 40\n\n&#x2F;&#x2F; car2.display();\nlea rcx, [rbp+28h]\ncall 00007FF685AF12FD\n\n15.2 自定义拷贝构造函数\n代码示例：（自定义拷贝构造函数）\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    int m_price;\n    int m_length;\n\npublic:\n    Car(int price &#x3D; 0, int lenght &#x3D; 0) : m_price(price), m_length(lenght)&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;    \n    Car(const Car &amp;car) : m_price(car.m_price), m_length(car.m_length)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;\n\n    void display()&#123;cout &lt;&lt; &quot;price:&quot; &lt;&lt; m_price &lt;&lt; &quot; length: &quot; &lt;&lt; m_length &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Car car1(1, 1);\n    car1.display();\n\n    Car car2(car1);\n    car2.display();\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo1.exe\nCar::Car()\nprice:1 length: 1\nCar::Car(const)\nprice:1 length: 1\n\n15.3 调用父类拷贝构造函数\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int m_age;\n\n    Person(int age) : m_age(age)&#123;&#125;;\n    Person(const Person &amp;person) : m_age(person.m_age)&#123;&#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic:\n    int m_score;\n    \n    Student(int age, int score) : Person(age), m_score(score)&#123;&#125;       \n    Student(const Student &amp;student) : Person(student), m_score(student.m_score)&#123;&#125;\n&#125;;\n\nint main()\n&#123;\n    Student stu1(1, 100);\n    Student stu2(stu1);\n\n    cout &lt;&lt; stu2.m_age &lt;&lt; &quot; &quot; &lt;&lt; stu2.m_score &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo2.exe\n1 100\n\n补充：如果是完全拷贝对象内的数据，可以直接使用默认拷贝构造函数\n\n\n15.4 浅复制\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Student\n&#123;\npublic:\n    int m_score;\n    \n    Student(int score &#x3D; 0) : m_score(score)&#123;cout &lt;&lt; &quot;Student::Student()&quot; &lt;&lt; endl;&#125;       \n    Student(const Student &amp;student) : m_score(student.m_score)&#123;cout &lt;&lt; &quot;Student::Student(const Student &amp;student)&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 默认构造\n    Student s1(10);\n    \n    &#x2F;&#x2F; 拷贝构造\n    Student s2(s1);\n    &#x2F;&#x2F; 拷贝构造 &#x3D;&gt; 创建对象的同时，将 s2 的数据给 s3，符合拷贝构造\n    Student s3 &#x3D; s2;\n    \n    &#x2F;&#x2F; 浅复制 &#x3D;&gt; 创建了对象，但没有利用已经存在的对象进赋值，所以是 默认构造\n    Student s4;\n    s4 &#x3D; s3; &#x2F;&#x2F; 此时的两个对象都是 已经存在的对象，不是拷贝g\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo3.exe\nStudent::Student()\nStudent::Student(const Student &amp;student)\nStudent::Student(const Student &amp;student)\nStudent::Student()\n\n15.5 浅&#x2F;深拷贝15.5.1 解决浅拷贝问题\n编译器默认的都是浅拷贝\n\n浅拷贝的缺点：\n\n如果出现堆空间指向栈空间，那么浅拷贝后，堆空间内存储着栈空间的地址\n栈空间的生命周期是不可控制的，可能会使得堆空间指向栈空间的指针变成野指针\n\n\n代码示例：解决浅拷贝的问题\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    int m_price;\n    char *m_name;\n\npublic:\n    Car(int price &#x3D; 0, const char *name &#x3D; nullptr) : m_price(price)\n    &#123;\n        if (name &#x3D;&#x3D; nullptr)&#123;return;&#125;\n\n        m_name &#x3D; new char[strlen(name) + 1]&#123;&#125;;\n        strcpy(m_name, name);\n    &#125;    \n    ~Car()\n    &#123;\n        if (m_name &#x3D;&#x3D; nullptr)&#123;return;&#125;\n        m_name &#x3D; nullptr;\n        delete[] m_name;\n    &#125;\n\n    void printInfo()&#123;cout &lt;&lt; m_price &lt;&lt; &quot; &quot; &lt;&lt; m_name &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    char name[] &#x3D; &#123;&#39;b&#39;, &#39;w&#39;, &#39;m&#39;, &#39;\\0&#39;&#125;;\n    Car *car &#x3D; new Car(100, name);\n    car-&gt;printInfo();\n\n    Car *car2 &#x3D; new Car(200, &quot;bwm&quot;);\n    car2-&gt;printInfo();\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo4.exe\n100 bwm\n200 bwm\n\n15.5.2 深拷贝\n使用深拷贝的原因：\n\n当类中有数据会在堆空间中开辟，且在类的对象析构时释放时\n此时这个类已有一个对象，而新的对象利用已有的对象进行默认的拷贝构造（浅拷贝）\n此时，两个对象的某一个指向堆空间的成员变量，所指的地址相同\n当其中一个对象释放，另一个对象中的某个指向堆空间的成员变量也会被释放，使得另一个对象中的成员变量无效化\n如果两个对象都释放，则会出现同一个堆空间，两次释放\n\n\n深拷贝定义：\n\n将指针指向的内容拷贝到新的存储空间\n\n\n代码示例：\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Car\n&#123;\nprivate:\n    int m_price;\n    char *m_name;\n    void copy(const char *name &#x3D; nullptr)\n    &#123;\n        if (name &#x3D;&#x3D; nullptr)&#123;return;&#125;\n\n        m_name &#x3D; new char[strlen(name) + 1]&#123;&#125;;\n        strcpy(m_name, name);\n    &#125;\n\npublic:\n    Car(int price &#x3D; 0, const char *name &#x3D; nullptr) : m_price(price)&#123;copy(name);&#125;    \n    Car(const Car &amp;car) : m_price(car.m_price)&#123;copy(car.m_name);&#125;\n    ~Car()\n    &#123;\n        if (m_name &#x3D;&#x3D; nullptr)&#123;return;&#125;\n        m_name &#x3D; nullptr;\n        delete[] m_name;\n    &#125;\n\n    void printInfo()&#123;cout &lt;&lt; m_price &lt;&lt; &quot; &quot; &lt;&lt; m_name &lt;&lt; endl;&#125;\n&#125;;\n\nint main()\n&#123;\n    Car car1(100, &quot;bwm&quot;);\n    Car car2 &#x3D; car1;\n    car2.printInfo();\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo5.exe\n100 bwm\n\n16. 对象类型参数和返回值\n代码示例1：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    Car()&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;\n    Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;    \n&#125;;\n\nvoid test(Car car)&#123;&#125;\n\nint main()\n&#123;\n    Car car1;\n    test(car1);\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo6.exe\nCar::Car() &#x2F;&#x2F; Car car1;\nCar::Car(const) &#x2F;&#x2F; Car car &#x3D; car1;\n\n\n\n\n\n\n\n代码示例2：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    Car()&#123;cout &lt;&lt; &quot;Car::Car() &quot;&lt;&lt; this &lt;&lt; endl;&#125;    \n    Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const) &quot; &lt;&lt; this &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test1(Car car)&#123;&#125;\n\nCar test2()\n&#123;\n    Car car;\n    return car;\n&#125;\n\nint main()\n&#123;\n    Car car;\n    test1(car);\n\n    cout &lt;&lt; endl;\n\n    Car car1;\n    car1 &#x3D; test2();\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo7&gt; .\\demo6.exe\nCar::Car() 0x7bfe1d\nCar::Car(const) 0x7bfe1e\n\nCar::Car() 0x7bfe1c\nCar::Car() 0x7bfe1f\n\n17. 匿名对象\n又名：临时对象\n\n没有名称，不被指针指向，一次性使用，立即销毁\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    Car()&#123;cout &lt;&lt; &quot;Car::Car()&quot; &lt;&lt; endl;&#125;\n    Car(const Car &amp;car)&#123;cout &lt;&lt; &quot;Car::Car(const)&quot; &lt;&lt; endl;&#125;    \n    ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test(Car car)&#123;&#125;\n\nint main()\n&#123;\n    test(Car());\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo1.exe\nCar::Car()\nCar::~Car()\n\n18. 隐式构造\n又名：转换构造\n\n在某些情况下，会隐式调用单参数的构造函数\n\n通过关键字explicit禁用隐式构造\n\n代码示例1：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:\n    int m_age;    \npublic:\n    Person()&#123;cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;&#125;\n    Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Car::Car(int)&quot; &lt;&lt; endl;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test(Person person)&#123;&#125;\nPerson test2()&#123;return 40;&#125;\n\nint main()\n&#123;\n    Person p1 &#x3D; 20;\n    test2();\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; g++ demo2.cpp -o demo2; .\\demo2\nCar::Car(int)\nCar::Car(int)\nPerson::~Person()\nPerson::~Person()\n\n\n\n\n\n代码示例2：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:\n    int m_age;    \npublic:\n    Person()&#123;cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;&#125;\n    explicit Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Car::Car(int)&quot; &lt;&lt; endl;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test(Person person)&#123;&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; Person p1 &#x3D; 20; &#x2F;&#x2F; 此时这样的写法被 禁用\n    Person p1(20);\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; g++ demo3.cpp -o demo3; .\\demo3\nCar::Car(int)\nPerson::~Person()\n\n19. 编译器自动生成的构造函数\nC++编译器会在特定的情况下，会给类自动生成无参的构造函数\n\n成员变量在声明时，初始化\n有定义虚函数\n虚继承了其它类\n包含了对象类型的成员，且这个成员有构造函数（可以是编译器自动生成的，或自定义的）\n\n\n总结：\n\n对象创建后，需要进行一些额外的操作（内存操作，函数调用，成员变量初始化，虚函数，虚继承，调用父类构造等等）\n编译器都会自动生成无参的构造函数\n\n\n代码示例1：成员变量在声明时，初始化\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    int m_age &#x3D; 5;    \n&#125;;\n\n&#x2F;&#x2F; 此段代码 完全等价 上面的写法\n&#x2F;*\nclass Car\n&#123;\npublic:\n    int m_age &#x3D; 5;    \n    Car()&#123;m_age &#x3D; 5;&#125;\n&#125;;\n*&#x2F;\n\nint main()\n&#123;\n    Car car;\n    return 0;\n&#125;\n\n反汇编查看：\n&#x2F;&#x2F; Car car;\nlea ecx, [car]\ncall Car::Car(0A1384h)\n\nmov dword ptr[eax], 5\nmov eax, dword ptr[this]\n\n\n\n\n\n代码示例2：有定义虚函数\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Car\n&#123;\npublic:\n    int m_age;  \n    virtual void run()&#123;&#125;\n&#125;;\n\nint main()\n&#123;\n    Car car;\n    return 0;\n&#125;\n\n反汇编查看：\nlea ecx, [car]\ncall Car::Car(0E5111Dh)\n\nmov dword ptr[this], ecx\nmov eax, dword ptr[this]\nmov dword ptr[eax], offset Car::&#96;vftable&#96;(0E57B34h) &#x2F;&#x2F; vftable &#x3D;&#x3D; virtual function table 虚函数表\nmov eax, dword ptr[this]\n\n\n\n\n\n代码示例3：虚继承了其它类\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int m_age;  \n    void run()&#123;&#125;\n&#125;;\n\nclass Student : virtual public Person\n&#123;\npublic:\n    int m_score;\n&#125;;\n\nint main()\n&#123;\n    Student student;\n    return 0;\n&#125;\n\n反汇编查看：\nlea ecx, [student]\ncall Student::Student(012213A7h)\n\nmov eax, dword ptr[this]\nmov dword ptr[eax], offset Student::&#96;vftable&#96;(01227B30h)\nmov eax, dword ptr[this]\n\n20. 友元\n友元包括：\n\n友元函数\n如果将函数A（非成员函数）声明为类B的友元函数，那么函数A内部可以直接访问类B对象的所有成员\n\n\n友元类\n类A内声明了类B的友元，类B可以访问类A的所有成员\n\n\n\n\n代码示例1：友元函数\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\n    &#x2F;&#x2F; 声明 友元函数\n    friend Point add_P(Point &amp;, Point &amp;);  \n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n    void printPoint()&#123;cout &lt;&lt; m_x &lt;&lt; &quot; &quot; &lt;&lt; m_y &lt;&lt; endl;&#125;    \n&#125;;\n\n&#x2F;&#x2F; 实现 友元函数\nPoint add_P(Point &amp;p1, Point &amp;p2)\n&#123;\n    return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);\n&#125;\n\nint main()\n&#123;\n    Point p1(10, 10);\n    Point p2(20, 20);\n    Point p3(add_P(p1, p2));\n    p3.printPoint();\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo5\n30 30\n\n\n\n\n\n代码示例2：友元类\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n    \n    &#x2F;&#x2F; 声明 友元类\n    friend class FH_Math;\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n    void printPoint()&#123;cout &lt;&lt; m_x &lt;&lt; &quot; &quot; &lt;&lt; m_y &lt;&lt; endl;&#125;    \n&#125;;\n\n&#x2F;&#x2F; 实现 友元类\nclass FH_Math\n&#123;\npublic:    \n    Point add_P(Point &amp;p1, Point &amp;p2)\n    &#123;\n        return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Point p1(10, 10);\n    Point p2(20, 20);\n    Point p3 &#x3D; FH_Math().add_P(p1, p2);\n    p3.printPoint();\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo8&gt; .\\demo6\n30 30\n\n21. 内部类21.1 内部类的定义\n定义：\n\n类B定义在类A中，B就是A的内部类（嵌套类）\n类A就是B的外部类\n\n\n特点：\n\n支持：public, protected, private权限\n内部类成员函数可以访问外部类所有成员\n外部类则无法访问内部类的成员\n成员函数可以直接不带类名，对象名访问其外部类的static修饰的成员\n不会影响外部类的内存布局\n\n\n代码示例1：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    void test1()&#123;cout &lt;&lt; &quot;Person::test1()&quot; &lt;&lt; endl;&#125;\n    static void test2()&#123;cout &lt;&lt; &quot;Person::test2(static)&quot; &lt;&lt; endl;&#125;\n\npublic:\n    class Student\n    &#123;\n    private:\n        int m_id;\n\n    public:        \n        void test3()&#123;test2();&#125;        \n    &#125;;\n&#125;;\n\n\nint main()\n&#123;\n    Person::Student s;\n    s.test3();\n\n    cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n    cout &lt;&lt; sizeof(Person::Student) &lt;&lt; endl;\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo1\nPerson::test2(static)\n4\n4\n\n21.2 内部类声明与实现分离\n跟正常的函数声明和实现分离差不多\n标明类的作用域就可以了\n\n22. 局部类\n在一个函数中定义一个类：局部类\n特点：\n作用域仅限于所在的函数内部，不允许static修饰成员\n局部类的成员函数不能直接访问所在函数的局部变量（static可以）\n\n\n\n23. 运算符重载\n注意：\n有些运算符不可以重载：\n对象成员访问运算符.\n域运算符::\n三目运算符?\nsizeof\n\n\n有些运算符只能重载为成员函数：\n赋值运算符=\n下标运算符[]\n函数运算符()\n指针访问成员-&gt;\n\n\n\n\n\n23.1 基本运算符重载\n作用：给运算符增加一些新的功能\n\n设计思路：\n\n如果仅和类相关，重载运算符函数优先写在类里面\n如果是&lt;&lt;，&gt;&gt;的重载，尽量写成全局函数\n\n\n代码示例1：+, -, +=, -=, ==, !=, -, ++, --\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n\n    void showPoint()&#123;cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;         \n\n    &#x2F;&#x2F; operator +, -\n    const Point operator+(const Point &amp;point) const\n    &#123;\n        return Point(this-&gt;m_x + point.m_x, this-&gt;m_y + point.m_y);\n    &#125;\n\n    &#x2F;&#x2F; operator +&#x3D;, -&#x3D;\n    Point &amp;operator+&#x3D;(const Point &amp;point)\n    &#123;\n        this-&gt;m_x +&#x3D; point.m_x;\n        this-&gt;m_y +&#x3D; point.m_y;\n        return *this;\n    &#125;\n\n    &#x2F;&#x2F; operator &#x3D;&#x3D;, !&#x3D;\n    const bool operator&#x3D;&#x3D;(const Point &amp;point)\n    &#123;\n        return (this-&gt;m_x &#x3D;&#x3D; point.m_x &amp;&amp; this-&gt;m_y &#x3D;&#x3D; point.m_y);\n    &#125;\n\n    &#x2F;&#x2F; operator -\n    const Point operator-() const\n    &#123;\n        return Point(-m_x, -m_y);\n    &#125;\n\n    &#x2F;&#x2F; operator ++, --\n    Point &amp;operator++()\n    &#123;\n        ++this-&gt;m_x;\n        ++this-&gt;m_y;\n        return *this;\n    &#125;\n    const Point operator++(int)\n    &#123;\n        Point origin_P(this-&gt;m_x, this-&gt;m_y);\n        ++this-&gt;m_x;\n        ++this-&gt;m_y;\n        return origin_P;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; operator +, -\n    cout &lt;&lt; &quot;operator +, -&quot; &lt;&lt; endl;\n    Point p1(10, 10);\n    Point p2(20, 20);\n    Point p3 &#x3D; p1 + p2;\n    Point p4 &#x3D; p1 + p2 + p3;\n    p4.showPoint();\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator +&#x3D;, -&#x3D;\n    cout &lt;&lt; &quot;operator +&#x3D;, -&#x3D;&quot; &lt;&lt; endl;\n    Point p5(1, 1);\n    Point p6(2, 2);\n    Point p7;\n    (p7 +&#x3D; p5) &#x3D; p6;\n    p4.showPoint();\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator &#x3D;&#x3D;, !&#x3D;\n    cout &lt;&lt; &quot;operator &#x3D;&#x3D;, !&#x3D;&quot; &lt;&lt; endl;\n    Point p8(1, 1);\n    Point p9(1, 1);\n    cout &lt;&lt; (p1 &#x3D;&#x3D; p2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator -\n    cout &lt;&lt; &quot;operator -&quot; &lt;&lt; endl;\n    Point p10(1, 1);\n    Point p11(0, 0);\n    Point p12;\n    p11 &#x3D; -p10;\n    p10.showPoint();\n    p11.showPoint();\n    p12 &#x3D; -(-p1);\n    p12.showPoint();\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F; operator ++, --\n    cout &lt;&lt; &quot;&#x2F;&#x2F; operator ++, --&quot; &lt;&lt; endl;\n    Point p13(1, 1);\n    Point p14(0, 0);\n    Point p15(2, 2);\n    ++p13;\n    p13++;\n    p13.showPoint();\n    p14 &#x3D; (p13++) + p15;\n    p14.showPoint();\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo3\noperator +, -\n(60, 60)\n---------\noperator +&#x3D;, -&#x3D;\n(60, 60)\n---------\noperator &#x3D;&#x3D;, !&#x3D;\nfalse\n---------\noperator -\n(1, 1)\n(-1, -1)\n(10, 10)\n---------\n&#x2F;&#x2F; operator ++, --\n(3, 3)\n(5, 5)\n---------\n\n\n\n代码示例2：&lt;&lt; &gt;&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n \n    &#x2F;&#x2F; operator &lt;&lt;, &gt;&gt;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);\n    friend istream &amp;operator&gt;&gt;(istream &amp;cin, Point &amp;point);\n&#125;;\n\nostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)\n&#123;\n    cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;\n    return cout;\n&#125;\n\nistream &amp;operator&gt;&gt;(istream &amp;cin, Point &amp;point)\n&#123;\n    cout &lt;&lt; &quot;input m_x: &quot;;\n    cin &gt;&gt; point.m_x;\n\n    cout &lt;&lt; &quot;input m_y: &quot;;\n    cin &gt;&gt; point.m_y;\n    return cin;\n\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; operator &lt;&lt;, &gt;&gt;\n    cout &lt;&lt; &quot;operator &lt;&lt;&quot; &lt;&lt; endl;\n    Point p1(10, 10);\n    cout &lt;&lt; p1 &lt;&lt; endl;\n    cout &lt;&lt; p1 &lt;&lt; p1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;operator &gt;&gt;&quot; &lt;&lt; endl;\n    Point p2;\n    Point p3;\n    cin &gt;&gt; p2 &gt;&gt; p3;\n    cout &lt;&lt; p2 &lt;&lt; &quot;\\n&quot; &lt;&lt; p3 &lt;&lt; endl;\n    cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo4    \noperator &lt;&lt;\n(10, 10)\n(10, 10)(10, 10)\n--------\noperator &gt;&gt;\ninput m_x: 1\ninput m_y: 1\ninput m_x: 2\ninput m_y: 2\n(1, 1)\n(2, 2)\n--------\n\n23.2 调用父类的运算符重载\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\npublic:    \n    int m_age;\n\n    Person &amp;operator&#x3D;(const Person &amp;person)\n    &#123;\n        this-&gt;m_age &#x3D; person.m_age;\n        return *this;\n    &#125;\n&#125;;\n\nclass Student : public Person\n&#123;\npublic: \n    int m_score;\n\n    Student &amp;operator&#x3D;(const Student &amp;student)\n    &#123;\n        Person::operator&#x3D;(student);\n        this-&gt;m_score &#x3D; student.m_score;\n        return *this;\n    &#125;\n\n    void showInfo()\n    &#123;\n        cout &lt;&lt; m_age &lt;&lt; &quot; &quot; &lt;&lt; m_score &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Student s1;\n    s1.m_age &#x3D; 10;\n    s1.m_score &#x3D; 20;\n\n    Student s2 &#x3D; s1;\n    s2.showInfo();\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\demo9&gt; .\\demo5\n10 20\n\n23.3 仿函数\n定义：\n\n仿函数(functor)，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator这个类就有了类似函数的行为\n将一个对象，作为一个函数来使用\n对比普通的函数，仿函数可以保存状态\n\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Sum\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    int operator()(int a &#x3D; 0, int b &#x3D; 0)\n    &#123;\n        return a + b;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Sum s1;\n    cout &lt;&lt; s1(10, 20) &lt;&lt; endl;\n    \n    return 0;\n&#125;\n\n打印示例：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo1\n30\n\n24. 模板\n泛型：一种类型参数化以达到代码复用的技术\n种类：函数模板，类模板\n模板没有被使用，不会被实例化\n\n24.1 函数模板定义\n代码示例：函数模板, 多参数函数模板\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;\n\n    Point operator+(const Point &amp;point)\n    &#123;\n        return Point(this-&gt;m_x + point.m_x, this-&gt;m_y + point.m_y);\n    &#125;         \n&#125;;\n\nostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)\n&#123;\n    return cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;\n&#125;\n\n&#x2F;&#x2F; 函数模板\ntemplate&lt;typename T&gt;\nT add(T a, T b)\n&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 多参数函数模板\ntemplate&lt;typename T_int, typename T_double&gt;\nT_double add(T_int a, T_double b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; add&lt;int&gt;(1, 2) &lt;&lt; endl;\n    cout &lt;&lt; add&lt;int, double&gt;(1, 2.1) &lt;&lt; endl;\n    cout &lt;&lt; add&lt;Point&gt;(Point(1, 1), Point(2, 2)) &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo1\n3\n3.1\n(3, 3)\n\n24.2 函数模板分离\n编译基本过程：\n\n先把A.cpp包含的A.h的内容复制到A.cpp中(声明和实现回到同一个cpp文件中)\n再编译main.cpp和A.cpp成main.obj和A.obj\n再通过main.ilk链接main.cpp和A.cpp\n修正了main.cpp中调用A.cpp中函数时，call的函数地址\n最后生成main.exe\n\n\n代码示例：模板的错误编译\n\nadd.h\ntemplate&lt;typename T&gt;\nT add(T a, T b);\n\nadd.cpp\n#include &#39;add.h&#39;\n\nT add(T a, T b)\n&#123;\n    return a + b;\n&#125;\n\nmain.cpp\n#include &lt;iostream&gt;\n#include &#39;add.h&#39;\nusing namespace std;\n\nint main()\n&#123;\n    add(1, 2);\n    return 0;\n&#125;\n\n以上代码编译不会报错，但链接报错，不会生成.exe\n\n原因：\n\n模板没有被使用，不会被实例化\n所以add.cpp在编译过程中，编译器未发现在add.cpp中有使用add()模板函数的地方\n于是，便将add.h和add.cpp中未被使用的add()模板函数优化了(即便链接后，add()在main.cpp中被使用)\n链接后，main.cpp中调用add()函数，得不到有效的函数实现地址(此时main.cpp中是有函数声明的，因为包含了add.h)，所以会报错\n\n\n代码示例：正确的写法\n\nadd.h\ntemplate&lt;typename T&gt;\nT add(T a, T b)\n&#123;\n    return a + b;\n&#125;\n\nmain.cpp\n#include &lt;iostream&gt;\n#include &#39;add.h&#39;\nusing namespace std;\n\nint main()\n&#123;\n    add(1, 2);\n    return 0;\n&#125;\n\n写模板函数时，不要进行声明实现分离，全部写在.h中，正规的方式是.hpp\n\n\n24.3 类模板的定义\n注意：类模板中的友元函数声明\n\n需先声明类和友元函数的模板\n再实现友元函数\n且最好友元函数的模板参数和类模板的参数类型不同\n另一种方式：声明和实现中都要在&lt;&lt;后加入&lt;&gt;\nostream &amp;operator&lt;&lt; &lt;&gt;(ostream &amp;cout, const Array&lt;Arr&gt; &amp;arr);\n\n\n\n\n代码示例：\n\narray.hpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2022&#x2F;3&#x2F;9 14:06\n&#x2F;&#x2F;\n#ifndef INC_8_CPP_STRUCTURE_SEQLIST_HPP\n#define INC_8_CPP_STRUCTURE_SEQLIST_HPP\n\nusing std::cout;\nusing std::endl;\n\n#define MAXSIZE 100\n\ntemplate&lt;typename tab_T&gt;\nclass SeqList;\ntemplate&lt;typename T&gt;\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab);\n\ntemplate &lt;typename tab_T&gt;\nclass SeqList\n&#123;\nprivate:\n    tab_T *m_tabData;\n    int m_capacity;\n    int m_size;\n\npublic:\n    explicit SeqList(int capacity);\n    ~SeqList();\n\n    int size() const;\n    tab_T get(int index) const;\n    void add(tab_T value);\n    void insert(int i, tab_T value);\n    void remove(int i);\n    void removeByRange(int i, int range);\n    void replaceByValue(tab_T tagValue, tab_T newValue);\n\n    tab_T operator[](int index) const;\n    template&lt;typename T&gt;\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab);\n&#125;;\n\ntemplate&lt;typename tab_T&gt;\nSeqList&lt;tab_T&gt;::SeqList(int capacity)\n&#123;\n    m_capacity &#x3D; (capacity &gt; 0) ? capacity : MAXSIZE;\n    m_tabData &#x3D; new tab_T[m_capacity];\n    if (m_tabData &#x3D;&#x3D; nullptr)&#123;return;&#125;\n    else&#123;cout &lt;&lt; &quot;&lt;-- SeqList Created --&gt;\\n&quot;;&#125;\n    m_size &#x3D; 0;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nSeqList&lt;tab_T&gt;::~SeqList()\n&#123;\n    if (m_tabData &#x3D;&#x3D; nullptr)&#123;return;&#125;\n    else&#123;cout &lt;&lt; &quot;&lt;-- SeqList Deleted --&gt;\\n&quot;;&#125;\n    delete[] m_tabData;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nint SeqList&lt;tab_T&gt;::size() const\n&#123;\n    return m_size;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\ntab_T SeqList&lt;tab_T&gt;::get(int index) const\n&#123;\n    if (index &lt; 0 || index &gt;&#x3D; m_size)\n    &#123;\n        throw(&quot;&lt;&lt; !!! 数组下标越界 !!! &gt;&gt;&quot;);\n    &#125;\n    return m_tabData[index];\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::add(tab_T value)\n&#123;\n    if (m_size &gt;&#x3D; m_capacity)\n    &#123;\n        &#x2F;&#x2F;TODO Reset Capacity\n    &#125;\n    m_tabData[m_size] &#x3D; value;\n    ++m_size;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::insert(int i, tab_T value)\n&#123;\n    if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;\n    if (m_size &#x3D;&#x3D; MAXSIZE)&#123;return;&#125;\n\n    for (int j &#x3D; m_size - 1; j &gt;&#x3D; i - 1; --j)\n    &#123;\n        m_tabData[j + 1] &#x3D; m_tabData[j];\n    &#125;\n    m_tabData[i] &#x3D; value;\n    ++m_size;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::remove(int i)\n&#123;\n    if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;\n    \n    for (int j &#x3D; i; j &lt;&#x3D; m_size -1; ++j)\n    &#123;\n        m_tabData[j] &#x3D; m_tabData[j + 1];\n    &#125;\n    --m_size;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::removeByRange(int i, int range)\n&#123;\n     if ((i &lt; 0) || (i &gt; m_size + 1))&#123;return;&#125;\n\n     for (int j &#x3D; i; j &lt;&#x3D; m_size - 1; ++j)\n     &#123;\n         m_tabData[j] &#x3D; m_tabData[j + range];\n     &#125;\n     m_size -&#x3D; range;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\nvoid SeqList&lt;tab_T&gt;::replaceByValue(tab_T tagValue, tab_T newValue)\n&#123;\n    for (int i &#x3D; 0; i &lt; m_size; ++i)\n    &#123;\n        if (m_tabData[i] &#x3D;&#x3D; tagValue)\n        &#123;\n            m_tabData[i] &#x3D; newValue;\n        &#125;\n    &#125;\n&#125;\n\ntemplate&lt;typename tab_T&gt;\ntab_T SeqList&lt;tab_T&gt;::operator[](int index) const\n&#123;\n    return get(index);\n&#125;\n\ntemplate&lt;typename T&gt;\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;f_cout, const SeqList&lt;T&gt; &amp;tab)\n&#123;\n    int size &#x3D; tab.size();\n    f_cout &lt;&lt; &quot;[&quot;;\n    for (int i &#x3D; 0; i &lt; size; ++i)\n    &#123;\n        if (i !&#x3D; 0)&#123;f_cout &lt;&lt; &quot;,&quot;;&#125;\n        f_cout &lt;&lt; tab[i];\n    &#125;\n    return f_cout &lt;&lt; &quot;]&quot;;\n&#125;\n\n#endif &#x2F;&#x2F;INC_8_CPP_STRUCTURE_SEQLIST_HPP\n\n\n\nMain.cpp\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2022&#x2F;3&#x2F;9 14:06\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &quot;SeqList.hpp&quot;\n\nint main()\n&#123;\n    SeqList&lt;int&gt; seqList(10);\n\n    for (int i &#x3D; 0; i &lt; 10; ++i)\n    &#123;\n        seqList.add(1);\n    &#125;\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    seqList.insert(2, 9);\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    seqList.remove(2);\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    seqList.removeByRange(2, 3);\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    seqList.replaceByValue(1, 9);\n    cout &lt;&lt; seqList &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n\n\n\n\ndemo2.cpp\n#include &quot;array.hpp&quot;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point\n&#123;\nprivate:\n    int m_x;\n    int m_y;\n\npublic:\n    Point(int x &#x3D; 0, int y &#x3D; 0) : m_x(x), m_y(y)&#123;&#125;      \n\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point);\n&#125;;\n\nostream &amp;operator&lt;&lt;(ostream &amp;cout, const Point &amp;point)\n&#123;\n    return cout &lt;&lt; &quot;(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;)&quot;;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;----Array&lt;int&gt;----&quot; &lt;&lt; endl;\n    Array&lt;int&gt; array(3);\n    array.add(1);\n    array.add(2);\n    array.add(3);\n    array.add(4);\n    cout &lt;&lt; &quot;arr[0]: &quot; &lt;&lt; array.get(0) &lt;&lt; endl;\n    cout &lt;&lt; &quot;arr[1]: &quot; &lt;&lt; array[1] &lt;&lt; endl;\n    cout &lt;&lt; &quot;size: &quot; &lt;&lt; array.size() &lt;&lt; endl;\n    cout &lt;&lt; &quot;arr: &quot; &lt;&lt; array &lt;&lt; endl;\n    cout &lt;&lt; &quot;\\n&quot;;\n\n    cout &lt;&lt; &quot;----Array&lt;Point&gt;----&quot; &lt;&lt; endl;\n    Array&lt;Point&gt; arr_Point(2);\n    arr_Point.add(Point(1, 1));\n    arr_Point.add(Point(2, 2));\n    cout &lt;&lt; &quot;arr_Point: &quot; &lt;&lt; arr_Point &lt;&lt; endl;\n    cout &lt;&lt; &quot;\\n&quot;;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo10&gt; .\\demo2\n----Array&lt;int&gt;----\nsize not free\narr[0]: 1\narr[1]: 2\nsize: 3\narr: [1, 2, 3]\n\n----Array&lt;Point&gt;----\narr_Point: [(1, 1), (2, 2)]\n\n25. 其它语法-特性25.1 类型转换\nC语言风格的类型转换符\n\n(type)expression\ntype(expression)\n\n\nC++四种转换\n\nstatic_cast\n\ndynamic_cast\n\nreinterpret_cast\n\nconst_cast\n使用格式：xx_cast&lt;type&gt;(expression)\n\n\n\n\n25.1.1 const_cast\n一般用于去除const属性，将const转换成非const\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person&#123;&#125;;\n\nint main()\n&#123;\n    const Person *p1 &#x3D; new Person;\n    &#x2F;&#x2F; 两种写法完全等价\n    Person *p2 &#x3D; const_cast&lt;Person *&gt;(p1);\n    Person *p3 &#x3D; (Person *)p1;\n    \n    return 0;\n&#125;\n\n反汇编查看\n&#x2F;&#x2F; Person *p2 &#x3D; const_cast&lt;Person *&gt;(p1);\nmov eax, dword ptr[p1]\nmov dword ptr[p2], eax\n\n&#x2F;&#x2F; Person *p3 &#x3D; (Person *)p1;\nmov eax, dword ptr[p1]\nmov dword ptr[p3], eax\n\n25.1.2 dynamic_cast\n一般用于多态类型转换，有运行时的安全检测\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person\n&#123;\n    virtual void run();\n&#125;;\n\nclass Student : public Person\n&#123;&#125;;\n\nint main()\n&#123;\n    Person *p1 &#x3D; new Person;\n    Person *p2 &#x3D; new Student;\n\n    &#x2F;&#x2F; 两种写法完全等价\n    Student *s1 &#x3D; (Student *)p1; &#x2F;&#x2F; 不安全\n    Student *s1 &#x3D; dynamic_cast&lt;Student *&gt;(p1); &#x2F;&#x2F; 不安全\n    \n    Student *s2 &#x3D; dynamic_cast&lt;Student *&gt;(p2); &#x2F;&#x2F; 安全\n    \n    return 0;\n&#125;\n\n反汇编查看：\n&#x2F;&#x2F; Student *s1 &#x3D; dynamic_cast&lt;Student *&gt;(p1);\nmov eax, dword ptr[p1]\ncall __RTDynamicCast(0C14ABh)\nmov dword ptr[s1], eax\n\n25.1.3 static_cast\n对比dynamic_cast确实安全检测\n\n不能交叉转换（不是同一继承体系的，无法转换）\n\n常用于基本数据类型转换，非const转换const\n\n代码示例：交叉转换\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person&#123;&#125;;\n\nclass Car&#123;&#125;;\n\nint main()\n&#123;\n    Person *p1 &#x3D; new Person;\n    \n    &#x2F;&#x2F; 两个类之间完全没有关系，强行转化：交叉转换\n    Car *c1 &#x3D; (Car *)p1;\n    Car *c2 &#x3D; dynamic_cast&lt;Car *&gt;(p1);\n    \n    return 0;\n&#125;\n\n\n\n代码示例：非const转换const\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Person&#123;&#125;;\n\nint main()\n&#123;\n    Person *p1 &#x3D; new Person;\n    const Person *p2 &#x3D; static_cast&lt;Person *&gt;(p1);\n    \n    return 0;\n&#125;\n\n25.1.4 reinterpret_cast\n属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅只是简单的二进制数据拷贝\n\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    \n    &#x2F;&#x2F; C语言的隐式转换\n    double b &#x3D; a;\n    \n    double d &#x3D; reinterpret_cast&lt;double&amp;&gt;(a);\n    \n    return 0;\n&#125;\n\n内存分析：反汇编\nint a &#x3D; 10;\n&#x2F;&#x2F; 二进制：00001010 00000000 00000000 00000000\n&#x2F;&#x2F; 十六进制：0A 00 00 00\n&#x2F;&#x2F; 小段模式：int类型4字节，从右往左读取\n\ndouble b &#x3D; a;\n&#x2F;&#x2F; 00 00 00 00 00 00 24 40\n&#x2F;&#x2F; cvtsi2sd xmm0, dword ptr[a]\n&#x2F;&#x2F; movsd mmword ptr[d], xmm0\n\ndouble d &#x3D; reinterpret_cast&lt;double&amp;&gt;(a);\n&#x2F;&#x2F; 0A 00 00 00 cc cc cc cc\n&#x2F;&#x2F; movsd xmm0, mmword ptr[a]\n&#x2F;&#x2F; movsd mmword ptr[d], xmm0\n\n25.2 C++11特性\nauto：\n\n可以初始化表达式中推断出变量的类型，提高开发效率\n\n属于编译器特性，不影响最终的机器码质量，不影响运行效率\nauto i &#x3D; 10; &#x2F;&#x2F; int\nauto str &#x3D; &quot;c++&quot;; &#x2F;&#x2F; const char *\nauto p &#x3D; new Person; &#x2F;&#x2F; Person *\n\n\ndecltype:\n\n可以获取变量的类型\nint a &#x3D; 10;\ndecltype(a) b &#x3D; 20;\n\n\nnullptr:\n\n可以解决NULL的二义性问题\n\nNULL本质是define NULL 0\n\n在c++98中void fun(int)&#123;&#125;``void fun(int *)&#123;&#125;时会遇到二义性，在c++11之后，默认为0\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid func(int a)&#123;cout &lt;&lt; &quot;func(int): &quot; &lt;&lt; a &lt;&lt; endl;&#125;\n\nvoid func(int *a)&#123;cout &lt;&lt; &quot;func(int *): &quot; &lt;&lt; a &lt;&lt; endl;&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; func(NULL);\n    func(nullptr);\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo3\nfunc(int *): 0\n\n\n快速遍历：\nint arr[] &#x3D; &#123;&#125;;\nfor (int a : arr)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;\n\n25.3 Lambda表达式\nlambda表达式：\n本质是函数\n完整结构：[capture list] (params list) mutable exception -&gt; return type &#123;function body&#125;;\ncapture list：捕获外部变量列表\nparams list：形参列表，不能使用默认参数，不能省略参数名\nmutable：用于说明是否可以修改捕获的变量\nexception ：异常设定\nreturn type：返回值类型\nfunction body：函数体\n\n\n省略的写法：\n[capture list] (params list) -&gt; return type &#123;function body&#125;;\n[capture list] (params list)&#123;function body&#125;; \n[capture list]&#123;function body&#125;; \n\n\n\n\n\n25.3.1 lambda基本用法\n代码示例1：\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 无参，无返回值，默认调用\n    ([]\n    &#123;\n        cout &lt;&lt; &quot;func() - 1&quot; &lt;&lt; endl;\n    &#125;)();\n\n    &#x2F;&#x2F; 可以用指针存储\n    void (*p)() &#x3D; []\n    &#123;\n        cout &lt;&lt; &quot;func() - p&quot; &lt;&lt; endl;\n    &#125;;\n    p();\n\n    &#x2F;&#x2F; 直接用auto存储更方便\n    auto p1 &#x3D; []\n    &#123;\n        cout &lt;&lt; &quot;func() - p1&quot; &lt;&lt; endl;\n    &#125;;\n    p1();\n\n    &#x2F;&#x2F; 有返回值和参数\n    auto add1 &#x3D; [](int a, int b) -&gt; auto\n    &#123;\n        return a + b;\n    &#125;;\n    cout &lt;&lt; add1(1, 2) &lt;&lt; endl;\n\n    &#x2F;&#x2F; 返回值类型也可省略\n    auto add2 &#x3D; [](int a, int b)\n    &#123;\n        return a + b;\n    &#125;;\n    cout &lt;&lt; add2(2, 3) &lt;&lt; endl;\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo4\nfunc() - 1\nfunc() - p\nfunc() - p1\n3\n5\n\n\n\n代码示例2：\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid calculate(int a, int b, int (*func)(int, int))\n&#123;\n    cout &lt;&lt; func(a, b) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    calculate(1, 2, [](int a, int b)&#123;return a + b;&#125;);\n    calculate(4, 2, [](int a, int b)&#123;return a - b;&#125;);\n    calculate(8, 2, [](int a, int b)&#123;return a * b;&#125;);\n    calculate(8, 2, [](int a, int b)&#123;return a &#x2F; b;&#125;);\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo11&gt; .\\demo5\n3\n2\n16\n4\n\n25.3.2 lambda变量捕获\n代码示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n\n    auto add1 &#x3D; [a, b](int c, int d)\n    &#123;\n        cout &lt;&lt; a + b &lt;&lt; &quot;\\n&quot; &lt;&lt; c + d &lt;&lt; endl;\n    &#125;;\n    add1(1, 98);\n\n    &#x2F;&#x2F; 隐式捕获:（全捕获）\n    &#x2F;&#x2F; [&#x3D;] 值类型\n    &#x2F;&#x2F; [&amp;] 引用类型 \n    auto add2 &#x3D; [&#x3D;]\n    &#123;\n        cout &lt;&lt; a + b &lt;&lt; &quot;\\n&quot;;\n    &#125;;\n    add2();\n    \n    return 0;\n&#125;\n\n25.4 C++14特性\n泛型lambda表达式：\nauto func &#x3D; [](auto a, auto b)&#123;return a + b;&#125;;\n\n\n\n捕获的变量进行初始化\nint a &#x3D; 9;\nauto func &#x3D; [a &#x3D; 10]&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;;\nfunc(); &#x2F;&#x2F;打印结果：10\n\ncout &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; 打印结果：9\n\n25.5 C++17特性\n可以进行初始化的if和switch语句\n\n代码示例：if，else if\nif (int a &#x3D; 10; a &gt; 0)\n&#123;\n    cout &lt;&lt; a &lt;&lt; endl;\n&#125;\n\n\n\n代码示例：switch\nswitch(int a &#x3D; 1; a)\n&#123;\n    case 0:\n        break;\n    case 1:\n        break;\n    default:\n        break;\n&#125;\n\n26. 异常26.1 异常基本用法\n编程过程中常见的错误：\n\n语法错误\n逻辑错误\n异常\n\n\n异常：一种程序运行过程中可能会发生的错误\n\n每次异常可能类型不同，不能确定\n异常没有处理，程序会直接中断或崩溃等等\n\n\n异常处理过程：\n\nthrow异常后，会在当前函数中查找匹配的catch\n找不到就会终止当前的函数代码，去上一层函数中查找\n如果都找不到，程序直接终止\n\n\n代码示例1：简单的异常演示\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int i &#x3D; 0;\n    for (i ; i &lt; 99999; ++i)\n    &#123;\n        try\n        &#123;\n            int *p &#x3D; new int[999999];\n        &#125;\n        catch(...)\n        &#123;\n            cout &lt;&lt; &quot;for loop &quot; &lt;&lt; i &lt;&lt; &quot; error!&quot; &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;\n\n打印结果：多次打印（每次的异常结果可能不同）\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1\nfor loop 6176 error!\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1\nfor loop 6180 error!\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo1\nfor loop 6182 error!\n\n\n\n\n\n代码示例2：主动抛出异常\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid divide(int a, int b)\n&#123;\n    if (b &#x3D;&#x3D; 0)\n    &#123;\n        throw 0;\n    &#125;\n    cout &lt;&lt; a &#x2F; b &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    try\n    &#123;\n        divide(10, 1);\n        divide(10, 0);\n        divide(10, 2);\n    &#125;\n    catch(const int exc)\n    &#123;\n        cout &lt;&lt; &quot;Divide Error &quot; &lt;&lt; exc &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo2\n10\nDivide Error 0\n\n总结：throw后面的类型，要和catch里面接受的类型保持一致\n\n代码示例3：异常处理过程\n\n没有catch\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid func1()\n&#123;\n    cout &lt;&lt; &quot;func1()-begin&quot; &lt;&lt; endl;\n    throw 0; &#x2F;&#x2F; 抛出异常，func1()中没有catch，向上层函数func2()中找\n    cout &lt;&lt; &quot;func1()-end&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2()\n&#123;\n    cout &lt;&lt; &quot;func2()-begin&quot; &lt;&lt; endl;\n    func1(); &#x2F;&#x2F; throw 来到func2()，也没有发现catch，继续向上到main()\n    cout &lt;&lt; &quot;func2()-end&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;main()-begin&quot; &lt;&lt; endl;\n    func2(); &#x2F;&#x2F; throw来到main()中，依然没有发现catch，此时程序终止\n    cout &lt;&lt; &quot;main()-end&quot; &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo3\nmain()-begin\nfunc2()-begin\nfunc1()-begin\n\n\n\n有catch\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid func1()\n&#123;\n    cout &lt;&lt; &quot;func1()-begin&quot; &lt;&lt; endl;\n    try\n    &#123;\n        throw 0;\n    &#125;\n    catch(int exc)\n    &#123;\n        cout &lt;&lt; &quot;Error &quot; &lt;&lt; exc &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    \n    cout &lt;&lt; &quot;func1()-end&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2()\n&#123;\n    cout &lt;&lt; &quot;func2()-begin&quot; &lt;&lt; endl;\n    func1();\n    cout &lt;&lt; &quot;func2()-end&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;main()-begin&quot; &lt;&lt; endl;\n    func2();\n    cout &lt;&lt; &quot;main()-end&quot; &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo3\nmain()-begin\nfunc2()-begin\nfunc1()-begin\nError 0\nfunc1()-end\nfunc2()-end\nmain()-end\n\n26.2 异常抛出声明\n为了增强可读性和方便团队协作，函数内部抛出异常，建议函数声明一下函数类型\n\n代码示例：\nvoid func1() throw()&#123;&#125; &#x2F;&#x2F; 不抛出异常\nvoid func2() throw(int, double)&#123;&#125; &#x2F;&#x2F; 可能抛出 int，double 类型的异常\n\n26.3 自定义异常类型\n代码示例1：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Exception\n&#123;\npublic:    \n    virtual const char *what() &#x3D; 0;\n&#125;;\n\nclass DivideException : public Exception\n&#123;\npublic:    \n    const char *what()&#123;return &quot;Divide Error&quot;;&#125;\n&#125;;\n\nvoid divide(int a, int b)\n&#123;\n    if (b &#x3D;&#x3D; 0)&#123;throw DivideException();&#125;\n    cout &lt;&lt; a &#x2F; b &lt;&lt; &quot;\\n&quot;;\n&#125;\n\nint main()\n&#123;\n    try\n    &#123;\n        divide(10, 0);\n    &#125;\n    catch(DivideException e)\n    &#123;\n        cout &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo4\nDivide Error\n\n\n\n\n\n代码示例2：\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Exception\n&#123;\npublic:    \n    virtual const char *what() const &#x3D; 0;\n&#125;;\n\nclass DivideException : public Exception\n&#123;\npublic:    \n    const char *what() const&#123;return &quot;Divide Error&quot;;&#125;\n&#125;;\n\nvoid divide(int a, int b)\n&#123;\n    if (b &#x3D;&#x3D; 0)&#123;throw DivideException();&#125;\n    cout &lt;&lt; a &#x2F; b &lt;&lt; &quot;\\n&quot;;\n&#125;\n\nint main()\n&#123;\n    try\n    &#123;\n        divide(10, 0);\n    &#125;\n    catch(const Exception &amp;e)\n    &#123;\n        cout &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    \n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo12&gt; .\\demo4\nDivide Error\n\n27. 智能指针\n目的：改善传统指针存在的问题\n\n传统指针存在的问题：\n\n需要手动管理内存\n容易发生内存泄漏\n忘记释放\n出现抛出异常\n\n\n释放后会变成野指针\n\n\n智能指针的作用：\n\nauto_ptr：C++98，存在缺陷，不能用于数组\nshared_ptr：C++11\nunique_ptr：C++11\n\n\n\n27.1 智能指针基本使用\n代码示例：\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nclass Person\n&#123;\nprivate:\n    int m_age;\n\npublic:\n    Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;        \n\n    void run()&#123;cout &lt;&lt; &quot;Person::run() &quot; &lt;&lt; m_age &lt;&lt; endl;&#125;\n&#125;;\n\nvoid test1()\n&#123;\n    shared_ptr&lt;Person&gt; p(new Person(10));\n    p-&gt;run();\n&#125;\n\nint main()\n&#123;\n    test1();\n    \n    return 0;\n&#125;\n\n打印结果：\n  PS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo1\n  Person::Person(int)\n  Person::run() 10\n  Person::~Person()\n\n\n\n\n\n#### 27.2 自定义智能指针\n\n\n\n- 代码示例：\n\n  &#96;&#96;&#96;c++\n  #include &lt;iostream&gt;\n  using namespace std;\n  \n  template&lt;typename class_T&gt;\n  class fh_ptr\n  &#123;\n  private:\n      class_T *obj_ptr;\n  \n  public:\n      fh_ptr(class_T *ptr) : obj_ptr(ptr)&#123;&#125;\n      ~fh_ptr()\n      &#123;\n          if (obj_ptr &#x3D;&#x3D; nullptr)&#123;return;&#125;\n          delete obj_ptr;\n          obj_ptr &#x3D; nullptr;\n      &#125;    \n  \n      class_T *operator-&gt;()&#123;return obj_ptr;&#125;\n  &#125;;\n  \n  class Person\n  &#123;\n  private:\n      int m_age;\n  \n  public:\n      Person(int age) : m_age(age)&#123;cout &lt;&lt; &quot;Person::Person(int)&quot; &lt;&lt; endl;&#125;\n      ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;&#125;        \n  \n      void run()&#123;cout &lt;&lt; &quot;Person::run() &quot; &lt;&lt; m_age &lt;&lt; endl;&#125;\n  &#125;;\n  \n  void test1()\n  &#123;\n      fh_ptr&lt;Person&gt; p(new Person(10));\n      p-&gt;run();\n  &#125;\n  \n  int main()\n  &#123;\n      test1();\n      \n      return 0;\n  &#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo2\nPerson::Person(int)\nPerson::run() 10\nPerson::~Person()\n\n27.3 shared_ptr27.3.1 shared_ptr原理\n一个shared_ptr会对一个对象产生强引用\n每个对象都会有一个对应的强引用计数，记录着当前的对象被多少shared_ptr强引用\n可以通过shared_ptr的use_count函数获得强引用计数\n\n\n当有一个新的shared_ptr指向对象时，对象的强引用计数会加1\n当一个shared_ptr销毁时，对象的强引用计数减1\n当一个对象的强引用计数为0时，对象就会自动销毁\n\n27.3.2 shared_ptr循环引用27.3.2.1 演示循环引用问题\n循环引用的问题：\n\nshared_ptr是强引用智能指针\n\n发生两个类的对象相互引用，产生循环引用\n\n循环引用会产生栈空间的智能指针对象销毁后，指向堆区的对象不会被销毁\n\n\n\n代码示例：演示循环引用的问题\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nclass Person;\n\nclass Car\n&#123;\npublic:\n    shared_ptr&lt;Person&gt; m_person;\n    Car()&#123;cout &lt;&lt; &quot;Car::Car()\\n&quot;;&#125;\n    ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()\\n&quot;;&#125;\n&#125;;\n\nclass Person\n&#123;\npublic:\n    shared_ptr&lt;Car&gt; m_car;\n    Person()&#123;cout &lt;&lt; &quot;Person::Person()\\n&quot;;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()\\n&quot;;&#125;\n&#125;;\n\nvoid test()\n&#123;\n    shared_ptr&lt;Person&gt; person(new Person);\n    shared_ptr&lt;Car&gt; car(new Car);\n\n    person-&gt;m_car &#x3D; car;\n    car-&gt;m_person &#x3D; person;\n&#125;\n\nint main()\n&#123;\n    test();\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo3\nPerson::Person()\nCar::Car()\n\n27.3.2.2 解决循环引用问题\nweak_ptr\n\n会对对象产生弱引用\n解决shared_ptr的循环引用问题\n\n\n代码示例：解决循环引用问题\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nclass Person;\n\nclass Car\n&#123;\npublic:\n    &#x2F;&#x2F; 只需要其中一个 是 弱引用 即可\n    weak_ptr&lt;Person&gt; m_person;\n    Car()&#123;cout &lt;&lt; &quot;Car::Car()\\n&quot;;&#125;\n    ~Car()&#123;cout &lt;&lt; &quot;Car::~Car()\\n&quot;;&#125;\n&#125;;\n\nclass Person\n&#123;\npublic:\n    shared_ptr&lt;Car&gt; m_car;\n    Person()&#123;cout &lt;&lt; &quot;Person::Person()\\n&quot;;&#125;\n    ~Person()&#123;cout &lt;&lt; &quot;Person::~Person()\\n&quot;;&#125;\n&#125;;\n\nvoid test()\n&#123;\n    shared_ptr&lt;Person&gt; person(new Person);\n    shared_ptr&lt;Car&gt; car(new Car);\n\n    person-&gt;m_car &#x3D; car;\n    car-&gt;m_person &#x3D; person;\n&#125;\n\nint main()\n&#123;\n    test();\n\n    return 0;\n&#125;\n\n打印结果：\nPS C:\\Users\\Admin\\Desktop\\Project\\Demo13&gt; .\\demo3\nPerson::Person()\nCar::Car()\nPerson::~Person()\nCar::~Car()\n\n27.4 unique_ptr\n同样是强引用，但可以确保同一时间只有一个指针指向对象\n\n当unique销毁时，指向的对象也就自动销毁\n\n使用std::move函数转移unqiue_ptr的所有权\nunique_ptr&lt;A&gt; a1;\nunique_ptr&lt;A&gt; a2(new A);\na1 &#x3D; std::move(a2)\n\n","slug":"1_C++_面向对象反汇编补充_08","date":"2022-10-06T07:28:25.917Z","categories_index":"编程","tags_index":"Assemly,C/C++","author_index":"FangH"},{"id":"c90c4a4848e304bff822a98a4aa17a84","title":"C++_基础","content":"C++_基础1. 第一阶段1. HelloWorld#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tcout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;\n&#125;\n\n\n\n2. 变量#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n    int a &#x3D; 10;\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n&#125;\n\n\n\n3. 常量定义常量的两张方法：\n\n#define 宏常量\n通常在文件的上方定义\n\nconst 修饰的变量\n通常在变量定义前加关键字const\n\n\n常量定义后，不可被修改\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n#define Day 7 &#x2F;&#x2F; #define 常量名 常量值\n\nint main()\n&#123;\n\tconst int Month &#x3D; 12; &#x2F;&#x2F; const 常量类型 常量名 &#x3D; 常量值\n\n\tcout &lt;&lt; &quot;One Week have &quot; &lt;&lt; Day &lt;&lt; &quot; day&quot; &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;One Year have &quot; &lt;&lt; Month &lt;&lt; &quot; month&quot; &lt;&lt; endl;\n\n&#125;\n\n\n\n4. 标识符命名规则\n标识符不能是关键字\n标识符只能是字母、数字、下划线组成\n标识符第一个字符必须是下划线或字母\n标识符区分大小写\n\n2. 数据类型1. 整型\n\n\n数据类型\n占用空间\n取值范围\n\n\n\nshort（短整型）\n2字节\n（-2^15 - 2^15-1）\n\n\nint（整型）\n4字节\n（-2^31 - 2^31-1）\n\n\nlong（长整型）\nwindows为4字节，Linux为4字节（32位），8字节（64位）\n（-2^31 - 2^31-1）\n\n\nlong long（长长整型）\n8字节\n（-2^63 - 2^63-1）\n\n\n2. sizeof 关键字\n作用：统计数据类型所占内存的大小\n语法：sizeof(数据类型/变量)\n\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tcout &lt;&lt; &quot;short Size is &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;int Size is &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;long Size is &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;long long Size is &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;\n&#125;\n\n\n\n2.1 sizeof补充\nsizeof()是编译器的一种特性，并非函数，只是用起来像，在C++编译转汇编时，编译器会自动将sizeof()的正确的值写在汇编中\n\n3. 浮点型\n\n\n数据类型\n占用空间\n有效数字范围\n\n\n\nfloat\n4字节\n7位有效数字\n\n\ndouble\n8字节\n15 - 16位有效数字\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;默认情况下显示6位有效数字\n\tfloat f1 &#x3D; 3.1415926f;\n\n\tdouble d1 &#x3D; 3.1415926;\n\n\tcout &lt;&lt; &quot;float f1 : &quot; &lt;&lt; f1 &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;double d1 : &quot; &lt;&lt; d1 &lt;&lt; endl;\n\n\t&#x2F;&#x2F;统计float和double占用的空间\n\tcout &lt;&lt; &quot;float size : &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;double size : &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;\n\n\t&#x2F;&#x2F;科学计数法\n\n\t&#x2F;&#x2F;3e2 : 3 * 10 ^2\n\tfloat f2 &#x3D; 3e2;\n\tcout &lt;&lt; &quot;float f2 : &quot; &lt;&lt; f2 &lt;&lt; endl;\n\n\t&#x2F;&#x2F;3e2 : 3 * 0.1 ^2\n\tfloat f3 &#x3D; 3e-2;\n\tcout &lt;&lt; &quot;float f3 : &quot; &lt;&lt; f3 &lt;&lt; endl;\n&#125;\n\n\n\n4. 字符型\n作用：显示单个字符\n语法：char 变量名 = &#39;变量值&#39;\n注意：char定义的变量只能用单引号；只能有一个字符\n占用：char占用1个字节；将字符对应的ASCII码放入存储单元\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;定义char\n\tchar c1 &#x3D; &#39;a&#39;;\n\n\t&#x2F;&#x2F;查看char占用的大小\n\tcout &lt;&lt; &quot;Char c1 size : &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;\n\n\t&#x2F;&#x2F;查看 &#39;a&#39; 对应的ASCII码\n\tcout &lt;&lt; &quot;Char a by ASCII : &quot; &lt;&lt; int(c1) &lt;&lt; endl;\n&#125;\n\n\nASCII：\t\n0 - 31 分配个控制字符\n32 - 126 分配个键盘上能找到的字符\n\n\n5. 转义字符#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tcout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F; \\n 是换行\n\tcout &lt;&lt; &quot;hello world\\n&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; \\\\ 是反斜杠\n\tcout &lt;&lt; &quot;hello world\\\\&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; \\t 是水平制表（换行对齐）\n\tcout &lt;&lt; &quot;hello world\\t&quot; &lt;&lt; endl;\n\n&#125;\n\n\n\n6. 字符串类型#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tstring s1 &#x3D; &quot;abc&quot;;\n\tcout &lt;&lt; &quot;string s1 : &quot; &lt;&lt; s1 &lt;&lt; endl;\n&#125;\n\n\n\n7. 布尔类型#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;true &#x3D; 1; false &#x3D; 0;\n\tbool b1 &#x3D; true;\n\tbool b2 &#x3D; false;\n\n\tcout &lt;&lt; &quot;Bool b1 : &quot; &lt;&lt; b1 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Bool b2 : &quot; &lt;&lt; b2 &lt;&lt; endl;\n\n\t&#x2F;&#x2F;计算bool类占用的大小\n\tcout &lt;&lt; &quot;Bool size is : &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl;\n&#125;\n\n\n\n8.数据的输入\n\n作用：获取从键盘中输入的值\n关键字：cin\n语法：cin &gt;&gt; 变量\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;int\n\tint a;\n\tcout &lt;&lt; &quot;Please enter num : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; a;\n\tcout &lt;&lt; &quot;Your enter num : &quot; &lt;&lt; a &lt;&lt; endl;\n\n\t&#x2F;&#x2F;string\n\tstring b;\n\tcout &lt;&lt; &quot;Please enter string : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; b;\n\tcout &lt;&lt; &quot;Your enter string : &quot; &lt;&lt; b &lt;&lt; endl;\n\n\t&#x2F;&#x2F;float or double\n\tfloat c;\n\tdouble d;\n\tcout &lt;&lt; &quot;Please enter floatNum : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; c;\n\tcout &lt;&lt; &quot;Your enter floatNum : &quot; &lt;&lt; c &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;Please enter doubleNum : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; d;\n\tcout &lt;&lt; &quot;Your enter doubleNum : &quot; &lt;&lt; d &lt;&lt; endl;\n\n\t&#x2F;&#x2F;bool\n\tbool bl1; \n\tcout &lt;&lt; &quot;Please enter boolVlaue bl1 : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; bl1;\n\tcout &lt;&lt; &quot;Your enter boolValue : &quot; &lt;&lt; bl1 &lt;&lt; endl;\n\t\n\t&#x2F;&#x2F;bool类型 除了0，其他都为真&#x3D;1\n&#125;\n\n\n\n9. 自增自减的区别#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;前置++ 或 前置--\n\tint i1 &#x3D; 10;\n\tint j1;\n\tcout &lt;&lt; &quot;i1 &#x3D; &quot; &lt;&lt; i1 &lt;&lt; endl;\n\n\tj1 &#x3D; ++i1 * 10;\n\tcout &lt;&lt; &quot;++i1 * 10 &#x3D; &quot; &lt;&lt; j1 &lt;&lt; endl;\n\n\tj1 &#x3D; --i1 * 10;\n\tcout &lt;&lt; &quot;--i1 * 10 &#x3D; &quot; &lt;&lt; j1 &lt;&lt; endl;\n\n\t&#x2F;&#x2F;后置++ 或 后置--\n\tint i2 &#x3D; 10;\n\tint j2;\n\tcout &lt;&lt; &quot;i2 &#x3D; &quot; &lt;&lt; i1 &lt;&lt; endl;\n\n\tj2 &#x3D; ++i2 * 10;\n\tcout &lt;&lt; &quot;++i2 * 10 &#x3D; &quot; &lt;&lt; j2 &lt;&lt; endl;\n\n\tj2 &#x3D; --i2 * 10;\n\tcout &lt;&lt; &quot;--i2 * 10 &#x3D; &quot; &lt;&lt; j2 &lt;&lt; endl;\n\n\t&#x2F;&#x2F;后置与前置的区别\n\tint a1 &#x3D; 10;\n\tint b1 &#x3D; ++a1 * 10; &#x2F;&#x2F;a1此时先+1为11\n\tcout &lt;&lt; &quot;a1 &#x3D; &quot; &lt;&lt; a1 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b1 &#x3D; &quot; &lt;&lt; b1 &lt;&lt; endl;\n\n\tint a2 &#x3D; 10;\n\tint b2 &#x3D; a2++ * 10; &#x2F;&#x2F;a2此时仍为10,b2计算完后，a2+1 为11\n\tcout &lt;&lt; &quot;a2 &#x3D; &quot; &lt;&lt; a2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b2 &#x3D; &quot; &lt;&lt; b2 &lt;&lt; endl;\n&#125;\n\n\n\n10. 逻辑运算符\n\n\n运算符\n术语\n示例\n结果\n\n\n\n！\n非\n！a\na为假，则 !a 为真\n\n\n&amp;&amp;\n与\na &amp;&amp; b\n有假则假，全真为真\n\n\n||\n或\na || b\n有真则真，全假为假\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint a &#x3D; 1;\n\tint b &#x3D; 0;\n\tint c &#x3D; 1;\n\tint d &#x3D; 0;\n\n\t&#x2F;&#x2F;逻辑非\n\tcout &lt;&lt; &quot;!a &#x3D; &quot; &lt;&lt; !a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;!!a &#x3D; &quot; &lt;&lt; !!a &lt;&lt; endl;\n\n\t&#x2F;&#x2F;逻辑与\n\tcout &lt;&lt; &quot;a &amp;&amp; b &#x3D; &quot; &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;a &amp;&amp; c &#x3D; &quot; &lt;&lt; (a &amp;&amp; c) &lt;&lt; endl;\n\n\t&#x2F;&#x2F;逻辑或\n\tcout &lt;&lt; &quot;a || b &#x3D; &quot; &lt;&lt; (a || b) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;a || c &#x3D; &quot; &lt;&lt; (a || c) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b || d &#x3D; &quot; &lt;&lt; (b || d) &lt;&lt; endl;\n&#125;\n\n\n\n\n\n3. 程序流程结构三种基本结构： 顺序结构，选择结构，循环结构\n\n顺序结构：程序按顺序执行，不发生跳转\n选择结构：依据条件是否满足，有选择的执行相应功能\n循环结构：依据条件是否满足，循环多次执行某段代码\n\n1. 选择结构1.1 if 语句#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint enterValue;\n\n\tcout &lt;&lt; &quot;Please enter value : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; enterValue;\n\n\tcout &lt;&lt; &quot;Your enter value is : &quot; &lt;&lt; enterValue &lt;&lt; endl;\n\n\tif (enterValue &gt;&#x3D; 650)\n\t&#123;\n\t\tcout &lt;&lt; &quot;You are so good !&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;You can do it !&quot; &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n\n\n1.2 多条件if语句#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint value;\n\n\tcout &lt;&lt; &quot;Please enter value : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; value;\n\n\tcout &lt;&lt; &quot;Your enter value is : &quot; &lt;&lt; value &lt;&lt; endl;\n\n\tif (value &gt;&#x3D; 650)\n\t&#123;\n\t\tcout &lt;&lt; &quot;You are A !&quot; &lt;&lt; endl;\n\t&#125;\n\telse if (value &gt;&#x3D; 550)\n\t&#123;\n\t\tcout &lt;&lt; &quot;You are B !&quot; &lt;&lt; endl;\n\t&#125;\n\telse if (value &gt;&#x3D; 450)\n\t&#123;\n\t\tcout &lt;&lt; &quot;You are C !&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;You are D !&quot; &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n\n\n1.3 嵌套if语句#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint value;\n\n\tcout &lt;&lt; &quot;Please enter value : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; value;\n\n\tcout &lt;&lt; &quot;Your enter value is : &quot; &lt;&lt; value &lt;&lt; endl;\n\n\tif (value &gt;&#x3D; 650)\n\t&#123;\n\t\tif (value &gt;&#x3D; 750)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;You are S !&quot; &lt;&lt; endl;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;You are A !&quot; &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\telse if (value &gt;&#x3D; 450)\n\t&#123;\n\t\tcout &lt;&lt; &quot;You are C !&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;You are D !&quot; &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n\n\n1.4 案列\n分别给a，b，c三个赋int值；判断最大的值，并打印\n\n#include &lt;iostream&gt;;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint a, b, c;\n\n\tcout &lt;&lt; &quot;Please enter a value : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; a;\n\n\tcout &lt;&lt; &quot;Please enter b value : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; b;\n\n\tcout &lt;&lt; &quot;Please enter c value : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; c;\n\n\tcout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;\n\n\tif (a &gt; b) &#x2F;&#x2F;如果a 比 b 大，则 a 继续与 c 比较\n\t&#123;\n\t\tif (a &gt; c) &#x2F;&#x2F;如果a 比 c 大，则 a 最大\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Max value is a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\t\t&#125;\n\t\telse &#x2F;&#x2F;否则 c 最大\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Max value is c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\telse &#x2F;&#x2F;如果b 比 a 大，则 b 继续与 c 比较\n\t&#123;\n\t\tif (b &gt; c) &#x2F;&#x2F;如果b 比 c 大，则 b 最大\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Max value is b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\t\t&#125;\n\t\telse &#x2F;&#x2F;否则 c 最大\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Max value is c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n1.5 三目运算符\n作用：通过三目运算符实现简单的判断\n语法：表达式a ？表达式b ：表达式c\n解释：\na为真，执行b，并返回b的结果；\na为假，执行c，并返回c的结果；\n\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint a &#x3D; 10, b &#x3D; 20;\n\tint c;\n\t\n\tc &#x3D; (a &gt; b ? a : b);\n\tcout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\t&#x2F;&#x2F;三目运算符表达式返回的是 变量，所以可以直接作为左值被赋值；\n\t(a &lt; b ? a : b) &#x3D; 100;\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n &#125;\n\n\n\n1.6 switch语句\n语法：\n\nswitch (表达式)\n&#123;\n    case 结果1:\n    执行语句;\n    break；\n    case 结果1:\n    执行语句;\n    break；\n    ...\n    default:\n    执行语句;\n    break；\n&#125;\n\n\n注意：\nswitch语句的表达式类型只能是整型或字符型；\ncase后没有break语句，程序会一直向下执行；\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint value;\n\n\tcout &lt;&lt; &quot;Enter int value : &quot; &lt;&lt; endl;\n\tcin &gt;&gt; value;\n\n\tswitch (value)\n\t&#123;\n\tcase 10:\n\t\tcout &lt;&lt; &quot;Return S&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 9:\n\t\tcout &lt;&lt; &quot;Return A&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 8:\n\t\tcout &lt;&lt; &quot;Return A&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 7:\n\t\tcout &lt;&lt; &quot;Return B&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 6:\n\t\tcout &lt;&lt; &quot;Return B&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 5:\n\t\tcout &lt;&lt; &quot;Return C&quot; &lt;&lt; endl;\n\t\tbreak;\n\tcase 4:\n\t\tcout &lt;&lt; &quot;Return C&quot; &lt;&lt; endl;\n\t\tbreak;\n\tdefault:\n\t\tcout &lt;&lt; &quot;Return D&quot; &lt;&lt; endl;\n\t\tbreak;\n\t&#125;\n&#125;\n\n\n\n\n\n2. 循环结构2.1 while循环\n作用：满足判断条件，执行循环语句\n\n语法：\nwhile (判断条件)\n&#123;\n\t循环语句;\n&#125;\n\n案列：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint num &#x3D; 0;\n\n\twhile (num &lt; 10)\n\t&#123;\n\t\tcout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;\n\t\tnum++;\n\t&#125;\n&#125;\n\n\n2.2 while案列\n随机生成 1 - 100 的数字，控制台输入数字，正确结束，错误则判断过大还是过小，直到正确为止（限定判断10次）。\n#include &lt;iostream&gt;\n#include &lt;time.h&gt; &#x2F;&#x2F;使用随机种子需要添加的头文件\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint randNum;\n\tint enterNum;\n\tint countNum &#x3D; 0;\n\n\t&#x2F;&#x2F;通过系统实时的时间作为当前随机数的随机种子\n\tsrand((unsigned int)time(NULL));\n\n\t&#x2F;&#x2F;此时的randNum为真随机\n\trandNum &#x3D; rand() % 100 + 1;\n\n\t&#x2F;&#x2F;每循环一次 countNum 加 1 ；为真继续执行，为假直接结束\n\twhile (countNum &lt; 10) \n\t&#123;\n\t\t&#x2F;&#x2F;显示当前执行的次数\n\t\tcout &lt;&lt; &quot;******** &quot; &lt;&lt; countNum + 1 &lt;&lt; &quot; ********&quot; &lt;&lt; endl; \n\n\t\tcout &lt;&lt; &quot;Enter Num : &quot;;\n\t\tcin &gt;&gt; enterNum;\n\n\t\tif (enterNum &gt; randNum)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;enter num is to big !\\n&quot; &lt;&lt; endl;\n\t\t\tcountNum++; &#x2F;&#x2F;只要enterNum !&#x3D; randNum 则 countNum 加 1\n\t\t&#125;\n\t\telse if (enterNum &lt; randNum)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;enter num is to small !\\n&quot; &lt;&lt; endl;\n\t\t\tcountNum++;\n\t\t&#125;\n\t\telse \n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;enter num is true !&quot; &lt;&lt; endl;\n\t\t\tbreak; &#x2F;&#x2F;enterNum &#x3D;&#x3D; randNum 则 结束\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; &quot;\\nTrue num is : &quot; &lt;&lt; randNum &lt;&lt; endl; &#x2F;&#x2F;while 结束后 显示正确的随机数值\n&#125;\n\n2.3 do…while 语句\n作用：先执行循环语句，再满足判断条件，执行循环语句\n\n注意：do…while 与 while的区别在于，do…while 先执行一次循环语句，再判断条件是否满足继续执行\n\n语法：\ndo\n&#123;\n    循环语句;\n&#125;while (循环条件);\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint num &#x3D; 0;\n\n\tdo\n\t&#123;\n\t\tcout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;\n\t\tnum++;\n\t&#125; while (num &lt; 10);\n&#125;\n\n\n2.4 水仙花案列\n说明：一个三位的整数满足每一位的三次方的和依旧等于这个三位数 （do … while）\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint dNum &#x3D; 100; &#x2F;&#x2F;最小的三位数\n\n\tdo\n\t&#123;\n\t\tdouble a, b, c, d; &#x2F;&#x2F; a为百位，b为十位，c为个位，d为 a b c三次方的和\n\n\t\t&#x2F;&#x2F;pow(x, y) &#x3D;&#x3D; x 的 y 次方\n\t\ta &#x3D; pow(dNum &#x2F; 100, 3);\n\t\tb &#x3D; pow(dNum &#x2F; 10 % 10, 3);\n\t\tc &#x3D; pow(dNum % 10, 3);\n\t\td &#x3D; a + b + c;\n\n\t\t&#x2F;&#x2F;判断当前的三位数是不是水仙花数\n\t\tif (d &#x3D;&#x3D; dNum)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;条件为真时 打印水仙花数\n\t\t\tcout &lt;&lt; dNum &lt;&lt; endl;\n\t\t&#125;\n\t\tdNum++; &#x2F;&#x2F;每当while条件满足都执行一遍\n\t&#125; while (dNum &lt; 1000); &#x2F;&#x2F;判断当前是否是三位数\n&#125;\n\n2.5 for 循环\n作用：满足条件，执行语句\n\n语法：\nfor (起始表达式; 循环条件; 循环体)\n&#123;\n\t循环语句;\n&#125;\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tcout &lt;&lt; i &lt;&lt; endl;\n\t&#125;\n&#125;\n\n2.6 for 循环案列\n说明：1 - 100 的区间数字，满足 各位 或 十位 或 倍数 与 7 有关，打印 yes，其余直接打印数字；\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#x2F;&#x2F;循环打印 1 - 100 \n\t&#123;\n\t\t&#x2F;&#x2F;判断遍历的数字是否满足条件\n\t\tif (i % 10 &#x3D;&#x3D; 7 || i &#x2F; 10 % 10 &#x3D;&#x3D; 7 || i % 7 &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#x2F;&#x2F;满足调件打印 yes\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tcout &lt;&lt; i &lt;&lt; endl; &#x2F;&#x2F;不满足条件打印 原数字\n\t\t&#125;\n\t&#125;\n&#125;\n\n2.7 嵌套循环\n作用：在循环语句内再添加循环，解决实际问题\n\n描述：打印 10*10 的矩阵\n #include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; 10; j++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;* &quot;;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n&#125;\n\n2.8 乘法表案列\n描述：打印乘法表\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tfor (int h &#x3D; 1; h &lt;&#x3D; 9; h++) &#x2F;&#x2F;行数\n\t&#123;\n\t\tfor (int v &#x3D; 1; v &lt;&#x3D; h; v++) &#x2F;&#x2F;列数，但不超过行数\n\t\t&#123;\n\t\t\tcout &lt;&lt; v &lt;&lt; &quot; * &quot; &lt;&lt; h &lt;&lt; &quot;\t&quot;; &#x2F;&#x2F;结果为 列数*行数&#x3D;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n&#125;\n\n3. 跳转语句3.1 break语句\n作用：用于跳出选择结构或者循环结构\n使用：\n出现在switch语句中，终止case并跳出switch；\n出现在循环语句中，跳出循环；\n出现在嵌套循环中，跳出内层循环；\n\n\n\n3.2 continue语句\n作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一循环\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;从1 -100 遍历100次\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 100; i++)\n\t&#123;\n\t\t&#x2F;&#x2F;如果i 为偶数，则跳过当前循环，执行下一次遍历\n\t\tif (i % 2 &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tcout &lt;&lt; i &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n\n3.3 goto语句\n作用：无条件跳转语句\n语法：goto 标记;\n解释：程序执行到goto时，如果标记存在，怎直接跳转到标记处，并继续执行\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tcout &lt;&lt; &quot;S&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;A&quot; &lt;&lt; endl;\n\n\tgoto GotoTarget; &#x2F;&#x2F;此处的 goto 语句标记为 GotoTarget\n\n\tcout &lt;&lt; &quot;B&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;C&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;D&quot; &lt;&lt; endl;\n\n\tGotoTarget: &#x2F;&#x2F;程序直接跳转至此处，并继续向下执行\n\tcout &lt;&lt; &quot;E&quot; &lt;&lt; endl;\n&#125;\n\n\n\n\n\n4. 数组解释：数组就是相同类型数据的元素集合\n特点：\n\n元素类型相同\n数组由连续的内存位置组成\n\n注意：\n\n数组的命名不要和其他变量名重名\n数组的索引从下标0开始\n\n1. 一维数组1.1 一维数组的定义\n数据类型 数组名[数组长度];\n\n数据类型 数组名[数组长度] &#x3D; {元素1，元素2，…..};\n\n数据类型 数组名[] &#x3D; {元素1，元素2，…..};\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;1. 数据类型 数组名[数组长度];\n\tcout &lt;&lt; &quot;数据类型 数组名[数组长度]&quot; &lt;&lt; endl;\n\n\tint arr1[3];\n\tarr1[0] &#x3D; 1;\n\tarr1[1] &#x3D; 2;\n\tarr1[2] &#x3D; 3;\n\t\n\tfor (int i &#x3D; 0; i &lt; 3; i++)\n\t&#123;\n\t\tcout &lt;&lt; arr1[i] &lt;&lt; &quot;  &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;2. 数据类型 数组名[数组长度] &#x3D; &#123;元素1，元素2，.....&#125;;\n\tcout &lt;&lt; &quot;数据类型 数组名[数组长度] &#x3D; &#123;元素1，元素2，.....&#125;&quot; &lt;&lt; endl;\n\n\tint arr2[3] &#x3D; &#123; 1, 2, 4 &#125;;\n\t\n\tfor (int j &#x3D; 0; j &lt; 3; j++)\n\t&#123;\n\t\tcout &lt;&lt; arr2[j] &lt;&lt; &quot;  &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;3. 数据类型 数组名[] &#x3D; &#123;元素1，元素2，.....&#125;;\n\tcout &lt;&lt; &quot;数据类型 数组名[] &#x3D; &#123;元素1，元素2，.....&#125;&quot; &lt;&lt; endl;\n\n\tint arr3[] &#x3D; &#123;1, 2, 3&#125;;\n\n\tfor (int k &#x3D; 0; k &lt; 3; k++)\n\t&#123;\n\t\tcout &lt;&lt; arr1[k] &lt;&lt; &quot;  &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\n1.2 一维数组名作用作用：\n\n可以统计整个数组在内存中的长度\n\n可以获取数组在内存中的首地址\n\n可以获取数组元素的个数\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint arr[10] &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;\n\n\tcout &lt;&lt; &quot;arr数组占用的内存空间：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组单个元素占用空间：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组的元素个数：&quot; &lt;&lt; sizeof(arr)&#x2F;sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组的首地址：&quot; &lt;&lt; (int)arr &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组第一元素的地址：&quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组第二元素的地址：&quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;arr数组最后元素的地址：&quot; &lt;&lt; (int)&amp;arr[sizeof(arr) &#x2F; sizeof(arr[0])] &lt;&lt; endl;\n&#125;\n\n1.3 一维数组案列\n案列1：在给定的数组中，打印其中最大的元素；\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint arr[] &#x3D; &#123; 100, 200, 500, 300, 999, 1000, 888888 &#125;;\n\tint maxEle &#x3D; arr[0]; &#x2F;&#x2F;默认将数组中第一个元素作为最大值，存入maxEle\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(arr) &#x2F; sizeof(arr[0]); i++)\n\t&#123;\n\t\tif (arr[i + 1] &gt; maxEle) &#x2F;&#x2F;将后一位的元素与默认的元素值进行比较\n\t\t&#123;\n\t\t\tmaxEle &#x3D; arr[i + 1]; &#x2F;&#x2F;如果后一位大于前一位，将后一位的值作为默认值存入maxEle\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; &quot;Max element is : &quot; &lt;&lt; maxEle &lt;&lt; endl;\n&#125;\n\n\n\n案列2：将一个给定的数组，反向排列；\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint arr[] &#x3D; &#123; 1, 3, 2, 5, 4&#125;;\n\tint arrIndex &#x3D; 0; &#x2F;&#x2F;定义一个数组首元素的下标\n\tint arrEnd &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]) - 1; &#x2F;&#x2F;定义数组末元素的下标\n\tint arrTemp; &#x2F;&#x2F;定义一个临时数组元素的下标\n\n\tcout &lt;&lt; &quot;逆向前: &quot;;\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(arr) &#x2F; sizeof(arr[0]); i++)\n\t&#123;\n\t\tcout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\twhile (arrIndex &lt;&#x3D; arrEnd) &#x2F;&#x2F;当首元素下标 &lt;&#x3D; 末元素下标时才执行\n\t&#123;\n\t\t&#x2F;&#x2F;互换两个下标元素的值\n\t\tarrTemp &#x3D; arr[arrIndex];\n\t\tarr[arrIndex] &#x3D; arr[arrEnd];\n\t\tarr[arrEnd] &#x3D; arrTemp;\n\n\t\t&#x2F;&#x2F;首元素下标加1\n\t\tarrIndex++;\n\t\t&#x2F;&#x2F;末元素下标减1\n\t\tarrEnd--;\n\t&#125;\n\n\tcout &lt;&lt; &quot;逆向后: &quot;;\n\n\tfor (int j &#x3D; 0; j &lt; sizeof(arr) &#x2F; sizeof(arr[0]); j++)\n\t&#123;\n\t\tcout &lt;&lt; arr[j] &lt;&lt; &quot; &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\n1.4 冒泡排序法作用：常用的排序算法，将数组内的元素进行排序\n原理：\n\n比较相邻的元素，如果第一个比第二个大，就互换它们的位置\n\n对每一个相邻的两个元素进行这种比较，找到一个最大值\n\n重复执行，每次执行后次数 -1\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint arr[] &#x3D; &#123; 5, 6, 3, 0, 4, 1, 2, 9, 7, 8 &#125;;\n\tint arrtemp;\n\n\tcout &lt;&lt; &quot;排序前：&quot;;\n\tfor (int a &#x3D; 0; a &lt; sizeof(arr) &#x2F; sizeof(arr[0]); a++)\n\t&#123;\n\t\tcout &lt;&lt; arr[a] &lt;&lt; &quot; &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(arr) &#x2F; sizeof(arr[0]) - 1; i++) &#x2F;&#x2F;排序的论数 &#x3D; 数组元素个数 - 1\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; sizeof(arr) &#x2F; sizeof(arr[0]) - i - 1; j++) &#x2F;&#x2F;每轮排序的次数 &#x3D; 数组元素个数 - 排序的论数 -1\n\t\t&#123;\n\t\t\tif (arr[j] &gt; arr[j + 1]) &#x2F;&#x2F;每排序一次，满足条件就执行一次互换位置\n\t\t\t&#123;\n\t\t\t\tarrtemp &#x3D; arr[j];\n\t\t\t\tarr[j] &#x3D; arr[j + 1];\n\t\t\t\tarr[j + 1] &#x3D; arrtemp;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; &quot;排序后：&quot;;\n\tfor (int b &#x3D; 0; b &lt; sizeof(arr) &#x2F; sizeof(arr[0]); b++)\n\t&#123;\n\t\tcout &lt;&lt; arr[b] &lt;&lt; &quot; &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\n2. 二维数组\n二维数组就是在一维数组的基础上增加一个维度\n\n2.1 二维数组的定义四种定义方式：\n\n数据类型 数组名 [行数] [列数]；\n数据类型 数组名 [行数] [列数] &#x3D; ｛｛数据1，数据2｝，｛数据3，数据4｝｝；\n数据类型 数组名 [行数] [列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n数据类型 数组名 [] [列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n\n第二种更直观，可读性更高\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;1. 数据类型 数组名[行数][列数]；\n\tint arr1[2][3];\n\t\n\tarr1[0][0] &#x3D; 1;\n\tarr1[0][1] &#x3D; 2;\n\tarr1[0][2] &#x3D; 3;\n\tarr1[1][0] &#x3D; 4;\n\tarr1[1][1] &#x3D; 5;\n\tarr1[1][2] &#x3D; 6;\n\n\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数]------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\n\tfor (int a &#x3D; 0; a &lt; 2; a++)\n\t&#123;\n\t\tfor (int a1 &#x3D; 0; a1 &lt; 3; a1++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; arr1[a][a1] &lt;&lt; &quot; &quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;2. 数据类型 数组名[行数][列数] &#x3D; &#123;｛数据1，数据2｝，｛数据3，数据4｝&#125;；\n\tint arr2[2][3] &#x3D;\n\t&#123;\n\t\t&#123;1, 2, 3&#125;,\n\t\t&#123;4, 5, 6&#125;\n\t&#125;;\n\n\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数] &#x3D; &#123;｛数据1，数据2｝，｛数据3，数据4｝&#125;------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\n\tfor (int b &#x3D; 0; b &lt; 2; b++)\n\t&#123;\n\t\tfor (int b1 &#x3D; 0; b1 &lt; 3; b1++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; arr2[b][b1] &lt;&lt; &quot; &quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;3. 数据类型 数组名[行数][列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n\tint arr3[2][3] &#x3D; &#123; 1, 2, 3, 4, 5, 6 &#125;;\n\n\tcout &lt;&lt; &quot;------数据类型 数组名[行数][列数] &#x3D; ｛数据1，数据2，数据3，数据4｝------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\n\tfor (int c &#x3D; 0; c &lt; 2; c++)\n\t&#123;\n\t\tfor (int c1 &#x3D; 0; c1 &lt; 3; c1++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; arr3[c][c1] &lt;&lt; &quot; &quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\t&#x2F;&#x2F;4. 数据类型 数组名[][列数] &#x3D; ｛数据1，数据2，数据3，数据4｝；\n\tint arr4[][3] &#x3D; &#123; 1, 2, 3, 4, 5, 6 &#125;;\n\n\tcout &lt;&lt; &quot;------数据类型 数组名[][列数] &#x3D; ｛数据1，数据2，数据3，数据4｝------&quot; &lt;&lt; endl &lt;&lt; &quot;\\t&quot;;\n\tfor (int d &#x3D; 0; d &lt; 2; d++)\n\t&#123;\n\t\tfor (int d1 &#x3D; 0; d1 &lt; 3; d1++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; arr4[d][d1] &lt;&lt; &quot; &quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\n\n\n2.2 二维数组名作用\n查看二维数组所占空间\n\n查看二维数组的首地址\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint arr[2][3] &#x3D;\n\t&#123;\n\t\t&#123;1, 2, 3&#125;,\n\t\t&#123;4, 5, 6&#125;\n\t&#125;;\n\n\tcout &lt;&lt; &quot;二维数组的大小：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组一行的大小：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组元素的大小：&quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组的行数：&quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组的列数：&quot; &lt;&lt; sizeof(arr[0]) &#x2F; sizeof(arr[0][0]) &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;*************************&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;地址\n\tcout &lt;&lt; &quot;二维数组的首地址：&quot; &lt;&lt; (int)arr &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第一行的地址：&quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第二行的地址：&quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第一个元素的地址：&quot; &lt;&lt; (int)&amp;arr[0][0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第二个元素的地址：&quot; &lt;&lt; (int)&amp;arr[0][1] &lt;&lt; endl;\n&#125;\n\n2.3 二维数组案列\n分别输出二维数组每一行的数值总和\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint num[3][3] &#x3D;\n\t&#123;\n\t\t&#123;100, 100, 100&#125;,\n\t\t&#123;80, 70, 60&#125;,\n\t\t&#123;10, 100, 90&#125;\n\t&#125;;\n\tstring name[] &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;\n\n\tfor (int i &#x3D; 0; i &lt; 3; i++)\n\t&#123;\n\t\tint sum &#x3D; 0;\n\t\tfor (int j &#x3D; 0; j &lt; 3; j++)\n\t\t&#123;\n\t\t\tsum +&#x3D; num[i][j];\n\t\t&#125;\n\t\tcout &lt;&lt; name[i] &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl;\n\t&#125;\n&#125;\n\n5. 函数作用：\n\n将一段经常使用的可复用性代码封装起来，作为一个函数，可重复调用\n一个较大的程序，一般分为多个执行程序模块，每个模块执行特定的功能\n\n1. 函数基础\n返回值类型\n函数名\n参数列表\n函数体语句\nreturn表达式\n\n1.1 函数语法返回值类型 函数名 （参数列表）\n&#123;\n    函数体语句；\n    return 表达式；\n&#125;\n\n\n\n1.2 函数定义案列实现一个加法函数，通过传入两个整型数据，返回加法计算结果\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\n&#125;\n\nint add(int num1, int num2)\n&#123;\n\tint sum;\n\tsum &#x3D; num1 + num2;\n\n\treturn sum;\n&#125;\n\n\n\n1.3 函数的调用功能：使用定义好的函数\n语法：函数名（参数）；\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint add(int num1, int num2)\n&#123;\n\tint sum &#x3D; num1 + num2;\n\treturn sum;\n&#125;\n\nvoid main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\tint c;\n\tc &#x3D; add(10, 20);\n\t\n\tcout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n&#125;\n\n\n\n1.4 函数值传递\n函数调用时实参将数值传入形参\n\n值传递时，形参发生变化，不影响实参\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int num1, int num2)\n&#123;\n\tcout &lt;&lt; &quot;值传递前：&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;num1 &#x3D; &quot; &lt;&lt; num1 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;num2 &#x3D; &quot; &lt;&lt; num2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;***************&quot; &lt;&lt; endl;\n\n\tint temp;\n\ttemp &#x3D; num1;\n\tnum1 &#x3D; num2;\n\tnum2 &#x3D; temp;\n\n\tcout &lt;&lt; &quot;值传递后：&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;num1 &#x3D; &quot; &lt;&lt; num1 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;num2 &#x3D; &quot; &lt;&lt; num2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;***************&quot; &lt;&lt; endl;\n&#125;\n\nvoid main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\tcout &lt;&lt; &quot;最先执行main中传递前 a值 和 b值&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; &quot;***************&quot; &lt;&lt; endl;\n\n\tswap(a, b);\n\n\tcout &lt;&lt; &quot;最后执行main中传递后 a值 和 b值&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n&#125;\n\n1.5 函数的常见样式类型：\n\n无参无返\n有参无返\n无参有返\n有参有返\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;1. 无参无返\nvoid demo1()\n&#123;\n\tcout &lt;&lt; &quot;无参无返&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;2. 有参无返\nvoid demo2(string str)\n&#123;\n\tcout &lt;&lt; str &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;3. 无参有返\nstring demo3()\n&#123;\n\tcout &lt;&lt; &quot;无参有返&quot; &lt;&lt; endl;\n\treturn &quot;无参有返&quot;;\n&#125;\n\n&#x2F;&#x2F;4. 有参有返\nstring demo4(string str)\n&#123;\n\tcout &lt;&lt; &quot;有参有返&quot; &lt;&lt; endl;\n\treturn str;\n&#125;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;1. 无参无返\n\tdemo1();\n\t&#x2F;&#x2F;2. 有参无返\n\tdemo2(&quot;有参无返&quot;);\n\t&#x2F;&#x2F;3. 无参有返\n\tdemo3();\n\t&#x2F;&#x2F;4. 有参有返\n\tdemo4(&quot;有参有返&quot;);\n&#125;\n\n\n\n1.6 函数的声明\n作用：\n​\t告诉编辑器函数的名称以及如何调用函数，函数的实际主体可以单独定义\n​\t在main之前声明函数，函数主体的定义可以写在main之后，没有提前声明，函数只能定义在main之前\n\n注意：函数可以声明多次，但函数的定义只能一次\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;提前声明函数，函数主体就可以定义到main后面\nint maxValue(int a, int b);\n\nvoid main()\n&#123;\n\tcout &lt;&lt; &quot;MaxValue &#x3D; &quot; &lt;&lt; maxValue(10, 20) &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;有了提前声明，此时，函数主体就可以定义到main后面\nint maxValue(int a, int b)\n&#123;\n\treturn a &gt; b ? a : b;\n&#125;\n\n1.7 函数的分文件编写作用：\n\n让项目的代码更加清晰，可读性和维护性更高\n\n步骤：\n\n创建后缀名为 .h 的头文件\n创建后缀名为 .cpp 的源文件\n在头文件中写函数的声明\n在源文件中写函数的定义\n在main中调用函数源文件中的函数\n\n示例：\n\n头文件\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int a, int b);\n\n\n\n函数源文件\n#include &quot;swap.h&quot;\n\nvoid swap(int a, int b)\n&#123;\n\tcout &lt;&lt; &quot;转换前：&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; &quot;******************&quot; &lt;&lt; endl;\n\n\tint temp;\n\ttemp &#x3D; a;\n\ta &#x3D; b;\n\tb &#x3D; temp;\n\n\tcout &lt;&lt; &quot;转换后：&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n&#125;\n\n\n\nmain文件\n#include &lt;iostream&gt;\n#include &quot;swap.h&quot;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tswap(10, 20);\n&#125;\n\n1.8 头源 main文件头文件：\n&#x2F;&#x2F; 头文件中写入main函数需要用到的库以及函数的定义（明确函数的参数类型）\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n#ifndef DEMO_FEATURE_H\n#define DEMO_FEATURE_H\n\nstruct personInfo\n&#123;\n    string name;\n    int age;\n&#125;;\n\nvoid printHello();\n\nint sumNum(int a, int b);\n\nvoid returnInfo(personInfo *s_per);\n\n#endif &#x2F;&#x2F;DEMO_FEATURE_H\n\n源文件：\n&#x2F;&#x2F; 源文件内写函数的具体内容\n&#x2F;&#x2F; 导入相关联的头文件\n\n#include &quot;feature.h&quot;\n\nvoid printHello()\n&#123;\n    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;\n&#125;\n\nint sumNum(int a, int b)\n&#123;\n    int c &#x3D; a + b;\n    return c;\n&#125;\n\nvoid returnInfo(personInfo *s_per)\n&#123;\n    cout &lt;&lt; &quot;name: &quot; &lt;&lt; s_per-&gt;name &lt;&lt; &quot; age: &quot; &lt;&lt; s_per-&gt;age &lt;&lt; endl;\n&#125;\n\nmain文件：\n&#x2F;&#x2F; 导入需要的头文件\n\n#include &quot;cmake-build-debug&#x2F;feature.h&quot;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 无返回值函数\n    printHello();\n\n    &#x2F;&#x2F; 有返回值函数\n    int sum;\n    sum &#x3D; sumNum(10, 20);\n    cout &lt;&lt; &quot;sum &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl;\n\n    &#x2F;&#x2F; 参数为结构体的函数\n    personInfo s_per &#x3D; &#123;&quot;FH&quot;, 22&#125;;\n    returnInfo(&amp;s_per);\n    return 0;\n&#125;\n\n\n\n\n\n6. 指针1. 指针概念作用：\n\n可通过指针间接访问内存\n\n注意：\n\n内存编号从0开始记录，一般用16进制数字表示\n可利用指针变量保存地址\n\n2. 指针变量的定义和使用\n语法：\n数据类型* 指针变量名 &#x2F;&#x2F;定义指针\n指针变量名 = &amp;变量名 &#x2F;&#x2F;将定义的变量存储的内存地址给指针\n*指针变量名 = 值或变量名 &#x2F;&#x2F;通过指针间接的读写指向地址的值\n\n示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\n  void main()\n  &#123;\n  \tint a &#x3D; 10; \n  \t&#x2F;&#x2F;定义一个指针变量\n  \tint* p_a;\n  \t\n  \t&#x2F;&#x2F;将变量a的地址给指针\n  \tp_a &#x3D; &amp;a;\n\n  \t&#x2F;&#x2F;查看两个变量的地址\n  \tcout &lt;&lt; &quot;a address is &quot; &lt;&lt; &amp;a &lt;&lt; endl;\n  \tcout &lt;&lt; &quot;p_a &#39;s value is &quot; &lt;&lt; p_a &lt;&lt; endl;\n\n  \tcout &lt;&lt; &quot;****************&quot; &lt;&lt; endl;\n\n  \t&#x2F;&#x2F;通 *指针变量名 &#x3D; 值 可以间接读写内存地址内的值\n  \t*p_a &#x3D; 1000;\n  \tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n  \tcout &lt;&lt; &quot;p_a &#x3D; &quot; &lt;&lt; *p_a &lt;&lt; endl;\n  &#125;\n\n3. 指针占用的内存空间\n说明：\n32位操作系统：指针占用4个字节\n64位操作系统：指针占用8个字节\n#include &lt;iostream&gt;\n  \nusing namespace std;\n  \nvoid main()\n&#123;\n  \tint a &#x3D; 10;\n  \tint* p_a &#x3D; &amp;a;\n  \n  \tcout &lt;&lt; &quot;sizeof (p_a) &#x3D; &quot; &lt;&lt; sizeof(p_a) &lt;&lt; endl;\n  \tcout &lt;&lt; &quot;sizeof (int*) &#x3D; &quot; &lt;&lt; sizeof(int*) &lt;&lt; endl;\n  \tcout &lt;&lt; &quot;sizeof (float*) &#x3D; &quot; &lt;&lt; sizeof(float*) &lt;&lt; endl;\n  \tcout &lt;&lt; &quot;sizeof (double*) &#x3D; &quot; &lt;&lt; sizeof(double*) &lt;&lt; endl;\n  \tcout &lt;&lt; &quot;sizeof (bool*) &#x3D; &quot; &lt;&lt; sizeof(bool*) &lt;&lt; endl;\n  \tcout &lt;&lt; &quot;sizeof (char*) &#x3D; &quot; &lt;&lt; sizeof(char*) &lt;&lt; endl;\n  \tcout &lt;&lt; &quot;sizeof (string*) &#x3D; &quot; &lt;&lt; sizeof(string*) &lt;&lt; endl;\n&#125;\n\n4. 空指针和野指针4.1 空指针\n空指针：指针变量指向内存中编号为0的空间\n\n用途：初始化指针变量\n\n空指针指向的内存空间是不可访问的（0-255是系统占用的）\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;指针变量指向内存中编号为0的空间\n\t&#x2F;&#x2F;初始化指针变量\n\tint* p &#x3D; NULL;\n\n\t&#x2F;&#x2F;空指针指向的内存空间是不可访问的（0 - 255是系统占用的）\n\tcout &lt;&lt; p &lt;&lt; endl;\n\n\t*p &#x3D; 10; &#x2F;&#x2F;提示该句无效\n\tcout &lt;&lt; p &lt;&lt; endl; &#x2F;&#x2F;什么都没有\n&#125;\n\n4.2 野指针\n野指针：指向非法的内存空间\n\n注意：程序中尽量避免出现野指针\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint* p &#x3D; (int*)0x1100;\n\tcout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;打印指针指向的内存值无效\n&#125; \n\n5. const修饰指针\n三种情况：\n\nconst修饰指针 –常量指针\nconst修饰常量 –指针常量\nconst即修饰指针又修饰常量\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\t&#x2F;&#x2F;1. const修饰指针 --常量指针\n\tconst int* p &#x3D; &amp;a; &#x2F;&#x2F; &#x3D;&gt; const *p (常量指针)\n\t*p &#x3D; b; &#x2F;&#x2F;错误：指针指向的内存空间值不能修改\n\tp &#x3D; &amp;b; &#x2F;&#x2F;指针的地址编号可以改\n\n\t&#x2F;&#x2F;2. const修饰常量 --指针常量\n\tint* const p1 &#x3D; &amp;a; &#x2F;&#x2F; &#x3D;&gt; const p1 (指针常量)\n\t*p1 &#x3D; b; &#x2F;&#x2F;指针指向的内存空间的值可以修改\n\tp1 &#x3D; &amp;b; &#x2F;&#x2F;错误：指针的地址编号不能修改\n\n\t&#x2F;&#x2F;3. const即修饰指针又修饰常量\n\tconst int* const p2 &#x3D; &amp;a;\n\t*p2 &#x3D; b; &#x2F;&#x2F;错误：指针指向的内存空间值不能修改\n\tp2 &#x3D; &amp;b; &#x2F;&#x2F;错误：指针的地址编号不能修改\n&#125;\n\n6. 指针和数组\n利用指针访问数组中的元素\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\n\tint* p &#x3D; arr;\n\n\tcout &lt;&lt; &quot;arr[0] &#x3D; &quot; &lt;&lt; arr[0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;*p &#x3D; &quot; &lt;&lt; *p &lt;&lt; endl;\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(arr) &#x2F; sizeof(arr[0]); i++)\n\t&#123;\n\t\tcout &lt;&lt; *p &lt;&lt; endl;\n\t\tcout &lt;&lt; p &lt;&lt; endl; &#x2F;&#x2F;每次遍历的内存地址\n\t\tp++;&#x2F;&#x2F;*p 是指针指向内存空间的值，p 是内存地址，p++ 内存地址向后移8个单位（64位）4个单位（32位）\n\t&#125;\n&#125;\n\n7. 指针和函数\n利用指针作为函数的实参，可以修改传入函数的实参值\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int* p1, int* p2) &#x2F;&#x2F;将指针指向内存的值进行调换\n&#123;\n\tint temp &#x3D; *p1;\n\t*p1 &#x3D; *p2;\n\t*p2 &#x3D; temp;\n\t&#x2F;&#x2F;此时 &amp;a &amp;b 的地址没变，但地址内存的值变了\n&#125;\n\nvoid main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tswap(&amp;a, &amp;b);\n\n\tcout &lt;&lt; &quot;swap a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;swap b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n&#125;\n\n8. 指针 数组 函数\n案列：封装一个函数，用冒泡排序，实现对整型数组的升序排序\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid upSort(int* arrIndex, int arrlength)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; arrlength - 1; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; arrlength - i - 1; j++)\n\t\t&#123;\n\t\t\tif (arrIndex[j] &gt; arrIndex[j + 1])\n\t\t\t&#123;\n\t\t\t\tint temp &#x3D; arrIndex[j];\n\t\t\t\tarrIndex[j] &#x3D; arrIndex[j + 1];\n\t\t\t\tarrIndex[j + 1] &#x3D; temp;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid printArray(int* arrIndex, int arrLength)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; arrLength; i++)\n\t&#123;\n\t\tcout &lt;&lt; arrIndex[i] &lt;&lt; &quot; &quot;;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\nvoid main()\n&#123;\n\tint arr[] &#x3D; &#123;4, 3, 2, 1, 8, 6, 9, 5, 7, 0&#125;;\n\tint arrLength &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n\tprintArray(arr, arrLength);\n\tupSort(arr, arrLength);\n\tprintArray(arr, arrLength);\n&#125;\n\n9. 指针补充int *p;\n\n&#x2F;&#x2F; 指针数组，数组里面可以存放3个int*\nint *arr1[3] &#x3D; &#123;p, p, p&#125;;\n\n&#x2F;&#x2F; 用于指向数组的指针\nint (*arr2)[3];\n\n\n\n\n\n\n\n7. 结构体1. 结构体基本概念\n结构体属于用户自定义的数据类型，允许用户存储不同的数据类型\n\n2. 结构体定义和使用\n语法：struct 结构体名 ｛结构体成员列表&#125;;\n\n创建：\n\nstruct 结构体名 变量名；\nstruct 结构体名 &#x3D; ｛成员1值，成员2值，…};\n定义结构体时创建变量\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;语法：struct 结构体名 ｛结构体成员列表｝；\nstruct studentID\n&#123;\n\tstring name;\n\tint age;\n&#125;;\n\nvoid main()\n&#123;\n\t&#x2F;&#x2F;1. struct 结构体名 变量名；\n\tstruct studentID s1;\n\ts1.age &#x3D; 23;\n\ts1.name &#x3D; &quot;FH&quot;;\n\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; s1.name &lt;&lt; &quot;  age: &quot; &lt;&lt; s1.age &lt;&lt; endl;\n\n\t&#x2F;&#x2F;2. struct 结构体名 &#x3D; ｛成员1值，成员2值，...｝；\n\tstruct studentID s2 &#x3D; &#123;&quot;XX&quot;, 99&#125;;\n\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; s2.name &lt;&lt; &quot;  age: &quot; &lt;&lt; s2.age &lt;&lt; endl;\n\t\n&#125;\n\n3. 结构体数组\n作用：将自定义的结构体存入数组中方便管理\n\n语法：struct 结构体名 数组名[元素个数] = ｛｛｝，｛｝，... ，｛｝&#125;;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct stuInfo\n&#123;\n\tstring name;\n\tint age;\n&#125;;\n\nvoid main()\n&#123;\n\tstruct stuInfo stuInfoArr[] &#x3D;\n\t&#123;\n\t\t&#123;&quot;XX&quot;, 66&#125;,\n\t\t&#123;&quot;YY&quot;, 99&#125;\n\t&#125;;\n\n\t&#x2F;&#x2F;修改结构体数组中第0个元素的值\n\tstuInfoArr[0] &#x3D; &#123; &quot;FH&quot;, 23 &#125;;\n\n\t&#x2F;&#x2F;修改结构体数组中第1个元素的值\n\tstuInfoArr[1].name &#x3D; &quot;CYL&quot;;\n\tstuInfoArr[1].age &#x3D; 22;\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(stuInfoArr) &#x2F; sizeof(stuInfoArr[0]); i++)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; stuInfoArr[i].name\n\t\t\t&lt;&lt; &quot;  Age: &quot; &lt;&lt; stuInfoArr[i].age\n\t\t\t&lt;&lt; endl;\n\t&#125;\n&#125; \n\n4. 结构体指针\n作用：通过指针访问或修改结构体中的成员\n\n利用操作符 -&gt; 可以通过结构体指针访问结构体属性\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct stuInfo\n&#123;\n\tstring name;\n\tint age;\n&#125;;\n\nvoid main()\n&#123;\n\tstuInfo stu &#x3D; &#123; &quot;FH&quot;, 23 &#125;;\n\tstuInfo* p_stu &#x3D; &amp;stu;\n\n\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; p_stu-&gt;name &lt;&lt; &quot;  Age: &quot; &lt;&lt; p_stu-&gt;age &lt;&lt; endl;\n&#125;\n\n5. 结构体嵌套结构体\n作用：\n结构体中的成员可以是另一个结构体\n结构体中可以定义另一个结构体成员\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct stuInfo\n&#123;\n\tstring name;\n\tint age;\n&#125;;\n\nstruct teaInfo\n&#123;\n\tstring name;\n\tint id;\n\tstruct stuInfo stu;\n&#125;;\n\nvoid main()\n&#123;\n\tstuInfo s1 &#x3D; &#123; &quot;FH&quot;, 23 &#125;;\n\t&#x2F;&#x2F;stuInfo s2 &#x3D; &#123; &quot;CYL&quot;, 22 &#125;;\n\n\tteaInfo t1 &#x3D; &#123; &quot;XX&quot;, 1001, s1&#125;;\n\t\n\tteaInfo t2;\n\tt2.name &#x3D; &quot;YY&quot;;\n\tt2.id &#x3D; 1002;\n\tt2.stu.name &#x3D; &quot;CYL&quot;;\n\tt2.stu.age &#x3D; 22;\n\n\tcout &lt;&lt; &quot;TeacherName: &quot; &lt;&lt; t1.name &lt;&lt; &quot;  TeacherID: &quot; &lt;&lt; t1.id \n\t\t&lt;&lt; &quot;  StudentName: &quot; &lt;&lt; s1.name &lt;&lt; &quot;  StudentAge: &quot; &lt;&lt; s1.age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;TeacherName: &quot; &lt;&lt; t2.name &lt;&lt; &quot;  TeacherID: &quot; &lt;&lt; t2.id \n\t\t&lt;&lt; &quot;  StudentName: &quot; &lt;&lt; t2.stu.name &lt;&lt; &quot;  StudentAge: &quot; &lt;&lt; t2.stu.name &lt;&lt; endl;\n&#125;\n\n6. 结构体做函数参数\n作用：将结构体作为参数向函数中传递\n\n方式：\n\n值传递\n地址传递\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct stuInfo\n&#123;\n\tstring name;\n\tint age;\n&#125;;\n\nvoid printInfo(stuInfo s)\n&#123;\n\tcout &lt;&lt; &quot;Value Transfer: &quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Modify Argument before: &quot;;\n\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; s.name &lt;&lt; &quot;  Age: &quot; &lt;&lt; s.age &lt;&lt; endl;\n\n\ts.age &#x3D; 99;\n\tcout &lt;&lt; &quot;Modify Argument later: &quot;;\n\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; s.name &lt;&lt; &quot;  Age: &quot; &lt;&lt; s.age &lt;&lt; endl;\n&#125;\n\nvoid printInfo2(stuInfo* p_s1)\n&#123;\n\tcout &lt;&lt; &quot;Pointer Address Transfer: &quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Modify Argument before: &quot;;\n\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; p_s1-&gt;name &lt;&lt; &quot;  Age: &quot; &lt;&lt; p_s1-&gt;age &lt;&lt; endl;\n\n\tp_s1-&gt;age &#x3D; 99;\n\tcout &lt;&lt; &quot;Modify Argument later: &quot;;\n\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; p_s1-&gt;name &lt;&lt; &quot;  Age: &quot; &lt;&lt; p_s1-&gt;age &lt;&lt; endl;\n&#125;\n\nvoid main()\n&#123;\n\tstuInfo s &#x3D; &#123;&quot;FH&quot;, 23&#125;;\n\tstuInfo p_s1 &#x3D; &#123; &quot;CYL&quot;, 22 &#125;;\n\n\tprintInfo(s);\n\tcout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;\n\tprintInfo2(&amp;p_s1);\n&#125;\n\n7. 结构体const应用\n作用：用const防止误操作\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct stuInfo\n&#123;\n\tstring name;\n\tint age;\n&#125;;\n\nvoid printInfo(const stuInfo* p_s)\n&#123;\n\t&#x2F;&#x2F;p_s-&gt;age &#x3D; 99; &#x2F;&#x2F;const 限定修饰后的结构体 内存值不能被修改\n\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; p_s-&gt;name &lt;&lt; &quot;  Age: &quot; &lt;&lt; p_s-&gt;age &lt;&lt; endl;\n&#125;\n\nvoid main()\n&#123;\n\tstuInfo p_s &#x3D; &#123;&quot;FH&quot;, 23&#125;;\n\tprintInfo(&amp;p_s);\n&#125;\n\n8. 结构体案列8.1 案列1\n描述：三位老师，每位老师下五名学生\n\n要求：设计老师，学生的结构体，老师结构体内有老师姓名和存放学生的数组；学生结构体内有姓名，年龄；创建数组存放老师；通过函数给老师及其下学生赋值，并打印\n#include &lt;iostream&gt;\n#include &lt;time.h&gt;\n\nusing namespace std;\n\nstruct stuInfo\n&#123;\n\tstring name;\n\tint age;\n&#125;;\n\nstruct teaInfo\n&#123;\n\tstring name;\n\tstuInfo sArr[5];\n&#125;;\n\nvoid noteValue(teaInfo tArr[], int tLength)\n&#123;\n\tstring nameSeed &#x3D; &quot;ABCDE&quot;;\n\tfor (int i &#x3D; 0; i &lt; tLength; i++)\n\t&#123;\n\t\ttArr[i].name &#x3D; &quot;Tea_&quot;;\n\t\ttArr[i].name +&#x3D; nameSeed[i];\n\n\t\tfor (int j &#x3D; 0; j &lt; 5; j++)\n\t\t&#123;\n\t\t\ttArr[i].sArr[j].name &#x3D; &quot;Stu_&quot;;\n\t\t\ttArr[i].sArr[j].name +&#x3D; nameSeed[j];\n\t\t\tint ranAge &#x3D; rand() % 21 + 10;\n\t\t\ttArr[i].sArr[j].age &#x3D; ranAge;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid printInfo(teaInfo tArr[], int tLength)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; tLength; i++)\n\t&#123;\n\t\tcout &lt;&lt; tArr[i].name &lt;&lt; endl;\n\t\tfor (int j &#x3D; 0; j &lt; 5; j++)\n\t\t&#123;\n\t\t\tcout &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;Name: &quot; &lt;&lt; tArr[i].sArr[j].name &lt;&lt; &quot;  Age: &quot; &lt;&lt; tArr[i].sArr[j].age &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid main()\n&#123;\n\tteaInfo tArr[3];\n\tint tLength &#x3D; sizeof(tArr) &#x2F; sizeof(tArr[0]);\n\tsrand((unsigned int)time(NULL));\n\tnoteValue(tArr, tLength);\n\tprintInfo(tArr, tLength);\n&#125;\n\n8.2 案列2\n描述：设计一个角色，包含姓名，年龄，性别；创建结构体数组，存放3个角色；通过冒泡排序，将角色按照年龄大小升序排序，并打印\n#include &lt;iostream&gt;\n#include &quot;Struct_demo8.h&quot;\n\nusing namespace std;\n\nstruct roleInfo\n&#123;\n\tstring name;\n\tint age;\n\tstring sex;\n&#125;;\n\nvoid upSort(roleInfo rArr[], int rLength)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; rLength - 1; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; rLength - i - 1; j++)\n\t\t&#123;\n\t\t\tif (rArr[j].age &gt; rArr[j + 1].age)\n\t\t\t&#123;\n\t\t\t\troleInfo tempInfo &#x3D; rArr[j];\n\t\t\t\trArr[j] &#x3D; rArr[j + 1];\n\t\t\t\trArr[j + 1] &#x3D; tempInfo;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid printInfo(roleInfo rArr[], int rlength)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; rlength; i++)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Name: &quot; &lt;&lt; rArr[i].name &lt;&lt; &quot;  Age: &quot; &lt;&lt; rArr[i].age &lt;&lt; &quot;  Sex: &quot; &lt;&lt; rArr[i].sex &lt;&lt; endl;\n\t&#125;\n&#125;\n\nvoid main()\n&#123;\n\troleInfo rArr[] &#x3D;\n\t&#123;\n\t\t&#123;&quot;FH&quot;, 23, &quot;M&quot;&#125;,\n\t\t&#123;&quot;MM&quot;, 22, &quot;W&quot;&#125;,\n\t\t&#123;&quot;XY&quot;, 21, &quot;W&quot;&#125;\n\t&#125;;\n\n\tint rlength &#x3D; sizeof(rArr) &#x2F; sizeof(rArr[0]);\n\n\tupSort(rArr, rlength);\n\tprintInfo(rArr, rlength);\n&#125;\n\n8. const补充\nconst修饰的是其右边的内容\nconst的位置带来的效果与变量类型名，没有联系\n\n8.1 const多种情况int age &#x3D; 10;\n\nconst int *p1 &#x3D; &amp;age;\n# &#x3D;&gt; const 修饰的是 *p1，*p1 不可更改\n# &#x3D;&gt; p1 不受影响\n\nint const *p2 &#x3D; &amp;age;\n# &#x3D;&gt; const 修饰的是 *p2，*p2 不可更改\n# &#x3D;&gt; p2 不受影响\n\nint * const p3 &#x3D; &amp;age;\n# &#x3D;&gt; const 修饰的是 p3，p3 不可更改\n# &#x3D;&gt; *p3 不受影响\n\nconst int * const p4 &#x3D; &amp;age;\n# &#x3D;&gt; const 修饰的是 *p4 和 p4，*p4 和 p4 不可更改\n\nint const * const p5 &#x3D; &amp;age;\n# &#x3D;&gt; const 修饰的是 *p5 和 p5，*p5 和 p5 不可更改\n\n\n\nstruct Student &#123;int age;&#125;;\n\nStudent stu1 &#x3D; &#123;10&#125;;\nStudent stu2 &#x3D; &#123;20&#125;;\n\nconst Student *p_Stu1 &#x3D; &amp;stu1;\n# &#x3D;&gt; const 在最左边，修饰的是 *p_Stu1 (值常量)\n# &#x3D;&gt; p_Stu1 是 指针，不受影响\n\n# *p_Stu1 &#x3D; stu2; (报错)\n# (*p_Stu1).age &#x3D; 20; (报错)\n# p_Stu1-&gt;age &#x3D; 20; (报错)\n# p_Stu1 &#x3D; &amp;stu2; (正确)\n\nStudent * const p_Stu2 &#x3D; &amp;stu2;\n# &#x3D;&gt; const 在 p_Stu2 左边，修饰的是 p_Stu2 (指针常量)\n# &#x3D;&gt; *p_Stu2 是 值，不受影响\n\n# *p_Stu2 &#x3D; stu1; (正确)\n# (*p_Stu2).age &#x3D; 30; (正确)\n# p_Stu2-&gt;age &#x3D; 30; (正确)\n# p_Stu2 &#x3D; &amp;stu1; (错误)\n\n","slug":"1_C++_基础_01","date":"2022-10-06T07:28:25.915Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"e94a77a3753f22f554c8c36e4173e356","title":"C++_核心编程","content":"C++_核心编程1. 内存分区模型C++程序在执行时，内存大方向划分为4个区域\n\n代码区：存放函数的二进制代码，由操作系统进行管理的\n全局区：存放全局变量和静态变量以及常量\n栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n堆区：由程序员分配和释放，若不释放，程序执行结束后会系统回收\n\n内存分区的意义：\n\n不同区域存放的数据，赋予不同的生命周期\n\n1.1 程序运行前程序编译后，生成可执行的 .exe 文件 未执行前，分成两个区域\n代码区：\n\n存放CPU执行的机器指令\n代码区是共享的，目的是对于频繁的执行程序，只需在内存中存放一份即可\n代码区是只读的，目的是防止程序意外的修改了它的指令\n\n全局区：\n\n全局变量和静态变量存放其中\n全局区还包括了常量区，字符串常量和其他常量也存放其中\n该区域的数据在程序结束后由操作系统释放\n\n分类：\n\n全局区：全局变量，静态变量，常量\n常量区：const修饰的全局变量，字符串常量\n局部区：局部变量，const修饰的局部变量和常量\n\n代码：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;Global variable outside Function\nint g_a &#x3D; 10;\nint g_b &#x3D; 20;\n\n&#x2F;&#x2F;Global constant variable outside Function\nconst int g_c_a &#x3D; 10;\nconst int g_c_b &#x3D; 20;\n\nint main()\n&#123;\n    &#x2F;&#x2F;Local variable inside Function\n    int l_a &#x3D; 10;\n    int l_b &#x3D; 20;\n\n    &#x2F;&#x2F;Static variable\n    static int s_a &#x3D; 10;\n    static int s_b &#x3D; 20;\n\n    &#x2F;&#x2F;Constant Local variable inside Function\n    const int l_c_a &#x3D; 10;\n    const int l_c_b &#x3D; 20;\n\n    &#x2F;&#x2F;Debug local variable\n    cout &lt;&lt; &quot;Local Area_Local variable l_a: &quot; &lt;&lt; (int) &amp;l_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Local Area_Local variable l_b: &quot; &lt;&lt; (int) &amp;l_b &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug constant local variable\n    cout &lt;&lt; &quot;Local Area_Constant local variable l_c_a:&quot; &lt;&lt; (int) &amp;l_c_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Local Area_Constant local variable l_c_b:&quot; &lt;&lt; (int) &amp;l_c_b &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug global variable\n    cout &lt;&lt; &quot;Global Area_Global variable g_a: &quot; &lt;&lt; (int) &amp;g_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Global Area_Global variable g_b: &quot; &lt;&lt; (int) &amp;g_b &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug static variable\n    cout &lt;&lt; &quot;Global Area_Static variable s_a: &quot; &lt;&lt; (int) &amp;s_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Global Area_Static variable s_b: &quot; &lt;&lt; (int) &amp;s_b &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug string constant\n    cout &lt;&lt; &quot;Global Area_String constant str_c_a:&quot; &lt;&lt; (int) &amp;&quot;Hello World&quot; &lt;&lt; endl;\n\n    &#x2F;&#x2F;Debug global constant variable\n    cout &lt;&lt; &quot;Global Area_global constant variable g_c_a:&quot; &lt;&lt; (int) &amp;g_c_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;Global Area_global constant variable g_c_b:&quot; &lt;&lt; (int) &amp;g_c_b &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n\n\n\n\n1.2 程序运行后\n栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n\n注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;定义一个返回值int类型的函数\nint *demoFunc()\n&#123;\n    &#x2F;&#x2F;定义一个局部变量，存在栈区中\n    int a &#x3D; 10;\n    &#x2F;&#x2F;返回一个局部变量的地址\n    return &amp;a;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F;接受局部变量传来的地址\n    int *p_a &#x3D; demoFunc();\n\n    cout &lt;&lt; *p_a &lt;&lt; endl; &#x2F;&#x2F;第一次能正常的解析地址对应的值，函数执行结束，系统回收了数据\n    cout &lt;&lt; *p_a &lt;&lt; endl; &#x2F;&#x2F;第二次，无法正常解析到对应的值，因为函数执行一次结束后，没有返回值了\n&#125;\n\n堆区：由程序员释放，若不释放，程序结束时由操作系统回收\n\n方式：C++通过 new 在堆区中开辟内存\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint *demoFunc()\n&#123;\n    &#x2F;&#x2F;通过指针地址存放 new 关键字对int类型的值在堆中开辟的内存所在的地址\n    &#x2F;&#x2F;这个 int的值存放在堆中，改函数执行结束后，依然存在\n    int *p_a &#x3D; new int(10);\n    return p_a;\n&#125;\n\nint main()\n&#123;\n    int *p_a &#x3D; demoFunc();\n    cout &lt;&lt; *p_a &lt;&lt; endl;\n    cout &lt;&lt; *p_a &lt;&lt; endl; &#x2F;&#x2F;函数执行结束后，指针指向的指针内存空间依然存在，所以可以正常得到内存中的值\n    return 0;\n&#125;\n\n1.3 new操作符\n\nC++ 通过 new 在堆区开辟数据\n堆区的数据，由程序员手动开辟，手动释放，利用 delet 操作符\n语法：new 数据类型（）；\n利用new创建的数据，会返回该数据对应的类型的指针地址\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F;创建一个返回int类型的地址函数\nint *newKeyDemo()\n&#123;\n    &#x2F;&#x2F;new操作符开辟的数据会返回一个指针\n    int *p_a &#x3D; new int(10);\n    &#x2F;&#x2F;返回指针\n    return p_a;\n&#125;\n\nvoid printDemo1Info()\n&#123;\n    &#x2F;&#x2F;创建一个指针接受返回值\n    int *Info1 &#x3D; newKeyDemo();\n    cout &lt;&lt; *Info1 &lt;&lt; endl;\n    &#x2F;&#x2F;delete 操作符会释放 new在堆中的数据\n    delete Info1;\n    cout &lt;&lt; *Info1 &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;利用new操作符创建数组\nvoid printDemo2Info()\n&#123;\n    int *p_arr &#x3D; new int[10];\n\n    for (int i &#x3D; 0; i &lt; 10; i++)\n    &#123;\n        p_arr[i] &#x3D; i + 1;\n    &#125;\n\n    for (int j &#x3D; 0; j &lt; 10; j++)\n    &#123;\n        cout &lt;&lt; p_arr[j] &lt;&lt; &quot; &quot;;\n    &#125;\n\n    delete[] p_arr;\n&#125;\n\nint main()\n&#123;\n    printDemo1Info();\n    printDemo2Info();\n    return 0;\n&#125;\n\n\n\n\n\n2. 引用2.1 引用的基本使用\n作用：给变量起别名\n\n语法：数据类型 &amp;别名 = 原名；\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int &amp;b &#x3D; a;\n\n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n    b &#x3D; 20;\n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n    return 0;\n&#125;\n\n2.2 引用注意事项\n引用必须初始化\n\n引用在初始化后不可以改变\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int c &#x3D; 10;\n    &#x2F;&#x2F;int &amp;b; 引用必须初始化\n    int &amp;b &#x3D; a;\n    &#x2F;&#x2F;int &amp;b &#x3D; c; 引用初始化后不可更改\n    return 0;\n&#125;\n\n2.3 引用做函数参数\n作用：函数传参时，可以利用引用的技术让形参修饰实参\n\n优点：可以简化指针修改实参\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap01(int a, int b)\n&#123;\n    int temp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; temp;\n&#125;\n\nvoid swap02(int *p_a, int *p_b)\n&#123;\n    int temp &#x3D; *p_a;\n    *p_a &#x3D; *p_b;\n    *p_b &#x3D; temp;\n&#125;\n\nvoid swap03(int &amp;a, int &amp;b)\n&#123;\n    int temp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; temp;\n&#125;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n\n&#x2F;&#x2F;    swap01(a, b); 值传递，形参不修饰实参\n&#x2F;&#x2F;    swap02(&amp;a, &amp;b); 地址传递，形参修饰实参\n    swap03(a, b); &#x2F;&#x2F; 引用传递，形参修饰实参\n\n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n    return 0;\n&#125;\n\n2.4 引用做函数的返回值\n作用：引用可以作为函数的返回值\n\n注意：不要返回局部变量引用\n\n用法：函数调用作为左值\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint &amp;demo1()\n&#123;\n    int a &#x3D; 10; &#x2F;&#x2F;函数体内定义的局部变量，函数执行完后，系统自动回收\n    return a;\n&#125;\n\nint &amp;demo2()\n&#123;\n    static int b &#x3D; 20; &#x2F;&#x2F;static 修饰的静态变量，存储在全局区，整个程序执行完后，系统自动回收\n    return b;\n&#125;\n\nint main()\n&#123;\n    int &amp;ref_a &#x3D; demo1();\n    int &amp;ref_b &#x3D; demo2();\n    cout &lt;&lt; &quot;ref_a &#x3D; &quot; &lt;&lt; ref_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;ref_a &#x3D; &quot; &lt;&lt; ref_a &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n\n    demo2() &#x3D; 1000; &#x2F;&#x2F;函数的调用是引用，可以作为左值\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n2.5 引用的本质\n本质：在C++内部实现一个指针常量\n\n示例：\n#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F; 转换为 int *const ref_b &#x3D; &amp;a\nvoid demo1(int &amp;ref_b)\n&#123;\n    ref_b &#x3D; 100;\n&#125;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    &#x2F;&#x2F; 自动转换为 int *const ref_a &#x3D; &amp;a; &lt;&lt; &#x3D; &gt;&gt; 指针常量；因为指针的指向（地址）不可改变，所以引用的初始化后不可更改\n    int &amp;ref_a &#x3D; a;\n    &#x2F;&#x2F; ref是引用，自动转换成 *ref &#x3D; 20；\n    ref_a &#x3D; 20;\n  \n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;ref_a &#x3D; &quot; &lt;&lt; ref_a &lt;&lt; endl;\n  \n    demo1(ref_a);\n  \n    return 0;\n&#125;\n\n结论：引用本质是指针，使用方便\n\n\n2.6 常量引用\n作用：常量引用一般用来修饰形参，防止误操作\n\n使用：在函数形参列表中，可以加 const 修饰形参，防止形参被实参修改\n\n示例：\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid printInfo(const int &amp;ref_b)\n&#123;\n    &#x2F;&#x2F;常量引用的值不可以修改\n    &#x2F;&#x2F;ref_b &#x3D; 1000;\n    cout &lt;&lt; &quot;ref_b &#x3D; &quot; &lt;&lt; ref_b &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 编辑器 转换为 int temp &#x3D; 10;   const int &amp;a &#x3D; temp;\n    &#x2F;&#x2F;const int &amp;ref_a &#x3D; 10;\n    &#x2F;&#x2F; ref_a 用 const 修饰后值不能被修改\n    &#x2F;&#x2F;ref_a &#x3D; 20;\n\tint a &#x3D; 100;\n\tprintInfo(a);\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n2.7 引用补充\n一个引用占用一个指针的大小\n\n证明引用本质是指针\n&#x2F;&#x2F; 指针转汇编\n&#x2F;&#x2F; int *p &#x3D; &amp;age;\nlea eax, [age]\nmov dword ptr [p], eax\n\n&#x2F;&#x2F; *p &#x3D; 30;\nmov eax, dword ptr [p]\nmov dword ptr [eax], 1Eh\n\n&#x2F;&#x2F; 引用转汇编\n&#x2F;&#x2F; int &amp;ref &#x3D; age;\nlea eax, [age]\nmov dword ptr [p], eax\n\n&#x2F;&#x2F; ref &#x3D; 30;\nmov eax, dword ptr [p]\nmov dword ptr [eax], 1Eh\n\n\n\n数组引用\nint array[] &#x3D; &#123;1, 2, 3&#125;;\n\n&#x2F;&#x2F; 数组名 array 是数组的首元素地址，&#x3D;&gt; (i)\n&#x2F;&#x2F; 两种写法\nint (&amp;ref1)[3] &#x3D; array;\nint *const &amp;ref2 &#x3D; array;\n\n\n\n\n不存在的引用\n\n引用的引用\n指向引用的指针\n引用数组\n\n\n常引用\n\nconst 必须写在 &amp; 左边，才算是常引用\n\n\n常引用的特点\n\n可以指向临时数据：常量、表达、函数返回值等\n&#x2F;&#x2F; 默认情况下，&amp;ref 只能将变量赋值给它\nint a &#x3D; 10;\nint &amp;ref &#x3D; a;\n\n&#x2F;&#x2F; 常量\nconst int &amp;ref &#x3D; 10;\n\n&#x2F;&#x2F; 表达式\nint a &#x3D; 10;\nint b &#x3D; 20;\n\nconst int &amp;ref &#x3D; a + b;\n\n&#x2F;&#x2F; 函数返回值\nint func()&#123;return 10;&#125;\n\nconst int &amp;ref &#x3D; func();\n\n\n\n可以指向不同类型的数据\nint a &#x3D; 10;\nconst double &amp;ref &#x3D; a;\n\n\n\n作为函数参数时(规则适用于 const指针)\n\n可以接受 const 和 非const 实参(非const 引用，只能接受 非const 实参)\nint sum(const int &amp;a, const int &amp;b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; const实参\n    const int a &#x3D; 10;\n    const int b &#x3D; 20;\n    sum(a, b);\n    sum(10, 20);\n    \n    &#x2F;&#x2F; 非const实参\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n    sum(a, b);\n    \n    return 0;\n&#125;\n\n\n\n可以跟 非const 引用构成重载\n&#x2F;&#x2F; sum_1\nint sum(const int &amp;a, const int &amp;b)\n&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; sum_2\nint sum(int &amp;a, int &amp;b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; const实参\n    const int a &#x3D; 10;\n    const int b &#x3D; 20;\n    \n    &#x2F;&#x2F; 调用 sum_1\n    sum(a, b);\n    sum(10, 20);\n    \n    &#x2F;&#x2F; 非const实参\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n    \n    &#x2F;&#x2F; 调用 sum_2\n    sum(a, b);\n    \n    return 0;\n&#125;\n\n\n\n\n当常量引用指向不同类型的数据时，会产生临时变量，即引用指向的并不是初始化时的那个变量\nint age &#x3D; 10;\nconst long &amp;rAge &#x3D; age;\nage &#x3D; 30;\n\ncout &lt;&lt; &quot;rAge: &quot; &lt;&lt; rAge &lt;&lt; endl;\ncout &lt;&lt; &quot;age: &quot; &lt;&lt; age &lt;&lt; endl;\n\n&#x2F;&#x2F; 运行结果&gt;&gt;\nrAge: 10\nage: 30\n\n利用反汇编分析：\n&#x2F;&#x2F; 查看反汇编\nmov dword ptr[age], 0Ah\n\n&#x2F;&#x2F; 常量引用指向不同类型数据，会产生如下两句；指向同类型不会\nmov eax, dword ptr[age]\nmov dword ptr[temp], eax\n\nlea ecx, [temp]\nmov dword ptr[rAge], ecx\nmov dword prt[age], 1Eh\n\n实际代码：\n&#x2F;&#x2F; 源代码\nint age &#x3D; 10;\nconst long &amp;rAge &#x3D; age;\nage &#x3D; 30;\n\n&#x2F;&#x2F; 实际代码\nint age &#x3D; 10;\nint temp &#x3D; age;\nconst long &amp;rAge &#x3D; temp;\nage &#x3D; 30;\n\n3. 函数进阶3.1 函数默认参数\n在C++中，函数的形参列表中的形参可以有默认值\n\n语法：返回值类型 函数名 （参数 = 默认值）&#123;&#125;\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 无默认值参数，通过调用函数传入参数值\nint func01(int a, int b, int c)\n&#123;\n    return a + b + c;\n&#125;\n\n&#x2F;&#x2F; 有默认值参数，可以通过调用函数传入参数值，也可以不传参数值\nint func02(int a &#x3D; 10, int b &#x3D; 20, int c &#x3D; 30)\n&#123;\n    return a + b + c;\n&#125;\n\n&#x2F;&#x2F; 当函数定义中，有默认参数值的一项形参，其之后的其他形参也要有形参\n&#x2F;&#x2F;int func03(int a &#x3D; 10, int b, int c)\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    return a + b + c;\n&#x2F;&#x2F;&#125;\n\n&#x2F;&#x2F; 函数在声明时，形参有默认值，定义时，形参不得定义默认值\nint func04(int a &#x3D; 10, int b &#x3D; 20);\n\n&#x2F;&#x2F;int func04(int a &#x3D; 20, int b &#x3D; 10)\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    return a + b;\n&#x2F;&#x2F;&#125;\n\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Func01: &quot; &lt;&lt; func01(10, 20, 30) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Func02: &quot; &lt;&lt; func02() &lt;&lt; endl;\n    return 0;\n&#125;\n\n3.1.1 函数默认参数补充\n默认参数可以是全局变量\nint b &#x3D; 20;\n\nint sum(int a &#x3D; 20, b &#x3D; a)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    cout &lt;&lt; sum() &lt;&lt; endl;\n    return 0;\n&#125;\n\n\n\n默认参数可以是函数名(函数所在内存的地址：指针变量)\nvoid test(int a)\n&#123;\n    cout &lt;&lt; &quot;test(int) - &quot; &lt;&lt; a &lt;&lt; endl;\n&#125;\n\nvoid func(int v1, void(*ptr_Test)(int) &#x3D; test)\n&#123;\n    ptr_Test(v1);\n&#125;\n\nint main()\n&#123;\n    func(20, test);\n    return 0;\n&#125;\n\nvoid(*ptr_Test)(int) = test;\nptr_Test(10);\n\n默认参数，需要保证从右到左依次赋予默认参数，不能出现右边形参没有默认值的情况\n\n原理：C++编译转汇编时，调用有默认参数的函数时，先进行push参数，再调用函数，其中优先push最右边的参数值\nvoid sum(int a, int b &#x3D; 2)\n&#123;\n    cout &lt;&lt; a + b;\n&#125;\n\nint main()\n&#123;\n    sum(1);\n    return 0;\n&#125;\n\npush 2\npush 1\ncall sum()\nadd esp, 8\n\n3.2 函数占位参数\nC++函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n\n占位参数可以有默认值\n\n语法：返回值类型 函数名 （数据类型）&#123;&#125;；\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 占位参数可以有默认值\nvoid func1(int a, int &#x3D; 10)\n&#123;\n    cout &lt;&lt; &quot;Func1 Test&quot; &lt;&lt; endl; \n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 有默认值可以不传实参，否则占位参数也要传实参\n    func1(10, 10);\n    return 0;\n&#125;\n\n3.3 函数重载3.3.1 函数重载概述\n作用：函数名可以重复，提高复用性\n\n条件：\n\n同一作用域下\n函数名相同\n函数参数类型不同 或 个数不同 或 顺序不同\n\n\n注意：函数的返回值不可以作为函数重载的条件\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid func()\n&#123;\n    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a)\n&#123;\n    cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a, int b)\n&#123;\n    cout &lt;&lt; &quot;func(int a, int b)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a, double b)\n&#123;\n    cout &lt;&lt; &quot;func(int a, double b)&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 返回值不可以作为函数重载的条件\n&#x2F;&#x2F;int func()\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;\n&#x2F;&#x2F;&#125;\n\nint main()\n&#123;\n    func();\n    func(10);\n    func(10, 20);\n    func(10, 20.20);\n    return 0;\n&#125;\n\n3.3.2 函数重载注意事项\n引用作为重载条件\n\n函数重载碰到函数默认参数\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid func()\n&#123;\n    cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int &amp;a)\n&#123;\n    cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(const int &amp;a)\n&#123;\n    cout &lt;&lt; &quot;func(const int &amp;a)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int &amp;a, int &amp;b)\n&#123;\n    cout &lt;&lt; &quot;func(int &amp;a, int &amp;b)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2(int a)\n&#123;\n    cout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2(int a, int b &#x3D; 10)\n&#123;\n    cout &lt;&lt; &quot;func(int a, int b &#x3D; 10)&quot; &lt;&lt; endl;\n&#125;\n\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n\n    func();\n    func(a);\n    func(10);\n    func(a, b);\n\n    &#x2F;&#x2F; func2 函数有重载，且其中一个参数有默认值\n    &#x2F;&#x2F;func2(a);\n\n    return 0;\n&#125;\n\n3.3.2.1 函数重载补充内容\n函数重载后，并非是所有的重载函数，共同有一个相同的函数名，仅参数不同\nvoid func();\n\nvoid func(int a);\n\nvoid func(int a, int b);\n\n以上三个函数func是重载函数，在编辑器和我们人类的视角中是有着相同的函数名称func；\ncall func_1()\n\ncall func_2()\n\ncall func_3()\n\n以上是当编译时，C++转汇编时，汇编中的情况，同时这些重载函数的内存地址自然也是不一样的；\n但在编译器中，不同版本或类型的编译器，在编译时会这些重载函数进行重新进行命名；\n\n\n3.4 内联函数\n功能描述：编译器会将内联函数的调用，直接展开成函数体\n\n使用inline修饰函数的声明或实现，可以使其变成内联函数(建议声明和实现都使用inline修饰)\n\n代码示例：\ninline int sum(int a, int b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    int c &#x3D; sum(1, 2);\n    return 0;\n&#125;\n\n&#x2F;&#x2F; sum(1, 2)  &#x3D;&gt; a + b;\n\n\n\n内联函数\n\n缺点：会增加代码的体积\n优点：函数调用，需要开辟栈空间，内联函数不需要，节省资源\n\n\n使用场景：\n\n函数的体积不大(不超过10行)\n不会被频繁调用\n\n\n补充知识：\n\n不是所有函数被inline修饰后，编译器都会将其变成内联函数：递归函数\n\n\n通过反汇编查看内联函数\ninline int sum(int a, int b)\n&#123;\n    return a + b;\n&#125;\n\nint main()\n&#123;\n    int c &#x3D; sum(1, 2);\n    return 0;\n&#125;\n\n&#x2F;&#x2F; int c &#x3D; sum(1, 2);\n\n&#x2F;&#x2F; 普通函数--反汇编\npush 0A\npush 0B\ncall sum()\nadd esp, 8\nmov dword ptr[c], eax\n\n&#x2F;&#x2F; 内联函数--反汇编\nmov eax, 0A\nadd eax, 0B\nmov dword ptr[c],\n\n4. 类和对象\nC++面向对象的三大特性：封装，继承，多态\n\n4.1 封装4.1.1 封装的意义\n意义一：\n\n将属性和行为作为一个整体，表现生活中的事物\n将属性和行为加以权限控制\n在设计类时，属性和行为写在一起，表现事物\n\n\n语法：class 类名 &#123; 访问权限：属性 / 行为 &#125;；\n\n示例1：设计一个圆，求圆的周长\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 类名 （圆）\nclass Circle\n&#123;\n    &#x2F;&#x2F; 权限（公开）\npublic:\n    &#x2F;&#x2F; 属性\n    const double Pi &#x3D; 3.14;\n    double cir_R;\n\n    &#x2F;&#x2F; 计算圆周长的函数\n    double calculatePerimeter()\n    &#123;\n        return  2 * Pi * cir_R;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 通过Circle类创建一个实例（对象） c1\n    Circle c1;\n    &#x2F;&#x2F; 通过对象，对类中的属性 cir_R 进行赋值 \n    c1.cir_R &#x3D; 10.0;\n    double value &#x3D; c1.calculatePerimeter();\n    cout &lt;&lt; &quot;Circle perimeter : &quot; &lt;&lt; value &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n示例2：设计一个学生类，属性有姓名和学号，对属性进行赋值，并显示属性信息（两种写法）\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Student\n&#123;\npublic:\n    string stu_Name;\n    int stu_ID;\n\n    void printStudentInfo()\n    &#123;\n        cout &lt;&lt; &quot;Student Info : &quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; stu_Name &lt;&lt; &quot;  ID: &quot; &lt;&lt; stu_ID &lt;&lt; endl;\n    &#125;\n&#125;;\n\n\nint main()\n&#123;\n    Student s1;\n    s1.stu_ID &#x3D; 123456;\n    s1.stu_Name &#x3D; &quot;FH&quot;;\n    s1.printStudentInfo();\n\n    return 0;\n&#125;\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Student\n&#123;\npublic:\n    string stu_Name;\n    int stu_ID;\n\n    void setName(string name)\n    &#123;\n        stu_Name &#x3D; name;\n    &#125;\n\n    void setID(int id)\n    &#123;\n        stu_ID &#x3D; id;\n    &#125;\n\n    void printStudentInfo()\n    &#123;\n        cout &lt;&lt; &quot;Student Info : &quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; stu_Name &lt;&lt; &quot;  ID: &quot; &lt;&lt; stu_ID &lt;&lt; endl;\n    &#125;\n&#125;;\n\n\nint main()\n&#123;\n    Student s1;\n    s1.setName(&quot;FH&quot;);\n    s1.setID(123456);\n    s1.printStudentInfo();\n\n    Student s2;\n    s2.setName(&quot;CYL&quot;);\n    s2.setID(666666);\n    s2.printStudentInfo();\n\n    return 0;\n&#125;\n\n意义二：不属性和行为放在不同的权限下，加以控制\n\n访问权限三种：\n\n\n\npublic 公开\n成员类内可访问，类外可访问\n子类可访问\n\n\n\nprotected 保护\n成员类内可访问，类外不可访问\n子类可访问保护内容\n\n\nprivate 私有\n成员类内可访问，类外不可访问\n子类不可访问私有内容\n\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n\nprotected:\n    string car;\n\nprivate:\n    int password;\n\nprivate:\n    void func()\n    &#123;\n        name &#x3D; &quot;FH&quot;;\n        car &#x3D; &quot;XXX&quot;;\n        password &#x3D; 123456;\n    &#125;\n&#125;;\n\n\nint main()\n&#123;\n    Person p1;\n    p1.name &#x3D; &quot;CYL&quot;;\n\n    &#x2F;&#x2F;p1.car &#x3D; &quot;YYY&quot;; &#x2F;&#x2F; 保护权限内容，类外不可访问和修改\n    &#x2F;&#x2F;p1.password &#x3D; 999999; &#x2F;&#x2F; 私有权限内容，类外不可访问和修改\n    return 0;\n&#125;\n\n4.1.2 struct和class区别\n区别：struct 默认权限为公开；class默认权限为私有\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass C1\n&#123;\n    int a;\n&#125;;\n\nstruct C2\n&#123;\n    int a;\n&#125;;\n\nint main()\n&#123;\n    C1 c1;\n    C2 c2;\n    \n    &#x2F;&#x2F;c1.a &#x3D; 10; &#x2F;&#x2F; class默认私有，无法访问\n    c2.a &#x3D; 10; &#x2F;&#x2F; struct默认公开，可以访问\n    \n    return 0;\n&#125;\n\n4.1.3 成员属性私有化\n优点：\n\n将所有成员属性设置为私有，可以自己控制读写权限\n对于写权限，可以检测数据的有效性\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    void setName(string name)\n    &#123;\n        p_Name &#x3D; name;\n    &#125;\n    string getName()\n    &#123;\n        return p_Name;\n    &#125;\n\n    int getAge()\n    &#123;\n        p_Age &#x3D; 24;\n        return p_Age;\n    &#125;\n\n    void setID(int id)\n    &#123;\n        p_ID &#x3D; id;\n    &#125;\n\nprivate:\n    string p_Name; &#x2F;&#x2F; 可读可写\n    int p_Age; &#x2F;&#x2F; 可读\n    int p_ID; &#x2F;&#x2F; 可写\n&#125;;\n\nint main()\n&#123;\n    Person p;\n    p.setName(&quot;FH&quot;);\n    p.setID(123455);\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n    cout &lt;&lt; &quot;Age: &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n4.1.4 案例：设计立方体\n要求：设计立法体类（cube），求面积和体积，分别用全局函数和成员函数判断两个立方体是否相等\n\n代码：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Cube\n&#123;\nprivate:\n    float c_Length &#x3D; 1.0;\n    float c_Width &#x3D; 1.0;\n    float c_Height &#x3D; 1.0;\n\npublic:\n    void setLength(float length)\n    &#123;\n        c_Length &#x3D; length;\n    &#125;\n\n    float getLength() const\n    &#123;\n        return c_Length;\n    &#125;\n\n    void setWidth(float width)\n    &#123;\n        c_Width &#x3D; width;\n    &#125;\n\n    float getWidth() const\n    &#123;\n        return c_Width;\n    &#125;\n\n    void setHeight(float height)\n    &#123;\n        c_Height &#x3D; height;\n    &#125;\n\n    float getHeight() const\n    &#123;\n        return c_Height;\n    &#125;\n\n    float calculateArea() const\n    &#123;\n        return 2 * c_Length * c_Width + 2 * c_Length * c_Height + 2 * c_Width * c_Height;\n    &#125;\n\n    float calculateVolume() const\n    &#123;\n        return c_Height * c_Width * c_Length;\n    &#125;\n\n    &#x2F;&#x2F; 成员函数判断两个立方体是否相等\n    string calculateSameFromClass(Cube &amp;c) const\n    &#123;\n        if (c.getLength() &#x3D;&#x3D; c_Length &amp;&amp; c.getWidth() &#x3D;&#x3D; c_Width &amp;&amp; c.getHeight() &#x3D;&#x3D; c_Height)\n        &#123;\n            return &quot;Class_Same!!!&quot;;\n        &#125;\n        return &quot;Class_No Same!!!&quot;;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 全局函数判断两个立方体是否相等\nstring calculateSameFromGlobal(Cube &amp;c1, Cube &amp;c2)\n&#123;\n    if (c1.getHeight() &#x3D;&#x3D; c2.getHeight() &amp;&amp; c1.getWidth() &#x3D;&#x3D; c2.getWidth() &amp;&amp; c1.getLength() &#x3D;&#x3D; c2.getLength())\n    &#123;\n        return &quot;Global_Same!!!&quot;;\n    &#125;\n    return &quot;Global_No Same!!!&quot;;\n&#125;\n\nint main()\n&#123;\n    Cube c1;\n    Cube c2;\n    Cube c3;\n\n    c1.setHeight(10.0);\n    c1.setLength(10.0);\n    c1.setWidth(10.0);\n\n    c2.setHeight(10.0);\n    c2.setLength(10.0);\n    c2.setWidth(10.0);\n\n    c3.setHeight(20.0);\n    c3.setLength(20.0);\n    c3.setWidth(20.0);\n\n    &#x2F;&#x2F; 存储立方体的面积以及体积返回的值\n    float cube_Area &#x3D; c1.calculateArea();\n    float cube_Volume &#x3D; c1.calculateVolume();\n\n    &#x2F;&#x2F; 存储两种函数等到的判断返回结果\n    string global_Same &#x3D; calculateSameFromGlobal(c1, c2);\n    string class_Same &#x3D; c1.calculateSameFromClass(c3);\n\n    cout &lt;&lt; &quot;Cube Area: &quot; &lt;&lt; cube_Area &lt;&lt; endl;\n    cout &lt;&lt; &quot;Cube Volume: &quot; &lt;&lt; cube_Volume &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;Global_Same: &quot; &lt;&lt; global_Same &lt;&lt; endl;\n    cout &lt;&lt; &quot;Class_Same: &quot; &lt;&lt; class_Same &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n4.1.5 案例：点圆的关系\n要求：设计圆类（Circle）设计点类（Point），计算点和圆的包含关系（圆外）（圆上）（圆内）（圆心）\n\n代码：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 点类\nclass Point\n&#123;\nprivate:\n    &#x2F;&#x2F; 点X坐标\n    double p_X;\n    &#x2F;&#x2F; 点Y坐标\n    double p_Y;\n\npublic:\n    void set_X(double x)\n    &#123;\n        p_X &#x3D; x;\n    &#125;\n    double get_X() const\n    &#123;\n        return p_X;\n    &#125;\n\n    void set_Y(double y)\n    &#123;\n        p_Y &#x3D; y;\n    &#125;\n    double get_Y() const\n    &#123;\n        return p_Y;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 圆类\nclass Circle\n&#123;\nprivate:\n    &#x2F;&#x2F; 圆的半径\n    double c_Radius;\n    &#x2F;&#x2F; 圆心的坐标\n    Point c_Center;\n\npublic:\n    void setRadius(double radius)\n    &#123;\n        c_Radius &#x3D; radius;\n    &#125;\n    double getRadius() const\n    &#123;\n        return c_Radius;\n    &#125;\n\n    void setCenter(Point &amp;center)\n    &#123;\n        c_Center &#x3D; center;\n    &#125;\n    Point getCenter()\n    &#123;\n        return c_Center;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 计算圆与点之间的关系\nvoid calculateCircleAndPoint(Circle &amp;c, Point &amp;p)\n&#123;\n    &#x2F;&#x2F; 圆心点X - 点X\n    double ppDistanceX &#x3D; c.getCenter().get_X() - p.get_X();\n    &#x2F;&#x2F; 圆心点Y - 点Y\n    double ppDistanceY &#x3D; c.getCenter().get_Y() - p.get_X();\n    &#x2F;&#x2F; 圆的半径\n    double rDistanceR &#x3D; c.getRadius();\n\n    &#x2F;&#x2F; 分别计算：圆心X到点X的平方值，圆心Y到点Y的平方值，圆半径的平方值\n    double powX &#x3D; pow(ppDistanceX, 2);\n    double powY &#x3D; pow(ppDistanceY, 2);\n    double powR &#x3D; pow(rDistanceR, 2);\n\n    &#x2F;&#x2F; 等到判断关系值 （x - x1）^2 + (y - y1)^2 &#x3D; r^2\n    double ppDistance &#x3D; powX + powY;\n    double rDistance &#x3D; powR;\n\n\n    if (ppDistance &#x3D;&#x3D; rDistance)\n    &#123;\n        cout &lt;&lt; &quot;Point On The Circle&quot; &lt;&lt; endl;\n    &#125;\n    else if (ppDistance &lt; rDistance)\n    &#123;\n        cout &lt;&lt; &quot;Point Within The Circle&quot; &lt;&lt; endl;\n    &#125;\n    else if (ppDistance &gt; rDistance)\n    &#123;\n        cout &lt;&lt; &quot;Point Outside The Circle&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; 实例化一个圆\n    Circle c&#123;&#125;;\n    &#x2F;&#x2F; 实例化一个圆心的坐标 和 点的坐标\n    Point p_center&#123;&#125;;\n    Point p&#123;&#125;;\n\n    p_center.set_X(10.0);\n    p_center.set_Y(0);\n    p.set_X(10.0);\n    p.set_Y(10.0);\n    c.setRadius(10.0);\n    c.setCenter(p_center);\n\n    calculateCircleAndPoint(c, p);\n\n    return 0;\n&#125;\n\n4.2 对象初始化和清理\nC++中每个对象都有初始设置以及对象销毁前的清理数据的设置\n\n4.2.1 构造函数和析构函数问题：\n\n对象的初始化和清理是两个很重要的安全问题\n一个对象或者变量没有初始化状态，使用的后果是未知的\n使用完一个对象或变量，没有及时清理，也会造成安全问题\n\n解决：\n\nC++利用构造函数和析构函数解决问题，这两个函数被编译器自动调用，完成对象的初始化和清理工作\n对象的初始化和清理工作是编译器强制要求的，如果不提供构造函数和析构函数，编译器会提供编译器提供的构造函数和析构函数是空实现\n\n含义：\n\n构造函数：主要为创建对象时为对象的成员属性赋值，构造函数由编译器自动调用\n析构函数：主要为对象销毁前系统自动调用，执行清理工作\n\n构造函数语法：类名（）&#123;&#125;;\n\n构造函数，没有返回值和void\n函数名称和类名相同\n构造函数可以有参数，所以可以重载\n程序在调用对象时，会自动调用构造函数，且只调用一次\n\n析构函数语法：~ 类名（）&#123;&#125;;\n\n析构函数，没有返回值和void\n函数名称和类名不相同，在前面加 ~\n构造函数部可以有参数，所以不可以重载\n程序在调用对象时，会自动调用析构函数，且只调用一次\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Test\n&#123;\npublic:\n    Test()\n    &#123;\n        cout &lt;&lt; &quot;Test构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Test()\n    &#123;\n        cout &lt;&lt; &quot;Test析构函数&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Test t1;\n&#125;\n\nint main()\n&#123;\n    demo(); &#x2F;&#x2F; 函数执行时调用构造函数，结束时调用析构函数\n    Test t2; &#x2F;&#x2F; 函数执行时调用构造函数\n    system(&quot;pause&quot;); &#x2F;&#x2F; 程序在此处暂停，析构函数为被调用，按任意键后执行析构函数\n    return 0;\n&#125;\n\n\n\n\n\n4.2.2 构造函数分类及调用\n分类：\n\n按参数分为：有参构造，无参构造\n按类型分为：普通构造，拷贝构造\n\n\n调用：\n\n括号法\n显示法\n隐式转换法\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\n\npublic:\n    &#x2F;&#x2F; 创建构造函数\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int a)\n    &#123;\n        age &#x3D; a;\n        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(const Person &amp;p) &#x2F;&#x2F; 将对象的属性拷贝进来\n    &#123;\n        age &#x3D; p.age;\n        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;\n    &#125;\n\n    int age;\n&#125;;\n\n&#x2F;&#x2F; 调用构造函数\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 括号法调用\n    &#x2F;&#x2F; 注意：无参构造函数不用括号：Person p1(); 编译器会作为 void func(); 声明来处理，调用空实现的构造函数\n    Person p1; &#x2F;&#x2F; 无参构造函数\n    Person p2(10); &#x2F;&#x2F; 有参构造函数\n    Person p3(p2); &#x2F;&#x2F; 拷贝构造函数\n\n    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.age &lt;&lt; endl;\n    cout &lt;&lt; &quot;p3 age: &quot; &lt;&lt; p3.age &lt;&lt; endl;\n\n    &#x2F;&#x2F; 显示法调用\n    Person p4;\n    Person p5 &#x3D; Person(20);\n    Person p6 &#x3D; Person(p5);\n    &#x2F;&#x2F; 注意 Person(20) 单独写出来为匿名对象，程序中无法使用，执行完会被系统立即回收\n    &#x2F;&#x2F; 注意 不用拷贝函数初始化匿名对象，Person(p6) 编译器等价于 Person p6 , 而 Person p6 已经作为对象被实例化了\n\n    &#x2F;&#x2F; 隐式转换法调用\n    Person p7 &#x3D; 10; &#x2F;&#x2F; 等价于 Person p7 &#x3D; Person(10);\n    Person p8 &#x3D; p7;\n\n    system(&quot;pause&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.2.3 拷贝构造函数调用时机\nC++中拷贝构造函数调用时机三种情况\t\n\n使用一个已经创建的对象来初始化一个新对象\n值传递的方式给函数参数传值\n以值方式返回局部对象\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int p_age;\n\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int a)\n    &#123;\n        p_age &#x3D; a;\n        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(const Person &amp;person)\n    &#123;\n        p_age &#x3D; person.p_age;\n        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;1. 使用一个已经创建的对象来初始化一个新对象\nvoid demo1()\n&#123;\n    Person p1(10); &#x2F;&#x2F; 有参构造\n    Person p2(p1); &#x2F;&#x2F; 拷贝构造\n    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.p_age &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;2. 值传递的方式给函数参数传值\nvoid test2(Person person)\n&#123;\n\n&#125;\n\nvoid demo2()\n&#123;\n    Person p3; &#x2F;&#x2F; 默认构造\n    test2(p3); &#x2F;&#x2F; 拷贝构造 - 此处 p3 为p3对象的副本（拷贝）\n&#125;\n\n&#x2F;&#x2F;3. 以值方式返回局部对象\nPerson test3()\n&#123;\n    Person p4; &#x2F;&#x2F; 默认构造\n    cout &lt;&lt; &quot;p4 address: &quot; &lt;&lt; (int *) &amp;p4 &lt;&lt; endl;\n    return p4; &#x2F;&#x2F; 此处 p4 为p4对象的副本（拷贝）\n&#125;\n\nvoid demo3()\n&#123;\n    Person p5 &#x3D; test3(); &#x2F;&#x2F; 拷贝构造 - 得到 p4 的对象副本\n    cout &lt;&lt; &quot;p5 address: &quot; &lt;&lt; (int *) &amp;p5 &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F;demo1();\n    &#x2F;&#x2F;demo2();\n    demo3();\n    return 0;\n&#125;\n\n4.2.4 构造函数调用规则\n默认情况下，C++编译器至少给一个类添三个函数\n\n默认构造函数（无参，函数体为空）\n默认析构函数（无参，函数体为空）\n默认拷贝构造函数 对类实例化的对象的属性值拷贝\n\n\n调用规则：\n\n如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数\n如果自定义拷贝构造函数，编译器不提供其他构造函数\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int p_age;\n\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int a)\n    &#123;\n        p_age &#x3D; a;\n        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(const Person &amp;person)\n    &#123;\n        p_age &#x3D; person.p_age;\n        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参析构函数&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;1. 如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数\nvoid demo1() &#x2F;&#x2F; 默认构造函数不会被调用\n&#123;\n    Person p1(10);\n    Person p2(p1);\n&#125;\n\n&#x2F;&#x2F;2. 如果自定义拷贝构造函数，编译器不提供其他构造函数\nvoid demo2() &#x2F;&#x2F; 自定义拷贝构造函数后，其他构造函数需自己添加\n&#123;\n Person p3;\n Person p4(p3);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n4.2.5 深拷贝和浅拷贝\n深拷贝：在堆区重新申请空间，进行拷贝操作\n\n浅拷贝：简单的赋值拷贝（编译器默认提供的拷贝构造函数就是浅拷贝）\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int p_age;\n    int *p_height;\n\n    Person()\n    &#123;\n        cout &lt;&lt; &quot;Person无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    Person(int a, int height)\n    &#123;\n        cout &lt;&lt; &quot;Person有参构造函数&quot; &lt;&lt; endl;\n        p_age &#x3D; a;\n        p_height &#x3D; new int(height);\n    &#125;\n\n    &#x2F;&#x2F; 通过深拷贝的方法解决浅拷贝带来的问题 深拷贝定义后，编译器默认执行该构造函数\n    Person(const Person &amp;person)\n    &#123;\n        cout &lt;&lt; &quot;Person拷贝构造函数&quot; &lt;&lt; endl;\n        p_age &#x3D; person.p_age;\n        p_height &#x3D; new int(*person.p_height); &#x2F;&#x2F; 自定义的赋值方式，堆中开辟空间\n        &#x2F;&#x2F;p_height &#x3D; person.p_height; &#x2F;&#x2F; 编译器默认的赋值方式\n    &#125;\n\n&#x2F;&#x2F; 浅拷贝时，p2 内的 p_height 被释放，p1 无可释放，程序执行非法操作（报错）\n&#x2F;&#x2F; 深拷贝时，p2 内的 p_height 是单独的堆区空间被释放，不影响 p1 的 p_height 内存释放（正确）\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;Person析构函数&quot; &lt;&lt; endl;\n        if (p_height !&#x3D; NULL)\n        &#123;\n            delete p_height;\n            p_height &#x3D; NULL;\n        &#125;\n    &#125;\n&#125;;\n\nvoid demoTest() &#x2F;&#x2F; 栈区内存释放的顺序是先进后出，所以析构函数 释放内存是从 p2 开始\n&#123;\n    Person p1(10, 170);\n    cout &lt;&lt; &quot;p1 age: &quot; &lt;&lt; p1.p_age &lt;&lt; &quot; p1 height: &quot; &lt;&lt; *p1.p_height &lt;&lt; endl;\n    Person p2(p1); &#x2F;&#x2F; 编译器提供的浅构造函数，解析的是p1指针指向的内存空间\n    cout &lt;&lt; &quot;p2 age: &quot; &lt;&lt; p2.p_age &lt;&lt; &quot; p2 height: &quot; &lt;&lt; *p2.p_height &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demoTest();\n    return 0;\n&#125;\n\n4.2.6 初始化列表\n作用：C++提供初始化列表，用来初始化属性\n\n语法：构造函数（）：属性1（值1），属性2（值2）... &#123;&#125;\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int p_a;\n    int p_b;\n\n    &#x2F;&#x2F; 通过有参构造函数初始化属性值\n&#x2F;&#x2F;    Person(int a, int b)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        p_a &#x3D; a;\n&#x2F;&#x2F;        p_b &#x3D; b;\n&#x2F;&#x2F;    &#125;\n\n&#x2F;&#x2F; 通过初始化列表来初始化属性值\n    Person(int a, int b) : p_a(a), p_b(b)\n    &#123;\n\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Person p1(10, 20);\n    cout &lt;&lt; &quot;p1 a: &quot; &lt;&lt; p1.p_a &lt;&lt; endl;\n    cout &lt;&lt; &quot;p1 b: &quot; &lt;&lt; p1.p_b &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n4.2.7 类对象作为类成员\nC++类中的成员可以说另一个类的对象，称为：对象成员\n\n例如：\nclass A &#123;&#125;\nclass B\n&#123;\n    A a;\n&#125;\n\nB类中有对象作为成员，A为对象成员\n\n程序执行时，先构造A，再构造B\n\n程序结束时，先析构B，再析构A\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Phone\n&#123;\npublic:\n    string p_Name;\n\n    Phone(string name)\n    &#123;\n        cout &lt;&lt; &quot;Phone 构造函数调用 (先构造)&quot; &lt;&lt; endl;\n        p_Name &#x3D; name;\n    &#125;\n\n    ~Phone()\n    &#123;\n        cout &lt;&lt; &quot;Phone 析构函数调用&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Human\n&#123;\npublic:\n    string h_Name;\n    Phone h_Phone;\n\n    Human(string name, string phone) : h_Name(name), h_Phone(phone)\n    &#123;\n        cout &lt;&lt; &quot;Human 构造函数调用&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Human()\n    &#123;\n        cout &lt;&lt; &quot;Human 析构函数调用 (先析构)&quot; &lt;&lt; endl;\n    &#125;\n\n&#125;;\n\nvoid demo()\n&#123;\n    Human h(&quot;FH&quot;, &quot;Apple&quot;);\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; h.h_Name &lt;&lt; &quot; Phone: &quot; &lt;&lt; h.h_Phone.p_Name &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.2.8 静态成员\n定义：在成员变量和成员函数前加关键字static，称为静态成员\n\n分类：\n\n静态成员变量\n所有对象共享一份数据\n在编译阶段分配内存\n类内声明，类外初始化\n\n\n静态成员函数\n所有对象共享一个函数\n静态成员函数只能访问静态成员变量\n\n\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    static int p_num; &#x2F;&#x2F; 静态成员变量 类内声明\n\n    static void func() &#x2F;&#x2F; 静态成员函数\n    &#123;\n        p_num &#x3D; 100;\n        cout &lt;&lt; &quot;num: &quot; &lt;&lt; p_num &lt;&lt; endl;\n    &#125;\n\nprivate: &#x2F;&#x2F; 静态成员变量的访问权限可以为私密 类外无法访问\n    static void func2()\n    &#123;\n        cout &lt;&lt; &quot;private func2&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint Person::p_num &#x3D; 0; &#x2F;&#x2F; 静态成员变量 类外初始化\n\nint main()\n&#123;\n    &#x2F;&#x2F; 通过对象访问\n    Person p;\n    p.func();\n\n    &#x2F;&#x2F; 通过类名访问 （静态成员函数可以直接通过类的作用域直接调用）\n    Person::func();\n\n    return 0;\n&#125;\n\n4.3 对象模型和this指针4.3.1 成员变量和成员函数分开存储\nC++中，类内的成员变量和成员函数分开存储\n\n只有非静态成员变量才属于类的对象上\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass demo1\n&#123;\n    &#x2F;&#x2F; 空对象 默认 占内存空间 1\n&#125;;\n\nclass demo2\n&#123;\n    int num &#x3D; 0; &#x2F;&#x2F; 非空对象 占内存空间 依据成员变量\n&#125;;\n\nclass demo3\n&#123;\n    int num3 &#x3D; 0;\n    static int s_num; &#x2F;&#x2F; 静态成员变量 不在类的对象上\n\n    void func()\n    &#123;\n        &#x2F;&#x2F; 成员函数 不在类的对象上 (无论是否静态)\n    &#125;\n&#125;;\n\nint demo3::s_num &#x3D; 0;\n\nvoid Test1()\n&#123;\n    cout &lt;&lt; &quot;Size of demo1: &quot; &lt;&lt; sizeof(demo1) &lt;&lt; endl;\n&#125;\n\nvoid Test2()\n&#123;\n    cout &lt;&lt; &quot;Size of demo2: &quot; &lt;&lt; sizeof(demo2) &lt;&lt; endl;\n&#125;\n\nvoid Test3()\n&#123;\n    cout &lt;&lt; &quot;Size of demo3: &quot; &lt;&lt; sizeof(demo3) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    Test1();\n    Test2();\n    Test3();\n\n    return 0;\n&#125;\n\n4.3.2 this指针概念\n作用：this指针指向被调用的成员函数所属对象\n\nthis指针是隐含每个非静态成员函数的一种指针\n\nthis指针不需定义，直接使用\n\n用途：\n\n当形参和成员变量同名时，可用this指针来区分\n在类的非静态成员函数返回对象本身，可使用 return *this；\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int age;\n\n    Person(int age)\n    &#123;\n        &#x2F;&#x2F; this可以区分相同名称的变量\n        this-&gt;age &#x3D; age;\n    &#125;\n\n    &#x2F;&#x2F;返回的是Person对象的引用\n    Person &amp;addPersonAge(Person &amp;p)\n    &#123;\n        this-&gt;age +&#x3D; p.age;\n        return *this; &#x2F;&#x2F; 返回对象为 *this\n    &#125;\n&#125;;\n\nvoid func1()\n&#123;\n    Person p1(10);\n    cout &lt;&lt; &quot;p1 Age: &quot; &lt;&lt; p1.age &lt;&lt; endl;\n&#125;\n\nvoid func2()\n&#123;\n    Person p2(20);\n    Person p3(20);\n    &#x2F;&#x2F; 链式编程思想\n    &#x2F;&#x2F; p3.addPersonAge(p2) 的执行结果是返回 对象的本身，所以可以链式调用成员函数\n    p3.addPersonAge(p2).addPersonAge(p2).addPersonAge(p2);\n    cout &lt;&lt; &quot;p3 Age: &quot; &lt;&lt; p3.age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    func1();\n    func2();\n    return 0;\n&#125;\n\n4.3.3 空指针访问成员函数\nC++中空指针可以调用成员函数，但要注意是否用到this\n\n如果用到this，需要加上判断，保证代码的安全\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Demo\n&#123;\npublic:\n    int age &#x3D; 10;\n\n    void func1()\n    &#123;\n        cout &lt;&lt; &quot;func1&quot; &lt;&lt; endl;\n    &#125;\n\n    void func2()\n    &#123;\n        &#x2F;&#x2F; 为保证安全性，防止传入的空指针调用成员变量导致崩溃\n        if (this &#x3D;&#x3D; NULL)\n        &#123;\n            return;\n        &#125;\n        &#x2F;&#x2F; 此处的this 《&#x3D;&#x3D;》 this.age this是空的，无实际对象，无法调用\n        cout &lt;&lt; &quot;func2 &quot; &lt;&lt; age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid test()\n&#123;\n    &#x2F;&#x2F; 创建一个对象的地址为空\n    Demo *d &#x3D; NULL;\n    d-&gt;func1();\n    d-&gt;func2();\n&#125;\n\nint main()\n&#123;\n    test();\n    return 0;\n&#125;\n\n4.3.4 const修饰成员函数\n常函数：\n\n成员函数后加const，该函数称为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable，在常函数中依然可以修改\n\n\n常对象\n\n声明对象前加const，则称为常对象\n常对象只能调用常函数\n\n\n示例：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int age;\n    &#x2F;&#x2F; mutable 修饰的成员变量\n    mutable int id;\n\n    &#x2F;&#x2F; this指针是指针常量，指针的指向不可修改\n    &#x2F;&#x2F; const Person *const this；\n    &#x2F;&#x2F; 常量函数的const 修饰的this指针 让this指针指向的值也不可修改\n    void printAge() const\n    &#123;\n        &#x2F;&#x2F; this-&gt;age &#x3D; 10;\n\n        &#x2F;&#x2F; 常函数可以修改 mutable的值\n        this-&gt;id &#x3D; 10;\n    &#125;\n\n    void printID()\n    &#123;\n\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 常对象\n    const Person p&#123;&#125;;\n\n    p.printAge();\n    &#x2F;&#x2F;p.printID(); &#x2F;&#x2F; 常对象只能调用 常函数\n\n    &#x2F;&#x2F;p.age &#x3D; 100; &#x2F;&#x2F; 常对象内的成员变量属性值不能修改\n    p.id &#x3D; 100; &#x2F;&#x2F; 常对象内的mutable成员变量属性值能修改\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.4 友元\n作用：目的是让一个函数或者类访问另一个类中的私有成员\n关键字：friend\n实现：\n全局函数做友元\n类做友元\n成员函数做友元\n\n\n\n4.4.1 全局函数做友元#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Room\n&#123;\n    &#x2F;&#x2F; 将一个全局函数 在类中 通过friend关键在修饰 声明后，该全局函数可以访问 类中私有的成员变量属性\n    friend void Func_Friend(Room *room);\nprivate:\n    string privateRoom;\n\npublic:\n    string publicRoom;\n\n    Room()\n    &#123;\n        privateRoom &#x3D; &quot;privateRoom Access Succeeded&quot;;\n        publicRoom &#x3D; &quot;publicRoom Access Succeeded&quot;;\n    &#125;\n&#125;;\n\nvoid Func_Friend(Room *room)\n&#123;\n    cout &lt;&lt; &quot;Friend Function Access: &quot; &lt;&lt; room-&gt;publicRoom &lt;&lt; endl;\n    &#x2F;&#x2F; 声明友元后，可以正常访问类中的私有成员变量\n    cout &lt;&lt; &quot;Friend Function Access: &quot; &lt;&lt; room-&gt;privateRoom &lt;&lt; endl;\n&#125;\n\nvoid Test()\n&#123;\n    Room room;\n    Func_Friend(&amp;room);\n&#125;\n\nint main()\n&#123;\n    Test();\n    return 0;\n&#125;\n\n\n\n\n\n4.4.2 类做友元#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 先声明一个 Service类\nclass Service;\n\nclass User\n&#123;\nprivate:\n    &#x2F;&#x2F; 定义一个 私有 Service类对象的指针\n    Service *service;\n\npublic:\n    &#x2F;&#x2F; 构造函数和成员函数写在类外\n    User();\n    void access();\n&#125;;\n\nclass Service\n&#123;\n    &#x2F;&#x2F; 将 User类 声明为 Service类的友元类 使得User类的对象是 Service类得到友元对象，可以访问私有成员变量的属性\n    friend class User;\nprivate:\n    string priContent;\n\npublic:\n    string pubContent;\n\n    &#x2F;&#x2F; 构造函数声明在外\n    Service();\n&#125;;\n\n&#x2F;&#x2F; 通过User类的作用域创建一个User类的构造函数，初始化User类中的成员变量的属性值\nUser::User()\n&#123;\n    &#x2F;&#x2F; 创建一个Service类的对象指针\n    service &#x3D; new Service;\n&#125;\n\n&#x2F;&#x2F; 通过User类的作用域创建一个User类的成员函数\nvoid User::access()\n&#123;\n    cout &lt;&lt; &quot;User Access Service: &quot; &lt;&lt; service-&gt;pubContent &lt;&lt; endl;\n    &#x2F;&#x2F; 当User类成为Service类的友元后，可以在User的函数内访问 Service类中的私有成员变量属性\n    cout &lt;&lt; &quot;User Access Service: &quot; &lt;&lt; service-&gt;priContent &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 通过Service类的作用域创建一个Service类的构造函数\nService::Service()\n&#123;\n    this-&gt;priContent &#x3D; &quot;priContent&quot;;\n    this-&gt;pubContent &#x3D; &quot;pubContent&quot;;\n&#125;\n\nvoid demo()\n&#123;\n    User user;\n    user.access();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n\n\n\n\n4.4.3 成员函数做友元#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Service;\n\nclass User\n&#123;\npublic:\n    Service *service;\n\n    User();\n\n    void access1();\n    void access2();\n&#125;;\n\nclass Service\n&#123;\n    &#x2F;&#x2F; 通过friend关键字 声明User类中的成员函数access2() 是Service类的友元函数\n    friend void User::access2();\nprivate:\n    string priContent;\n\npublic:\n    string pubContent;\n\n    Service();\n&#125;;\n\n&#x2F;&#x2F; User类和Service类的构造函数和成员函数在类外创建，类内声明\nUser::User()\n&#123;\n    service &#x3D; new Service;\n&#125;\n\nvoid User::access1()\n&#123;\n    cout &lt;&lt; &quot;Access pubContent: &quot; &lt;&lt; service-&gt;pubContent &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 访问Service类中的私有成员变量的属性\nvoid User::access2()\n&#123;\n    cout &lt;&lt; &quot;Access priContent: &quot; &lt;&lt; service-&gt;priContent &lt;&lt; endl;\n&#125;\n\nService::Service()\n&#123;\n    priContent &#x3D; &quot;priContent&quot;;\n    pubContent &#x3D; &quot;pubContent&quot;;\n&#125;\n\nvoid demo()\n&#123;\n    User user;\n    user.access1();\n    user.access2();\n&#125;\n\nint main()\n&#123;\n    demo();\n\n    return 0;\n&#125;\n\n\n\n\n\n4.5 运算符重载\n概念：对已有的运算符进行重新的定义，赋予另一种功能，以适应不同的数据类型\n\n4.5.1 加号运算符重载\n作用：实现两个自定义数据类型相加的运算\n\n编辑器提供了通用名称：operator+\n\n内置的不能使用运算符重载，只有自定义类型的可以使用\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2020&#x2F;8&#x2F;11.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Num\n&#123;\npublic:\n    int num1;\n    int num2;\n\n    &#x2F;&#x2F; 类中 成员函数 实现的 重载运算‘+’\n    Num operator+(Num &amp;n) const\n    &#123;\n        Num my_n&#123;&#125;;\n        my_n.num1 &#x3D; this-&gt;num1 + n.num1;\n        my_n.num2 &#x3D; this-&gt;num2 + n.num2;\n        return my_n;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 全局函数 运算符重载的默认写法\nNum operator+(Num &amp;n1, Num &amp;n2)\n&#123;\n    Num my_n&#123;&#125;;\n    my_n.num1 &#x3D; n1.num1 + n2.num1;\n    my_n.num2 &#x3D; n1.num2 + n2.num2;\n    return my_n;\n&#125;\n\n&#x2F;&#x2F; 运算符函数 重载\nNum operator+(Num &amp;n, int num)\n&#123;\n    Num my_n&#123;&#125;;\n    my_n.num1 &#x3D; n.num1 + num;\n    my_n.num2 &#x3D; n.num2 + num;\n    return my_n;\n&#125;\n\nvoid demo1()\n&#123;\n    Num n1&#123;&#125;;\n    n1.num1 &#x3D; 10;\n    n1.num2 &#x3D; 10;\n\n    Num n2&#123;&#125;;\n    n2.num1 &#x3D; 5;\n    n2.num2 &#x3D; 5;\n\n    Num n3&#123;&#125;;\n    &#x2F;&#x2F; 重载后的简化写法\n    n3 &#x3D; n1 + n2;\n\n    &#x2F;&#x2F; 成员函数 重载的默认写法\n    &#x2F;&#x2F; n3 &#x3D; n1.operator+(n2);\n\n    &#x2F;&#x2F; 全局函数 重载的默认写法\n    &#x2F;&#x2F; n3 &#x3D; operator+(n1, n2);\n\n    cout &lt;&lt; &quot;Operator: n3 &#x3D; n1 + n2 &#x3D; &quot; &lt;&lt; n3.num1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;Operator: n3 &#x3D; n1 + n2 &#x3D; &quot; &lt;&lt; n3.num2 &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    Num n4&#123;&#125;;\n    n4.num1 &#x3D; 20;\n\n    int num2 &#x3D; 10;\n\n    &#x2F;&#x2F; 重载运算符函数的 重载写法 （Num类型 + int类型）\n    Num n5 &#x3D; n4 + num2;\n\n    cout &lt;&lt; &quot;Operator: n5 &#x3D; n4 + num2 &#x3D; &quot; &lt;&lt; n5.num1 &lt;&lt;endl;\n    cout &lt;&lt; &quot;Operator: n5 &#x3D; n4 + num2 &#x3D; &quot; &lt;&lt; n5.num2 &lt;&lt;endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n\n    return 0;\n&#125;\n\n4.5.2 左移运算符重载\n作用：输出自定义的数据类型\n\n左移运算符重载 最好在声明为全局函数\n\n配合友元使用\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;4&#x2F;29.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, Person &amp;p);\nprivate:\n    string name;\n    int age&#123;&#125;;\n\npublic:\n    Person(string name, int age);\n&#125;;\n\nPerson::Person(string newName, int newAge)\n&#123;\n    name &#x3D; newName;\n    age &#x3D; newAge;\n&#125;\n\nostream &amp;operator&lt;&lt;(ostream &amp;c, Person &amp;p)\n&#123;\n    cout &lt;&lt; &quot;Person Name: &quot; &lt;&lt; p.name &lt;&lt; endl;\n    cout &lt;&lt; &quot;Person Age: &quot; &lt;&lt; p.age &lt;&lt; endl;\n    return c;\n&#125;\n\nvoid demo()\n&#123;\n    Person p(&quot;FHang&quot;, 24);\n    cout &lt;&lt; p &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.5.3 递增运算符重载\n需要配合 全局左移运算符 重载\n\n配合使用 友元\n\n前置重载 返回引用\n\n后置重载 返回类内值\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass MyInt\n&#123;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt);\nprivate:\n    int my_num;\n\npublic:\n    MyInt()\n    &#123;\n        my_num &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 重载 前置 ++ 运算符\n    &#x2F;&#x2F; 返回引用的目的是 仅对当前的对象进行计算，若是返回对象，则一次计算后，生成另一个新对象\n    MyInt &amp;operator++()\n    &#123;\n        my_num++;\n        return *this;\n    &#125;\n\n    &#x2F;&#x2F; 重载 后置 ++ 运算符\n    &#x2F;&#x2F; MyInt &amp;operator++(int) &#x3D;&gt; int 是 占位参数，告诉编译器，用于区分，前后置重载\n    &#x2F;&#x2F; 此处 返回值 不返回自身引用，该函数内 自身的引用指向的值 是临时变量，一次操作后，被回收，若是连续多次使用 后置 ++，便是访问NULL，非法操作\n    MyInt operator++(int)\n    &#123;\n        MyInt tempInt &#x3D; *this;\n        my_num++;\n        return tempInt;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 全局重载 左移运算符\nostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt)\n&#123;\n    cout &lt;&lt; myInt.my_num;\n    return c;\n&#125;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;&lt;---------demo1-----------&gt;&quot; &lt;&lt; endl;\n    MyInt myInt;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;&lt;---------demo2-----------&gt;&quot; &lt;&lt; endl;\n    MyInt myInt;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n    cout &lt;&lt; ++myInt &lt;&lt; endl;\n    cout &lt;&lt; ++(++myInt) &lt;&lt; endl;\n    cout &lt;&lt; myInt++ &lt;&lt; endl;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n4.5.4 递减运算符重载\n基本情况 同 递增运算符重载\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass MyInt\n&#123;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt);\nprivate:\n    int my_num;\n\npublic:\n    MyInt()\n    &#123;\n        my_num &#x3D; 10;\n    &#125;\n\n    &#x2F;&#x2F; 重置 前置 -- 返回引用\n    MyInt &amp;operator--()\n    &#123;\n        my_num--;\n        return *this;\n    &#125;\n\n    &#x2F;&#x2F; 重置 后置 -- 返回值\n    MyInt operator--(int)\n    &#123;\n        MyInt tempInt &#x3D; *this;\n        my_num--;\n        return tempInt;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 全局重载 左移运算符\nostream &amp;operator&lt;&lt;(ostream &amp;c, MyInt myInt)\n&#123;\n    cout &lt;&lt; myInt.my_num;\n    return c;\n&#125;\n\nvoid demo1()\n&#123;\n    cout &lt;&lt; &quot;&lt;---------demo1-----------&gt;&quot; &lt;&lt; endl;\n    MyInt myInt;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    cout &lt;&lt; &quot;&lt;---------demo2-----------&gt;&quot; &lt;&lt; endl;\n    MyInt myInt;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n    cout &lt;&lt; --myInt &lt;&lt; endl;\n    cout &lt;&lt; --(--myInt) &lt;&lt; endl;\n    cout &lt;&lt; myInt-- &lt;&lt; endl;\n    cout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n4.5.5 赋值运算符重载\nC++ 编译器至少给一个类添加4个函数\n\n默认构造函数（无参，函数体为空）\n默认析构函数（无参，函数体为空）\n默认拷贝构造函数，对属性值进行值拷贝\n赋值运算符 operator&#x3D;，对属性值进行值拷贝\n\n\n如果类中有属性指向堆区，做赋值操作也会出现深浅拷贝问题\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int *my_Age;\n\n    explicit Person(int age)\n    &#123;\n        my_Age &#x3D; new int(age);\n    &#125;\n\n    ~Person()\n    &#123;\n        if (my_Age !&#x3D; nullptr)\n        &#123;\n            delete my_Age;\n            my_Age &#x3D; nullptr;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 重载 赋值运算符 让每一个对象 都各自对应一块堆区，避免浅拷贝带来的多个对象指向同一堆区，在析构函数的作用下，重复释放堆区\n    Person &amp;operator&#x3D;(Person &amp;person)\n    &#123;\n        &#x2F;&#x2F; 编译器 默认 浅拷贝\n        &#x2F;&#x2F; my_Age &#x3D; person.my_Age;\n\n        &#x2F;&#x2F; 1. 在 p2 &#x3D; p1 中，p2在堆区中已有属性值，所以在进行深拷贝之前，先释放 p2 堆区\n        if (my_Age !&#x3D; nullptr)\n        &#123;\n            delete my_Age;\n            my_Age &#x3D; nullptr;\n        &#125;\n\n        &#x2F;&#x2F; 2. 进行 深拷贝\n        my_Age &#x3D; new int(*person.my_Age);\n\n        return *this;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    Person p1(18);\n    Person p2(24);\n\n    &#x2F;&#x2F; 该 赋值操作 为 浅拷贝\n    p2 &#x3D; p1;\n\n    &#x2F;&#x2F; 浅拷贝时 堆区 my_Age 占有 的内存 被析构函数 重复释放\n    cout &lt;&lt; *p1.my_Age &lt;&lt; endl;\n    cout &lt;&lt; *p2.my_Age &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    Person p1(18);\n    Person p2(24);\n    Person p3(36);\n\n    p3 &#x3D; p2 &#x3D; p1;\n\n    cout &lt;&lt; *p1.my_Age &lt;&lt; endl;\n    cout &lt;&lt; *p2.my_Age &lt;&lt; endl;\n    cout &lt;&lt; *p3.my_Age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    &#x2F;&#x2F; demo1();\n    demo2();\n    return 0;\n&#125;\n\n4.5.6 关系运算符重载\n让自定义的两个对象类型进行比较操作\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string my_Name;\n    int my_Age;\n\n    Person(string name, int age)\n    &#123;\n        my_Name &#x3D; std::move(name);\n        my_Age &#x3D; age;\n    &#125;\n\n    &#x2F;&#x2F; 重载 关系运算符 返回值类型可以为：int类型 0&#x2F;1；或者 bool类型\n    &#x2F;&#x2F; 此次 重载的关系运算符为 &#x3D;&#x3D;，其他例如：!&#x3D;, &lt;, &gt; ...同理\n    int operator&#x3D;&#x3D;(Person &amp;person) const\n    &#123;\n        if (this-&gt;my_Name &#x3D;&#x3D; person.my_Name &amp;&amp; this-&gt;my_Age &#x3D;&#x3D; person.my_Age)\n        &#123;\n            return 1;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    Person p1(&quot;FH&quot;, 24);\n    Person p2(&quot;HF&quot;, 24);\n\n    &#x2F;&#x2F; 此处 的 p1 &#x3D;&#x3D; p2 是 p1.operator&#x3D;&#x3D;(p2), 返回一个 bool类型 或者 0&#x2F;1的int类型，进行if语句判断\n    if (p1 &#x3D;&#x3D; p2)\n    &#123;\n        cout &lt;&lt; &quot;P1 &#x3D; P2&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;P1 !&#x3D; P2&quot; &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; 此次 得到的返回值为 int类型的 0&#x2F;1，所以亦可采用 switch语句来xie\n    switch (p1 &#x3D;&#x3D; p2)\n    &#123;\n        case 0:\n            cout &lt;&lt; &quot;P1 !&#x3D; P2&quot; &lt;&lt; endl;\n            break;\n\n        case 1:\n            cout &lt;&lt; &quot;P1 &#x3D; P2&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;\n\n4.5.7 函数调用运算符重载\n函数调用运算符（）也可重载\n\n重载后使用的方式，类似函数的调用，被称为 “仿函数”\n\n仿函数 的写法灵活，没有固定写法\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;20.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass FPrint\n&#123;\npublic:\n    void operator()(const string &amp;text)\n    &#123;\n        cout &lt;&lt; text &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass FAdd\n&#123;\npublic:\n    void operator()(int num1, int num2)\n    &#123;\n        cout &lt;&lt; num1 + num2 &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    FPrint fPrint;\n    fPrint(&quot;Hello World !&quot;);\n&#125;\n\nvoid demo2()\n&#123;\n    FAdd fAdd;\n    fAdd(10, 20);\n\n    &#x2F;&#x2F; 匿名函数对象\n    FAdd()(20, 40);\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n4.6 继承4.6.1 继承的基本使用\n继承的作用：减少编写重复的代码\n\n继承的语法：\nclass 子类 : 继承方式 父类 \n1. 子类 也叫 派生类 （derived class）\n2. 父类 也叫 基类 (base class)\n3. 继承方式：public\n\n继承的演示：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;22.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 公共页面 是 其子类页面 公用拥有的属性\nclass BasePage\n&#123;\npublic:\n    void pageHeader()\n    &#123;\n        cout &lt;&lt; &quot; -首页 公开课 登陆 注册 (公共)&quot; &lt;&lt; endl;\n    &#125;\n\n    void pageLeft()\n    &#123;\n        cout &lt;&lt; &quot; -Java C# C&#x2F;C++ Php Golang (公共)&quot; &lt;&lt; endl;\n    &#125;\n\n    void pageFoot()\n    &#123;\n        cout &lt;&lt; &quot; -帮助中心 交流合作 友链 (公共)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容\nclass JavaPage : public BasePage\n&#123;\npublic:\n    JavaPage()\n    &#123;\n        cout &lt;&lt; &quot;&lt;&lt;-- Java Web Page --&gt;&gt;&quot; &lt;&lt; endl;\n    &#125;\n    \n    ~JavaPage()\n    &#123;\n        cout &lt;&lt; endl;\n    &#125;\n\n    void pageBody()\n    &#123;\n        cout &lt;&lt; &quot; -Java_demo1 Java_demo2 Java_demo3 (Java)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容\nclass CPP : public BasePage\n&#123;\npublic:\n    CPP()\n    &#123;\n        cout &lt;&lt; &quot;&lt;&lt;-- C&#x2F;C++ Web Page --&gt;&gt;&quot; &lt;&lt; endl;\n    &#125;\n    \n    ~CPP()\n    &#123;\n        cout &lt;&lt; endl;\n    &#125;\n\n    void pageBody()\n    &#123;\n        cout &lt;&lt; &quot; -C&#x2F;C++_demo1 C&#x2F;C++_demo2 C&#x2F;C++_demo3 (C&#x2F;C++)&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid java_demo()\n&#123;\n    JavaPage javaPage;\n    javaPage.pageHeader();\n    javaPage.pageLeft();\n    javaPage.pageBody();\n    javaPage.pageFoot();\n&#125;\n\nvoid cpp_demo()\n&#123;\n    CPP cpp;\n    cpp.pageHeader();\n    cpp.pageLeft();\n    cpp.pageBody();\n    cpp.pageFoot();\n&#125;\n\nint main()\n&#123;\n    java_demo();\n    cpp_demo();\n    return 0;\n&#125;\n\n4.6.2 继承的方式\n继承语法: class 子类 : 继承方式 父类\n\n继承方式：\n\n公共继承：public\n保护继承：protected\n私有继承：private\n\n\n继承方式演示：\n&#x2F;&#x2F; 父类中的 private 可以被 子类  任何继承方式 继承；但 ！ 子类 无法 访问 和 使用\nclass Father\n&#123;\npublic:\n    int a;\nprotected:\n    int b;\nprivate:\n    int c;\n&#125;;\n\nclass Son : public Father\n&#123;\n&#x2F;&#x2F; public继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 无改动；\npublic:\n    int a;\nprotected:\n    int b;\n&#125;;\n\nclass Son : protected Father\n&#123;\n&#x2F;&#x2F; protected继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 protected\nprotected:\n    int a;\n    int b;\n&#125;;\n\nclass Son : private Father\n&#123;\n&#x2F;&#x2F; private继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 private\nprivate:\n    int a;\n    int b;\n&#125;;\n\n&#x2F;&#x2F; 总结：\n&#x2F;&#x2F; 父类的 private 可以被 任何 继承方式 继承；但 ！ 子类 无法 访问 和 使用\n&#x2F;&#x2F; 子类通过某个 继承方式 继承 父类 后，父类中的 public，protected 中的成员变量 在子类中 以某种继承方式出现；\n\n4.6.3 继承中的对象模型4.6.3.1 验证子类模型\n父类中的所有成员变量(非静态)，无论是什么权限保护的成员，都会被子类继承，但子类无法访问和使用\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;22.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base\n&#123;\npublic:\n    int base_A;\nprotected:\n    int base_B;\nprivate:\n    int base_C;\n&#125;;\n\nclass Derived_1 : public Base\n&#123;\npublic:\n    int derived_A;\n&#125;;\n\nvoid demo1()\n&#123;\n    Derived_1 derived1&#123;&#125;;\n    cout &lt;&lt; sizeof(derived1) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;\n\n4.6.3.2 Developer Powershell - VS\nVisual Studio 提供的工具\n\n使用方式：\n\n首先找到上面的案例代码的所在文件位置\n打开 Visual Studio 提供的 Developer Powershell\n将工作路径切换到案例代码的所在文件路径\n通过开发命令，查看案例代码中，子类对象的结构\n\n\n使用步骤：\n# 切换路径 和 查看路径下 是否存在 案例代码 cpp 文件\n\n**********************************************************************\n** Visual Studio 2019 Developer PowerShell v16.9.4\n** Copyright (c) 2021 Microsoft Corporation\n**********************************************************************\nPS C:\\Users\\Admin\\source\\repos&gt; D:\nPS D:\\DevelopmentTool\\VisualStudio\\IDE&gt; cd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; ls\n\n\n    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a----         2021&#x2F;6&#x2F;22     15:09           1515 Inherit_Base.cpp\n-a----         2021&#x2F;6&#x2F;22     15:42            397 Inherit_ObjectModel.cpp\n\n# 通过开发命令，查看案例代码中，子类对象的结构\n\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl &#x2F;d1 reportSingleClassLayoutDerived_1 &quot;.\\Inherit_ObjectModel.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nInherit_ObjectModel.cpp\n\nclass Derived_1 size(16): # 此处可以看到 子类Derived_1对象的大小 和 之前的案例代码的打印结果一致\n        +---\n 0      | +--- (base class Base) # 子类Derived_1完全继承父类中所有成员 中的 base_A base_B  base_C\n 0      | | base_A\n 4      | | base_B\n 8      | | base_C\n        | +---\n12      | derived_A # 同时 子类Derived_1 自身的成员也在 derived_A\n        +---\n\n# 总结：子类 Derived_1中 四个int类型的成员变量，占内存大小为16字节\n\n# 用到的指令\n\n# 切换盘符 到 案例代码 所在 的 盘\nD:\n\n# 切换到具体的路径地址\ncd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9\n\n# 查看路径下 的 案例代码文件 Inherit_ObjectModel.cpp\nls\n\n# 指定 报告单个类的布局 ：子类Deriverd_1\n# cl &#x2F;d1 reportSingleClassLayout需要查看的类 &quot;类所在的具体文件&quot;\ncl &#x2F;d1 reportSingleClassLayoutDerived_1 &quot;.\\Inherit_ObjectModel.cpp&quot;\n\n4.6.4 继承中构造和析构顺序\n子类继承父类之后，当创建子类对象时，也会调用父类的构造和析构函数\n\n案例验证，子类和父类的构造和析构函数的调用先后顺序\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;22.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base\n&#123;\npublic:\n    Base()\n    &#123;\n        cout &lt;&lt; &quot;Base Constructor Transfer&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Base()\n    &#123;\n        cout &lt;&lt; &quot;Base Destructor Transfer&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Derived : public Base\n&#123;\npublic:\n    Derived()\n    &#123;\n        cout &lt;&lt; &quot;Derived Constructor Transfer&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Derived()\n    &#123;\n        cout &lt;&lt; &quot;Derived Destructor Transfer&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Derived derived;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n# 案例结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_3.exe\nBase Constructor Transfer\nDerived Constructor Transfer\nDerived Destructor Transfer\nBase Destructor Transfer\n\n由 案例结果 可以 看出\n\n当创建子类时，子类和父类 的 构造和析构函数的调用 顺序\n\n子类构造\n父类构造\n父类析构\n子类析构\n\n\n\n4.6.5 继承同名成员处理方式\n继承时的问题：当子类和父类出现同名成员，如何通过子类对象，访问子类或父类的同名数据\n\n访问子类同名成员，直接访问\n访问父类同名成员，添加作用域\n\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by Admin on 2021&#x2F;6&#x2F;22.\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base\n&#123;\npublic:\n    int num;\n\n    Base()\n    &#123;\n        num &#x3D; 100;\n    &#125;\n\n    void FPrint()\n    &#123;\n        cout &lt;&lt; &quot;Base Print&quot; &lt;&lt; endl;\n    &#125;\n\n    void FPrint(int n)\n    &#123;\n        cout &lt;&lt; &quot;Base Print (int n) : Overload Function&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Derived : public Base\n&#123;\npublic:\n    int num;\n\n    Derived()\n    &#123;\n        num &#x3D; 200;\n    &#125;\n\n    void FPrint()\n    &#123;\n        cout &lt;&lt; &quot;Derived Print&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Derived derived;\n    cout &lt;&lt; &quot;Derived num &#x3D; &quot; &lt;&lt; derived.num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base num &#x3D; &quot; &lt;&lt; derived.Base::num &lt;&lt; endl;\n    derived.FPrint();\n    derived.Base::FPrint();\n\n    &#x2F;&#x2F; 当父类和子类中，存在同名成员时，会默认隐藏父类的成员，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用\n    &#x2F;&#x2F; derived.FPrint(10);  &#x2F;&#x2F; 父类被隐藏，所以直接传参也无法找到 重载的函数，因为子类没有 FPrint的重载函数\n    derived.Base::FPrint(10); &#x2F;&#x2F; 加上 父类作用域后 可调用\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n解决方法：\n\n子类对象可以直接访问到子类同名成员\n子类对象加上作用域可以访问到父类同名成员\n当子类和父类拥有同名的成员函数，子类会隐藏父类同名成员函数，子类加作用域可以访问到父类中同名函数\n\n\n\n4.6.6 继承同名静态成员处理方式\n问题：继承中，同名的静态成员在子类对象上如何访问\n\n静态成员和非静态成员出现同名，处理方式一致\n\n访问子类同名成员，直接访问\n访问父类同名成员，添加作用域\n\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 10:23\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 基类\nclass Base\n&#123;\npublic:\n    static int num;\n\n    static void func()\n    &#123;\n        cout &lt;&lt; &quot;Base-Static Func&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Base()\n    &#123;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint Base::num &#x3D; 100;\n\n&#x2F;&#x2F; 子类\nclass Derived : public Base\n&#123;\npublic:\n    static int num;\n\n    static void func()\n    &#123;\n        cout &lt;&lt; &quot;Derived-Static Func&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint Derived::num &#x3D; 200;\n\n&#x2F;&#x2F; 同名静态成员属性\nvoid demo1()\n&#123;\n    Derived derived;\n    &#x2F;&#x2F; 通过对象访问\n    cout &lt;&lt; &quot;通过对象访问&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;Derived Num &#x3D; &quot; &lt;&lt; derived.num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base Num &#x3D; &quot; &lt;&lt; derived.Base::num &lt;&lt; endl;\n\n    &#x2F;&#x2F; 通过类目访问\n    cout &lt;&lt; &quot;通过类目访问&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;Derived Num &#x3D; &quot; &lt;&lt; Derived::num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base Num &#x3D; &quot; &lt;&lt; Base::num &lt;&lt; endl;\n\n    &#x2F;&#x2F; 第一个 :: 表示使用类名访问；第二个 :: 表示父类作用域下\n    cout &lt;&lt; &quot;Base Num &#x3D; &quot; &lt;&lt; Derived::Base::num &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 同名静态成员变量\nvoid demo2()\n&#123;\n    Derived derived;\n    &#x2F;&#x2F; 通过对象访问\n    cout &lt;&lt; &quot;通过对象访问&quot; &lt;&lt; endl;\n    derived.func();\n    derived.Base::func();\n\n    &#x2F;&#x2F; 通过类目访问\n    cout &lt;&lt; &quot;通过类目访问&quot; &lt;&lt; endl;\n    Derived::func();\n    Derived::Base::func();\n&#125;\n\n&#x2F;&#x2F; 当父类和子类中，存在同名成员变量时，会默认隐藏父类的成员变量，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n总结：同名静态成员处理方式和非同名静态的处理方式一样\n\n区别：同名静态成员处理：\n\n通过对象调用\n通过类目调用\n\n\n\n4.6.7 多继承语法\nC++ 允许一个类继承多个类\n\n语法：class 子类 : 继承方式 父类1, 继承方式 父类2…\n\n多继承可能会引发父类中同名成员出现，需要加作用域区分使用\n\n实际开发中，建议不用，不易于维护\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 11:03\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base1\n&#123;\npublic:\n    int num;\n\n    Base1()\n    &#123;\n        num &#x3D; 100;\n    &#125;\n&#125;;\n\nclass Base2\n&#123;\npublic:\n    int num;\n\n    Base2()\n    &#123;\n        num &#x3D; 200;\n    &#125;\n&#125;;\n\nclass Derived : public Base1, public Base2\n&#123;\npublic:\n    int num;\n\n    Derived()\n    &#123;\n        num &#x3D; 300;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Derived derived;\n    cout &lt;&lt; &quot;Sizeof derived &#x3D; &quot; &lt;&lt; sizeof(derived) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Derived Num &#x3D; &quot; &lt;&lt; derived.num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base1 Num &#x3D; &quot; &lt;&lt; derived.Base1::num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Base2 Num &#x3D; &quot; &lt;&lt; derived.Base2::num &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n此处也使用了 Developer PowerShell 查看了 Derived 类的结构\n**********************************************************************\n** Visual Studio 2019 Developer PowerShell v16.9.4\n** Copyright (c) 2021 Microsoft Corporation\n**********************************************************************\nPS C:\\Users\\Admin\\source\\repos&gt; D:\nPS D:\\DevelopmentTool\\VisualStudio\\IDE&gt; cd D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo&gt; ls\n\n\n    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\nd-----          2021&#x2F;5&#x2F;4      9:34                .idea\nd-----         2021&#x2F;6&#x2F;24     11:12                cmake-build-debug\nd-----          2021&#x2F;5&#x2F;4      9:34                Code1\nd-----          2021&#x2F;5&#x2F;4      9:34                Code2\nd-----          2021&#x2F;5&#x2F;4      9:34                Code3\nd-----          2021&#x2F;5&#x2F;4      9:34                Code4\nd-----          2021&#x2F;5&#x2F;4      9:34                Code4_CirclePoint\nd-----          2021&#x2F;5&#x2F;4      9:34                Code5\nd-----          2021&#x2F;5&#x2F;4      9:34                Code6\nd-----          2021&#x2F;5&#x2F;4      9:34                Code7\nd-----         2021&#x2F;6&#x2F;20     21:27                Code8\nd-----         2021&#x2F;6&#x2F;24     11:11                Code9\n-a----         2021&#x2F;2&#x2F;21     19:24            174 .gitignore\n-a----         2021&#x2F;6&#x2F;24     11:12           2930 CMakeLists.txt\n\n\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo&gt; cd Code9\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; ls\n\n\n    目录: D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a----         2021&#x2F;6&#x2F;22     15:09           1515 Inherit_Base.cpp\n-a----         2021&#x2F;6&#x2F;22     16:36            590 Inherit_ConstructorDestructorTransferOrder.cpp\n-a----         2021&#x2F;6&#x2F;22     17:32           1216 Inherit_DealWithSameName.cpp\n-a----         2021&#x2F;6&#x2F;24     10:49           1431 Inherit_DealWithSameNameObject.cpp\n-a----         2021&#x2F;6&#x2F;24     11:11            126 Inherit_DiamondInheritance.cpp\n-a----         2021&#x2F;6&#x2F;24     11:10            730 Inherit_MoreInherit.cpp\n-a----         2021&#x2F;6&#x2F;22     16:01            395 Inherit_ObjectModel.cpp\n\n\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl &#x2F;d1 reportSingleClassLayoutDerived &quot;.\\Inherit_MoreInherit.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nInherit_MoreInherit.cpp\n\nclass Derived   size(12):\n        +---\n 0      | +--- (base class Base1)\n 0      | | num\n        | +---\n 4      | +--- (base class Base2)\n 4      | | num\n        | +---\n 8      | num\n        +---\n\n4.6.8 菱形继承\n概念：\n\n两个派生类继承同一个基类\n又有某一个类同时继承了两个派生类\n\n\n问题解决：\n\n默认情况下\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 11:11\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    int age;\n\n    Animal()\n    &#123;\n        age &#x3D; 10;\n    &#125;\n&#125;;\n\nclass Tiger : public Animal&#123;&#125;;\n\nclass Lion : public Animal&#123;&#125;;\n\nclass LionTiger : public Tiger, public Lion&#123;&#125;;\n\nvoid demo1()\n&#123;\n    LionTiger lionTiger;\n\n    &#x2F;&#x2F; 菱形继承，两个父类拥有相同的数据，通过作用域区分，同时造成资源浪费，通过 虚继承 解决问题\n    lionTiger.Tiger::age &#x3D; 20;\n    lionTiger.Lion::age &#x3D; 30;\n\n    cout &lt;&lt; &quot;Tiger Age &#x3D; &quot; &lt;&lt; lionTiger.Tiger::age &lt;&lt; endl;\n    cout &lt;&lt; &quot;Lion Age &#x3D; &quot; &lt;&lt; lionTiger.Lion::age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 打印结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_7.exe\n&#x2F;&#x2F; 此时，可看出，LionTiger同时继承了两个成员变量，在作用域下可单独赋值\nTiger Age &#x3D; 20\nLion Age &#x3D; 30\n\n# 利用 Developer Powershell 工具， 查看 LionTriger 类 的结构\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl &#x2F;d1 reportSingleClassLayoutLionTiger &quot;.\\Inherit_DiamondInheritance.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nInherit_DiamondInheritance.cpp\n.\\Inherit_DiamondInheritance.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以 防止数据丢失\n\nclass LionTiger size(8): # 可以看到，LionTiger 继承了两个 重复的成员\n        +---\n 0      | +--- (base class Tiger)\n 0      | | +--- (base class Animal)\n 0      | | | age\n        | | +---\n        | +---\n 4      | +--- (base class Lion)\n 4      | | +--- (base class Animal)\n 4      | | | age\n        | | +---\n        | +---\n        +---\n\n使用虚继承解决问题，关键字：virtual\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 11:11\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    int age;\n\n    Animal()\n    &#123;\n        age &#x3D; 10;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 利用 虚继承 解决菱形继承的问题\n&#x2F;&#x2F; 使用 关键字 virtual ，两个派生类继承同一个父类时，两个派生类 可虚拟共享同一个 父类中继承来的成员，（继承了虚基类 Animal的age 的地址）\n&#x2F;&#x2F; Animal 类，称为 虚基类\nclass Tiger : virtual public Animal&#123;&#125;;\n\nclass Lion : virtual public Animal&#123;&#125;;\n\nclass LionTiger : public Tiger, public Lion&#123;&#125;;\n\nvoid demo1()\n&#123;\n    LionTiger lionTiger;\n\n    &#x2F;&#x2F; 菱形继承，两个父类拥有相同的数据，通过作用域区分，同时造成资源浪费，通过 虚继承 解决问题\n    lionTiger.Tiger::age &#x3D; 20;\n    lionTiger.Lion::age &#x3D; 30;\n\n    cout &lt;&lt; &quot;Tiger Age &#x3D; &quot; &lt;&lt; lionTiger.Tiger::age &lt;&lt; endl;\n    cout &lt;&lt; &quot;Lion Age &#x3D; &quot; &lt;&lt; lionTiger.Lion::age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 打印结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code9_7.exe\n&#x2F;&#x2F; 使用 虚继承 后，LionTiger 只继承了一个 成员变量\nTiger Age &#x3D; 30\nLion Age &#x3D; 30\n\n# 利用 Developer Powershell 工具， 查看 LionTriger 类 的结构 (使用了 虚继承)\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code9&gt; cl &#x2F;d1 reportSingleClassLayoutLionTiger &quot;.\\Inherit_DiamondInheritance.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nInherit_DiamondInheritance.cpp\n.\\Inherit_DiamondInheritance.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以 防止数据丢失\n\nclass LionTiger size(12):\n        +---\n 0      | +--- (base class Tiger)\n 0      | | &#123;vbptr&#125; # 指向 LionTiger::$vbtable@Tiger@: \n        | +---\n 4      | +--- (base class Lion)\n 4      | | &#123;vbptr&#125; # 指向 LionTiger::$vbtable@Lion@:\n        | +---\n        +---\n        +--- (virtual base Animal)\n 8      | age\n        +---\n\nLionTiger::$vbtable@Tiger@: # 偏移量 8，从类结构布局的开始 +8，刚好指向 virtual base Animal 的 成员变量 age\n 0      | 0\n 1      | 8 (LionTigerd(Tiger+0)Animal)\n \nLionTiger::$vbtable@Lion@: # 偏移量 4，从类结构布局的开始 +4，刚好指向 virtual base Animal 的 成员变量 age\n 0      | 0\n 1      | 4 (LionTigerd(Lion+0)Animal)\nvbi:       class  offset o.vbptr  o.vbte fVtorDisp\n          Animal       8       0       4 0\n\n#  一些解释，上面的结构\nvbptr -&gt; v&#x3D;virtual, b&#x3D;base, ptr&#x3D;pointer; vbptr 指向 vbtable\nvbtable -&gt; v&#x3D;virtual, b&#x3D;base, table\n\n\n\n4.7 多态4.7.1 多态的基本概念多态是C++面向对象的三大特性之一\n\n多态分为两类\n\n静态多态：函数重载 和 运算符重载 属于静态多态，复用函数名\n动态多态：派生类 和 虚函数 实现运行时，为多态\n\n\n静态多态和动态多态的区别\n\n静态多态的函数地址早绑定 — 编译阶段确定函数地址\n动态多态的函数地址晚绑定 — 运行阶段确定函数地址\n\n\n案例说明\n\n静态多态\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 14:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 该函数的地址是早绑定，编译阶段确定引用的 Animal类的对象地址，后面调用时，传入Cat对象，不改变结果（静态多态）\n&#x2F;&#x2F; 将基类Animal中的 函数 speak() 设为虚函数，运行时才确定地址，后面调用时，传入Cat对象，引用的便是Cat的对象地址（动态多态）\nvoid doSpeak(Animal &amp;animal)\n&#123;\n    animal.speak();\n&#125;\n\nvoid demo()\n&#123;\n    Cat cat;\n    doSpeak(cat);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 运行结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code10_1.exe\nAnimal Speaking\n\n动态多态\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 14:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    &#x2F;&#x2F; 使用关键字 virtual，使得变成虚函数\n    virtual void speak()\n    &#123;\n        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Dog Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 该函数内传入引用对象调用的speak()函数的地址是早绑定，编译阶段确定引用的 Animal类的对象地址，后面调用时，传入Cat对象，不改变结果（静态多态）\n&#x2F;&#x2F; 将基类Animal中的 函数 speak() 设为虚函数，运行时才确定地址，后面调用时，传入Cat对象，引用的便是Cat的对象地址（动态多态）\nvoid doSpeak(Animal &amp;animal)\n&#123;\n    &#x2F;&#x2F; speak()早绑定时，默认是传入基类Animal的引用对象地址\n    &#x2F;&#x2F; speak()使用virtual后是晚绑定时，传入指定引用对象地址\n    animal.speak();\n&#125;\n\nvoid demo()\n&#123;\n    Cat cat;\n    Dog dog;\n    doSpeak(cat);\n    doSpeak(dog);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 运行结果\nD:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\cmake-build-debug\\Code10_1.exe\nCat Speaking\nDog Speaking\n\n\n动态多态的满足条件\n\n有继承关系\n子类重写父类的虚函数\n重写：函数返回值类型，函数名，参数列表，完全一致\n\n\n动态多态的使用：父类的指针或引用，执行子类对象\n\n\n4.7.2 多态深入原理案例代码\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 14:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    virtual void speak()\n    &#123;\n        cout &lt;&lt; &quot;Animal Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Cat : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Cat Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Dog : public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;Dog Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid doSpeak(Animal &amp;animal) &#x2F;&#x2F; 此处 &#x3D;&gt; Animal &amp;animal &#x3D; cat\n&#123;\n    animal.speak();\n&#125;\n\nvoid demo()\n&#123;\n    Cat cat;\n    Dog dog;\n    doSpeak(cat); \n    doSpeak(dog);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n\n静态多态\n\n基类 Animal 中的 speak() 没有 virtual 前是早绑定，函数地址在类外，此时Animal类是空类，大小为1；\n\n\n动态多态\n\n基类 Animal 中的 speak() 有 virtual 是晚绑定，函数地址在类内，此时Animal类不是空类，大小为4；\n\n此时 虚函数speak()，在类内中是 vfptr &#x3D; virtualFunctionPointer ( 虚函数(表)指针 )，指向vftable (虚函数表)，函数地址入口是 &amp;Animal::speak;\n\n子类Cat继承Animal后，默认情况下，Cat类完全继承了Animal类的属性；\n\n但案例代码中，Cat类内实现了speak()的重写，此时函数地址入口是 &amp;Cat::speak;\n\n子类中的虚函数表内部会替换成子类的虚函数地址；\n\n此时，当父类的指针或引用指向子类对象时，发生多态；\n\n\n\n验证：Developer PowerShell\n\n静态多态\n# 基类Animal 的函数表\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutAnimal &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass Animal    size(1):\n        +---\n        +---\n\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass _s__CatchableType size(28):\n        +---\n 0      | properties\n 4      | pType\n 8      | _PMD thisDisplacement\n20      | sizeOrOffset\n24      | copyFunction\n        +---\n\nclass _s__CatchableTypeArray    size(4):\n        +---\n 0      | nCatchableTypes\n 4      | arrayOfCatchableTypes\n        +---\n\nclass Cat       size(1):\n        +---\n 0      | +--- (base class Animal) #基类没有实现虚函数，为静态多态时，子类完全继承基类，即使子类重写了speak，也依然是默认的基类对象引用\n        | +---\n        +---\n\n\n\n动态多态\n# 基类Animal 的函数表\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutAnimal &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass Animal    size(4):\n        +---\n 0      | &#123;vfptr&#125;\n        +---\n\nAnimal::$vftable@:\n        | &amp;Animal_meta\n        |  0\n 0      | &amp;Animal::speak\n\nAnimal::speak this adjustor: 0\n\n# 子类Cat 没有发生重写时的 函数表\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass _s__CatchableType size(28):\n        +---\n 0      | properties\n 4      | pType\n 8      | _PMD thisDisplacement\n20      | sizeOrOffset\n24      | copyFunction\n        +---\n\nclass _s__CatchableTypeArray    size(4):\n        +---\n 0      | nCatchableTypes\n 4      | arrayOfCatchableTypes\n        +---\n\nclass Cat       size(4):\n        +---\n 0      | +--- (base class Animal)\n 0      | | &#123;vfptr&#125;\n        | +---\n        +---\n\nCat::$vftable@:\n        | &amp;Cat_meta\n        |  0\n 0      | &amp;Animal::speak # Cat内没有重写 speak 时，Cat类的函数指针指向的函数表是 Animal 的\n\n# 子类Cat 发生重写时的 函数表\nPS D:\\Learn\\Cpp\\3_Cpp_plus_Clion\\CodeDemo\\Code10&gt; cl &#x2F;d1 reportSingleClassLayoutCat &quot;.\\Polymorphism_DeepUnderlying.cpp&quot;\n用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.28.29914 版\n版权所有(C) Microsoft Corporation。保留所有权利。\n\nPolymorphism_DeepUnderlying.cpp\n\nclass _s__CatchableType size(28):\n        +---\n 0      | properties\n 4      | pType\n 8      | _PMD thisDisplacement\n20      | sizeOrOffset\n24      | copyFunction\n        +---\n\nclass _s__CatchableTypeArray    size(4):\n        +---\n 0      | nCatchableTypes\n 4      | arrayOfCatchableTypes\n        +---\n\nclass Cat       size(4):\n        +---\n 0      | +--- (base class Animal)\n 0      | | &#123;vfptr&#125;\n        | +---\n        +---\n\nCat::$vftable@:\n        | &amp;Cat_meta\n        |  0\n 0      | &amp;Cat::speak  # Cat内重写 speak 后，Cat类的函数指针指向的函数表是 Cat 的\n\nCat::speak this adjustor: 0\n\n\n\n4.7.3 多态案例-计算器\n案例描述：分别使用普通的方法和多态，设计实现两个操作数进行运算的计算器类\n\n多态的优点：\n\n代码组织结构清晰\n可读性强\n利于前期和后期的扩展和维护\n\n\n示例：普通实现\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 16:39\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Calculator\n&#123;\npublic:\n    int num1;\n    int num2;\n\n    float getResult(string f_operator)\n    &#123;\n        if (f_operator &#x3D;&#x3D; &quot;+&quot;)\n        &#123;\n            return num1 + num2;\n        &#125;\n        if (f_operator &#x3D;&#x3D; &quot;-&quot;)\n        &#123;\n            return num1 - num2;\n        &#125;\n        if (f_operator &#x3D;&#x3D; &quot;*&quot;)\n        &#123;\n            return num1 * num2;\n        &#125;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Calculator calculator&#123;&#125;;\n    calculator.num1 &#x3D; 10;\n    calculator.num2 &#x3D; 15;\n\n    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; + &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; calculator.getResult(&quot;+&quot;) &lt;&lt; endl;\n    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; - &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; calculator.getResult(&quot;-&quot;) &lt;&lt; endl;\n    cout &lt;&lt; calculator.num1 &lt;&lt; &quot; * &quot; &lt;&lt; calculator.num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; calculator.getResult(&quot;*&quot;) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n多态实现\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 18:46\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass AbstractCalculator\n&#123;\npublic:\n    int num1;\n    int num2;\n\n    virtual float getResult()\n    &#123;\n        return 0.0;\n    &#125;\n&#125;;\n\nclass SumCalculator : public AbstractCalculator\n&#123;\npublic:\n    virtual float getResult()\n    &#123;\n        return float (num1 + num2);\n    &#125;\n&#125;;\n\nclass SubCalculator : public AbstractCalculator\n&#123;\npublic:\n    virtual float getResult()\n    &#123;\n        return float (num1 - num2);\n    &#125;\n&#125;;\n\nclass MulCalculator : public AbstractCalculator\n&#123;\npublic:\n    virtual float getResult()\n    &#123;\n        return float (num1 * num2);\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 父类指针或引用指向子类执行\n    AbstractCalculator *abs;\n    &#x2F;&#x2F; Sum\n    abs &#x3D; new SumCalculator;\n    abs-&gt;num1 &#x3D; 10;\n    abs-&gt;num2 &#x3D; 15;\n    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; + &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;\n    delete abs;\n\n    &#x2F;&#x2F; Sub\n    abs &#x3D; new SubCalculator;\n    abs-&gt;num1 &#x3D; 10;\n    abs-&gt;num2 &#x3D; 15;\n    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; - &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;\n    delete abs;\n\n    &#x2F;&#x2F; Mul\n    abs &#x3D; new MulCalculator;\n    abs-&gt;num1 &#x3D; 10;\n    abs-&gt;num2 &#x3D; 15;\n    cout &lt;&lt; abs-&gt;num1 &lt;&lt; &quot; * &quot; &lt;&lt; abs-&gt;num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;\n    delete abs;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.7.4 纯虚函数和抽象类\n纯函数和抽象类的定义和语法：\n\n在多态中，通常父类中虚函数的实现是无意义的，主要是调用子类中重写的内容，因此可将该虚函数称为 纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0；\n当类中存在纯虚函数时，该类亦可称为抽象类；（例如：4.7.3中的AbstractCalculator类）\n\n\n抽象类的特点：\n\n无法实例化对象\n子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n\n示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 19:15\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 抽象类\nclass Base\n&#123;\npublic:\n    &#x2F;&#x2F; 纯虚函数\n    virtual void func() &#x3D; 0;\n&#125;;\n\nclass Derived : public Base\n&#123;\npublic:\n    virtual void func()\n    &#123;\n        cout &lt;&lt; &quot;Derived Function&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    Base *base &#x3D; new Derived;\n    base-&gt;func();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.7.5 多态案例-制作饮品\n案例描述：煮水 -&gt; 冲泡 -&gt; 倒入杯中 -&gt; 加入辅料\n\n实现要求：利用多态，提供抽象制作的饮品基类，提供子类制作咖啡和茶叶\n\n案例代码：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 19:29\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass AbstractMakeDrinks\n&#123;\npublic:\n    virtual void boilWater() &#x3D; 0;\n    virtual void brew() &#x3D; 0;\n    virtual void pourIntoCup() &#x3D; 0;\n    virtual void addAccessories() &#x3D; 0;\n\n    void makeDrinks()\n    &#123;\n        boilWater();\n        brew();\n        pourIntoCup();\n        addAccessories();\n    &#125;\n\n    ~AbstractMakeDrinks()\n    &#123;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass MakeCoffee : public AbstractMakeDrinks\n&#123;\npublic:\n    MakeCoffee()\n    &#123;\n        cout &lt;&lt; &quot;&lt; -- Make Coffee --&gt;&quot; &lt;&lt; endl;\n    &#125;\n    virtual void boilWater()\n    &#123;\n        cout &lt;&lt; &quot;BoilWater&quot; &lt;&lt; endl;\n    &#125;\n    virtual void brew()\n    &#123;\n        cout &lt;&lt; &quot;Brew Coffee&quot; &lt;&lt; endl;\n    &#125;\n    virtual void pourIntoCup()\n    &#123;\n        cout &lt;&lt; &quot;Pour Coffee Into The Cup&quot; &lt;&lt; endl;\n    &#125;\n    virtual void addAccessories()\n    &#123;\n        cout &lt;&lt; &quot;Add Accessories Like Milk&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass MakeTea : public AbstractMakeDrinks\n&#123;\npublic:\n    MakeTea()\n    &#123;\n        cout &lt;&lt; &quot;&lt; -- Make Tea --&gt;&quot; &lt;&lt; endl;\n    &#125;\n    virtual void boilWater()\n    &#123;\n        cout &lt;&lt; &quot;BoilWater&quot; &lt;&lt; endl;\n    &#125;\n    virtual void brew()\n    &#123;\n        cout &lt;&lt; &quot;Brew Tea&quot; &lt;&lt; endl;\n    &#125;\n    virtual void pourIntoCup()\n    &#123;\n        cout &lt;&lt; &quot;Pour Tea Into The Cup&quot; &lt;&lt; endl;\n    &#125;\n    virtual void addAccessories()\n    &#123;\n        cout &lt;&lt; &quot;Add Accessories Like Sugar&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 参数是 指针地址 的写法\nvoid makeDrinks(AbstractMakeDrinks *abstractMakeDrinks)\n&#123;\n    abstractMakeDrinks-&gt;makeDrinks();\n    delete abstractMakeDrinks;\n&#125;\n\nvoid makeDrinks_Coffee()\n&#123;\n    makeDrinks(new MakeCoffee);\n&#125;\n\nvoid makeDrinks_Tea()\n&#123;\n    makeDrinks(new MakeTea);\n&#125;\n\n&#x2F;&#x2F; 参数是 对象引用 的写法\n&#x2F;&#x2F;void makeDrinks(AbstractMakeDrinks &amp;abstractMakeDrinks)\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    abstractMakeDrinks.makeDrinks();\n&#x2F;&#x2F;    delete &amp;abstractMakeDrinks;\n&#x2F;&#x2F;&#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;void makeDrinks_Coffee()\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    makeDrinks(*new MakeCoffee);\n&#x2F;&#x2F;&#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;void makeDrinks_Tea()\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    makeDrinks(*new MakeTea);\n&#x2F;&#x2F;&#125;\n\nint main()\n&#123;\n    makeDrinks_Coffee();\n    makeDrinks_Tea();\n    return 0;\n&#125;\n\n4.7.6 虚析构和纯虚析构\n多态使用时，如果子类中有属性开辟到堆区，父类指针在释放时无法调用到子类的析构代码\n\n解决方式：将父类中的析构函数改为虚析构或纯虚析构\n\n虚析构和纯虚析构的共性：\n\n可以解决父类指针释放子类对象\n都需要具体的函数实现\n\n\n虚析构和纯虚析构的区别：\n\n如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n\n虚析构语法：virtual ~类名 () &#123;&#125;\n\n纯虚析构语法：\n\n类内：virtual ~类名 () = 0;\n类外：类名::~类名() &#123;&#125;\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;24 20:24\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Animal\n&#123;\npublic:\n    Animal()\n    &#123;\n        cout &lt;&lt; &quot;Animal Construct Transfer&quot; &lt;&lt; endl;\n    &#125;\n    &#x2F;&#x2F; 虚析构，此时释放父类时，会调用子类的析构函数\n    virtual ~Animal()\n    &#123;\n        cout &lt;&lt; &quot;Animal Destruct Transfer&quot; &lt;&lt; endl;\n    &#125;\n    &#x2F;&#x2F; 纯虚析构，在类外实现具体\n    &#x2F;&#x2F; virtual ~Animal() &#x3D; 0;\n\n    &#x2F;&#x2F; 纯虚函数\n    virtual void speak() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; 类外实现的 纯虚析构\n&#x2F;&#x2F;Animal::~Animal()\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;    cout &lt;&lt; &quot;Animal Destruct Transfer&quot; &lt;&lt; endl;\n&#x2F;&#x2F;&#125;\n\nclass Cat : public Animal\n&#123;\npublic:\n    string *cat_Name;\n\n    Cat(string name)\n    &#123;\n        cout &lt;&lt; &quot;Cat Construct Transfer&quot; &lt;&lt; endl;\n        cat_Name &#x3D; new string(name);\n    &#125;\n    ~Cat()\n    &#123;\n        if (cat_Name !&#x3D; nullptr)\n        &#123;\n            cout &lt;&lt; &quot;Cat Destruct Transfer&quot; &lt;&lt; endl;\n            delete cat_Name;\n            cat_Name &#x3D; nullptr;\n        &#125;\n    &#125;\n\n    virtual void speak()\n    &#123;\n        cout &lt;&lt; *cat_Name &lt;&lt; &quot;Cat is Speaking&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    &#x2F;&#x2F; 父类指针指向子类调用\n    Animal *animal &#x3D; new Cat(&quot;Tom&quot;);\n    animal-&gt;speak();\n    &#x2F;&#x2F; 释放父类对象析构时，不会调用子类的析构函数，出现内存泄露\n    &#x2F;&#x2F; 在基类的析构函数前 加入关键字 virtual，即可解决问题\n    delete animal;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n总结：\n\n虚析构和纯虚析构，用来解决父类指针释放子类对象\n如果子类在堆区中，没有开辟空间，可以不写虚析构或纯虚析构\n拥有纯虚析构的类，属于抽象类\n\n\n\n4.7.7 多态案例-电脑组装\n案例描述：\n\n电脑主要组成部分：CPU，显卡，内存条；\n将每个零件封装成抽象基类，并且提供不同的厂商生产不同的零件，例如：Inter和AMD；\n创建电脑类提供电脑工作的函数，并且调用每个零件工作的接口；\n测试时，组装三台电脑进行测试\n\n\n案例代码：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 14:06\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 抽象 CPU类\nclass CPU\n&#123;\npublic:\n    virtual void calculation() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; 抽象 显卡类\nclass GraphicsCard\n&#123;\npublic:\n    virtual void display() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; 抽象 内存类\nclass RAM\n&#123;\npublic:\n    virtual void storage() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; 电脑类\nclass Computer\n&#123;\nprivate:\n    string *name;\n    CPU *cpu;\n    GraphicsCard *graphicsCard;\n    RAM *ram;\n\npublic:\n    &#x2F;&#x2F; 电脑零件组装\n    Computer(string *name, CPU *cpu, GraphicsCard *graphicsCard, RAM *ram)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;cpu &#x3D; cpu;\n        this-&gt;graphicsCard &#x3D; graphicsCard;\n        this-&gt;ram &#x3D; ram;\n        cout &lt;&lt; &quot;&lt; --&quot; &lt;&lt; *this-&gt;name &lt;&lt; &quot; Computer Is Start Run&quot; &lt;&lt; &quot;-- &gt;&quot; &lt;&lt; endl;\n    &#125;\n    ~Computer()\n    &#123;\n        if (cpu !&#x3D; nullptr)\n        &#123;\n            delete cpu;\n            cpu &#x3D; nullptr;\n        &#125;\n        if (graphicsCard !&#x3D; nullptr)\n        &#123;\n            delete graphicsCard;\n            graphicsCard &#x3D; nullptr;\n        &#125;\n        if (ram !&#x3D; nullptr)\n        &#123;\n            delete ram;\n            ram &#x3D; nullptr;\n        &#125;\n        cout &lt;&lt; &quot;&lt; --&quot; &lt;&lt; *this-&gt;name &lt;&lt; &quot; Computer Is Running Normal&quot; &lt;&lt; &quot;-- &gt;&quot; &lt;&lt; endl;\n        cout &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; 电脑运行函数\n    void computerRun()\n    &#123;\n        &#x2F;&#x2F; 电脑零件 接口调用\n        cpu-&gt;calculation();\n        graphicsCard-&gt;display();\n        ram-&gt;storage();\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 具体厂商的类\n&#x2F;&#x2F; Inter Class\nclass Inter_CPU : public CPU\n&#123;\npublic:\n    void calculation() override\n    &#123;\n        cout &lt;&lt; &quot;Inter CPU Is Calculation&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Inter_GraphicsCard : public GraphicsCard\n&#123;\npublic:\n    void display() override\n    &#123;\n        cout &lt;&lt; &quot;Inter Graphics Card Is Displaying&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Inter_RAM : public RAM\n&#123;\npublic:\n    void storage() override\n    &#123;\n        cout &lt;&lt; &quot;Inter RAM Is In Storage&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; AMD Class\nclass AMD_CPU : public CPU\n&#123;\npublic:\n    void calculation() override\n    &#123;\n        cout &lt;&lt; &quot;AMD CPU Is Calculation&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass AMD_GraphicsCard : public GraphicsCard\n&#123;\npublic:\n    void display() override\n    &#123;\n        cout &lt;&lt; &quot;AMD Graphics Card Is Displaying&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass AMD_RAM : public RAM\n&#123;\npublic:\n    void storage() override\n    &#123;\n        cout &lt;&lt; &quot;AMD RAM Is In Storage&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 组装不同厂商组件的电脑\n&#x2F;&#x2F; Assembling Inter Computer\nvoid assemblingComputer_Inter()\n&#123;\n    &#x2F;&#x2F; 准备 Inter Computer 的 Component\n    string name &#x3D; &quot;Inter&quot;;\n    CPU *interCPU &#x3D; new Inter_CPU;\n    GraphicsCard *interGraphicsCard &#x3D; new Inter_GraphicsCard;\n    RAM *interRAM &#x3D; new Inter_RAM;\n\n    &#x2F;&#x2F; Assembling Inter Computer\n    Computer *computer &#x3D; new Computer(&amp;name, interCPU, interGraphicsCard, interRAM);\n\n    &#x2F;&#x2F; Running Inter Computer\n    computer-&gt;computerRun();\n    delete computer;\n&#125;\n\n&#x2F;&#x2F; Assembling AMD Computer\nvoid assemblingComputer_AMD()\n&#123;\n    &#x2F;&#x2F; 准备 AMD Computer 的 Component\n    string name &#x3D; &quot;AMD&quot;;\n    CPU *amdCPU &#x3D; new AMD_CPU;\n    GraphicsCard *amdGraphicsCard &#x3D; new AMD_GraphicsCard;\n    RAM *amdRAM &#x3D; new AMD_RAM;\n\n    &#x2F;&#x2F; Assembling AMD Computer\n    Computer *computer &#x3D; new Computer(&amp;name, amdCPU, amdGraphicsCard, amdRAM);\n\n    &#x2F;&#x2F; Running AMD Computer\n    computer-&gt;computerRun();\n    delete computer;\n&#125;\n\nint main()\n&#123;\n    assemblingComputer_Inter();\n    assemblingComputer_AMD();\n    return 0;\n&#125;\n\n5. 文件操作\n文件作用：\n程序运行时产生的数据都是临时数据，程序结束后，都会被释放\n通过文件，可以将数据持久化\nC++中对文件操作，需要包含头文件 &lt;fstream&gt;\n\n\n文件类型：\n文本文件：文件以文本的ASCII码形式存储在计算机中\n二进制文件：文件以文本的二进制形式存储在计算机中，无法直接读懂\n\n\n操作文件的三大类：\nofstream：写操作\t\nifstream：读操作\nfstream：读写操作\n\n\n\n5.1 文本文件5.1.1 写文本文件\n写文件步骤：\n\n包含头文件：#include &lt;fstream&gt;\n创建流对象：ofstream ofs\n打开文件：ofs.open(&quot;文件路径&quot;, 打开方式)\n写数据：ofs &lt;&lt; &quot;写入数据&quot;;\n关闭文件：ofs.close()\n\n\n文件的打开方式：\n\n\n\n打开方式\n解释\n\n\n\nios::in\n为读文件而打开文件\n\n\nios::out\n为写文件而打开文件\n\n\nios::ate\n初始位置：文件尾\n\n\nios::app\n追加方式写文件\n\n\nios::trunc\n如果文件存在，先删除，再创建\n\n\nios::binary\n二进制方式\n\n\n\n注意：文件打开方式，可以配合使用，利用 |操作符\n\n例如：用二进制方式写文件：ios::binary | ios::out\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 15:56\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    ofstream ofs;\n    ofs.open(R&quot;(C:\\Users\\Admin\\Desktop\\demo.txt)&quot;, ios::out);\n\n    ofs &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;\n    ofs &lt;&lt; &quot;Hello FHang&quot; &lt;&lt; endl;\n\n    ofs.close();\n\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n5.1.2 读文本文件\n写文件步骤：\n\n包含头文件：#include &lt;fstream&gt;\n创建流对象：ifstream ifs\n先判断打开文件是否成功，打开文件：ifs.open(&quot;文件路径&quot;, 打开方式)\n读数据：四种读取方式\n关闭文件：ifs.close()\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 16:06\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    ifstream ifs;\n    ifs.open(R&quot;(C:\\Users\\Admin\\Desktop\\demo.txt)&quot;, ios::in);\n\n    if (!ifs.is_open())\n    &#123;\n        cout &lt;&lt; &quot;Open File Failed&quot; &lt;&lt; endl;\n\treturn;\n    &#125;\n\n    &#x2F;&#x2F; 读数据，四种\n    &#x2F;&#x2F; 1. 一行行读，不喜欢这个\n&#x2F;&#x2F;    char buf[1024] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;    while (ifs &gt;&gt; buf)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; buf &lt;&lt; endl;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F; 2. 一行行读，感觉一般\n&#x2F;&#x2F;    char buf[1024] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;    while (ifs.getline(buf, sizeof(buf)))\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; buf &lt;&lt; endl;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F; 3. 一行行读，个人一般常用\n    string buf;\n    while (getline(ifs, buf))\n    &#123;\n        cout &lt;&lt; buf &lt;&lt; endl;\n    &#125;\n\n    &#x2F;&#x2F; 4. 一个个读，慢\n&#x2F;&#x2F;    char buf;\n&#x2F;&#x2F;    while ((buf &#x3D; ifs.get()) !&#x3D; EOF)\n&#x2F;&#x2F;    &#123;\n&#x2F;&#x2F;        cout &lt;&lt; buf;\n&#x2F;&#x2F;    &#125;\n\n    ifs.close();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n5.2 二进制文件\n以二进制的方式对文件进行读写操作\n打开方式需要指定：ios:binary\n\n5.2.1 写二进制文件\n二进制写文件主要利用 流对象 调用成员函数 write()\n\n函数原型：ostream &amp;write(const char *buffer, int len);\n\n参数解释：字符指针 buffer指向内存中一段内存空间，len是读写的字节数\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 16:34\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string f_Name;\n    int f_Age;\n&#125;;\n\nvoid demo()\n&#123;\n    Person person &#x3D; &#123;&quot;FHang&quot;, 24&#125;;\n    ofstream ofs;\n    ofs.open(R&quot;(C:\\Users\\Admin\\Desktop\\Person.txt)&quot;, ios::out | ios::binary);\n    ofs.write((const char *) &amp;person, sizeof(Person));\n    ofs.close();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n5.2.2 读二进制文件\n二进制方式读文件，主要利用 流对象 调用成员函数 read\n\n函数原型：ostream &amp;read(char *buffer, int len);\n\n参数解释：字符指针 buffer指向内存中一段内存空间，len是读写的字节数\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;6&#x2F;25 17:00\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string f_Name;\n    int f_Age;\n&#125;;\n\nvoid demo()\n&#123;\n    Person person;\n    ifstream ifs;\n    ifs.open(R&quot;(C:\\Users\\Admin\\Desktop\\Person.txt)&quot;, ios::in | ios::binary);\n\n    if (!ifs.is_open())\n    &#123;\n        cout &lt;&lt; &quot;Open File Failed&quot; &lt;&lt; endl;\n        return;\n    &#125;\n\n    ifs.read((char *) &amp;person, sizeof(Person));\n    cout &lt;&lt; &quot;Name &#x3D; &quot; &lt;&lt; person.f_Name &lt;&lt; endl;\n    cout &lt;&lt; &quot;Age &#x3D; &quot; &lt;&lt; person.f_Age &lt;&lt; endl;\n\n    ifs.close();\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n6. extern C\n功能描述：将C++代码，以C语言的形式进行编译\n\n作用：用于C/C++混合开发时，C++中使用C写的第三方库时使用\n\n注意：C不支持函数重载\n\n代码示例：\nextern &quot;C&quot;\n&#123;\n    int func();\n    int func(int a);\n&#125;\n\nint main()\n&#123;\n    func();\n    func(1);\n    return o;\n&#125;\n\nint func()&#123;return 0;&#125;\n\nint func(int a)&#123;return a;&#125;\n\n以上是 extern C 的使用方式，但这个程序编译会报错；\n在 C/C++ 中，编译时转汇编，依据编译器的区别，函数名会变改名：\n&#x2F;&#x2F; C \ncall _func()\n\n&#x2F;&#x2F; C++\ncall func_i()\n\n所以，当C++文件中，使用extern C修饰重载函数后，编译会出错\n\n\n6.1 实例演示1\nmath.h\nextern &quot;C&quot;\n&#123;\n    int sum(int a, int b);\n&#125;\n\nmath.c\nint sum(int a, int b)\n&#123;\n    return a + b;\n&#125;\n\ndemo.cpp\n#include &lt;iostream&gt;\n#include &quot;math.h&quot;\n\nint main()\n&#123;\n    std::cout &lt;&lt; sum(1, 2) &lt;&lt; std::endl;\n    return 0;\n&#125;\n\n在C++文件中，不能直接使用C文件中的函数，因为编译器的区别，相同的函数名，在编译时，函数的名称会变得不同，所以C++文件中就找不到C中的函数声明和实现，只能指向自己文件中的声明；\n所以需要 extern C修饰，这样编译器就会在编译时修改函数名，修改成C的规范，这样C++文件中就可以找到C文件中的函数声明和实现;\n\n补充：如果别的 C 文件中要使用 math.h ，直接包含 math.h 会报错，因为 C 的编译器 无法识别 extern C\n\n注意：\n\nextern C 直接修饰 C的头文件内的声明即可，同时修饰实现也可以，但没必要；唯独不能只修饰实现；\n\n\n\n6.2 实例演示2\n补充知识：\n\nCpp 文件开头默认会有#define __cpluscplus，用于编译时标识自己是 Cpp 文件\nCpp 头文件中一般可以使用： \n#ifdef 项目文件名\n#endif\n包含头文件内容\n\n\n\n\n代码示例：\nmath.h \n#ifdef __cpluscplus\nextern &quot;C&quot;\n&#123;\n#endif &#x2F;&#x2F; __cpluscplus\n    \n    int sum(int a, int b);\n    \n#ifdef __cpluscplus    \n&#125;\n#endif &#x2F;&#x2F; __cpluscplus\n\n\n\ndemo.cpp\n#define __cpluscplus &#x2F;&#x2F; 编译时 默认存在的\n\n#include &lt;iostream&gt;\n#include &quot;math.h&quot;\n\nint main()\n&#123;\n    std::cout &lt;&lt; sum(1, 2) &lt;&lt; std::endl;\n    return 0;\n&#125;\n\n当 Cpp 文件包含这个头文件时，编译时会识别到 #ifdef和#endif，这样 extern C就可以生效；\n当 C 文件包含这个头文件时，编译时就会忽略 extern C；\n这样的写法格式的好处：C 文件 和 Cpp 文件 都可以直接包含 math.h文件，进行使用\n\n补充知识：实际开发中，避免重复引用头文件，浪费资源，需要使用 #ifndef __文件名_H 、#define __文件名_H 、#endif\nmath.h\n#ifndef __MATH_H &#x2F;&#x2F; 规范写法\n#define __MATH_H\n\n#ifdef __cpluscplus\nextern &quot;C&quot;\n&#123;\n#endif &#x2F;&#x2F; __cpluscplus\n    \n    int sum(int a, int b);\n    \n#ifdef __cpluscplus    \n&#125;\n#endif &#x2F;&#x2F; __cpluscplus\n\n#endif &#x2F;&#x2F; MATH\n\n#ifdef：如果定义了，参与编译\n\n#ifndef：如果没有被其它文件引用或定义\n\n#define：定义这个文件的内容\n\n#endif：结束定义\n\n简单写法：#pragma once\nmath.h\n#pragma once\n\n#ifdef __cpluscplus\nextern &quot;C&quot;\n&#123;\n#endif &#x2F;&#x2F; __cpluscplus\n    \n    int sum(int a, int b);\n    \n#ifdef __cpluscplus    \n&#125;\n#endif &#x2F;&#x2F; __cpluscplus\n\n效果和 #ifndef __文件名_H 、#define __文件名_H 、#endif 是一样的\n\n#ifndef __文件名_H 、#define __文件名_H 、#endif受到C&#x2F;C++标准支持，不受编译器限制\n\n#pragma once 老版编译器不兼容(GCC 3.4之前的版本)\n\n\n","slug":"1_C++_核心编程_03","date":"2022-10-06T07:28:25.912Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"1314ed16965aff00f28615c8023e8a57","title":"C++_STL算法","content":"C++_STL算法概述：\n\n算法主要是头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt; 组成\n&lt;algorithm&gt; 是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等到\n&lt;numeric&gt; 体积很小，包括几个序列上面进行简单数学运算和模板函数\n&lt;functional&gt; 定义了一些类模板，用以声明函数对象\n\n1. 常用遍历算法\n\n\n算法简介\n\n\n\n\nfor_each\n遍历容器\n\n\ntransform\n搬运容器到另一个容器\n\n\n1.1 for_each\n功能描述：实现遍历容器\n\n函数原型：\n\nfor_each(iterator begin, iterator end, _functional);\n_functional 函数或函数对象\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 13:48\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass PrintVector_Class\n&#123;\npublic:\n    void operator()(int &amp;value)\n    &#123;\n        cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid printVector_func(int &amp;value)\n&#123;\n    cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n    v.reserve(5);\n\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    for_each(v.begin(), v.end(), printVector_func);\n    cout &lt;&lt; endl;\n\n    for_each(v.begin(), v.end(), PrintVector_Class());\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n1.2 transform\n功能描述：搬运容器到另一个容器中\n\ntransform(iterator begin_1, iterator end_1, iterator iterator_2, _functional);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 14:29\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass TransVector\n&#123;\npublic:\n    int operator()(int &amp;value)\n    &#123;\n        return value;\n    &#125;\n&#125;;\n\nint transVector_Func(int &amp;value)\n&#123;\n    return value;\n&#125;\n\nvoid printVector(const vector&lt;int&gt; &amp;v)\n&#123;\n    for (int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    v1.reserve(5);\n    for (int i &#x3D; 0; i &lt; 5; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n\n    v2.resize(v1.size());\n\n    &#x2F;&#x2F; transform(v1.begin(), v1.end(), v2.begin(), TransVector());\n    transform(v1.begin(), v1.end(), v2.begin(), transVector_Func);\n    printVector(v2);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n2. 常用查找算法\n\n\n算法简介\n\n\n\n\nfind\n查找元素\n\n\nfind_if\n按条件查找元素\n\n\nadjacent_find\n查找相邻重复的元素\n\n\nbinary_search\n二分查找法\n\n\ncount\n统计元素个数\n\n\ncount_if\n按条件统计元素个数\n\n\n2.1 find\n功能描述：查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()\n\n函数原型：find(iterator begin, iterator end, value);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 14:52\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(const string &amp;name, const int &amp;age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n\n    &#x2F;&#x2F; find 底层无法比较 自定义数据类型，所以要 重载&#x3D;&#x3D;\n    &#x2F;&#x2F; find 底层是直接 解析元素迭代器去比较要 查找的元素值，所以 自定义类型的数据，无法直接比较\n    bool operator&#x3D;&#x3D;(const Person &amp;person)\n    &#123;\n        if (this-&gt;name &#x3D;&#x3D; person.name &amp;&amp; this-&gt;age &#x3D;&#x3D; person.age)\n        &#123;\n            return true;\n        &#125;\n        else\n        &#123;\n            return false;\n        &#125;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(&quot;QQ&quot;, 12);\n    Person p2(&quot;WW&quot;, 12);\n    Person p3(&quot;EE&quot;, 12);\n    Person p4(&quot;RR&quot;, 12);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    vector&lt;Person&gt;::iterator it &#x3D; find(v.begin(), v.end(), p2);\n    if (it &#x3D;&#x3D; v.cend())\n    &#123;\n        cout &lt;&lt; &quot;No Find&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; it-&gt;name &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n\n\n总结：\n\nfind 底层无法比较自定义数据类型，所以要重载==\nfind 底层是直接解析元素迭代器去比较要查找的元素值，所以自定义类型的数据，无法直接比较\n\n\n\n2.2 find_if\n功能描述：按条件查找\n\n函数原型：find_if(iterator begin, iterator end, _Pred);\n\n_Pred：函数或谓词(返回bool类型)\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 15:42\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(const string &amp;name, const int &amp;age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nclass FindIF_MoreThan_3\n&#123;\npublic:\n    bool operator()(const int &amp;value)\n    &#123;\n        return value &gt; 3;\n    &#125;\n&#125;;\n\nclass FindIF_MoreThan_Age_8\n&#123;\npublic:\n    bool operator()(const Person &amp;person)\n    &#123;\n        return person.age &gt; 8;\n    &#125;\n&#125;;\n\nclass UpSort_Age\n&#123;\npublic:\n    bool operator()(Person &amp;person1, Person &amp;person2)\n    &#123;\n        return person1.age &lt; person2.age;\n    &#125;\n&#125;;\n\nvoid printVector(const vector&lt;Person&gt; &amp;v)\n&#123;\n    for (vector&lt;Person&gt;::const_iterator it &#x3D; v.cbegin(); it !&#x3D; v.cend(); ++it)\n    &#123;\n        cout &lt;&lt; it-&gt;name &lt;&lt; &quot; : &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 0; i &lt;&#x3D; 5; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    vector&lt;int&gt;::iterator it &#x3D; find_if(v.begin(), v.end(), FindIF_MoreThan_3());\n    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; *it &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    vector&lt;Person&gt; v;\n    Person p1(&quot;QQ&quot;, 13);\n    Person p2(&quot;WW&quot;, 8);\n    Person p3(&quot;EE&quot;, 10);\n    Person p4(&quot;RR&quot;, 12);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    sort(v.begin(), v.end(), UpSort_Age());\n    printVector(v);\n\n    vector&lt;Person&gt;::iterator it &#x3D; find_if(v.begin(),  v.end(), FindIF_MoreThan_Age_8());\n    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n2.3 adjacent_find\n功能描述：查找相邻重复元素\n\n函数原型：adjacent_find(iterator begin, iterator end);\n\n返回相邻元素的第一个位置的迭代器\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 16:38\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    v.push_back(0);\n    v.push_back(1);\n    v.push_back(0);\n    v.push_back(2);\n    v.push_back(2);\n\n    vector&lt;int&gt;::iterator it &#x3D; adjacent_find(v.begin(),  v.end());\n    cout &lt;&lt; &quot;Find: &quot; &lt;&lt; *it &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n2.4 binary_search\n功能描述：查找指定元素是否存在\n\n函数原型：bool binary_search(iterator begin, iterator end, value);\n\n查找指定元素，找到返回 ture 否则返回 false\n\n不用于无序序列(就是容器内的元素不是有序排列的)\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;20 16:51\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 0; i &lt;&#x3D; 5; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    bool isSearch &#x3D; binary_search(v.begin(),  v.end(), 5);\n\n    string searchRet &#x3D; isSearch ? &quot;true&quot; : &quot;false&quot;;\n\n    if (isSearch)\n    &#123;\n        cout &lt;&lt; &quot;Search: &quot; &lt;&lt; searchRet &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;Search: &quot; &lt;&lt; searchRet &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n\n\n总结：binary_search()效率很高，只用于有序序列\n\n\n2.5 count\n功能描述：统计元素个数\n\n函数原型：count(iterator begin, iterator end, value);\n\n返回int类型\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 13:02\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    string name;\n    int age;\n\n    Person(const string &amp;name, const int &amp;age)\n    &#123;\n        this-&gt;name &#x3D; name;\n        this-&gt;age &#x3D; age;\n    &#125;\n\n    bool operator&#x3D;&#x3D;(const Person &amp;p)\n    &#123;\n        if (this-&gt;age &#x3D;&#x3D; p.age)\n        &#123;\n            return true;\n        &#125;\n        else\n        &#123;\n            return false;\n        &#125;\n    &#125;\n&#125;;\n\nvoid printVector(const vector&lt;int&gt; &amp;v)\n&#123;\n    for (int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printVector(const vector&lt;Person&gt; &amp;p)\n&#123;\n    for (Person it : p)\n    &#123;\n        cout &lt;&lt; it.name &lt;&lt; &quot; : &quot; &lt;&lt; it.age &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(rand()%2);\n    &#125;\n\n    printVector(v);\n\n    int countNum &#x3D; count(v.begin(),  v.end(), 0);\n    cout &lt;&lt; &quot;Count 0 : &quot; &lt;&lt; countNum &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(&quot;QQ&quot;, 11);\n    Person p2(&quot;WW&quot;, 10);\n    Person p3(&quot;EE&quot;, 10);\n    Person p4(&quot;RR&quot;, 10);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    Person p(&quot;SS&quot;, 10);\n\n    printVector(v);\n\n    int countNum &#x3D; count(v.begin(),  v.end(), p);\n    cout &lt;&lt; &quot;Count P : &quot; &lt;&lt; countNum &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int) time(NULL));\n    demo1();\n    demo2();\n\n    return 0;\n&#125;\n\n2.6 count_if\n功能描述：按条件统计元素个数\n\n函数原型：count_if(iterator begin, iterator end, _Pred);\n\n_Pred谓词(条件)\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 13:50\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Person\n&#123;\npublic:\n    int age;\n\n    Person(const int &amp;age)\n    &#123;\n        this-&gt;age &#x3D; age;\n    &#125;\n&#125;;\n\nbool great_4(const int &amp;value)\n&#123;\n    return value &gt; 4;\n&#125;\n\nbool equal_10(const Person &amp;p)\n&#123;\n    return p.age &#x3D;&#x3D; 10;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D;9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    const int countNum &#x3D; count_if(v.begin(),  v.end(), great_4);\n    cout &lt;&lt; countNum &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(11);\n    Person p2(10);\n    Person p3(10);\n    Person p4(10);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    int countNum &#x3D; count_if(v.begin(),  v.end(), equal_10);\n    cout &lt;&lt; countNum &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n3. 常用排序算法\n\n\n算法简介\n\n\n\n\nsort\n对容器内元素进行排序\n\n\nrandom_shuffle\n洗牌–指定范围内元素随机调整次序\n\n\nmerge\n容器元素合并，并存储到另一个容器中\n\n\nreverse\n反转指定范围的元素\n\n\n3.1 sort\n功能描述：对容器内元素进行排序\n\n函数原型：\n\nsort(iterator begin, iterator end, _Pred);\n按照谓词的条件查找元素，找到返回指定元素位置的迭代器，找不到返回结束迭代器位置\nsort(iterator begin, iterator end);\n默认从小到大排序\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 14:09\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nvoid printVector(const vector&lt;T&gt; &amp;v)\n&#123;\n    for (T it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\ntemplate&lt;class T&gt;\nbool downSort(const T &amp;value1, const T &amp;value2)\n&#123;\n    return value1 &gt; value2;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D;9; ++i)\n    &#123;\n        v.push_back(rand()%10);\n    &#125;\n    printVector(v);\n\n    sort(v.begin(), v.end());\n    printVector(v);\n\n    sort(v.begin(), v.end(), downSort&lt;int&gt;);\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int)time(NULL));\n    demo1();\n    return 0;\n&#125;\n\n3.2 random_shuffle\n功能描述：洗牌–指定范围内的元素随机调整次序\n\n函数原型：random_shuffle(iterator begin, iterator end);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 14:27\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;ctime&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nvoid printVector(const vector&lt;T&gt; &amp;v)\n&#123;\n    for (T it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo1()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    printVector(v);\n\n    random_shuffle(v.begin(), v.end());\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int)time(NULL));\n    demo1();\n    return 0;\n&#125;\n\n3.3 merge\n功能描述：两个容器元素合并，存储到同一个容器中\n\n函数原型：merge(iterator begin1, iterator end1, iterator begin2, iterator end2, iterator newBegin);\n\n注意：两个容器内的元素，必须是有序序列\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 15:41\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nvoid printVector(T value)\n&#123;\n    cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v3;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(9 - i);\n    &#125;\n\n    v3.resize(v1.size() + v2.size());\n\n    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());\n    for_each(v3.begin(), v3.end(), printVector&lt;int&gt;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.4 reverse\n功能描述：将容器内元素进行反转\n\n函数原型：reverse(iterator begin, iterator end);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 15:51\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nclass PrintVector_T\n&#123;\npublic:\n    void operator()(const T &amp;value)\n    &#123;\n        cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\ntemplate&lt;class T&gt;\nvoid printVector_T(const T &amp;value)\n&#123;\n    cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    cout &lt;&lt; &quot;Meta: &quot;;\n    for_each(v.begin(), v.end(), PrintVector_T&lt;int&gt;());\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;Reverse: &quot;;\n    reverse(v.begin(), v.end());\n    for_each(v.begin(), v.end(), printVector_T&lt;int&gt;);\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4. 常用拷贝替换算法\n\n\n算法简介\n\n\n\n\ncopy\n容器内指定范围的元素拷贝到另一个容器中\n\n\nreplace\n容器内指定范围的旧元素 改为 新元素\n\n\nreplace_if\n容器内指定范围的满足条件的旧元素 改为 新元素\n\n\nswap\n互换两个容器的元素\n\n\n4.1 copy\n功能描述：容器内指定范围的元素拷贝到另一个容器中\n\n函数原型：copy(iterator begin, iterator end, iterator newBegin);\n\n按值查找元素，返回找到的指定位置迭代器，找不到返回结束迭代器\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 16:10\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass PrintVector\n&#123;\npublic:\n    void operator()(int value)\n    &#123;\n        cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n    &#125;\n\n    v2.resize(v1.size());\n\n    copy(v1.begin(), v1.end(), v2.begin());\n\n    for_each(v2.begin(), v2.end(), PrintVector());\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.2 replace\n功能描述：容器内指定范围的旧元素 改为 新元素\n\n函数原型：replace(iterator begin, iterator end, old_Value, new_Value);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 16:18\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)\n&#123;\n    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;\n    for (const int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    printVector(v, &quot;Meta&quot;);\n\n    replace(v.begin(), v.end(), 0, 9);\n    printVector(v, &quot;New&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.3 replace_if\n功能描述：容器内指定范围的满足条件的旧元素 改为 新元素\n\n函数原型：replace_if(iterator beign, iterator end, _Pred, new_Value);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 16:25\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)\n&#123;\n    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;\n    for (const int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nbool greater_5(int value)\n&#123;\n    return value &gt; 5;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    printVector(v, &quot;Meta&quot;);\n\n    replace_if(v.begin(), v.end(), greater_5, 0);\n    printVector(v, &quot;New&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n4.4 swap\n功能描述：互换两个容器的元素\n\n函数原型：swap(contatiner c1, contatiner c2);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 16:30\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const string &amp;str)\n&#123;\n    cout &lt;&lt; str &lt;&lt; &quot;: &quot;;\n    for (const int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(9 - i);\n    &#125;\n\n    printVector(v1, &quot;meta&quot;);\n    printVector(v2, &quot;meta&quot;);\n\n    swap(v1, v2);\n    printVector(v1, &quot;new&quot;);\n    printVector(v2, &quot;new&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n5. 常用算术生成算法\n注意：算术生成算法属于小型算法，使用时需要包含头文件#include &lt;numeric&gt;\n\n\n\n算法简介\n\n\n\n\naccumulate\n计算容器区间内元素累计总和\n\n\nfill\n向容器中填充元素\n\n\n\n\n5.1 accumulate\n功能描述：计算容器区间内元素累计总和\n\n函数原型：accumulate(iterator begin, iterator end, value);\n\nvalue起始值\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 17:02\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    const int sum &#x3D; accumulate(v.cbegin(), v.cend(), 0);\n    cout &lt;&lt; sum &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n5.2 fill\n功能描述：向容器中填充元素\n\n函数原型：fill(iterator begin, iterator end, value);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 17:12\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v)\n&#123;\n    for (const int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 8; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    fill(v.begin(), v.end(), 9);\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n6. 常用集合算法\n\n\n算法简介\n\n\n\n\nset_intersection\n求两个容器的交集\n\n\nset_union\n求两个容器的并集\n\n\nset_difference\n求两个容器的差集\n\n\n\n注意：\n使用前，确保 新容器 的预设一个 合适大小\n算法返回的是 最后一个元素 所在位置的 迭代器\n遍历 新容器 要用 算法返回的迭代器，而不是使用 新容器自身的结束迭代器\n交集算法中，新容器自身的结束迭代器 可能超出 最后一个元素 所在位置的 迭代器\n\n\n\n6.1 set_intersection\n功能描述：求两个容器的交集\n\n函数原型：set_intersection(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 17:27\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (const int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (vector&lt;int&gt;::const_iterator itBegin &#x3D; v.begin(); itBegin !&#x3D; it; ++itBegin)\n    &#123;\n        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v_tag;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i + 5);\n    &#125;\n    printVector(v1, &quot;V1&quot;);\n    printVector(v2, &quot;V2&quot;);\n\n    v_tag.resize(min(v1.size(), v2.size()));\n\n    vector&lt;int&gt;::const_iterator itLast &#x3D; set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());\n\n    &#x2F;&#x2F; 使用 新容器自身迭代器\n    printVector(v_tag, &quot;Target&quot;);\n\n    &#x2F;&#x2F; 使用 set_intersection 返回的 最后一个元素的迭代器\n    printVector(v_tag, itLast, &quot;Target&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n6.2 set_union\n功能描述：求两个容器的并集\n\n函数原型：set_union(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 17:50\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (const int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (vector&lt;int&gt;::const_iterator itBegin &#x3D; v.begin(); itBegin !&#x3D; it; ++itBegin)\n    &#123;\n        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v_tag;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 4; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i + 4);\n    &#125;\n    printVector(v1, &quot;V1&quot;);\n    printVector(v2, &quot;V2&quot;);\n\n    v_tag.resize(v1.size() + v2.size());\n\n    vector&lt;int&gt;::const_iterator itLast &#x3D; set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());\n\n    &#x2F;&#x2F; 使用 set_union 返回的 最后一个元素的迭代器\n    printVector(v_tag, itLast, &quot;Target&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n6.3 set_difference\n功能描述：求两个容器的差集\n\n差集：\n\n求出 c1 和 c2 的交集\n\nc1 与 c2 的差集：c1 的 减去 交集部分\n\nc2 与 c1 的差集：c2 的 减去 交集部分\n\n\n\n函数原型：set_difference(iterator begin_1, iterator end_1, iterator begin_2, iterator end_2, iterator new_Begin);\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;21 18:13\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (const int it: v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid printVector(const vector&lt;int&gt; &amp;v, const vector&lt;int&gt;::const_iterator &amp;it, const char *containerName)\n&#123;\n    cout &lt;&lt; containerName &lt;&lt; &quot;: &quot;;\n    for (vector&lt;int&gt;::const_iterator itBegin &#x3D; v.begin(); itBegin !&#x3D; it; ++itBegin)\n    &#123;\n        cout &lt;&lt; *itBegin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v_tag;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; 9; ++i)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i + 5);\n    &#125;\n    printVector(v1, &quot;V1&quot;);\n    printVector(v2, &quot;V2&quot;);\n\n    v_tag.resize(max(v1.size(), v2.size()));\n\n    &#x2F;&#x2F; V1 对于 V2 的 差集\n    vector&lt;int&gt;::const_iterator itLast_V1 &#x3D; set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v_tag.begin());\n    printVector(v_tag, itLast_V1, &quot;V1 Difference&quot;);\n\n    &#x2F;&#x2F; V2 对于 V1 的 差集\n    vector&lt;int&gt;::const_iterator itLast_V2 &#x3D; set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), v_tag.begin());\n    printVector(v_tag, itLast_V2, &quot;V2 Difference&quot;);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n","slug":"1_C++_STL算法_07","date":"2022-10-06T07:28:25.910Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"},{"id":"29cfc82accb2b6a310cfbec39b1d8603","title":"C++_STL函数对象","content":"C++_STL函数对象1. 函数对象1.1 函数对象概念\n概念：\n重载函数调用操作符的类，其对象常称为函数对象\n函数对象使用重载的()时，行为类似函数调用，也叫仿函数\n\n\n本质：\n函数对象(仿函数)是一个类，不是一个函数\n\n\n\n1.2 函数对象使用\n特点：\n\n函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值\n函数对象超出普通函数的概念，函数对象可以有自己的状态\n函数对象可以作为参数传递\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 15:17\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值\nclass Fh_Add\n&#123;\npublic:\n    int operator()(int value1, int value2)\n    &#123;\n        return value1 + value2;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 函数对象超出普通函数的概念，函数对象可以有自己的状态\nclass Fh_Print\n&#123;\npublic:\n    int transferCount;\n\n    Fh_Print()\n    &#123;\n        this-&gt;transferCount &#x3D; 0;\n    &#125;\n\n    void operator()(const string &amp;printStr)\n    &#123;\n        cout &lt;&lt; printStr &lt;&lt; endl;\n        this-&gt;transferCount++;\n    &#125;\n&#125;;\n\nvoid demo1()\n&#123;\n    Fh_Add fhAdd;\n    cout &lt;&lt; &quot;Fh_Add&gt;&gt; &quot; &lt;&lt; fhAdd(1, 2) &lt;&lt; endl;\n\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    Fh_Print fhPrint;\n    fhPrint(&quot;Hello World&quot;);\n    fhPrint(&quot;Hello World&quot;);\n    fhPrint(&quot;Hello World&quot;);\n    cout &lt;&lt; &quot;Fh_Print Transfer Count&gt;&gt; &quot; &lt;&lt; fhPrint.transferCount &lt;&lt; endl;\n\n    cout &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F; 函数对象可以作为参数传递\nvoid doPrint(Fh_Print &amp;fhPrint, const string &amp;printStr)\n&#123;\n    fhPrint(printStr);\n&#125;\n\nvoid demo3()\n&#123;\n    Fh_Print fhPrint;\n    doPrint(fhPrint, &quot;Hello World&quot;);\n\n    cout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    demo3();\n    return 0;\n&#125;\n\n2. 谓词2.1 谓词基本概念\n概念：\n返回bool类型的仿函数称为谓词\n如果operator()接受一个参数，为一元谓词\n如果operator()接受二个参数，为二元谓词\n\n\n\n2.2 一元谓词\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 16:09\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass DownSort\n&#123;\npublic:\n    bool operator()(const int &amp;value1, const int &amp;value2)\n    &#123;\n        return value1 &gt; value2;\n    &#125;\n&#125;;\n\nvoid printVector(const vector&lt;int&gt; &amp;other)\n&#123;\n    for (int it : other)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i &#x3D; 1; i &lt; 6; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n    printVector(v);\n\n    sort(v.begin(), v.end(), DownSort());\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3. 内建函数对象3.1 内建函数对象意义\n概念：\nSTL内建一些函数对象\n\n\n分类：\n算术仿函数\n关系仿函数\n逻辑仿函数\n\n\n用法：\n这些仿函数所产生的对象，用法和一般函数完全相同\n使用内建函数对象，需要引入头文件#include&lt;functional&gt;\n\n\n\n3.2 算术仿函数\n功能描述：\n\n实现四则运算\n其中negate是一元运算，其它的都是二元运算\n\n\n\n\n仿函数原型\n\n\n\n\ntemplate&lt;class T&gt; T plus&lt;T&gt;\n加法仿函数\n\n\ntemplate&lt;class T&gt; T minus&lt;T&gt;\n减法仿函数\n\n\ntemplate&lt;class T&gt; T multiplies&lt;T&gt;\n乘法仿函数\n\n\ntemplate&lt;class T&gt; T divides&lt;T&gt;\n除法仿函数\n\n\ntemplate&lt;class T&gt; T modulus&lt;T&gt;\n取模仿函数\n\n\ntemplate&lt;class T&gt; T negate&lt;T&gt;\n取反仿函数\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 16:45\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nusing namespace std;\n\nvoid demo1()\n&#123;\n    negate&lt;&gt; negate1;\n    cout &lt;&lt; negate1(10) &lt;&lt; endl;\n&#125;\n\nvoid demo2()\n&#123;\n    plus&lt;&gt; plus1;\n    cout &lt;&lt; plus1(10, 20) &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n    demo1();\n    demo2();\n    return 0;\n&#125;\n\n3.3 关系仿函数\n功能描述：实现关系对比\n\n\n\n仿函数原型\n\n\n\n\ntemplate&lt;class T&gt; bool equal_to&lt;T&gt;\n等于\n\n\ntemplate&lt;class T&gt; bool not_equal_to&lt;T&gt;\n不等于\n\n\ntemplate&lt;class T&gt; bool greater&lt;T&gt;\n大于\n\n\ntemplate&lt;class T&gt; bool greater_equal&lt;T&gt;\n大于等于\n\n\ntemplate&lt;class T&gt; bool less&lt;T&gt;\n小于\n\n\ntemplate&lt;class T&gt; bool less_equal&lt;T&gt;\n小于等于\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 16:58\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;int&gt; &amp;v)\n&#123;\n    for (int it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;int&gt; v;\n\n    for (int i &#x3D; 1; i &lt; 6; ++i)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    printVector(v);\n\n    sort(v.begin(),  v.end(), greater&lt;&gt;());\n    printVector(v);\n&#125;\n\nint main()\n&#123;\n    demo();\n    return 0;\n&#125;\n\n3.4 逻辑仿函数\n功能描述：实现逻辑运算\n\n\n\n函数原型\n\n\n\n\ntemplate&lt;class T&gt; bool logical_and&lt;T&gt;\n逻辑与\n\n\ntemplate&lt;class T&gt; bool logical_or&lt;T&gt;\n逻辑或\n\n\ntemplate&lt;class T&gt; bool logical_not&lt;T&gt;\n逻辑非\n\n\n\n代码示例：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Created by FHang on 2021&#x2F;11&#x2F;14 17:43\n&#x2F;&#x2F;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nvoid printVector(const vector&lt;bool&gt; &amp;v)\n&#123;\n    for (bool it : v)\n    &#123;\n        cout &lt;&lt; it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid demo()\n&#123;\n    vector&lt;bool&gt; v1;\n    for (int i &#x3D; 1; i &lt; 5; ++i)\n    &#123;\n        v1.push_back(rand()%2);\n    &#125;\n\n    printVector(v1);\n\n    vector&lt;bool&gt; v2;\n    v2.resize(v1.size());\n\n    transform(v1.begin(), v1.end(), v2.begin(), logical_not&lt;bool&gt;());\n    printVector(v2);\n&#125;\n\nint main()\n&#123;\n    srand((unsigned int)time(NULL));\n    demo();\n    return 0;\n&#125;\n\n","slug":"1_C++_STL函数对象_06","date":"2022-10-06T07:28:25.907Z","categories_index":"编程","tags_index":"C/C++","author_index":"FangH"}]